% The outline proposal needs to identify the research area as
% something rather more specific than (say) Neuroinformatics, Natural
% Language Processing or Automated Reasoning. For those students who
% started the programme with no topic, one would expect an outline
% proposal of around 2-3 pages, detailing the specific research area
% and problem to be addressed, plus a very brief description of the
% idea the student will pursue for solving it.
%
% For those students who started their PhD programme with a specific
% research proposal already, this proposal should be much more fleshed
% out (e.g., 15 pages), providing more details of both the research
% problem and research methods, a more detailed justification of the
% approach and how it will be evaluated, and a scheduled work plan. If
% the student is in a position to write this more detailed proposal at
% this point in the programme, then this can be used as part of the
% deliverable (perhaps with minor amendments) for the formal First
% Year Review in month 9, together with a separate document that
% describes the research achievements to date and how they relate to
% the work plan described in the proposal. Details of the documents to
% be submitted for the First Year Review are given below under “Month
% 9”.
%
% The literature review that forms a part of this submission must be
% relevant to the research area defined in the proposal and serve to
% justify the approach taken in the proposed thesis. The course notes
% for the MSc "Informatics Research Review" course has some notes on
% the form and content of a literature review and how to go about
% tracking down relevant publications.
%
\input{preamble}

% Document starts
\begin{document}

\title{Outline}

\author{Chris Cummins}

\maketitle

\begin{abstract}
  The physical limitations of microprocessor design have forced the
  industry towards increasingly heterogeneous designs to extract
  performance. This trend has not been matched with adequate software
  tools, leading to a growing disparity between the availability of
  parallelism and the ability for application developers to exploit
  it. Algorithmic skeletons simplify parallel programming by providing
  high-level, reusable patterns of computation. Achieving performant
  skeleton implementations is a difficult task; skeleton authors must
  attempt to anticipate and tune for a wide range of architectures and
  use cases. This results in implementations that target the general
  case and cannot provide the performance advantages that are gained
  from tuning low level optimization parameters. Autotuning combined
  with machine learning offers promising performance benefits in these
  situations, but the high cost of training and lack of available
  tools limits the practicality of autotuning for real world
  programming. We believe that performing autotuning at the level of
  the skeleton library can overcome these issues.
\end{abstract}


\section{Introduction}


\section{Background}


\section{Methodology}


\section{Literature Review}


\subsection{Skeleton-aware compilation}

% * What are the limits of compiler optimisations for parallel code?

%   * How does dependency analysis cope?

% * Compiler optimisations for parallel programs

% * Optimisations for skeletons
%   * “skeletons" - Intel TBB, std::algorithm, FastFlow, MapReduce
%   * Composition and nesting.
%   * Rewrite rules:

%     Patterns and Rewrite Rules for Systematic Code Generation From
%     High-Level Functional Patterns to High-Performance OpenCL Code

%       A

\subsubsection{Autotuning for parallel programs}

%   * Autotuning for skeletons


\subsection{Skeleton-aware debugging}

General purpose, platform-specific debuggers: Intel Debugger for
Linux~\cite{Blair-chappell}, Microsoft Windows Debugger.


\subsubsection{Debugging Parallel Frameworks and Libraries}

Allinea DDT~\cite{K2010}, a scalable parallel debugger.

TotalView~\cite{Cownie2000}, an OpenMP debugger.

Jumbune~\cite{ImpetusTechnologies}, an open source debugger for
Hadoop.


\subsubsection{Debugging GPGPU programs}

CUDA-GDB~\cite{NVIDIA2016}, Intel OpenCL Debugger for Linux
OS~\cite{IntelCorporation2016}.

Oclgrind~\cite{Price2015}.


\subsubsection{Debugging Algorithmic Skeletons}

SkIE~\cite{Bacci1999} is based on a coordination language, but
provides advanced features such as debugging tools, performance
analysis, visualization, and graphical user interface. Instead of
directly using the coordination language, programmers interact with a
graphical tool, where parallel modules based on skeletons can be
composed

SKiPPER~\cite{Cezeaux1999} supports sequential execution for
debugging.


\subsection{Skeleton-aware profiling}

% * Profiling parallel applications


\section{Conclusions}


\label{bibliography}
\printbibliography


\end{document}
