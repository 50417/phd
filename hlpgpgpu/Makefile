#------------------------------------------------------------------------
# Build configuration.
#------------------------------------------------------------------------
Document         = hlpgpgpu
DocumentPDF      = $(Document).pdf
DocumentTxt      = $(Document).txt
DocumentTex      = $(Document).tex
DocumentAux      = $(Document).aux
DocumentBuildLog = make.log
DocumentBibfile  = refs.bib

# Programs and binaries.
AWK              = awk
BIBER            = biber
BIBTOOL          = bibtool
CHECKCITES       = checkcites
CLEANBIB         = cleanbib
DETEX            = detex
EGREP            = egrep
GREP             = grep
PARSE_TEXCOUNT   = parse_texcount
PDF_OPEN         = open
PDFLATEX         = pdflatex
RM               = rm
SED              = sed
TEXTLINT         = textlint

# The system-wide LaTeX library name (without '.bib' extension).
BIBLIBRARY       = library

# The default goal is...
.DEFAULT_GOAL = all

# Use V=1 to see full verbosity
QUIET_  = @
QUIET   = $(QUIET_$(V))

#------------------------------------------------------------------------
# Build hooks.
# ------------------------------------------------------------------------
# Build hooks are programs which are executed before or after
# compiling the LaTeX document.
#
# Execution of hooks can be ignored using the environment variable
# NO_HOOKS. E.g.
#
#     $ NO_HOOKS=1 make
#
HooksDirectory = scripts
PreHooksExtension = .pre
PostHooksExtension = .post
PreExecutionHooks = $(shell test -z "$$NO_HOOKS" && ls $(HooksDirectory)/*$(PreHooksExtension) 2>/dev/null)
PostExecutionHooks = $(shell test -z "$$NO_HOOKS" && ls $(HooksDirectory)/*$(PostHooksExtension) 2>/dev/null)

# The full list of input files read by pdflatex. This is grabbed from
# the .fls that is generated by pdflatex. As a result, if we haven't
# run pdflatex before, there will be no .fls file, so we just return
# the $(DocumentTex) file. Note also that we filter out any generated
# files from the dependency list. That is, any path which begins with
# 'gen/' or './gen'.
DocumentDependencies    = \
	$(shell test -f $(Document).fls				\
		&& $(EGREP) '^INPUT ' $(Document).fls		\
		| $(AWK) ' !x[$$0]++' | $(SED) 's/^INPUT //'	\
	        | $(EGREP) -v '^(./)?gen/'			\
		|| echo $(DocumentTex))
# The full list of input .tex files read by pdflatex.
DocumentTexDependencies = $(filter %.tex,$(DocumentDependencies))
# The list of .tex files which are local to this project, i.e. don't
# contain absolute paths.
DocumentSources         = $(filter-out /%,$(DocumentTexDependencies))
# Add the local .tex files to the $(Sources) variable.
Sources                += $(DocumentSources)

PdflatexArgs = 				\
	-recorder			\
	-output-format pdf 		\
	-progname pdflatex 		\
	-file-line-error 		\
	-interaction=nonstopmode	\
	--shell-escape			\
	$(NULL)

# Import lib/*.sty libraries.
export TEXINPUTS := .:./lib:$(TEXINPUTS)

CleanFiles +=                           \
	$(DocumentPDF) 			\
	$(Document).wc			\
	$(Document).cite		\
	$(Document).fls			\
	$(DocumentBuildLog)		\
	*-blx.bib 			\
	*.acn 				\
	*.acr 				\
	*.alg 				\
	*.aux 				\
	*.bbl 				\
	*.bcf 				\
	*.blg 				\
	*.dvi 				\
	*.fdb_latexmk 			\
	*.glg 				\
	*.glo 				\
	*.gls 				\
	*.idx 				\
	*.ilg 				\
	*.ind 				\
	*.ist 				\
	*.lof 				\
	*.log 				\
	*.lol 				\
	*.lot 				\
	*.maf 				\
	*.mtc 				\
	*.mtc0 				\
	*.nav 				\
	*.nlo 				\
	*.out 				\
	*.pdfsync 			\
	*.ps 				\
	*.run.xml 			\
	*.snm 				\
	*.synctex.gz			\
	*.tdo 				\
	*.toc 				\
	*.vrb 				\
	*.xdy 				\
	$(NULL)

#------------------------------------------------------------------------
# Local build rules.
#------------------------------------------------------------------------

all: $(DocumentPDF)

#
# Opening the compiled PDF.
#
PhonyTargets += open
open:
	$(QUIET)if [ -f $(DocumentPDF) ]; then				\
		$(PDF_OPEN) $(DocumentPDF) >/dev/null 2>&1 &		\
	else								\
		$(MAKE) $(DocumentPDF);					\
		$(MAKE) $@;						\
	fi

# Document word counts and summaryy.
PhonyTargets += wc status
wc: $(Document).wc
	$(QUIET)$(PARSE_TEXCOUNT) < $<

# Generate a word count file.
$(Document).wc: $(DocumentSources)
	$(QUIET)if [ -f $(DocumentPDF) ]; then			\
		$(TEXCOUNT) $(DocumentSources) > $(Document).wc; 	\
	else								\
		$(MAKE) $(DocumentPDF);					\
		$(MAKE) $@;						\
	fi

status: $(Document).wc
	@echo -n " Words:    "
	$(QUIET)$(SED) -n '/Total/,$$p' < $(Document).wc		\
		| $(EGREP) '^Words in text:' | sed 's/Words in text: //'
	@echo -n " TODOs:    "
	$(QUIET)cat $(DocumentSources) | $(EGREP) -ic '\todo' || true
	@echo -n "FIXMEs:    "
	$(QUIET)cat $(DocumentSources) | $(EGREP) -ic '\fixme' || true

#
# Citation checks.
#
PhonyTargets += cite
cite: $(Document).cite
	$(QUIET)cat $<

# Generate a citation check file.
$(Document).cite: $(DocumentSources)
	$(QUIET)if [ -f $(DocumentPDF) ]; then			\
		$(CHECKCITES) --undefined $(DocumentAux) > $@;		\
	else								\
		$(MAKE) $(DocumentPDF);					\
		$(MAKE) $@;						\
	fi

#
# Document linter.
#
PhonyTargets += style lint

# The process for caching the result of textlint is a little bit more
# complicated than the "wc" or "cite" rules. Since textlint is a slow
# process to run, we invoke it while using the "tee" command in order
# to simultaneously print the results to stdout while caching them for
# future retrieval. As a result, a use the file .$(Document).lint to
# indicate whether we have just generated the files, so that cache-hit
# rule doesn't print the cached results that we've just generated.
style lint: $(Document).lint
	$(QUIET)if [ ! -f .$(Document).lint ]; then			\
		cat $(Document).lint;					\
	fi
	$(QUIET)$(RM) .$(Document).lint

# Run textlint and cache results.
$(Document).lint: $(DocumentSources)
	$(QUIET)if [ -f $(DocumentPDF) ]; then			\
		$(RM) $(Document).lint;					\
		for f in $(DocumentSources); do				\
			echo -e "\n*** $$f ***" | tee --append $@;	\
			$(TEXTLINT) $$f | tee --append $@;		\
		done;							\
		touch .$(Document).lint;				\
	else								\
		$(MAKE) $(DocumentPDF);					\
		$(MAKE) $@;						\
	fi

CleanFiles += $(Document).lint .$(Document).lint

# Print make targets.
help:
	@echo "Build targets:"
	@echo
	@echo "  make all       Compile $(DocumentPDF)"
	@echo "  make txt       Export plaintext to $(DocumentTxt)"
	@echo "  make clean     Remove all build files"
	@echo "  make open      Open $(DocumentPDF) in default PDF viewer"
	@echo "  make wc        Show a word count"
	@echo "  make cite      Check citations"
	@echo "  make style     Check writing style"

#------------------------------------------------------------------------
# Compiling PDF LaTeX documents.
#------------------------------------------------------------------------

doc_DATA = $(DocumentPDF)
$(DocumentPDF): $(DocumentDependencies)

# Compile commands. We pipe the output to /dev/null to silence it, and
# if there is an error, we re-run the compilation without the pipe so
# as to print the failure messages.
define pdflatex
	(echo -e "\nCOMMAND: $(PDFLATEX) $(PdflatexArgs) $1\n" >>$(DocumentBuildLog); \
	 $(PDFLATEX) $(PdflatexArgs) $1 2>&1 >>$(DocumentBuildLog) || $(PDFLATEX) $(PdflatexArgs) $1)
endef

define biber
	(echo -e "\nCOMMAND: $(BIBER) $1\n" >>$(DocumentBuildLog);	\
	 $(BIBER) $1 2>&1 >>$(DocumentBuildLog) || $(BIBER) $1)
endef

define bibtool
	(echo -e "\nCOMMAND: $(BIBTOOL) -x $1 -o $2\n" >>$(DocumentBuildLog); \
	 $(BIBTOOL) -v -x $1 -o $2 >$(DocumentBuildLog) 2>&1 || $(BIBTOOL) -v -x $1 -o $2)
endef

define cleanbib
	(echo -e "\nCOMMAND: $(CLEANBIB) $1\n" >>$(DocumentBuildLog); \
	 $(CLEANBIB) $1 >$(DocumentBuildLog) 2>&1 || $(CLEANBIB) $1)
endef

define hook
	(echo -e "\nCOMMAND: $1\n" >>$(DocumentBuildLog); \
	 $1 >$(DocumentBuildLog) 2>&1 || $1)
endef

# The LaTeX build target. This gnarly bit of shell hackery uses nested
# conditionals and sub-shells to invoke pdflatex, biber, bibtool, and
# cleanbib the correct number of times depending on the document
# contents. The sequence of program invocations is as follows:
#
# 1. pre-execution hooks
# 2. pdflatex
# -  If the document contains citations:
# 3.     biber
# -      If the document uses the global biblibrary:
# 4.          bibtool
# 5.          cleanbib
# 6.     pdflatex
# 7.  pdflatex
# 8.  post-execution hooks
%.pdf: %.tex
	$(QUIET)for pre in $(PreExecutionHooks); do                            \
		@echo "  EXEC     $$pre";                                      \
		$(call hook,./$$pre);                                          \
	done
	$(QUIET)echo -e "Build log for `date`\n" >$(DocumentBuildLog)
	@echo '  LATEX    $@'
	$(QUIET)$(call pdflatex, $<)
	$(QUIET)($(GREP) 'cite{' >/dev/null 2>&1 < $*.aux && {                 \
			echo "  BIBER    $@";                                  \
			$(call biber, $*);                                     \
			$(EGREP) '\\bibdata.*$(BIBLIBRARY)' $*.aux >/dev/null 2>&1 && { \
				echo '  BIBTOOL  $(DocumentBibfile)';          \
				$(call bibtool,$*.aux,$(DocumentBibfile));     \
				$(call cleanbib,$(DocumentBibfile));           \
			} || true;                                             \
			echo '  LATEX    $@';                                  \
			$(call pdflatex, $<);                                  \
		} || true)
	@echo '  LATEX    $@'
	$(QUIET)$(call pdflatex, $<)
	$(QUIET)for post in $(PostExecutionHooks); do                          \
		@echo "  EXEC     $$post";                                     \
		$(call hook,./$$post);                                         \
	done

# Compile a plaintext version of the document.
#
txt: $(DocumentTxt)

$(DocumentTxt): $(DocumentTex)
	@echo '  TEXT     $@'
	$(QUIET)$(DETEX) $< > $@

# TODO: clean

PhonyTargets += clean

clean:
	$(QUIET)$(RM) -fv $(CleanFiles)

.PHONY: $(PhonyTargets)
