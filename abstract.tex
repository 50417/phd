\begin{abstract}
Compilers should produce correct code for valid inputs, and produce meaningful errors when inputs are invalid. Fixed test-suites are inadequate for ensuring these properties over the enormous range of possible inputs to a compiler, and the complexity of optimizing compilers renders them beyond the scope of formal verification. In recent years, probabilistic grammar-based tools have proven successful for finding bugs by comparing the output randomly generated programs across compilers.

These tools require extensive development effort, and by design, yield large random programs which bare little resemblance to actual real code written by human programmers. These ``implausible'' programs attempt to discover bugs using uncommon combinations of language constructs. \cc{\ldots}

What is needed is a technique for biasing the random generation of programs so that the generated codes are ``plausible'', and closely resemble that of real hand-written code.

We present a new approach for the generation of \emph{plausible} compiler test cases. We apply deep learning techniques over large corpuses of open source code fragments to learn models which describe the structure of common real world codes. We use these models to generate thousands of code samples, and show how established differential testing methodologies can be used to expose bugs in compilers which are symptomatic of real hand-written code.

We extend the state of the art in compiler test-case generation, automatically exposing bugs in compilers which are likely to arise from real world use cases, in a way which is not possible using existing techniques. In an empirical evaluation of 9 commercial and open source OpenCL implementations, we discover bugs in all of them, submitting XX bug reports to commercial and open source OpenCL implementations.

Our paper serves two purposes: first, we propose a novel methodology for compiler test case generation, capable of finding bugs at a faster rate and covering more areas of the compiler than existing approaches; second, we report on the state of OpenCL implementations.
\end{abstract}
