       # -*- coding: utf-8 -*-
    4: import unittest
    4: import pickle
    4: import cPickle
    4: import StringIO
    4: import cStringIO
    4: import pickletools
    4: import copy_reg
    4: import sys
       
    4: from test import test_support as support
    4: from test.test_support import TestFailed, verbose, have_unicode, TESTFN
    4: try:
    4:     from test.test_support import _2G, _1M, precisionbigmemtest
>>>>>> except ImportError:
           # this import might fail when run on older Python versions by test_xpickle
>>>>>>     _2G = _1M = 0
>>>>>>     def precisionbigmemtest(*args, **kwargs):
>>>>>>         return lambda self: None
       
       # Tests that try a number of pickle protocols should have a
       #     for proto in protocols:
       # kind of outer loop.
    4: assert pickle.HIGHEST_PROTOCOL == cPickle.HIGHEST_PROTOCOL == 2
    4: protocols = range(pickle.HIGHEST_PROTOCOL + 1)
       
       # Copy of test.test_support.run_with_locale. This is needed to support Python
       # 2.4, which didn't include it. This is all to support test_xpickle, which
       # bounces pickled objects through older Python versions to test backwards
       # compatibility.
    4: def run_with_locale(catstr, *locales):
    4:     def decorator(func):
    4:         def inner(*args, **kwds):
   11:             try:
   11:                 import locale
   11:                 category = getattr(locale, catstr)
   11:                 orig_locale = locale.setlocale(category)
>>>>>>             except AttributeError:
                       # if the test author gives us an invalid category string
>>>>>>                 raise
>>>>>>             except:
                       # cannot retrieve original locale, so do nothing
>>>>>>                 locale = orig_locale = None
                   else:
   11:                 for loc in locales:
   11:                     try:
   11:                         locale.setlocale(category, loc)
   11:                         break
>>>>>>                     except:
>>>>>>                         pass
       
                   # now run the function, resetting the locale on exceptions
   11:             try:
   11:                 return func(*args, **kwds)
                   finally:
   11:                 if locale and orig_locale:
   11:                     locale.setlocale(category, orig_locale)
    4:         inner.func_name = func.func_name
    4:         inner.__doc__ = func.__doc__
    4:         return inner
    4:     return decorator
       
    4: def no_tracing(func):
           """Decorator to temporarily turn off tracing for the duration of a test."""
    4:     if not hasattr(sys, 'gettrace'):
>>>>>>         return func
           else:
    4:         def wrapper(*args, **kwargs):
   11:             original_trace = sys.gettrace()
   11:             try:
   11:                 sys.settrace(None)
>>>>>>                 return func(*args, **kwargs)
                   finally:
>>>>>>                 sys.settrace(original_trace)
    4:         wrapper.__name__ = func.__name__
    4:         return wrapper
       
       
       # Return True if opcode code appears in the pickle, else False.
    4: def opcode_in_pickle(code, pickle):
 5028:     for op, dummy, dummy in pickletools.genops(pickle):
 4854:         if op.code == code:
  434:             return True
  174:     return False
       
       # Return the number of times opcode code appears in pickle.
    4: def count_opcode(code, pickle):
  132:     n = 0
304630:     for op, dummy, dummy in pickletools.genops(pickle):
304498:         if op.code == code:
  176:             n += 1
  132:     return n
       
    8: class UnseekableIO(StringIO.StringIO):
    4:     def peek(self, *args):
>>>>>>         raise NotImplementedError
       
    4:     def seek(self, *args):
>>>>>>         raise NotImplementedError
       
    4:     def tell(self):
>>>>>>         raise NotImplementedError
       
       # We can't very well test the extension registry without putting known stuff
       # in it, but we have to be careful to restore its original state.  Code
       # should do this:
       #
       #     e = ExtensionSaver(extension_code)
       #     try:
       #         fiddle w/ the extension registry's stuff for extension_code
       #     finally:
       #         e.restore()
       
    8: class ExtensionSaver:
           # Remember current registration for code (if any), and remove it (if
           # there is one).
    4:     def __init__(self, code):
   91:         self.code = code
   91:         if code in copy_reg._inverted_registry:
>>>>>>             self.pair = copy_reg._inverted_registry[code]
>>>>>>             copy_reg.remove_extension(self.pair[0], self.pair[1], code)
               else:
   91:             self.pair = None
       
           # Restore previous registration for code.
    4:     def restore(self):
   91:         code = self.code
   91:         curpair = copy_reg._inverted_registry.get(code)
   91:         if curpair is not None:
   89:             copy_reg.remove_extension(curpair[0], curpair[1], code)
   91:         pair = self.pair
   91:         if pair is not None:
>>>>>>             copy_reg.add_extension(pair[0], pair[1], code)
       
    8: class C:
    4:     def __cmp__(self, other):
  279:         return cmp(self.__dict__, other.__dict__)
       
    8: class D(C):
    4:     def __init__(self, arg):
   18:         pass
       
    8: class E(C):
    4:     def __getinitargs__(self):
>>>>>>         return ()
       
    8: class H(object):
    4:     pass
       
    8: class MyErr(Exception):
    4:     def __init__(self):
   12:         pass
       
    8: class I:
    4:     def __init__(self, *args, **kwargs):
   12:         raise MyErr()
       
    4:     def __getinitargs__(self):
>>>>>>         return ()
       
       # Hashable mutable key
    8: class K(object):
    4:     def __init__(self, value):
   62:         self.value = value
       
    4:     def __reduce__(self):
               # Shouldn't support the recursion itself
  407:         return K, (self.value,)
       
    4: __main__ = sys.modules['__main__']
    4: __main__.C = C
    4: C.__module__ = "__main__"
    4: __main__.D = D
    4: D.__module__ = "__main__"
    4: __main__.E = E
    4: E.__module__ = "__main__"
    4: __main__.H = H
    4: H.__module__ = "__main__"
    4: __main__.I = I
    4: I.__module__ = "__main__"
    4: __main__.K = K
    4: K.__module__ = "__main__"
       
    8: class myint(int):
    4:     def __init__(self, x):
   33:         self.str = str(x)
       
    8: class initarg(C):
       
    4:     def __init__(self, a, b):
   66:         self.a = a
   66:         self.b = b
       
    4:     def __getinitargs__(self):
   33:         return self.a, self.b
       
    8: class metaclass(type):
    4:     pass
       
    8: class use_metaclass(object):
    4:     __metaclass__ = metaclass
       
    8: class pickling_metaclass(type):
    4:     def __eq__(self, other):
   33:         return (type(self) == type(other) and
   33:                 self.reduce_args == other.reduce_args)
       
    4:     def __reduce__(self):
   33:         return (create_dynamic_class, self.reduce_args)
       
    4:     __hash__ = None
       
    4: def create_dynamic_class(name, bases):
   44:     result = pickling_metaclass(name, bases, dict())
   44:     result.reduce_args = (name, bases)
   44:     return result
       
       # DATA0 .. DATA2 are the pickles we expect under the various protocols, for
       # the object returned by create_data().
       
       # break into multiple strings to avoid confusing font-lock-mode
       DATA0 = """(lp1
       I0
       aL1L
       aF2
       ac__builtin__
       complex
       p2
       """ + \
       """(F3
       F0
       tRp3
       aI1
       aI-1
       aI255
       aI-255
       aI-256
       aI65535
       aI-65535
       aI-65536
       aI2147483647
       aI-2147483647
       aI-2147483648
       a""" + \
       """(S'abc'
       p4
       g4
       """ + \
       """(i__main__
       C
       p5
    4: """ + \
       """(dp6
       S'foo'
       p7
       I1
       sS'bar'
       p8
       I2
       sbg5
       tp9
       ag9
       aI5
       a.
    4: """
       
       # Disassembly of DATA0.
       DATA0_DIS = """\
           0: (    MARK
           1: l        LIST       (MARK at 0)
           2: p    PUT        1
           5: I    INT        0
           8: a    APPEND
           9: L    LONG       1L
          13: a    APPEND
          14: F    FLOAT      2.0
          17: a    APPEND
          18: c    GLOBAL     '__builtin__ complex'
          39: p    PUT        2
          42: (    MARK
          43: F        FLOAT      3.0
          46: F        FLOAT      0.0
          49: t        TUPLE      (MARK at 42)
          50: R    REDUCE
          51: p    PUT        3
          54: a    APPEND
          55: I    INT        1
          58: a    APPEND
          59: I    INT        -1
          63: a    APPEND
          64: I    INT        255
          69: a    APPEND
          70: I    INT        -255
          76: a    APPEND
          77: I    INT        -256
          83: a    APPEND
          84: I    INT        65535
          91: a    APPEND
          92: I    INT        -65535
         100: a    APPEND
         101: I    INT        -65536
         109: a    APPEND
         110: I    INT        2147483647
         122: a    APPEND
         123: I    INT        -2147483647
         136: a    APPEND
         137: I    INT        -2147483648
         150: a    APPEND
         151: (    MARK
         152: S        STRING     'abc'
         159: p        PUT        4
         162: g        GET        4
         165: (        MARK
         166: i            INST       '__main__ C' (MARK at 165)
         178: p        PUT        5
         181: (        MARK
         182: d            DICT       (MARK at 181)
         183: p        PUT        6
         186: S        STRING     'foo'
         193: p        PUT        7
         196: I        INT        1
         199: s        SETITEM
         200: S        STRING     'bar'
         207: p        PUT        8
         210: I        INT        2
         213: s        SETITEM
         214: b        BUILD
         215: g        GET        5
         218: t        TUPLE      (MARK at 151)
         219: p    PUT        9
         222: a    APPEND
         223: g    GET        9
         226: a    APPEND
         227: I    INT        5
         230: a    APPEND
         231: .    STOP
       highest protocol among opcodes = 0
    4: """
       
    4: DATA1 = (']q\x01(K\x00L1L\nG@\x00\x00\x00\x00\x00\x00\x00'
                'c__builtin__\ncomplex\nq\x02(G@\x08\x00\x00\x00\x00\x00'
                '\x00G\x00\x00\x00\x00\x00\x00\x00\x00tRq\x03K\x01J\xff\xff'
                '\xff\xffK\xffJ\x01\xff\xff\xffJ\x00\xff\xff\xffM\xff\xff'
                'J\x01\x00\xff\xffJ\x00\x00\xff\xffJ\xff\xff\xff\x7fJ\x01\x00'
                '\x00\x80J\x00\x00\x00\x80(U\x03abcq\x04h\x04(c__main__\n'
                'C\nq\x05oq\x06}q\x07(U\x03fooq\x08K\x01U\x03barq\tK\x02ubh'
                '\x06tq\nh\nK\x05e.'
               )
       
       # Disassembly of DATA1.
       DATA1_DIS = """\
           0: ]    EMPTY_LIST
           1: q    BINPUT     1
           3: (    MARK
           4: K        BININT1    0
           6: L        LONG       1L
          10: G        BINFLOAT   2.0
          19: c        GLOBAL     '__builtin__ complex'
          40: q        BINPUT     2
          42: (        MARK
          43: G            BINFLOAT   3.0
          52: G            BINFLOAT   0.0
          61: t            TUPLE      (MARK at 42)
          62: R        REDUCE
          63: q        BINPUT     3
          65: K        BININT1    1
          67: J        BININT     -1
          72: K        BININT1    255
          74: J        BININT     -255
          79: J        BININT     -256
          84: M        BININT2    65535
          87: J        BININT     -65535
          92: J        BININT     -65536
          97: J        BININT     2147483647
         102: J        BININT     -2147483647
         107: J        BININT     -2147483648
         112: (        MARK
         113: U            SHORT_BINSTRING 'abc'
         118: q            BINPUT     4
         120: h            BINGET     4
         122: (            MARK
         123: c                GLOBAL     '__main__ C'
         135: q                BINPUT     5
         137: o                OBJ        (MARK at 122)
         138: q            BINPUT     6
         140: }            EMPTY_DICT
         141: q            BINPUT     7
         143: (            MARK
         144: U                SHORT_BINSTRING 'foo'
         149: q                BINPUT     8
         151: K                BININT1    1
         153: U                SHORT_BINSTRING 'bar'
         158: q                BINPUT     9
         160: K                BININT1    2
         162: u                SETITEMS   (MARK at 143)
         163: b            BUILD
         164: h            BINGET     6
         166: t            TUPLE      (MARK at 112)
         167: q        BINPUT     10
         169: h        BINGET     10
         171: K        BININT1    5
         173: e        APPENDS    (MARK at 3)
         174: .    STOP
       highest protocol among opcodes = 1
    4: """
       
    4: DATA2 = ('\x80\x02]q\x01(K\x00\x8a\x01\x01G@\x00\x00\x00\x00\x00\x00\x00'
                'c__builtin__\ncomplex\nq\x02G@\x08\x00\x00\x00\x00\x00\x00G\x00'
                '\x00\x00\x00\x00\x00\x00\x00\x86Rq\x03K\x01J\xff\xff\xff\xffK'
                '\xffJ\x01\xff\xff\xffJ\x00\xff\xff\xffM\xff\xffJ\x01\x00\xff\xff'
                'J\x00\x00\xff\xffJ\xff\xff\xff\x7fJ\x01\x00\x00\x80J\x00\x00\x00'
                '\x80(U\x03abcq\x04h\x04(c__main__\nC\nq\x05oq\x06}q\x07(U\x03foo'
                'q\x08K\x01U\x03barq\tK\x02ubh\x06tq\nh\nK\x05e.')
       
       # Disassembly of DATA2.
       DATA2_DIS = """\
           0: \x80 PROTO      2
           2: ]    EMPTY_LIST
           3: q    BINPUT     1
           5: (    MARK
           6: K        BININT1    0
           8: \x8a     LONG1      1L
          11: G        BINFLOAT   2.0
          20: c        GLOBAL     '__builtin__ complex'
          41: q        BINPUT     2
          43: G        BINFLOAT   3.0
          52: G        BINFLOAT   0.0
          61: \x86     TUPLE2
          62: R        REDUCE
          63: q        BINPUT     3
          65: K        BININT1    1
          67: J        BININT     -1
          72: K        BININT1    255
          74: J        BININT     -255
          79: J        BININT     -256
          84: M        BININT2    65535
          87: J        BININT     -65535
          92: J        BININT     -65536
          97: J        BININT     2147483647
         102: J        BININT     -2147483647
         107: J        BININT     -2147483648
         112: (        MARK
         113: U            SHORT_BINSTRING 'abc'
         118: q            BINPUT     4
         120: h            BINGET     4
         122: (            MARK
         123: c                GLOBAL     '__main__ C'
         135: q                BINPUT     5
         137: o                OBJ        (MARK at 122)
         138: q            BINPUT     6
         140: }            EMPTY_DICT
         141: q            BINPUT     7
         143: (            MARK
         144: U                SHORT_BINSTRING 'foo'
         149: q                BINPUT     8
         151: K                BININT1    1
         153: U                SHORT_BINSTRING 'bar'
         158: q                BINPUT     9
         160: K                BININT1    2
         162: u                SETITEMS   (MARK at 143)
         163: b            BUILD
         164: h            BINGET     6
         166: t            TUPLE      (MARK at 112)
         167: q        BINPUT     10
         169: h        BINGET     10
         171: K        BININT1    5
         173: e        APPENDS    (MARK at 5)
         174: .    STOP
       highest protocol among opcodes = 2
    4: """
       
    4: def create_data():
    4:     c = C()
    4:     c.foo = 1
    4:     c.bar = 2
    4:     x = [0, 1L, 2.0, 3.0+0j]
           # Append some integer test cases at cPickle.c's internal size
           # cutoffs.
    4:     uint1max = 0xff
    4:     uint2max = 0xffff
    4:     int4max = 0x7fffffff
    4:     x.extend([1, -1,
    4:               uint1max, -uint1max, -uint1max-1,
    4:               uint2max, -uint2max, -uint2max-1,
    4:                int4max,  -int4max,  -int4max-1])
    4:     y = ('abc', 'abc', c, c)
    4:     x.append(y)
    4:     x.append(y)
    4:     x.append(5)
    4:     return x
       
       
    8: class AbstractUnpickleTests(unittest.TestCase):
           # Subclass must define self.loads, self.error.
       
    4:     _testdata = create_data()
       
    4:     def assert_is_copy(self, obj, objcopy, msg=None):
               """Utility method to verify if two objects are copies of each others.
               """
   72:         if msg is None:
   72:             msg = "{!r} is not a copy of {!r}".format(obj, objcopy)
   72:         self.assertEqual(obj, objcopy, msg=msg)
   72:         self.assertIs(type(obj), type(objcopy), msg=msg)
   72:         if hasattr(obj, '__dict__'):
   54:             self.assertDictEqual(obj.__dict__, objcopy.__dict__, msg=msg)
   54:             self.assertIsNot(obj.__dict__, objcopy.__dict__, msg=msg)
   72:         if hasattr(obj, '__slots__'):
>>>>>>             self.assertListEqual(obj.__slots__, objcopy.__slots__, msg=msg)
>>>>>>             for slot in obj.__slots__:
>>>>>>                 self.assertEqual(
>>>>>>                     hasattr(obj, slot), hasattr(objcopy, slot), msg=msg)
>>>>>>                 self.assertEqual(getattr(obj, slot, None),
>>>>>>                                  getattr(objcopy, slot, None), msg=msg)
       
    4:     def check_unpickling_error(self, errors, data):
  810:         try:
  810:             try:
  810:                 self.loads(data)
  810:             except:
  810:                 if support.verbose > 1:
>>>>>>                     exc_type, exc, tb = sys.exc_info()
>>>>>>                     print '%-32r - %s: %s' % (data, exc_type.__name__, exc)
  810:                 raise
  810:         except errors:
  810:             pass
               else:
>>>>>>             try:
>>>>>>                 exc_name = errors.__name__
>>>>>>             except AttributeError:
>>>>>>                 exc_name = str(errors)
>>>>>>             raise self.failureException('%s not raised' % exc_name)
       
    4:     def test_load_from_canned_string(self):
    6:         expected = self._testdata
   24:         for canned in DATA0, DATA1, DATA2:
   18:             got = self.loads(canned)
   18:             self.assert_is_copy(expected, got)
       
    4:     def test_garyp(self):
    6:         self.check_unpickling_error(self.error, 'garyp')
       
    4:     def test_maxint64(self):
    6:         maxint64 = (1L << 63) - 1
    6:         data = 'I' + str(maxint64) + '\n.'
    6:         got = self.loads(data)
    6:         self.assertEqual(got, maxint64)
       
               # Try too with a bogus literal.
    6:         data = 'I' + str(maxint64) + 'JUNK\n.'
    6:         self.check_unpickling_error(ValueError, data)
       
    4:     def test_insecure_strings(self):
    6:         insecure = ["abc", "2 + 2", # not quoted
                           #"'abc' + 'def'", # not a single quoted string
    6:                     "'abc", # quote is not closed
    6:                     "'abc\"", # open quote and close quote don't match
    6:                     "'abc'   ?", # junk after close quote
    6:                     "'\\'", # trailing backslash
                           # issue #17710
    6:                     "'", '"',
    6:                     "' ", '" ',
    6:                     '\'"', '"\'',
    6:                     " ''", ' ""',
    6:                     ' ',
                           # some tests of the quoting rules
                           #"'abc\"\''",
                           #"'\\\\a\'\'\'\\\'\\\\\''",
                           ]
   96:         for s in insecure:
   90:             buf = "S" + s + "\n."
   90:             self.check_unpickling_error(ValueError, buf)
       
    4:     def test_correctly_quoted_string(self):
    6:         goodpickles = [("S''\n.", ''),
    6:                        ('S""\n.', ''),
    6:                        ('S"\\n"\n.', '\n'),
    6:                        ("S'\\n'\n.", '\n')]
   30:         for p, expected in goodpickles:
   24:             self.assertEqual(self.loads(p), expected)
       
    4:     def test_load_classic_instance(self):
               # See issue5180.  Test loading 2.x pickles that
               # contain an instance of old style class.
   24:         for X, args in [(C, ()), (D, ('x',)), (E, ())]:
   18:             xname = X.__name__.encode('ascii')
                   # Protocol 0 (text mode pickle):
                   """
                    0: (    MARK
                    1: i        INST       '__main__ X' (MARK at 0)
                   13: p    PUT        0
                   16: (    MARK
                   17: d        DICT       (MARK at 16)
                   18: p    PUT        1
                   21: b    BUILD
                   22: .    STOP
                   """
   18:             pickle0 = ("(i__main__\n"
                              "X\n"
                              "p0\n"
   18:                        "(dp1\nb.").replace('X', xname)
   18:             self.assert_is_copy(X(*args), self.loads(pickle0))
       
                   # Protocol 1 (binary mode pickle)
                   """
                    0: (    MARK
                    1: c        GLOBAL     '__main__ X'
                   13: q        BINPUT     0
                   15: o        OBJ        (MARK at 0)
                   16: q    BINPUT     1
                   18: }    EMPTY_DICT
                   19: q    BINPUT     2
                   21: b    BUILD
                   22: .    STOP
                   """
   18:             pickle1 = ('(c__main__\n'
                              'X\n'
   18:                        'q\x00oq\x01}q\x02b.').replace('X', xname)
   18:             self.assert_is_copy(X(*args), self.loads(pickle1))
       
                   # Protocol 2 (pickle2 = '\x80\x02' + pickle1)
                   """
                    0: \x80 PROTO      2
                    2: (    MARK
                    3: c        GLOBAL     '__main__ X'
                   15: q        BINPUT     0
                   17: o        OBJ        (MARK at 2)
                   18: q    BINPUT     1
                   20: }    EMPTY_DICT
                   21: q    BINPUT     2
                   23: b    BUILD
                   24: .    STOP
                   """
   18:             pickle2 = ('\x80\x02(c__main__\n'
                              'X\n'
   18:                        'q\x00oq\x01}q\x02b.').replace('X', xname)
   18:             self.assert_is_copy(X(*args), self.loads(pickle2))
       
    4:     def test_load_classic_instance_error(self):
               # Issue #28925.
               # Protocol 0 (text mode pickle):
               """
                0: (    MARK
                1: i        INST       '__main__ I' (MARK at 0)
               13: (    MARK
               14: d        DICT       (MARK at 13)
               15: b    BUILD
               16: .    STOP
               """
    6:         pickle0 = ('(i__main__\n'
                          'I\n'
                          '(db.')
    6:         self.assertRaises(MyErr, self.loads, pickle0)
       
               # Protocol 1 (binary mode pickle)
               """
                0: (    MARK
                1: c        GLOBAL     '__main__ I'
               13: o        OBJ        (MARK at 0)
               14: }    EMPTY_DICT
               15: b    BUILD
               16: .    STOP
               """
    6:         pickle1 = ('(c__main__\n'
                          'I\n'
                          'o}b.')
    6:         self.assertRaises(MyErr, self.loads, pickle1)
       
    4:     def test_load_str(self):
               # From Python 2: pickle.dumps('a\x00\xa0', protocol=0)
    6:         self.assertEqual(self.loads("S'a\\x00\\xa0'\n."), 'a\x00\xa0')
               # From Python 2: pickle.dumps('a\x00\xa0', protocol=1)
    6:         self.assertEqual(self.loads('U\x03a\x00\xa0.'), 'a\x00\xa0')
               # From Python 2: pickle.dumps('a\x00\xa0', protocol=2)
    6:         self.assertEqual(self.loads('\x80\x02U\x03a\x00\xa0.'), 'a\x00\xa0')
       
    4:     def test_load_unicode(self):
               # From Python 2: pickle.dumps(u'π', protocol=0)
    6:         self.assertEqual(self.loads('V\\u03c0\n.'), u'π')
               # From Python 2: pickle.dumps(u'π', protocol=1)
    6:         self.assertEqual(self.loads('X\x02\x00\x00\x00\xcf\x80.'), u'π')
               # From Python 2: pickle.dumps(u'π', protocol=2)
    6:         self.assertEqual(self.loads('\x80\x02X\x02\x00\x00\x00\xcf\x80.'), u'π')
       
    4:     def test_constants(self):
    6:         self.assertIsNone(self.loads('N.'))
    6:         self.assertIs(self.loads('\x88.'), True)
    6:         self.assertIs(self.loads('\x89.'), False)
    6:         self.assertIs(self.loads('I01\n.'), True)
    6:         self.assertIs(self.loads('I00\n.'), False)
       
    4:     def test_misc_get(self):
    6:         self.check_unpickling_error(self.error, 'g0\np0\n')
    6:         self.check_unpickling_error(self.error, 'h\x00q\x00')
       
    4:     def test_get(self):
    6:         pickled = '((lp100000\ng100000\nt.'
    6:         unpickled = self.loads(pickled)
    6:         self.assertEqual(unpickled, ([],)*2)
    6:         self.assertIs(unpickled[0], unpickled[1])
       
    4:     def test_binget(self):
    6:         pickled = '(]q\xffh\xfft.'
    6:         unpickled = self.loads(pickled)
    6:         self.assertEqual(unpickled, ([],)*2)
    6:         self.assertIs(unpickled[0], unpickled[1])
       
    4:     def test_long_binget(self):
    6:         pickled = '(]r\x00\x00\x01\x00j\x00\x00\x01\x00t.'
    6:         unpickled = self.loads(pickled)
    6:         self.assertEqual(unpickled, ([],)*2)
    6:         self.assertIs(unpickled[0], unpickled[1])
       
    4:     def test_dup(self):
    6:         pickled = '((l2t.'
    6:         unpickled = self.loads(pickled)
    6:         self.assertEqual(unpickled, ([],)*2)
    6:         self.assertIs(unpickled[0], unpickled[1])
       
    4:     def test_bad_stack(self):
               badpickles = [
    6:             '.',                        # STOP
    6:             '0',                        # POP
    6:             '1',                        # POP_MARK
    6:             '2',                        # DUP
                   # '(2',                     # PyUnpickler doesn't raise
    6:             'R',                        # REDUCE
    6:             ')R',
    6:             'a',                        # APPEND
    6:             'Na',
    6:             'b',                        # BUILD
    6:             'Nb',
    6:             'd',                        # DICT
    6:             'e',                        # APPENDS
                   # '(e',                     # PyUnpickler raises AttributeError
    6:             'i__builtin__\nlist\n',     # INST
    6:             'l',                        # LIST
    6:             'o',                        # OBJ
    6:             '(o',
    6:             'p1\n',                     # PUT
    6:             'q\x00',                    # BINPUT
    6:             'r\x00\x00\x00\x00',        # LONG_BINPUT
    6:             's',                        # SETITEM
    6:             'Ns',
    6:             'NNs',
    6:             't',                        # TUPLE
    6:             'u',                        # SETITEMS
                   # '(u',                     # PyUnpickler doesn't raise
    6:             '}(Nu',
    6:             '\x81',                     # NEWOBJ
    6:             ')\x81',
    6:             '\x85',                     # TUPLE1
    6:             '\x86',                     # TUPLE2
    6:             'N\x86',
    6:             '\x87',                     # TUPLE3
    6:             'N\x87',
    6:             'NN\x87',
               ]
  204:         for p in badpickles:
  198:             self.check_unpickling_error(self.bad_stack_errors, p)
       
    4:     def test_bad_mark(self):
               badpickles = [
                   # 'N(.',                      # STOP
    6:             'N(2',                      # DUP
    6:             'c__builtin__\nlist\n)(R',  # REDUCE
    6:             'c__builtin__\nlist\n()R',
    6:             ']N(a',                     # APPEND
                                               # BUILD
    6:             'c__builtin__\nValueError\n)R}(b',
    6:             'c__builtin__\nValueError\n)R(}b',
    6:             '(Nd',                      # DICT
    6:             'N(p1\n',                   # PUT
    6:             'N(q\x00',                  # BINPUT
    6:             'N(r\x00\x00\x00\x00',      # LONG_BINPUT
    6:             '}NN(s',                    # SETITEM
    6:             '}N(Ns',
    6:             '}(NNs',
    6:             '}((u',                     # SETITEMS
                                               # NEWOBJ
    6:             'c__builtin__\nlist\n)(\x81',
    6:             'c__builtin__\nlist\n()\x81',
    6:             'N(\x85',                   # TUPLE1
    6:             'NN(\x86',                  # TUPLE2
    6:             'N(N\x86',
    6:             'NNN(\x87',                 # TUPLE3
    6:             'NN(N\x87',
    6:             'N(NN\x87',
               ]
  138:         for p in badpickles:
  132:             self.check_unpickling_error(self.bad_mark_errors, p)
       
    4:     def test_truncated_data(self):
    6:         self.check_unpickling_error(EOFError, '')
    6:         self.check_unpickling_error(EOFError, 'N')
               badpickles = [
    6:             'F',                        # FLOAT
    6:             'F0.0',
    6:             'F0.00',
    6:             'G',                        # BINFLOAT
    6:             'G\x00\x00\x00\x00\x00\x00\x00',
    6:             'I',                        # INT
    6:             'I0',
    6:             'J',                        # BININT
    6:             'J\x00\x00\x00',
    6:             'K',                        # BININT1
    6:             'L',                        # LONG
    6:             'L0',
    6:             'L10',
    6:             'L0L',
    6:             'L10L',
    6:             'M',                        # BININT2
    6:             'M\x00',
                   # 'P',                        # PERSID
                   # 'Pabc',
    6:             'S',                        # STRING
    6:             "S'abc'",
    6:             'T',                        # BINSTRING
    6:             'T\x03\x00\x00',
    6:             'T\x03\x00\x00\x00',
    6:             'T\x03\x00\x00\x00ab',
    6:             'U',                        # SHORT_BINSTRING
    6:             'U\x03',
    6:             'U\x03ab',
    6:             'V',                        # UNICODE
    6:             'Vabc',
    6:             'X',                        # BINUNICODE
    6:             'X\x03\x00\x00',
    6:             'X\x03\x00\x00\x00',
    6:             'X\x03\x00\x00\x00ab',
    6:             '(c',                       # GLOBAL
    6:             '(c__builtin__',
    6:             '(c__builtin__\n',
    6:             '(c__builtin__\nlist',
    6:             'Ng',                       # GET
    6:             'Ng0',
    6:             '(i',                       # INST
    6:             '(i__builtin__',
    6:             '(i__builtin__\n',
    6:             '(i__builtin__\nlist',
    6:             'Nh',                       # BINGET
    6:             'Nj',                       # LONG_BINGET
    6:             'Nj\x00\x00\x00',
    6:             'Np',                       # PUT
    6:             'Np0',
    6:             'Nq',                       # BINPUT
    6:             'Nr',                       # LONG_BINPUT
    6:             'Nr\x00\x00\x00',
    6:             '\x80',                     # PROTO
    6:             '\x82',                     # EXT1
    6:             '\x83',                     # EXT2
    6:             '\x84\x01',
    6:             '\x84',                     # EXT4
    6:             '\x84\x01\x00\x00',
    6:             '\x8a',                     # LONG1
    6:             '\x8b',                     # LONG4
    6:             '\x8b\x00\x00\x00',
               ]
  360:         for p in badpickles:
  354:             self.check_unpickling_error(self.truncated_errors, p)
       
       
    8: class AbstractPickleTests(unittest.TestCase):
           # Subclass must define self.dumps, self.loads.
       
    4:     _testdata = AbstractUnpickleTests._testdata
       
    4:     def setUp(self):
  599:         pass
       
    4:     def test_misc(self):
               # test various datatypes not tested by testdata
   44:         for proto in protocols:
   33:             x = myint(4)
   33:             s = self.dumps(x, proto)
   33:             y = self.loads(s)
   33:             self.assertEqual(x, y)
       
   33:             x = (1, ())
   33:             s = self.dumps(x, proto)
   33:             y = self.loads(s)
   33:             self.assertEqual(x, y)
       
   33:             x = initarg(1, x)
   33:             s = self.dumps(x, proto)
   33:             y = self.loads(s)
   33:             self.assertEqual(x, y)
       
               # XXX test __reduce__ protocol?
       
    4:     def test_roundtrip_equality(self):
   10:         expected = self._testdata
   40:         for proto in protocols:
   30:             s = self.dumps(expected, proto)
   30:             got = self.loads(s)
   30:             self.assertEqual(expected, got)
       
           # There are gratuitous differences between pickles produced by
           # pickle and cPickle, largely because cPickle starts PUT indices at
           # 1 and pickle starts them at 0.  See XXX comment in cPickle's put2() --
           # there's a comment with an exclamation point there whose meaning
           # is a mystery.  cPickle also suppresses PUT for objects with a refcount
           # of 1.
    4:     def dont_test_disassembly(self):
>>>>>>         from pickletools import dis
       
>>>>>>         for proto, expected in (0, DATA0_DIS), (1, DATA1_DIS):
>>>>>>             s = self.dumps(self._testdata, proto)
>>>>>>             filelike = cStringIO.StringIO()
>>>>>>             dis(s, out=filelike)
>>>>>>             got = filelike.getvalue()
>>>>>>             self.assertEqual(expected, got)
       
    4:     def test_recursive_list(self):
   10:         l = []
   10:         l.append(l)
   40:         for proto in protocols:
   30:             s = self.dumps(l, proto)
   30:             x = self.loads(s)
   30:             self.assertIsInstance(x, list)
   30:             self.assertEqual(len(x), 1)
   30:             self.assertIs(x[0], x)
       
    4:     def test_recursive_tuple_and_list(self):
   10:         t = ([],)
   10:         t[0].append(t)
   40:         for proto in protocols:
   30:             s = self.dumps(t, proto)
   30:             x = self.loads(s)
   30:             self.assertIsInstance(x, tuple)
   30:             self.assertEqual(len(x), 1)
   30:             self.assertIsInstance(x[0], list)
   30:             self.assertEqual(len(x[0]), 1)
   30:             self.assertIs(x[0][0], x)
       
    4:     def test_recursive_dict(self):
   11:         d = {}
   11:         d[1] = d
   41:         for proto in protocols:
   31:             s = self.dumps(d, proto)
   30:             x = self.loads(s)
   30:             self.assertIsInstance(x, dict)
   30:             self.assertEqual(x.keys(), [1])
   30:             self.assertIs(x[1], x)
       
    4:     def test_recursive_dict_key(self):
   11:         d = {}
   11:         k = K(d)
   11:         d[k] = 1
   41:         for proto in protocols:
   31:             s = self.dumps(d, proto)
   30:             x = self.loads(s)
   30:             self.assertIsInstance(x, dict)
   30:             self.assertEqual(len(x.keys()), 1)
   30:             self.assertIsInstance(x.keys()[0], K)
   30:             self.assertIs(x.keys()[0].value, x)
       
    4:     def test_recursive_list_subclass(self):
   10:         y = MyList()
   10:         y.append(y)
   10:         s = self.dumps(y, 2)
   10:         x = self.loads(s)
   10:         self.assertIsInstance(x, MyList)
   10:         self.assertEqual(len(x), 1)
   10:         self.assertIs(x[0], x)
       
    4:     def test_recursive_dict_subclass(self):
   11:         d = MyDict()
   11:         d[1] = d
   11:         s = self.dumps(d, 2)
   10:         x = self.loads(s)
   10:         self.assertIsInstance(x, MyDict)
   10:         self.assertEqual(x.keys(), [1])
   10:         self.assertIs(x[1], x)
       
    4:     def test_recursive_dict_subclass_key(self):
   11:         d = MyDict()
   11:         k = K(d)
   11:         d[k] = 1
   11:         s = self.dumps(d, 2)
   10:         x = self.loads(s)
   10:         self.assertIsInstance(x, MyDict)
   10:         self.assertEqual(len(x.keys()), 1)
   10:         self.assertIsInstance(x.keys()[0], K)
   10:         self.assertIs(x.keys()[0].value, x)
       
    4:     def test_recursive_inst(self):
   10:         i = C()
   10:         i.attr = i
   40:         for proto in protocols:
   30:             s = self.dumps(i, proto)
   30:             x = self.loads(s)
   30:             self.assertIsInstance(x, C)
   30:             self.assertEqual(dir(x), dir(i))
   30:             self.assertIs(x.attr, x)
       
    4:     def test_recursive_multi(self):
   10:         l = []
   10:         d = {1:l}
   10:         i = C()
   10:         i.attr = d
   10:         l.append(i)
   40:         for proto in protocols:
   30:             s = self.dumps(l, proto)
   30:             x = self.loads(s)
   30:             self.assertIsInstance(x, list)
   30:             self.assertEqual(len(x), 1)
   30:             self.assertEqual(dir(x[0]), dir(i))
   30:             self.assertEqual(x[0].attr.keys(), [1])
   30:             self.assertTrue(x[0].attr[1] is x)
       
    4:     def check_recursive_collection_and_inst(self, factory):
   82:         h = H()
   82:         y = factory([h])
   82:         h.attr = y
  322:         for proto in protocols:
  242:             s = self.dumps(y, proto)
  240:             x = self.loads(s)
  240:             self.assertIsInstance(x, type(y))
  240:             self.assertEqual(len(x), 1)
  240:             self.assertIsInstance(list(x)[0], H)
  240:             self.assertIs(list(x)[0].attr, x)
       
    4:     def test_recursive_list_and_inst(self):
   10:         self.check_recursive_collection_and_inst(list)
       
    4:     def test_recursive_tuple_and_inst(self):
   10:         self.check_recursive_collection_and_inst(tuple)
       
    4:     def test_recursive_dict_and_inst(self):
   11:         self.check_recursive_collection_and_inst(dict.fromkeys)
       
    4:     def test_recursive_set_and_inst(self):
   10:         self.check_recursive_collection_and_inst(set)
       
    4:     def test_recursive_frozenset_and_inst(self):
   10:         self.check_recursive_collection_and_inst(frozenset)
       
    4:     def test_recursive_list_subclass_and_inst(self):
   10:         self.check_recursive_collection_and_inst(MyList)
       
    4:     def test_recursive_tuple_subclass_and_inst(self):
   10:         self.check_recursive_collection_and_inst(MyTuple)
       
    4:     def test_recursive_dict_subclass_and_inst(self):
   11:         self.check_recursive_collection_and_inst(MyDict.fromkeys)
       
    4:     if have_unicode:
    4:         def test_unicode(self):
   10:             endcases = [u'', u'<\\u>', u'<\\\u1234>', u'<\n>',
   10:                         u'<\\>', u'<\\\U00012345>',
                               # surrogates
   10:                         u'<\udc80>']
   40:             for proto in protocols:
  240:                 for u in endcases:
  210:                     p = self.dumps(u, proto)
  210:                     u2 = self.loads(p)
  210:                     self.assertEqual(u2, u)
       
    4:         def test_unicode_high_plane(self):
   10:             t = u'\U00012345'
   40:             for proto in protocols:
   30:                 p = self.dumps(t, proto)
   30:                 t2 = self.loads(p)
   30:                 self.assertEqual(t2, t)
       
    4:     def test_ints(self):
   11:         import sys
   44:         for proto in protocols:
   33:             n = sys.maxint
 2112:             while n:
 6237:                 for expected in (-n, n):
 4158:                     s = self.dumps(expected, proto)
 4158:                     n2 = self.loads(s)
 4158:                     self.assertEqual(expected, n2)
 2079:                 n = n >> 1
       
    4:     def test_long(self):
   44:         for proto in protocols:
                   # 256 bytes is where LONG4 begins.
  231:             for nbits in 1, 8, 8*254, 8*255, 8*256, 8*257:
  198:                 nbase = 1L << nbits
  792:                 for npos in nbase-1, nbase, nbase+1:
 1782:                     for n in npos, -npos:
 1188:                         pickle = self.dumps(n, proto)
 1188:                         got = self.loads(pickle)
 1188:                         self.assertEqual(n, got)
               # Try a monster.  This is quadratic-time in protos 0 & 1, so don't
               # bother with those.
   11:         nbase = long("deadbeeffeedface", 16)
   11:         nbase += nbase << 1000000
   33:         for n in nbase, -nbase:
   22:             p = self.dumps(n, 2)
   22:             got = self.loads(p)
   22:             self.assertEqual(n, got)
       
    4:     def test_float(self):
   11:         test_values = [0.0, 4.94e-324, 1e-310, 7e-308, 6.626e-34, 0.1, 0.5,
   11:                        3.14, 263.44582062374053, 6.022e23, 1e30]
  132:         test_values = test_values + [-x for x in test_values]
   44:         for proto in protocols:
  759:             for value in test_values:
  726:                 pickle = self.dumps(value, proto)
  726:                 got = self.loads(pickle)
  726:                 self.assertEqual(value, got)
       
    4:     @run_with_locale('LC_ALL', 'de_DE', 'fr_FR')
           def test_float_format(self):
               # make sure that floats are formatted locale independent
   11:         self.assertEqual(self.dumps(1.2)[0:3], 'F1.')
       
    4:     def test_reduce(self):
   10:         pass
       
    4:     def test_getinitargs(self):
   11:         pass
       
    4:     def test_metaclass(self):
   11:         a = use_metaclass()
   44:         for proto in protocols:
   33:             s = self.dumps(a, proto)
   33:             b = self.loads(s)
   33:             self.assertEqual(a.__class__, b.__class__)
       
    4:     def test_dynamic_class(self):
   11:         a = create_dynamic_class("my_dynamic_class", (object,))
   11:         copy_reg.pickle(pickling_metaclass, pickling_metaclass.__reduce__)
   44:         for proto in protocols:
   33:             s = self.dumps(a, proto)
   33:             b = self.loads(s)
   33:             self.assertEqual(a, b)
   33:             self.assertIs(a.__class__, b.__class__)
       
    4:     def test_structseq(self):
   10:         import time
   10:         import os
       
   10:         t = time.localtime()
   40:         for proto in protocols:
   30:             s = self.dumps(t, proto)
   30:             u = self.loads(s)
   30:             self.assertEqual(t, u)
   30:             if hasattr(os, "stat"):
   30:                 t = os.stat(os.curdir)
   30:                 s = self.dumps(t, proto)
   30:                 u = self.loads(s)
   30:                 self.assertEqual(t, u)
   30:             if hasattr(os, "statvfs"):
   30:                 t = os.statvfs(os.curdir)
   30:                 s = self.dumps(t, proto)
   30:                 u = self.loads(s)
   30:                 self.assertEqual(t, u)
       
           # Tests for protocol 2
       
    4:     def test_proto(self):
   11:         build_none = pickle.NONE + pickle.STOP
   44:         for proto in protocols:
   33:             expected = build_none
   33:             if proto >= 2:
   11:                 expected = pickle.PROTO + chr(proto) + expected
   33:             p = self.dumps(None, proto)
   33:             self.assertEqual(p, expected)
       
   11:         oob = protocols[-1] + 1     # a future protocol
   11:         badpickle = pickle.PROTO + chr(oob) + build_none
   11:         try:
   11:             self.loads(badpickle)
   11:         except ValueError, detail:
   11:             self.assertTrue(str(detail).startswith(
   11:                                             "unsupported pickle protocol"))
               else:
>>>>>>             self.fail("expected bad protocol number to raise ValueError")
       
    4:     def test_long1(self):
   11:         x = 12345678910111213141516178920L
   44:         for proto in protocols:
   33:             s = self.dumps(x, proto)
   33:             y = self.loads(s)
   33:             self.assertEqual(x, y)
   33:             self.assertEqual(opcode_in_pickle(pickle.LONG1, s), proto >= 2)
       
    4:     def test_long4(self):
   11:         x = 12345678910111213141516178920L << (256*8)
   44:         for proto in protocols:
   33:             s = self.dumps(x, proto)
   33:             y = self.loads(s)
   33:             self.assertEqual(x, y)
   33:             self.assertEqual(opcode_in_pickle(pickle.LONG4, s), proto >= 2)
       
    4:     def test_short_tuples(self):
               # Map (proto, len(tuple)) to expected opcode.
   10:         expected_opcode = {(0, 0): pickle.TUPLE,
   10:                            (0, 1): pickle.TUPLE,
   10:                            (0, 2): pickle.TUPLE,
   10:                            (0, 3): pickle.TUPLE,
   10:                            (0, 4): pickle.TUPLE,
       
   10:                            (1, 0): pickle.EMPTY_TUPLE,
   10:                            (1, 1): pickle.TUPLE,
   10:                            (1, 2): pickle.TUPLE,
   10:                            (1, 3): pickle.TUPLE,
   10:                            (1, 4): pickle.TUPLE,
       
   10:                            (2, 0): pickle.EMPTY_TUPLE,
   10:                            (2, 1): pickle.TUPLE1,
   10:                            (2, 2): pickle.TUPLE2,
   10:                            (2, 3): pickle.TUPLE3,
   10:                            (2, 4): pickle.TUPLE,
                                 }
   10:         a = ()
   10:         b = (1,)
   10:         c = (1, 2)
   10:         d = (1, 2, 3)
   10:         e = (1, 2, 3, 4)
   40:         for proto in protocols:
  180:             for x in a, b, c, d, e:
  150:                 s = self.dumps(x, proto)
  150:                 y = self.loads(s)
  150:                 self.assertEqual(x, y, (proto, x, s, y))
  150:                 expected = expected_opcode[proto, len(x)]
  150:                 self.assertEqual(opcode_in_pickle(expected, s), True)
       
    4:     def test_singletons(self):
               # Map (proto, singleton) to expected opcode.
   10:         expected_opcode = {(0, None): pickle.NONE,
   10:                            (1, None): pickle.NONE,
   10:                            (2, None): pickle.NONE,
       
   10:                            (0, True): pickle.INT,
   10:                            (1, True): pickle.INT,
   10:                            (2, True): pickle.NEWTRUE,
       
   10:                            (0, False): pickle.INT,
   10:                            (1, False): pickle.INT,
   10:                            (2, False): pickle.NEWFALSE,
                                 }
   40:         for proto in protocols:
  120:             for x in None, False, True:
   90:                 s = self.dumps(x, proto)
   90:                 y = self.loads(s)
   90:                 self.assertTrue(x is y, (proto, x, s, y))
   90:                 expected = expected_opcode[proto, x]
   90:                 self.assertEqual(opcode_in_pickle(expected, s), True)
       
    4:     def test_newobj_tuple(self):
   11:         x = MyTuple([1, 2, 3])
   11:         x.foo = 42
   11:         x.bar = "hello"
   44:         for proto in protocols:
   33:             s = self.dumps(x, proto)
   33:             y = self.loads(s)
   33:             self.assertEqual(tuple(x), tuple(y))
   33:             self.assertEqual(x.__dict__, y.__dict__)
       
    4:     def test_newobj_list(self):
   11:         x = MyList([1, 2, 3])
   11:         x.foo = 42
   11:         x.bar = "hello"
   44:         for proto in protocols:
   33:             s = self.dumps(x, proto)
   33:             y = self.loads(s)
   33:             self.assertEqual(list(x), list(y))
   33:             self.assertEqual(x.__dict__, y.__dict__)
       
    4:     def test_newobj_generic(self):
   44:         for proto in protocols:
  330:             for C in myclasses:
  297:                 B = C.__base__
  297:                 x = C(C.sample)
  297:                 x.foo = 42
  297:                 s = self.dumps(x, proto)
  297:                 y = self.loads(s)
  297:                 detail = (proto, C, B, x, y, type(y))
  297:                 self.assertEqual(B(x), B(y), detail)
  297:                 self.assertEqual(x.__dict__, y.__dict__, detail)
       
    4:     def test_newobj_proxies(self):
               # NEWOBJ should use the __class__ rather than the raw type
   11:         import weakref
   11:         classes = myclasses[:]
               # Cannot create weakproxies to these classes
   55:         for c in (MyInt, MyLong, MyStr, MyTuple):
   44:             classes.remove(c)
   44:         for proto in protocols:
  198:             for C in classes:
  165:                 B = C.__base__
  165:                 x = C(C.sample)
  165:                 x.foo = 42
  165:                 p = weakref.proxy(x)
  165:                 s = self.dumps(p, proto)
  165:                 y = self.loads(s)
  165:                 self.assertEqual(type(y), type(x))  # rather than type(p)
  165:                 detail = (proto, C, B, x, y, type(y))
  165:                 self.assertEqual(B(x), B(y), detail)
  165:                 self.assertEqual(x.__dict__, y.__dict__, detail)
       
           # Register a type with copy_reg, with extension code extcode.  Pickle
           # an object of that type.  Check that the resulting pickle uses opcode
           # (EXT[124]) under proto 2, and not in proto 1.
       
    4:     def produce_global_ext(self, extcode, opcode):
   88:         e = ExtensionSaver(extcode)
   88:         try:
   88:             copy_reg.add_extension(__name__, "MyList", extcode)
   88:             x = MyList([1, 2, 3])
   88:             x.foo = 42
   88:             x.bar = "hello"
       
                   # Dump using protocol 1 for comparison.
   88:             s1 = self.dumps(x, 1)
   88:             self.assertIn(__name__, s1)
   88:             self.assertIn("MyList", s1)
   88:             self.assertEqual(opcode_in_pickle(opcode, s1), False)
       
   88:             y = self.loads(s1)
   88:             self.assertEqual(list(x), list(y))
   88:             self.assertEqual(x.__dict__, y.__dict__)
       
                   # Dump using protocol 2 for test.
   88:             s2 = self.dumps(x, 2)
   88:             self.assertNotIn(__name__, s2)
   88:             self.assertNotIn("MyList", s2)
   88:             self.assertEqual(opcode_in_pickle(opcode, s2), True)
       
   88:             y = self.loads(s2)
   88:             self.assertEqual(list(x), list(y))
   88:             self.assertEqual(x.__dict__, y.__dict__)
       
               finally:
   88:             e.restore()
       
    4:     def test_global_ext1(self):
   11:         self.produce_global_ext(0x00000001, pickle.EXT1)  # smallest EXT1 code
   11:         self.produce_global_ext(0x000000ff, pickle.EXT1)  # largest EXT1 code
       
    4:     def test_global_ext2(self):
   11:         self.produce_global_ext(0x00000100, pickle.EXT2)  # smallest EXT2 code
   11:         self.produce_global_ext(0x0000ffff, pickle.EXT2)  # largest EXT2 code
   11:         self.produce_global_ext(0x0000abcd, pickle.EXT2)  # check endianness
       
    4:     def test_global_ext4(self):
   11:         self.produce_global_ext(0x00010000, pickle.EXT4)  # smallest EXT4 code
   11:         self.produce_global_ext(0x7fffffff, pickle.EXT4)  # largest EXT4 code
   11:         self.produce_global_ext(0x12abcdef, pickle.EXT4)  # check endianness
       
    4:     def test_list_chunking(self):
   11:         n = 10  # too small to chunk
   11:         x = range(n)
   44:         for proto in protocols:
   33:             s = self.dumps(x, proto)
   33:             y = self.loads(s)
   33:             self.assertEqual(x, y)
   33:             num_appends = count_opcode(pickle.APPENDS, s)
   33:             self.assertEqual(num_appends, proto > 0)
       
   11:         n = 2500  # expect at least two chunks when proto > 0
   11:         x = range(n)
   44:         for proto in protocols:
   33:             s = self.dumps(x, proto)
   33:             y = self.loads(s)
   33:             self.assertEqual(x, y)
   33:             num_appends = count_opcode(pickle.APPENDS, s)
   33:             if proto == 0:
   11:                 self.assertEqual(num_appends, 0)
                   else:
   22:                 self.assertTrue(num_appends >= 2)
       
    4:     def test_dict_chunking(self):
   11:         n = 10  # too small to chunk
   11:         x = dict.fromkeys(range(n))
   44:         for proto in protocols:
   33:             s = self.dumps(x, proto)
   33:             y = self.loads(s)
   33:             self.assertEqual(x, y)
   33:             num_setitems = count_opcode(pickle.SETITEMS, s)
   33:             self.assertEqual(num_setitems, proto > 0)
       
   11:         n = 2500  # expect at least two chunks when proto > 0
   11:         x = dict.fromkeys(range(n))
   44:         for proto in protocols:
   33:             s = self.dumps(x, proto)
   33:             y = self.loads(s)
   33:             self.assertEqual(x, y)
   33:             num_setitems = count_opcode(pickle.SETITEMS, s)
   33:             if proto == 0:
   11:                 self.assertEqual(num_setitems, 0)
                   else:
   22:                 self.assertTrue(num_setitems >= 2)
       
    4:     def test_simple_newobj(self):
   10:         x = SimpleNewObj.__new__(SimpleNewObj, 0xface)  # avoid __init__
   10:         x.abc = 666
   40:         for proto in protocols:
   30:             s = self.dumps(x, proto)
   30:             if proto < 1:
   10:                 self.assertIn('\nI64206', s)  # INT
                   else:
   20:                 self.assertIn('M\xce\xfa', s)  # BININT2
   30:             self.assertEqual(opcode_in_pickle(pickle.NEWOBJ, s), proto >= 2)
   30:             y = self.loads(s)   # will raise TypeError if __init__ called
   30:             self.assertEqual(y.abc, 666)
   30:             self.assertEqual(x.__dict__, y.__dict__)
       
    4:     def test_complex_newobj(self):
   11:         x = ComplexNewObj.__new__(ComplexNewObj, 0xface)  # avoid __init__
   11:         x.abc = 666
   44:         for proto in protocols:
   33:             s = self.dumps(x, proto)
   33:             if proto < 1:
   11:                 self.assertIn('\nI64206', s)  # INT
   22:             elif proto < 2:
   11:                 self.assertIn('M\xce\xfa', s)  # BININT2
                   else:
   11:                 self.assertIn('U\x04FACE', s)  # SHORT_BINSTRING
   33:             self.assertEqual(opcode_in_pickle(pickle.NEWOBJ, s), proto >= 2)
   33:             y = self.loads(s)   # will raise TypeError if __init__ called
   33:             self.assertEqual(y.abc, 666)
   33:             self.assertEqual(x.__dict__, y.__dict__)
       
    4:     def test_newobj_list_slots(self):
   11:         x = SlotList([1, 2, 3])
   11:         x.foo = 42
   11:         x.bar = "hello"
   11:         s = self.dumps(x, 2)
   11:         y = self.loads(s)
   11:         self.assertEqual(list(x), list(y))
   11:         self.assertEqual(x.__dict__, y.__dict__)
   11:         self.assertEqual(x.foo, y.foo)
   11:         self.assertEqual(x.bar, y.bar)
       
    4:     def test_reduce_overrides_default_reduce_ex(self):
   40:         for proto in protocols:
   30:             x = REX_one()
   30:             self.assertEqual(x._reduce_called, 0)
   30:             s = self.dumps(x, proto)
   30:             self.assertEqual(x._reduce_called, 1)
   30:             y = self.loads(s)
   30:             self.assertEqual(y._reduce_called, 0)
       
    4:     def test_reduce_ex_called(self):
   40:         for proto in protocols:
   30:             x = REX_two()
   30:             self.assertEqual(x._proto, None)
   30:             s = self.dumps(x, proto)
   30:             self.assertEqual(x._proto, proto)
   30:             y = self.loads(s)
   30:             self.assertEqual(y._proto, None)
       
    4:     def test_reduce_ex_overrides_reduce(self):
   40:         for proto in protocols:
   30:             x = REX_three()
   30:             self.assertEqual(x._proto, None)
   30:             s = self.dumps(x, proto)
   30:             self.assertEqual(x._proto, proto)
   30:             y = self.loads(s)
   30:             self.assertEqual(y._proto, None)
       
    4:     def test_reduce_ex_calls_base(self):
   40:         for proto in protocols:
   30:             x = REX_four()
   30:             self.assertEqual(x._proto, None)
   30:             s = self.dumps(x, proto)
   30:             self.assertEqual(x._proto, proto)
   30:             y = self.loads(s)
   30:             self.assertEqual(y._proto, proto)
       
    4:     def test_reduce_calls_base(self):
   40:         for proto in protocols:
   30:             x = REX_five()
   30:             self.assertEqual(x._reduce_called, 0)
   30:             s = self.dumps(x, proto)
   30:             self.assertEqual(x._reduce_called, 1)
   30:             y = self.loads(s)
   30:             self.assertEqual(y._reduce_called, 1)
       
    4:     @no_tracing
           def test_bad_getattr(self):
               # Issue #3514: crash when there is an infinite loop in __getattr__
>>>>>>         x = BadGetattr()
>>>>>>         for proto in protocols:
>>>>>>             self.assertRaises(RuntimeError, self.dumps, x, proto)
       
    4:     def test_reduce_bad_iterator(self):
               # Issue4176: crash when 4th and 5th items of __reduce__()
               # are not iterators
   20:         class C(object):
   10:             def __reduce__(self):
                       # 4th item is not an iterator
   30:                 return list, (), None, [], None
   20:         class D(object):
   10:             def __reduce__(self):
                       # 5th item is not an iterator
   30:                 return dict, (), None, None, []
       
               # Protocol 0 in Python implementation is less strict and also accepts
               # iterables.
   40:         for proto in protocols:
   30:             try:
   30:                 self.dumps(C(), proto)
   27:             except (AttributeError, pickle.PicklingError, cPickle.PicklingError):
   27:                 pass
   30:             try:
   30:                 self.dumps(D(), proto)
   27:             except (AttributeError, pickle.PicklingError, cPickle.PicklingError):
   27:                 pass
       
    4:     def test_many_puts_and_gets(self):
               # Test that internal data structures correctly deal with lots of
               # puts/gets.
 1122:         keys = ("aaa" + str(i) for i in xrange(100))
 1122:         large_dict = dict((k, [4, 5, 6]) for k in keys)
   11:         obj = [dict(large_dict), dict(large_dict), dict(large_dict)]
       
   44:         for proto in protocols:
   33:             dumped = self.dumps(obj, proto)
   33:             loaded = self.loads(dumped)
   33:             self.assertEqual(loaded, obj,
   33:                              "Failed protocol %d: %r != %r"
   33:                              % (proto, obj, loaded))
       
    4:     def test_attribute_name_interning(self):
               # Test that attribute names of pickled objects are interned when
               # unpickling.
   44:         for proto in protocols:
   33:             x = C()
   33:             x.foo = 42
   33:             x.bar = "hello"
   33:             s = self.dumps(x, proto)
   33:             y = self.loads(s)
   33:             x_keys = sorted(x.__dict__)
   33:             y_keys = sorted(y.__dict__)
   99:             for x_key, y_key in zip(x_keys, y_keys):
   66:                 self.assertIs(x_key, y_key)
       
    4:     def test_large_pickles(self):
               # Test the correctness of internal buffering routines when handling
               # large data.
   44:         for proto in protocols:
   33:             data = (1, min, 'xy' * (30 * 1024), len)
   33:             dumped = self.dumps(data, proto)
   33:             loaded = self.loads(dumped)
   33:             self.assertEqual(len(loaded), len(data))
   33:             self.assertEqual(loaded, data)
       
    4:     def _check_pickling_with_opcode(self, obj, opcode, proto):
   63:         pickled = self.dumps(obj, proto)
   63:         self.assertTrue(opcode_in_pickle(opcode, pickled))
   63:         unpickled = self.loads(pickled)
   63:         self.assertEqual(obj, unpickled)
       
    4:     def test_appends_on_non_lists(self):
               # Issue #17720
   11:         obj = REX_six([1, 2, 3])
   44:         for proto in protocols:
   33:             if proto == 0:
   11:                 self._check_pickling_with_opcode(obj, pickle.APPEND, proto)
                   else:
   22:                 self._check_pickling_with_opcode(obj, pickle.APPENDS, proto)
       
    4:     def test_setitems_on_non_dicts(self):
   10:         obj = REX_seven({1: -1, 2: -2, 3: -3})
   40:         for proto in protocols:
   30:             if proto == 0:
   10:                 self._check_pickling_with_opcode(obj, pickle.SETITEM, proto)
                   else:
   20:                 self._check_pickling_with_opcode(obj, pickle.SETITEMS, proto)
       
       
       # Test classes for reduce_ex
       
    8: class REX_one(object):
    4:     _reduce_called = 0
    4:     def __reduce__(self):
   30:         self._reduce_called = 1
   30:         return REX_one, ()
           # No __reduce_ex__ here, but inheriting it from object
       
    8: class REX_two(object):
    4:     _proto = None
    4:     def __reduce_ex__(self, proto):
   30:         self._proto = proto
   30:         return REX_two, ()
           # No __reduce__ here, but inheriting it from object
       
    8: class REX_three(object):
    4:     _proto = None
    4:     def __reduce_ex__(self, proto):
   30:         self._proto = proto
   30:         return REX_two, ()
    4:     def __reduce__(self):
>>>>>>         raise TestFailed, "This __reduce__ shouldn't be called"
       
    8: class REX_four(object):
    4:     _proto = None
    4:     def __reduce_ex__(self, proto):
   30:         self._proto = proto
   30:         return object.__reduce_ex__(self, proto)
           # Calling base class method should succeed
       
    8: class REX_five(object):
    4:     _reduce_called = 0
    4:     def __reduce__(self):
   30:         self._reduce_called = 1
   30:         return object.__reduce__(self)
           # This one used to fail with infinite recursion
       
    8: class REX_six(object):
           """This class is used to check the 4th argument (list iterator) of
           the reduce protocol.
    4:     """
    4:     def __init__(self, items=None):
   44:         if items is None:
   33:             items = []
   44:         self.items = items
    4:     def __eq__(self, other):
   33:         return type(self) is type(other) and self.items == other.items
    4:     __hash__ = None
    4:     def append(self, item):
   99:         self.items.append(item)
    4:     def extend(self, items):
   24:         for item in items:
   18:             self.append(item)
    4:     def __reduce__(self):
   33:         return type(self), (), None, iter(self.items), None
       
    8: class REX_seven(object):
           """This class is used to check the 5th argument (dict iterator) of
           the reduce protocol.
    4:     """
    4:     def __init__(self, table=None):
   40:         if table is None:
   30:             table = {}
   40:         self.table = table
    4:     def __eq__(self, other):
   30:         return type(self) is type(other) and self.table == other.table
    4:     __hash__ = None
    4:     def __setitem__(self, key, value):
   90:         self.table[key] = value
    4:     def __reduce__(self):
   30:         return type(self), (), None, None, iter(self.table.items())
       
       # Test classes for newobj
       
    8: class MyInt(int):
    4:     sample = 1
       
    8: class MyLong(long):
    4:     sample = 1L
       
    8: class MyFloat(float):
    4:     sample = 1.0
       
    8: class MyComplex(complex):
    4:     sample = 1.0 + 0.0j
       
    8: class MyStr(str):
    4:     sample = "hello"
       
    8: class MyUnicode(unicode):
    4:     sample = u"hello \u1234"
       
    8: class MyTuple(tuple):
    4:     sample = (1, 2, 3)
       
    8: class MyList(list):
    4:     sample = [1, 2, 3]
       
    8: class MyDict(dict):
    4:     sample = {"a": 1, "b": 2}
       
    4: myclasses = [MyInt, MyLong, MyFloat,
    4:              MyComplex,
    4:              MyStr, MyUnicode,
    4:              MyTuple, MyList, MyDict]
       
       
    8: class SlotList(MyList):
    4:     __slots__ = ["foo"]
       
    8: class SimpleNewObj(int):
    4:     def __init__(self, *args, **kwargs):
               # raise an error, to make sure this isn't called
>>>>>>         raise TypeError("SimpleNewObj.__init__() didn't expect to get called")
    4:     def __eq__(self, other):
>>>>>>         return int(self) == int(other) and self.__dict__ == other.__dict__
    4:     __hash__ = None
       
    8: class ComplexNewObj(SimpleNewObj):
    4:     def __getnewargs__(self):
   11:         return ('%X' % self, 16)
       
    8: class BadGetattr:
    4:     def __getattr__(self, key):
>>>>>>         self.foo
       
    8: class AbstractPickleModuleTests(unittest.TestCase):
       
    4:     def test_dump_closed_file(self):
    3:         import os
    3:         f = open(TESTFN, "w")
    3:         try:
    3:             f.close()
    3:             self.assertRaises(ValueError, self.module.dump, 123, f)
               finally:
    3:             os.remove(TESTFN)
       
    4:     def test_load_closed_file(self):
    3:         import os
    3:         f = open(TESTFN, "w")
    3:         try:
    3:             f.close()
    3:             self.assertRaises(ValueError, self.module.dump, 123, f)
               finally:
    3:             os.remove(TESTFN)
       
    4:     def test_load_from_and_dump_to_file(self):
    3:         stream = cStringIO.StringIO()
    3:         data = [123, {}, 124]
    3:         self.module.dump(data, stream)
    3:         stream.seek(0)
    3:         unpickled = self.module.load(stream)
    3:         self.assertEqual(unpickled, data)
       
    4:     def test_highest_protocol(self):
               # Of course this needs to be changed when HIGHEST_PROTOCOL changes.
    3:         self.assertEqual(self.module.HIGHEST_PROTOCOL, 2)
       
    4:     def test_callapi(self):
    3:         f = cStringIO.StringIO()
               # With and without keyword arguments
    3:         self.module.dump(123, f, -1)
    3:         self.module.dump(123, file=f, protocol=-1)
    3:         self.module.dumps(123, -1)
    3:         self.module.dumps(123, protocol=-1)
    3:         self.module.Pickler(f, -1)
    3:         self.module.Pickler(f, protocol=-1)
       
    4:     def test_incomplete_input(self):
    3:         s = StringIO.StringIO("X''.")
    3:         self.assertRaises(EOFError, self.module.load, s)
       
    4:     def test_restricted(self):
               # issue7128: cPickle failed in restricted mode
    3:         builtins = {self.module.__name__: self.module,
    3:                     '__import__': __import__}
    3:         d = {}
    3:         teststr = "def f(): {0}.dumps(0)".format(self.module.__name__)
    3:         exec teststr in {'__builtins__': builtins}, d
    3:         d['f']()
       
    4:     def test_bad_input(self):
               # Test issue4298
    3:         s = '\x58\0\0\0\x54'
    3:         self.assertRaises(EOFError, self.module.loads, s)
       
       
    8: class AbstractPersistentPicklerTests(unittest.TestCase):
       
           # This class defines persistent_id() and persistent_load()
           # functions that should be used by the pickler.  All even integers
           # are pickled using persistent ids.
       
    4:     def persistent_id(self, object):
   48:         if isinstance(object, int) and object % 2 == 0:
   15:             self.id_count += 1
   15:             return str(object)
   33:         elif object == "test_false_value":
    3:             self.false_count += 1
    3:             return ""
               else:
   30:             return None
       
    4:     def persistent_load(self, oid):
   18:         if not oid:
    3:             self.load_false_count += 1
    3:             return "test_false_value"
               else:
   15:             self.load_count += 1
   15:             object = int(oid)
   15:             assert object % 2 == 0
   15:             return object
       
    4:     def test_persistence(self):
    1:         L = range(10) + ["test_false_value"]
    4:         for proto in protocols:
    3:             self.id_count = 0
    3:             self.false_count = 0
    3:             self.load_false_count = 0
    3:             self.load_count = 0
    3:             self.assertEqual(self.loads(self.dumps(L, proto)), L)
    3:             self.assertEqual(self.id_count, 5)
    3:             self.assertEqual(self.false_count, 1)
    3:             self.assertEqual(self.load_count, 5)
    3:             self.assertEqual(self.load_false_count, 1)
       
    8: class AbstractPicklerUnpicklerObjectTests(unittest.TestCase):
       
    4:     pickler_class = None
    4:     unpickler_class = None
       
    4:     def setUp(self):
    7:         assert self.pickler_class
    7:         assert self.unpickler_class
       
    4:     def test_clear_pickler_memo(self):
               # To test whether clear_memo() has any effect, we pickle an object,
               # then pickle it again without clearing the memo; the two serialized
               # forms should be different. If we clear_memo() and then pickle the
               # object again, the third serialized form should be identical to the
               # first one we obtained.
    1:         data = ["abcdefg", "abcdefg", 44]
    1:         f = cStringIO.StringIO()
    1:         pickler = self.pickler_class(f)
       
    1:         pickler.dump(data)
    1:         first_pickled = f.getvalue()
       
               # Reset StringIO object.
    1:         f.seek(0)
    1:         f.truncate()
       
    1:         pickler.dump(data)
    1:         second_pickled = f.getvalue()
       
               # Reset the Pickler and StringIO objects.
    1:         pickler.clear_memo()
    1:         f.seek(0)
    1:         f.truncate()
       
    1:         pickler.dump(data)
    1:         third_pickled = f.getvalue()
       
    1:         self.assertNotEqual(first_pickled, second_pickled)
    1:         self.assertEqual(first_pickled, third_pickled)
       
    4:     def test_priming_pickler_memo(self):
               # Verify that we can set the Pickler's memo attribute.
    1:         data = ["abcdefg", "abcdefg", 44]
    1:         f = cStringIO.StringIO()
    1:         pickler = self.pickler_class(f)
       
    1:         pickler.dump(data)
    1:         first_pickled = f.getvalue()
       
    1:         f = cStringIO.StringIO()
    1:         primed = self.pickler_class(f)
    1:         primed.memo = pickler.memo
       
    1:         primed.dump(data)
    1:         primed_pickled = f.getvalue()
       
    1:         self.assertNotEqual(first_pickled, primed_pickled)
       
    4:     def test_priming_unpickler_memo(self):
               # Verify that we can set the Unpickler's memo attribute.
    1:         data = ["abcdefg", "abcdefg", 44]
    1:         f = cStringIO.StringIO()
    1:         pickler = self.pickler_class(f)
       
    1:         pickler.dump(data)
    1:         first_pickled = f.getvalue()
       
    1:         f = cStringIO.StringIO()
    1:         primed = self.pickler_class(f)
    1:         primed.memo = pickler.memo
       
    1:         primed.dump(data)
    1:         primed_pickled = f.getvalue()
       
    1:         unpickler = self.unpickler_class(cStringIO.StringIO(first_pickled))
    1:         unpickled_data1 = unpickler.load()
       
    1:         self.assertEqual(unpickled_data1, data)
       
    1:         primed = self.unpickler_class(cStringIO.StringIO(primed_pickled))
    1:         primed.memo = unpickler.memo
    1:         unpickled_data2 = primed.load()
       
    1:         primed.memo.clear()
       
    1:         self.assertEqual(unpickled_data2, data)
    1:         self.assertTrue(unpickled_data2 is unpickled_data1)
       
    4:     def test_reusing_unpickler_objects(self):
    1:         data1 = ["abcdefg", "abcdefg", 44]
    1:         f = cStringIO.StringIO()
    1:         pickler = self.pickler_class(f)
    1:         pickler.dump(data1)
    1:         pickled1 = f.getvalue()
       
    1:         data2 = ["abcdefg", 44, 44]
    1:         f = cStringIO.StringIO()
    1:         pickler = self.pickler_class(f)
    1:         pickler.dump(data2)
    1:         pickled2 = f.getvalue()
       
    1:         f = cStringIO.StringIO()
    1:         f.write(pickled1)
    1:         f.seek(0)
    1:         unpickler = self.unpickler_class(f)
    1:         self.assertEqual(unpickler.load(), data1)
       
    1:         f.seek(0)
    1:         f.truncate()
    1:         f.write(pickled2)
    1:         f.seek(0)
    1:         self.assertEqual(unpickler.load(), data2)
       
    4:     def _check_multiple_unpicklings(self, ioclass, seekable):
    8:         for proto in protocols:
12006:             data1 = [(x, str(x)) for x in xrange(2000)] + ["abcde", len]
    6:             f = ioclass()
    6:             pickler = self.pickler_class(f, protocol=proto)
    6:             pickler.dump(data1)
    6:             pickled = f.getvalue()
       
    6:             N = 5
    6:             f = ioclass(pickled * N)
    6:             unpickler = self.unpickler_class(f)
   36:             for i in xrange(N):
   30:                 if seekable:
   15:                     pos = f.tell()
   30:                 self.assertEqual(unpickler.load(), data1)
   30:                 if seekable:
   15:                     self.assertEqual(f.tell(), pos + len(pickled))
    6:             self.assertRaises(EOFError, unpickler.load)
       
    4:     def test_multiple_unpicklings_seekable(self):
    1:         self._check_multiple_unpicklings(StringIO.StringIO, True)
       
    4:     def test_multiple_unpicklings_unseekable(self):
    1:         self._check_multiple_unpicklings(UnseekableIO, False)
       
    4:     def test_unpickling_buffering_readline(self):
               # Issue #12687: the unpickler's buffering logic could fail with
               # text mode opcodes.
    1:         import io
    1:         data = list(xrange(10))
    4:         for proto in protocols:
   33:             for buf_size in xrange(1, 11):
   30:                 f = io.BufferedRandom(io.BytesIO(), buffer_size=buf_size)
   30:                 pickler = self.pickler_class(f, protocol=proto)
   30:                 pickler.dump(data)
   30:                 f.seek(0)
   30:                 unpickler = self.unpickler_class(f)
   30:                 self.assertEqual(unpickler.load(), data)
       
       
    8: class BigmemPickleTests(unittest.TestCase):
       
           # Memory requirements: 1 byte per character for input strings, 1 byte
           # for pickled data, 1 byte for unpickled strings, 1 byte for internal
           # buffer and 1 byte of free space for resizing of internal buffer.
       
    4:     @precisionbigmemtest(size=_2G + 100*_1M, memuse=5)
           def test_huge_strlist(self, size):
    1:         chunksize = 2**20
    1:         data = []
    1:         while size > chunksize:
>>>>>>             data.append('x' * chunksize)
>>>>>>             size -= chunksize
>>>>>>             chunksize += 1
    1:         data.append('y' * size)
       
    1:         try:
    4:             for proto in protocols:
    3:                 try:
    3:                     pickled = self.dumps(data, proto)
    3:                     res = self.loads(pickled)
    3:                     self.assertEqual(res, data)
                       finally:
    3:                     res = None
    3:                     pickled = None
               finally:
    1:             data = None
