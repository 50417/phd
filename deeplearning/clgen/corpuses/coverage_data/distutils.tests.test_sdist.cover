    1: """Tests for distutils.command.sdist."""
    1: import os
    1: import tarfile
    1: import unittest
    1: import warnings
    1: import zipfile
    1: from os.path import join
    1: from textwrap import dedent
    1: from test.test_support import captured_stdout, check_warnings, run_unittest
       
       # zlib is not used here, but if it's not available
       # the tests that use zipfile may fail
    1: try:
    1:     import zlib
>>>>>> except ImportError:
>>>>>>     zlib = None
       
    1: try:
    1:     import grp
    1:     import pwd
    1:     UID_GID_SUPPORT = True
>>>>>> except ImportError:
>>>>>>     UID_GID_SUPPORT = False
       
       
    1: from distutils.command.sdist import sdist, show_formats
    1: from distutils.core import Distribution
    1: from distutils.tests.test_config import PyPIRCCommandTestCase
    1: from distutils.errors import DistutilsOptionError
    1: from distutils.spawn import find_executable
    1: from distutils.log import WARN
    1: from distutils.filelist import FileList
    1: from distutils.archive_util import ARCHIVE_FORMATS
       
       SETUP_PY = """
       from distutils.core import setup
       import somecode
       
       setup(name='fake')
    1: """
       
       MANIFEST = """\
       # file GENERATED by distutils, do NOT edit
       README
       buildout.cfg
       inroot.txt
       setup.py
       data%(sep)sdata.dt
       scripts%(sep)sscript.py
       some%(sep)sfile.txt
       some%(sep)sother_file.txt
       somecode%(sep)s__init__.py
       somecode%(sep)sdoc.dat
       somecode%(sep)sdoc.txt
    1: """
       
    2: class SDistTestCase(PyPIRCCommandTestCase):
       
    1:     def setUp(self):
               # PyPIRCCommandTestCase creates a temp dir already
               # and put it in self.tmp_dir
   17:         super(SDistTestCase, self).setUp()
               # setting up an environment
   17:         self.old_path = os.getcwd()
   17:         os.mkdir(join(self.tmp_dir, 'somecode'))
   17:         os.mkdir(join(self.tmp_dir, 'dist'))
               # a package, and a README
   17:         self.write_file((self.tmp_dir, 'README'), 'xxx')
   17:         self.write_file((self.tmp_dir, 'somecode', '__init__.py'), '#')
   17:         self.write_file((self.tmp_dir, 'setup.py'), SETUP_PY)
   17:         os.chdir(self.tmp_dir)
       
    1:     def tearDown(self):
               # back to normal
   17:         os.chdir(self.old_path)
   17:         super(SDistTestCase, self).tearDown()
       
    1:     def get_cmd(self, metadata=None):
               """Returns a cmd"""
   16:         if metadata is None:
   14:             metadata = {'name': 'fake', 'version': '1.0',
   14:                         'url': 'xxx', 'author': 'xxx',
   14:                         'author_email': 'xxx'}
   16:         dist = Distribution(metadata)
   16:         dist.script_name = 'setup.py'
   16:         dist.packages = ['somecode']
   16:         dist.include_package_data = True
   16:         cmd = sdist(dist)
   16:         cmd.dist_dir = 'dist'
   16:         return dist, cmd
       
    1:     @unittest.skipUnless(zlib, "requires zlib")
           def test_prune_file_list(self):
               # this test creates a project with some VCS dirs and an NFS rename
               # file, then launches sdist to check they get pruned on all systems
       
               # creating VCS directories with some files in them
    1:         os.mkdir(join(self.tmp_dir, 'somecode', '.svn'))
    1:         self.write_file((self.tmp_dir, 'somecode', '.svn', 'ok.py'), 'xxx')
       
    1:         os.mkdir(join(self.tmp_dir, 'somecode', '.hg'))
    1:         self.write_file((self.tmp_dir, 'somecode', '.hg',
    1:                          'ok'), 'xxx')
       
    1:         os.mkdir(join(self.tmp_dir, 'somecode', '.git'))
    1:         self.write_file((self.tmp_dir, 'somecode', '.git',
    1:                          'ok'), 'xxx')
       
    1:         self.write_file((self.tmp_dir, 'somecode', '.nfs0001'), 'xxx')
       
               # now building a sdist
    1:         dist, cmd = self.get_cmd()
       
               # zip is available universally
               # (tar might not be installed under win32)
    1:         cmd.formats = ['zip']
       
    1:         cmd.ensure_finalized()
    1:         cmd.run()
       
               # now let's check what we have
    1:         dist_folder = join(self.tmp_dir, 'dist')
    1:         files = os.listdir(dist_folder)
    1:         self.assertEqual(files, ['fake-1.0.zip'])
       
    1:         zip_file = zipfile.ZipFile(join(dist_folder, 'fake-1.0.zip'))
    1:         try:
    1:             content = zip_file.namelist()
               finally:
    1:             zip_file.close()
       
               # making sure everything has been pruned correctly
    1:         self.assertEqual(len(content), 4)
       
    1:     @unittest.skipUnless(zlib, "requires zlib")
           def test_make_distribution(self):
               # now building a sdist
    1:         dist, cmd = self.get_cmd()
       
               # creating a gztar then a tar
    1:         cmd.formats = ['gztar', 'tar']
    1:         cmd.ensure_finalized()
    1:         cmd.run()
       
               # making sure we have two files
    1:         dist_folder = join(self.tmp_dir, 'dist')
    1:         result = os.listdir(dist_folder)
    1:         result.sort()
    1:         self.assertEqual(result, ['fake-1.0.tar', 'fake-1.0.tar.gz'])
       
    1:         os.remove(join(dist_folder, 'fake-1.0.tar'))
    1:         os.remove(join(dist_folder, 'fake-1.0.tar.gz'))
       
               # now trying a tar then a gztar
    1:         cmd.formats = ['tar', 'gztar']
       
    1:         cmd.ensure_finalized()
    1:         cmd.run()
       
    1:         result = os.listdir(dist_folder)
    1:         result.sort()
    1:         self.assertEqual(result, ['fake-1.0.tar', 'fake-1.0.tar.gz'])
       
    1:     @unittest.skipUnless(zlib, "requires zlib")
           def test_unicode_metadata_tgz(self):
               """
               Unicode name or version should not break building to tar.gz format.
               Reference issue #11638.
               """
       
               # create the sdist command with unicode parameters
    1:         dist, cmd = self.get_cmd({'name': u'fake', 'version': u'1.0'})
       
               # create the sdist as gztar and run the command
    1:         cmd.formats = ['gztar']
    1:         cmd.ensure_finalized()
    1:         cmd.run()
       
               # The command should have created the .tar.gz file
    1:         dist_folder = join(self.tmp_dir, 'dist')
    1:         result = os.listdir(dist_folder)
    1:         self.assertEqual(result, ['fake-1.0.tar.gz'])
       
    1:         os.remove(join(dist_folder, 'fake-1.0.tar.gz'))
       
    1:     @unittest.skipUnless(zlib, "requires zlib")
           def test_add_defaults(self):
       
               # http://bugs.python.org/issue2279
       
               # add_default should also include
               # data_files and package_data
    1:         dist, cmd = self.get_cmd()
       
               # filling data_files by pointing files
               # in package_data
    1:         dist.package_data = {'': ['*.cfg', '*.dat'],
    1:                              'somecode': ['*.txt']}
    1:         self.write_file((self.tmp_dir, 'somecode', 'doc.txt'), '#')
    1:         self.write_file((self.tmp_dir, 'somecode', 'doc.dat'), '#')
       
               # adding some data in data_files
    1:         data_dir = join(self.tmp_dir, 'data')
    1:         os.mkdir(data_dir)
    1:         self.write_file((data_dir, 'data.dt'), '#')
    1:         some_dir = join(self.tmp_dir, 'some')
    1:         os.mkdir(some_dir)
               # make sure VCS directories are pruned (#14004)
    1:         hg_dir = join(self.tmp_dir, '.hg')
    1:         os.mkdir(hg_dir)
    1:         self.write_file((hg_dir, 'last-message.txt'), '#')
               # a buggy regex used to prevent this from working on windows (#6884)
    1:         self.write_file((self.tmp_dir, 'buildout.cfg'), '#')
    1:         self.write_file((self.tmp_dir, 'inroot.txt'), '#')
    1:         self.write_file((some_dir, 'file.txt'), '#')
    1:         self.write_file((some_dir, 'other_file.txt'), '#')
       
    1:         dist.data_files = [('data', ['data/data.dt',
    1:                                      'buildout.cfg',
    1:                                      'inroot.txt',
    1:                                      'notexisting']),
    1:                            'some/file.txt',
    1:                            'some/other_file.txt']
       
               # adding a script
    1:         script_dir = join(self.tmp_dir, 'scripts')
    1:         os.mkdir(script_dir)
    1:         self.write_file((script_dir, 'script.py'), '#')
    1:         dist.scripts = [join('scripts', 'script.py')]
       
    1:         cmd.formats = ['zip']
    1:         cmd.use_defaults = True
       
    1:         cmd.ensure_finalized()
    1:         cmd.run()
       
               # now let's check what we have
    1:         dist_folder = join(self.tmp_dir, 'dist')
    1:         files = os.listdir(dist_folder)
    1:         self.assertEqual(files, ['fake-1.0.zip'])
       
    1:         zip_file = zipfile.ZipFile(join(dist_folder, 'fake-1.0.zip'))
    1:         try:
    1:             content = zip_file.namelist()
               finally:
    1:             zip_file.close()
       
               # making sure everything was added
    1:         self.assertEqual(len(content), 12)
       
               # checking the MANIFEST
    1:         f = open(join(self.tmp_dir, 'MANIFEST'))
    1:         try:
    1:             manifest = f.read()
               finally:
    1:             f.close()
    1:         self.assertEqual(manifest, MANIFEST % {'sep': os.sep})
       
    1:     @unittest.skipUnless(zlib, "requires zlib")
           def test_metadata_check_option(self):
               # testing the `medata-check` option
    1:         dist, cmd = self.get_cmd(metadata={})
       
               # this should raise some warnings !
               # with the `check` subcommand
    1:         cmd.ensure_finalized()
    1:         cmd.run()
    4:         warnings = [msg for msg in self.get_logs(WARN) if
    3:                     msg.startswith('warning: check:')]
    1:         self.assertEqual(len(warnings), 2)
       
               # trying with a complete set of metadata
    1:         self.clear_logs()
    1:         dist, cmd = self.get_cmd()
    1:         cmd.ensure_finalized()
    1:         cmd.metadata_check = 0
    1:         cmd.run()
    2:         warnings = [msg for msg in self.get_logs(WARN) if
    1:                     msg.startswith('warning: check:')]
    1:         self.assertEqual(len(warnings), 0)
       
    1:     def test_check_metadata_deprecated(self):
               # makes sure make_metadata is deprecated
    1:         dist, cmd = self.get_cmd()
    1:         with check_warnings() as w:
    1:             warnings.simplefilter("always")
    1:             cmd.check_metadata()
    1:             self.assertEqual(len(w.warnings), 1)
       
    1:     def test_show_formats(self):
    1:         with captured_stdout() as stdout:
    1:             show_formats()
       
               # the output should be a header line + one line per format
    1:         num_formats = len(ARCHIVE_FORMATS.keys())
    8:         output = [line for line in stdout.getvalue().split('\n')
    7:                   if line.strip().startswith('--formats=')]
    1:         self.assertEqual(len(output), num_formats)
       
    1:     def test_finalize_options(self):
    1:         dist, cmd = self.get_cmd()
    1:         cmd.finalize_options()
       
               # default options set by finalize
    1:         self.assertEqual(cmd.manifest, 'MANIFEST')
    1:         self.assertEqual(cmd.template, 'MANIFEST.in')
    1:         self.assertEqual(cmd.dist_dir, 'dist')
       
               # formats has to be a string splitable on (' ', ',') or
               # a stringlist
    1:         cmd.formats = 1
    1:         self.assertRaises(DistutilsOptionError, cmd.finalize_options)
    1:         cmd.formats = ['zip']
    1:         cmd.finalize_options()
       
               # formats has to be known
    1:         cmd.formats = 'supazipa'
    1:         self.assertRaises(DistutilsOptionError, cmd.finalize_options)
       
    1:     @unittest.skipUnless(zlib, "requires zlib")
    1:     @unittest.skipUnless(UID_GID_SUPPORT, "Requires grp and pwd support")
    1:     @unittest.skipIf(find_executable('tar') is None,
    1:                      "The tar command is not found")
    1:     @unittest.skipIf(find_executable('gzip') is None,
    1:                      "The gzip command is not found")
           def test_make_distribution_owner_group(self):
               # now building a sdist
    1:         dist, cmd = self.get_cmd()
       
               # creating a gztar and specifying the owner+group
    1:         cmd.formats = ['gztar']
    1:         cmd.owner = pwd.getpwuid(0)[0]
    1:         cmd.group = grp.getgrgid(0)[0]
    1:         cmd.ensure_finalized()
    1:         cmd.run()
       
               # making sure we have the good rights
    1:         archive_name = join(self.tmp_dir, 'dist', 'fake-1.0.tar.gz')
    1:         archive = tarfile.open(archive_name)
    1:         try:
    7:             for member in archive.getmembers():
    6:                 self.assertEqual(member.uid, 0)
    6:                 self.assertEqual(member.gid, 0)
               finally:
    1:             archive.close()
       
               # building a sdist again
    1:         dist, cmd = self.get_cmd()
       
               # creating a gztar
    1:         cmd.formats = ['gztar']
    1:         cmd.ensure_finalized()
    1:         cmd.run()
       
               # making sure we have the good rights
    1:         archive_name = join(self.tmp_dir, 'dist', 'fake-1.0.tar.gz')
    1:         archive = tarfile.open(archive_name)
       
               # note that we are not testing the group ownership here
               # because, depending on the platforms and the container
               # rights (see #7408)
    1:         try:
    7:             for member in archive.getmembers():
    6:                 self.assertEqual(member.uid, os.getuid())
               finally:
    1:             archive.close()
       
           # the following tests make sure there is a nice error message instead
           # of a traceback when parsing an invalid manifest template
       
    1:     def _check_template(self, content):
    2:         dist, cmd = self.get_cmd()
    2:         os.chdir(self.tmp_dir)
    2:         self.write_file('MANIFEST.in', content)
    2:         cmd.ensure_finalized()
    2:         cmd.filelist = FileList()
    2:         cmd.read_template()
    2:         warnings = self.get_logs(WARN)
    2:         self.assertEqual(len(warnings), 1)
       
    1:     def test_invalid_template_unknown_command(self):
    1:         self._check_template('taunt knights *')
       
    1:     def test_invalid_template_wrong_arguments(self):
               # this manifest command takes one argument
    1:         self._check_template('prune')
       
    1:     @unittest.skipIf(os.name != 'nt', 'test relevant for Windows only')
           def test_invalid_template_wrong_path(self):
               # on Windows, trailing slashes are not allowed
               # this used to crash instead of raising a warning: #8286
>>>>>>         self._check_template('include examples/')
       
    1:     @unittest.skipUnless(zlib, "requires zlib")
           def test_get_file_list(self):
               # make sure MANIFEST is recalculated
    1:         dist, cmd = self.get_cmd()
       
               # filling data_files by pointing files in package_data
    1:         dist.package_data = {'somecode': ['*.txt']}
    1:         self.write_file((self.tmp_dir, 'somecode', 'doc.txt'), '#')
    1:         cmd.formats = ['gztar']
    1:         cmd.ensure_finalized()
    1:         cmd.run()
       
    1:         f = open(cmd.manifest)
    1:         try:
    7:             manifest = [line.strip() for line in f.read().split('\n')
    6:                         if line.strip() != '']
               finally:
    1:             f.close()
       
    1:         self.assertEqual(len(manifest), 5)
       
               # adding a file
    1:         self.write_file((self.tmp_dir, 'somecode', 'doc2.txt'), '#')
       
               # make sure build_py is reinitialized, like a fresh run
    1:         build_py = dist.get_command_obj('build_py')
    1:         build_py.finalized = False
    1:         build_py.ensure_finalized()
       
    1:         cmd.run()
       
    1:         f = open(cmd.manifest)
    1:         try:
    8:             manifest2 = [line.strip() for line in f.read().split('\n')
    7:                          if line.strip() != '']
               finally:
    1:             f.close()
       
               # do we have the new file in MANIFEST ?
    1:         self.assertEqual(len(manifest2), 6)
    1:         self.assertIn('doc2.txt', manifest2[-1])
       
    1:     @unittest.skipUnless(zlib, "requires zlib")
           def test_manifest_marker(self):
               # check that autogenerated MANIFESTs have a marker
    1:         dist, cmd = self.get_cmd()
    1:         cmd.ensure_finalized()
    1:         cmd.run()
       
    1:         f = open(cmd.manifest)
    1:         try:
    6:             manifest = [line.strip() for line in f.read().split('\n')
    5:                         if line.strip() != '']
               finally:
    1:             f.close()
       
    1:         self.assertEqual(manifest[0],
    1:                          '# file GENERATED by distutils, do NOT edit')
       
    1:     @unittest.skipUnless(zlib, 'requires zlib')
           def test_manifest_comments(self):
               # make sure comments don't cause exceptions or wrong includes
    1:         contents = dedent("""\
                   # bad.py
                   #bad.py
                   good.py
    1:             """)
    1:         dist, cmd = self.get_cmd()
    1:         cmd.ensure_finalized()
    1:         self.write_file((self.tmp_dir, cmd.manifest), contents)
    1:         self.write_file((self.tmp_dir, 'good.py'), '# pick me!')
    1:         self.write_file((self.tmp_dir, 'bad.py'), "# don't pick me!")
    1:         self.write_file((self.tmp_dir, '#bad.py'), "# don't pick me!")
    1:         cmd.run()
    1:         self.assertEqual(cmd.filelist.files, ['good.py'])
       
    1:     @unittest.skipUnless(zlib, "requires zlib")
           def test_manual_manifest(self):
               # check that a MANIFEST without a marker is left alone
    1:         dist, cmd = self.get_cmd()
    1:         cmd.formats = ['gztar']
    1:         cmd.ensure_finalized()
    1:         self.write_file((self.tmp_dir, cmd.manifest), 'README.manual')
    1:         self.write_file((self.tmp_dir, 'README.manual'),
    1:                          'This project maintains its MANIFEST file itself.')
    1:         cmd.run()
    1:         self.assertEqual(cmd.filelist.files, ['README.manual'])
       
    1:         f = open(cmd.manifest)
    1:         try:
    2:             manifest = [line.strip() for line in f.read().split('\n')
    1:                         if line.strip() != '']
               finally:
    1:             f.close()
       
    1:         self.assertEqual(manifest, ['README.manual'])
       
    1:         archive_name = join(self.tmp_dir, 'dist', 'fake-1.0.tar.gz')
    1:         archive = tarfile.open(archive_name)
    1:         try:
    4:             filenames = [tarinfo.name for tarinfo in archive]
               finally:
    1:             archive.close()
    1:         self.assertEqual(sorted(filenames), ['fake-1.0', 'fake-1.0/PKG-INFO',
    1:                                              'fake-1.0/README.manual'])
       
    1: def test_suite():
    1:     return unittest.makeSuite(SDistTestCase)
       
    1: if __name__ == "__main__":
>>>>>>     run_unittest(test_suite())
