    1: import sys
    1: import os
    1: import shutil
    1: import StringIO
    1: from binascii import unhexlify
    1: from hashlib import md5
    1: from random import Random
    1: import errno
       
    1: import unittest
    1: import tarfile
       
    1: from test import test_support
    1: from test import test_support as support
       
       # Check for our compression modules.
    1: try:
    1:     import gzip
    1:     gzip.GzipFile
>>>>>> except (ImportError, AttributeError):
>>>>>>     gzip = None
    1: try:
    1:     import bz2
>>>>>> except ImportError:
>>>>>>     bz2 = None
       
    1: def md5sum(data):
   18:     return md5(data).hexdigest()
       
    1: TEMPDIR = os.path.abspath(test_support.TESTFN)
    1: tarname = test_support.findfile("testtar.tar")
    1: gzipname = os.path.join(TEMPDIR, "testtar.tar.gz")
    1: bz2name = os.path.join(TEMPDIR, "testtar.tar.bz2")
    1: tmpname = os.path.join(TEMPDIR, "tmp.tar")
       
    1: md5_regtype = "65f477c818ad9e15f7feab0c6d37742f"
    1: md5_sparse = "a54fbc4ca4f4399a90e1b27164012fc6"
       
       
    2: class ReadTest(unittest.TestCase):
       
    1:     tarname = tarname
    1:     mode = "r:"
       
    1:     def setUp(self):
  133:         self.tar = tarfile.open(self.tarname, mode=self.mode, encoding="iso8859-1")
       
    1:     def tearDown(self):
  139:         self.tar.close()
       
       
    2: class UstarReadTest(ReadTest):
       
    1:     def test_fileobj_regular_file(self):
    3:         tarinfo = self.tar.getmember("ustar/regtype")
    3:         fobj = self.tar.extractfile(tarinfo)
    3:         data = fobj.read()
    3:         self.assertTrue((len(data), md5sum(data)) == (tarinfo.size, md5_regtype),
    3:                 "regular file extraction failed")
       
    1:     def test_fileobj_readlines(self):
    3:         self.tar.extract("ustar/regtype", TEMPDIR)
    3:         tarinfo = self.tar.getmember("ustar/regtype")
    3:         fobj1 = open(os.path.join(TEMPDIR, "ustar/regtype"), "rU")
    3:         with open(os.path.join(TEMPDIR, "ustar/regtype"), "rU") as fobj1:
    3:             lines1 = fobj1.readlines()
    3:         fobj2 = self.tar.extractfile(tarinfo)
       
    3:         lines2 = fobj2.readlines()
    3:         self.assertTrue(lines1 == lines2,
    3:                 "fileobj.readlines() failed")
    3:         self.assertTrue(len(lines2) == 114,
    3:                 "fileobj.readlines() failed")
    3:         self.assertTrue(lines2[83] ==
    3:                 "I will gladly admit that Python is not the fastest running scripting language.\n",
    3:                 "fileobj.readlines() failed")
       
    1:     def test_fileobj_iter(self):
    3:         self.tar.extract("ustar/regtype", TEMPDIR)
    3:         tarinfo = self.tar.getmember("ustar/regtype")
    3:         with open(os.path.join(TEMPDIR, "ustar/regtype"), "rU") as fobj1:
    3:             lines1 = fobj1.readlines()
    3:         fobj2 = self.tar.extractfile(tarinfo)
  345:         lines2 = [line for line in fobj2]
    3:         self.assertTrue(lines1 == lines2,
    3:                      "fileobj.__iter__() failed")
       
    1:     def test_fileobj_seek(self):
    3:         self.tar.extract("ustar/regtype", TEMPDIR)
    3:         with open(os.path.join(TEMPDIR, "ustar/regtype"), "rb") as fobj:
    3:             data = fobj.read()
       
    3:         tarinfo = self.tar.getmember("ustar/regtype")
    3:         fobj = self.tar.extractfile(tarinfo)
       
    3:         text = fobj.read()
    3:         fobj.seek(0)
    3:         self.assertTrue(0 == fobj.tell(),
    3:                      "seek() to file's start failed")
    3:         fobj.seek(2048, 0)
    3:         self.assertTrue(2048 == fobj.tell(),
    3:                      "seek() to absolute position failed")
    3:         fobj.seek(-1024, 1)
    3:         self.assertTrue(1024 == fobj.tell(),
    3:                      "seek() to negative relative position failed")
    3:         fobj.seek(1024, 1)
    3:         self.assertTrue(2048 == fobj.tell(),
    3:                      "seek() to positive relative position failed")
    3:         s = fobj.read(10)
    3:         self.assertTrue(s == data[2048:2058],
    3:                      "read() after seek failed")
    3:         fobj.seek(0, 2)
    3:         self.assertTrue(tarinfo.size == fobj.tell(),
    3:                      "seek() to file's end failed")
    3:         self.assertTrue(fobj.read() == "",
    3:                      "read() at file's end did not return empty string")
    3:         fobj.seek(-tarinfo.size, 2)
    3:         self.assertTrue(0 == fobj.tell(),
    3:                      "relative seek() to file's start failed")
    3:         fobj.seek(512)
    3:         s1 = fobj.readlines()
    3:         fobj.seek(512)
    3:         s2 = fobj.readlines()
    3:         self.assertTrue(s1 == s2,
    3:                      "readlines() after seek failed")
    3:         fobj.seek(0)
    3:         self.assertTrue(len(fobj.readline()) == fobj.tell(),
    3:                      "tell() after readline() failed")
    3:         fobj.seek(512)
    3:         self.assertTrue(len(fobj.readline()) + 512 == fobj.tell(),
    3:                      "tell() after seek() and readline() failed")
    3:         fobj.seek(0)
    3:         line = fobj.readline()
    3:         self.assertTrue(fobj.read() == data[len(line):],
    3:                      "read() after readline() failed")
    3:         fobj.close()
       
           # Test if symbolic and hard links are resolved by extractfile().  The
           # test link members each point to a regular member whose data is
           # supposed to be exported.
    1:     def _test_fileobj_link(self, lnktype, regtype):
   15:         a = self.tar.extractfile(lnktype)
   15:         b = self.tar.extractfile(regtype)
   15:         self.assertEqual(a.name, b.name)
       
    1:     def test_fileobj_link1(self):
    3:         self._test_fileobj_link("ustar/lnktype", "ustar/regtype")
       
    1:     def test_fileobj_link2(self):
    3:         self._test_fileobj_link("./ustar/linktest2/lnktype", "ustar/linktest1/regtype")
       
    1:     def test_fileobj_symlink1(self):
    3:         self._test_fileobj_link("ustar/symtype", "ustar/regtype")
       
    1:     def test_fileobj_symlink2(self):
    3:         self._test_fileobj_link("./ustar/linktest2/symtype", "ustar/linktest1/regtype")
       
    1:     def test_issue14160(self):
    3:         self._test_fileobj_link("symtype2", "ustar/regtype")
       
       
    2: class ListTest(ReadTest, unittest.TestCase):
       
           # Override setUp to use default encoding (UTF-8)
    1:     def setUp(self):
    6:         self.tar = tarfile.open(self.tarname, mode=self.mode)
       
    1:     def test_list(self):
    3:         with test_support.captured_stdout() as t:
    3:             self.tar.list(verbose=False)
    3:         out = t.getvalue()
    3:         self.assertIn('ustar/conttype', out)
    3:         self.assertIn('ustar/regtype', out)
    3:         self.assertIn('ustar/lnktype', out)
    3:         self.assertIn('ustar' + ('/12345' * 40) + '67/longname', out)
    3:         self.assertIn('./ustar/linktest2/symtype', out)
    3:         self.assertIn('./ustar/linktest2/lnktype', out)
               # Make sure it puts trailing slash for directory
    3:         self.assertIn('ustar/dirtype/', out)
    3:         self.assertIn('ustar/dirtype-with-size/', out)
               # Make sure it is able to print non-ASCII characters
    3:         self.assertIn('ustar/umlauts-'
    3:                       '\xc4\xd6\xdc\xe4\xf6\xfc\xdf', out)
    3:         self.assertIn('misc/regtype-hpux-signed-chksum-'
    3:                       '\xc4\xd6\xdc\xe4\xf6\xfc\xdf', out)
    3:         self.assertIn('misc/regtype-old-v7-signed-chksum-'
    3:                       '\xc4\xd6\xdc\xe4\xf6\xfc\xdf', out)
               # Make sure it prints files separated by one newline without any
               # 'ls -l'-like accessories if verbose flag is not being used
               # ...
               # ustar/conttype
               # ustar/regtype
               # ...
    3:         self.assertRegexpMatches(out, r'ustar/conttype ?\r?\n'
                                             r'ustar/regtype ?\r?\n')
               # Make sure it does not print the source of link without verbose flag
    3:         self.assertNotIn('link to', out)
    3:         self.assertNotIn('->', out)
       
    1:     def test_list_verbose(self):
    3:         with test_support.captured_stdout() as t:
    3:             self.tar.list(verbose=True)
    3:         out = t.getvalue()
               # Make sure it prints files separated by one newline with 'ls -l'-like
               # accessories if verbose flag is being used
               # ...
               # ?rw-r--r-- tarfile/tarfile     7011 2003-01-06 07:19:43 ustar/conttype
               # ?rw-r--r-- tarfile/tarfile     7011 2003-01-06 07:19:43 ustar/regtype
               # ...
    3:         self.assertRegexpMatches(out, (r'-rw-r--r-- tarfile/tarfile\s+7011 '
                                              r'\d{4}-\d\d-\d\d\s+\d\d:\d\d:\d\d '
    3:                                        r'ustar/\w+type ?\r?\n') * 2)
               # Make sure it prints the source of link with verbose flag
    3:         self.assertIn('ustar/symtype -> regtype', out)
    3:         self.assertIn('./ustar/linktest2/symtype -> ../linktest1/regtype', out)
    3:         self.assertIn('./ustar/linktest2/lnktype link to '
    3:                       './ustar/linktest1/regtype', out)
    3:         self.assertIn('gnu' + ('/123' * 125) + '/longlink link to gnu' +
    3:                       ('/123' * 125) + '/longname', out)
    3:         self.assertIn('pax' + ('/123' * 125) + '/longlink link to pax' +
    3:                       ('/123' * 125) + '/longname', out)
       
       
    2: class GzipListTest(ListTest):
    1:     tarname = gzipname
    1:     mode = "r:gz"
    1:     taropen = tarfile.TarFile.gzopen
       
       
    2: class Bz2ListTest(ListTest):
    1:     tarname = bz2name
    1:     mode = "r:bz2"
    1:     taropen = tarfile.TarFile.bz2open
       
       
    2: class CommonReadTest(ReadTest):
       
    1:     def test_empty_tarfile(self):
               # Test for issue6123: Allow opening empty archives.
               # This test checks if tarfile.open() is able to open an empty tar
               # archive successfully. Note that an empty tar archive is not the
               # same as an empty file!
    6:         with tarfile.open(tmpname, self.mode.replace("r", "w")):
    6:             pass
    6:         try:
    6:             tar = tarfile.open(tmpname, self.mode)
    6:             tar.getnames()
>>>>>>         except tarfile.ReadError:
>>>>>>             self.fail("tarfile.open() failed on empty archive")
               else:
    6:             self.assertListEqual(tar.getmembers(), [])
               finally:
    6:             tar.close()
       
    1:     def test_null_tarfile(self):
               # Test for issue6123: Allow opening empty archives.
               # This test guarantees that tarfile.open() does not treat an empty
               # file as an empty tar archive.
    6:         with open(tmpname, "wb"):
    6:             pass
    6:         self.assertRaises(tarfile.ReadError, tarfile.open, tmpname, self.mode)
    6:         self.assertRaises(tarfile.ReadError, tarfile.open, tmpname)
       
    1:     def test_non_existent_tarfile(self):
               # Test for issue11513: prevent non-existent gzipped tarfiles raising
               # multiple exceptions.
    6:         exctype = OSError if '|' in self.mode else IOError
    6:         with self.assertRaisesRegexp(exctype, "xxx") as ex:
    6:             tarfile.open("xxx", self.mode)
    6:         self.assertEqual(ex.exception.errno, errno.ENOENT)
       
    1:     def test_ignore_zeros(self):
               # Test TarFile's ignore_zeros option.
    6:         if self.mode.endswith(":gz"):
    1:             _open = gzip.GzipFile
    5:         elif self.mode.endswith(":bz2"):
    1:             _open = bz2.BZ2File
               else:
    4:             _open = open
       
               # generate 512 pseudorandom bytes
    6:         data = unhexlify('%1024x' % Random(0).getrandbits(512*8))
   18:         for char in ('\0', 'a'):
                   # Test if EOFHeaderError ('\0') and InvalidHeaderError ('a')
                   # are ignored correctly.
   12:             with _open(tmpname, "wb") as fobj:
   12:                 fobj.write(char * 1024)
   12:                 tarinfo = tarfile.TarInfo("foo")
   12:                 tarinfo.size = len(data)
   12:                 fobj.write(tarinfo.tobuf())
   12:                 fobj.write(data)
       
   12:             tar = tarfile.open(tmpname, mode="r", ignore_zeros=True)
   12:             try:
   12:                 self.assertListEqual(tar.getnames(), ["foo"],
   12:                     "ignore_zeros=True should have skipped the %r-blocks" % char)
                   finally:
   12:                 tar.close()
       
    1:     def test_premature_end_of_archive(self):
   30:         for size in (512, 600, 1024, 1200):
   24:             with tarfile.open(tmpname, "w:") as tar:
   24:                 t = tarfile.TarInfo("foo")
   24:                 t.size = 1024
   24:                 tar.addfile(t, StringIO.StringIO("a" * 1024))
       
   24:             with open(tmpname, "r+b") as fobj:
   24:                 fobj.truncate(size)
       
   24:             with tarfile.open(tmpname) as tar:
   24:                 with self.assertRaisesRegexp(tarfile.ReadError, "unexpected end of data"):
   48:                     for t in tar:
   24:                         pass
       
   24:             with tarfile.open(tmpname) as tar:
   24:                 t = tar.next()
       
   24:                 with self.assertRaisesRegexp(tarfile.ReadError, "unexpected end of data"):
   24:                     tar.extract(t, TEMPDIR)
       
   24:                 with self.assertRaisesRegexp(tarfile.ReadError, "unexpected end of data"):
   24:                     tar.extractfile(t).read()
       
       
    2: class MiscReadTest(CommonReadTest):
    1:     taropen = tarfile.TarFile.taropen
       
    1:     def test_no_name_argument(self):
    3:         with open(self.tarname, "rb") as fobj:
    3:             tar = tarfile.open(fileobj=fobj, mode=self.mode)
    3:             self.assertEqual(tar.name, os.path.abspath(fobj.name))
       
    1:     def test_no_name_attribute(self):
    3:         with open(self.tarname, "rb") as fobj:
    3:             data = fobj.read()
    3:         fobj = StringIO.StringIO(data)
    3:         self.assertRaises(AttributeError, getattr, fobj, "name")
    3:         tar = tarfile.open(fileobj=fobj, mode=self.mode)
    3:         self.assertEqual(tar.name, None)
       
    1:     def test_empty_name_attribute(self):
    3:         with open(self.tarname, "rb") as fobj:
    3:             data = fobj.read()
    3:         fobj = StringIO.StringIO(data)
    3:         fobj.name = ""
    3:         tar = tarfile.open(fileobj=fobj, mode=self.mode)
    3:         self.assertEqual(tar.name, None)
       
    1:     def test_illegal_mode_arg(self):
    3:         with open(tmpname, 'wb'):
    3:             pass
    3:         self.addCleanup(os.unlink, tmpname)
    3:         with self.assertRaisesRegexp(ValueError, 'mode must be '):
    3:             tar = self.taropen(tmpname, 'q')
    3:         with self.assertRaisesRegexp(ValueError, 'mode must be '):
    3:             tar = self.taropen(tmpname, 'rw')
    3:         with self.assertRaisesRegexp(ValueError, 'mode must be '):
    3:             tar = self.taropen(tmpname, '')
       
    1:     def test_fileobj_with_offset(self):
               # Skip the first member and store values from the second member
               # of the testtar.
    3:         tar = tarfile.open(self.tarname, mode=self.mode)
    3:         try:
    3:             tar.next()
    3:             t = tar.next()
    3:             name = t.name
    3:             offset = t.offset
    3:             data = tar.extractfile(t).read()
               finally:
    3:             tar.close()
       
               # Open the testtar and seek to the offset of the second member.
    3:         if self.mode.endswith(":gz"):
    1:             _open = gzip.GzipFile
    2:         elif self.mode.endswith(":bz2"):
    1:             _open = bz2.BZ2File
               else:
    1:             _open = open
    3:         fobj = _open(self.tarname, "rb")
    3:         try:
    3:             fobj.seek(offset)
       
                   # Test if the tarfile starts with the second member.
    3:             tar = tar.open(self.tarname, mode="r:", fileobj=fobj)
    3:             t = tar.next()
    3:             self.assertEqual(t.name, name)
                   # Read to the end of fileobj and test if seeking back to the
                   # beginning works.
    3:             tar.getmembers()
    3:             self.assertEqual(tar.extractfile(t).read(), data,
    3:                     "seek back did not work")
    3:             tar.close()
               finally:
    3:             fobj.close()
       
    1:     def test_fail_comp(self):
               # For Gzip and Bz2 Tests: fail with a ReadError on an uncompressed file.
    3:         if self.mode == "r:":
    1:             self.skipTest('needs a gz or bz2 mode')
    2:         self.assertRaises(tarfile.ReadError, tarfile.open, tarname, self.mode)
    2:         with open(tarname, "rb") as fobj:
    2:             self.assertRaises(tarfile.ReadError, tarfile.open,
    2:                               fileobj=fobj, mode=self.mode)
       
    1:     def test_v7_dirtype(self):
               # Test old style dirtype member (bug #1336623):
               # Old V7 tars create directory members using an AREGTYPE
               # header with a "/" appended to the filename field.
    3:         tarinfo = self.tar.getmember("misc/dirtype-old-v7")
    3:         self.assertTrue(tarinfo.type == tarfile.DIRTYPE,
    3:                 "v7 dirtype failed")
       
    1:     def test_xstar_type(self):
               # The xstar format stores extra atime and ctime fields inside the
               # space reserved for the prefix field. The prefix field must be
               # ignored in this case, otherwise it will mess up the name.
    3:         try:
    3:             self.tar.getmember("misc/regtype-xstar")
>>>>>>         except KeyError:
>>>>>>             self.fail("failed to find misc/regtype-xstar (mangled prefix?)")
       
    1:     def test_check_members(self):
  102:         for tarinfo in self.tar:
   99:             self.assertTrue(int(tarinfo.mtime) == 07606136617,
   99:                     "wrong mtime for %s" % tarinfo.name)
   99:             if not tarinfo.name.startswith("ustar/"):
   60:                 continue
   39:             self.assertTrue(tarinfo.uname == "tarfile",
   39:                     "wrong uname for %s" % tarinfo.name)
       
    1:     def test_find_members(self):
    3:         self.assertTrue(self.tar.getmembers()[-1].name == "misc/eof",
    3:                 "could not find all members")
       
    1:     def test_extract_hardlink(self):
               # Test hardlink extraction (e.g. bug #857297).
    3:         with tarfile.open(tarname, errorlevel=1, encoding="iso8859-1") as tar:
    3:             tar.extract("ustar/regtype", TEMPDIR)
    3:             self.addCleanup(os.remove, os.path.join(TEMPDIR, "ustar/regtype"))
       
    3:             tar.extract("ustar/lnktype", TEMPDIR)
    3:             self.addCleanup(os.remove, os.path.join(TEMPDIR, "ustar/lnktype"))
    3:             with open(os.path.join(TEMPDIR, "ustar/lnktype"), "rb") as f:
    3:                 data = f.read()
    3:             self.assertEqual(md5sum(data), md5_regtype)
       
    3:             tar.extract("ustar/symtype", TEMPDIR)
    3:             self.addCleanup(os.remove, os.path.join(TEMPDIR, "ustar/symtype"))
    3:             with open(os.path.join(TEMPDIR, "ustar/symtype"), "rb") as f:
    3:                 data = f.read()
    3:             self.assertEqual(md5sum(data), md5_regtype)
       
    1:     def test_extractall(self):
               # Test if extractall() correctly restores directory permissions
               # and times (see issue1735).
    3:         tar = tarfile.open(tarname, encoding="iso8859-1")
    3:         try:
  102:             directories = [t for t in tar if t.isdir()]
    3:             tar.extractall(TEMPDIR, directories)
   12:             for tarinfo in directories:
    9:                 path = os.path.join(TEMPDIR, tarinfo.name)
    9:                 if sys.platform != "win32":
                           # Win32 has no support for fine grained permissions.
    9:                     self.assertEqual(tarinfo.mode & 0777, os.stat(path).st_mode & 0777)
    9:                 self.assertEqual(tarinfo.mtime, os.path.getmtime(path))
               finally:
    3:             tar.close()
       
    1:     def test_init_close_fobj(self):
               # Issue #7341: Close the internal file object in the TarFile
               # constructor in case of an error. For the test we rely on
               # the fact that opening an empty file raises a ReadError.
    3:         empty = os.path.join(TEMPDIR, "empty")
    3:         with open(empty, "wb") as fobj:
    3:             fobj.write("")
       
    3:         try:
    3:             tar = object.__new__(tarfile.TarFile)
    3:             try:
    3:                 tar.__init__(empty)
    3:             except tarfile.ReadError:
    3:                 self.assertTrue(tar.fileobj.closed)
                   else:
>>>>>>                 self.fail("ReadError not raised")
               finally:
    3:             support.unlink(empty)
       
    1:     def test_parallel_iteration(self):
               # Issue #16601: Restarting iteration over tarfile continued
               # from where it left off.
    3:         with tarfile.open(self.tarname) as tar:
  102:             for m1, m2 in zip(tar, tar):
   99:                 self.assertEqual(m1.offset, m2.offset)
   99:                 self.assertEqual(m1.name, m2.name)
       
       
    2: class StreamReadTest(CommonReadTest):
       
    1:     mode="r|"
       
    1:     def test_fileobj_regular_file(self):
    3:         tarinfo = self.tar.next() # get "regtype" (can't use getmember)
    3:         fobj = self.tar.extractfile(tarinfo)
    3:         data = fobj.read()
    3:         self.assertTrue((len(data), md5sum(data)) == (tarinfo.size, md5_regtype),
    3:                 "regular file extraction failed")
       
    1:     def test_provoke_stream_error(self):
    3:         tarinfos = self.tar.getmembers()
    3:         f = self.tar.extractfile(tarinfos[0]) # read the first member
    3:         self.assertRaises(tarfile.StreamError, f.read)
       
    1:     def test_compare_members(self):
    3:         tar1 = tarfile.open(tarname, encoding="iso8859-1")
    3:         try:
    3:             tar2 = self.tar
       
  102:             while True:
  102:                 t1 = tar1.next()
  102:                 t2 = tar2.next()
  102:                 if t1 is None:
    3:                     break
   99:                 self.assertTrue(t2 is not None, "stream.next() failed.")
       
   99:                 if t2.islnk() or t2.issym():
   21:                     self.assertRaises(tarfile.StreamError, tar2.extractfile, t2)
   21:                     continue
       
   78:                 v1 = tar1.extractfile(t1)
   78:                 v2 = tar2.extractfile(t2)
   78:                 if v1 is None:
   18:                     continue
   60:                 self.assertTrue(v2 is not None, "stream.extractfile() failed")
   60:                 self.assertTrue(v1.read() == v2.read(), "stream extraction failed")
               finally:
    3:             tar1.close()
       
       
    2: class DetectReadTest(unittest.TestCase):
       
    1:     def _testfunc_file(self, name, mode):
   16:         try:
   16:             tar = tarfile.open(name, mode)
>>>>>>         except tarfile.ReadError:
>>>>>>             self.fail()
               else:
   16:             tar.close()
       
    1:     def _testfunc_fileobj(self, name, mode):
   15:         try:
   15:             tar = tarfile.open(name, mode, fileobj=open(name, "rb"))
>>>>>>         except tarfile.ReadError:
>>>>>>             self.fail()
               else:
   15:             tar.close()
       
    1:     def _test_modes(self, testfunc):
    2:         testfunc(tarname, "r")
    2:         testfunc(tarname, "r:")
    2:         testfunc(tarname, "r:*")
    2:         testfunc(tarname, "r|")
    2:         testfunc(tarname, "r|*")
       
    2:         if gzip:
    2:             self.assertRaises(tarfile.ReadError, tarfile.open, tarname, mode="r:gz")
    2:             self.assertRaises(tarfile.ReadError, tarfile.open, tarname, mode="r|gz")
    2:             self.assertRaises(tarfile.ReadError, tarfile.open, gzipname, mode="r:")
    2:             self.assertRaises(tarfile.ReadError, tarfile.open, gzipname, mode="r|")
       
    2:             testfunc(gzipname, "r")
    2:             testfunc(gzipname, "r:*")
    2:             testfunc(gzipname, "r:gz")
    2:             testfunc(gzipname, "r|*")
    2:             testfunc(gzipname, "r|gz")
       
    2:         if bz2:
    2:             self.assertRaises(tarfile.ReadError, tarfile.open, tarname, mode="r:bz2")
    2:             self.assertRaises(tarfile.ReadError, tarfile.open, tarname, mode="r|bz2")
    2:             self.assertRaises(tarfile.ReadError, tarfile.open, bz2name, mode="r:")
    2:             self.assertRaises(tarfile.ReadError, tarfile.open, bz2name, mode="r|")
       
    2:             testfunc(bz2name, "r")
    2:             testfunc(bz2name, "r:*")
    2:             testfunc(bz2name, "r:bz2")
    2:             testfunc(bz2name, "r|*")
    2:             testfunc(bz2name, "r|bz2")
       
    1:     def test_detect_file(self):
    1:         self._test_modes(self._testfunc_file)
       
    1:     def test_detect_fileobj(self):
    1:         self._test_modes(self._testfunc_fileobj)
       
    1:     @unittest.skipUnless(bz2, 'requires bz2')
           def test_detect_stream_bz2(self):
               # Originally, tarfile's stream detection looked for the string
               # "BZh91" at the start of the file. This is incorrect because
               # the '9' represents the blocksize (900kB). If the file was
               # compressed using another blocksize autodetection fails.
    1:         with open(tarname, "rb") as fobj:
    1:             data = fobj.read()
       
               # Compress with blocksize 100kB, the file starts with "BZh11".
    1:         with bz2.BZ2File(tmpname, "wb", compresslevel=1) as fobj:
    1:             fobj.write(data)
       
    1:         self._testfunc_file(tmpname, "r|*")
       
       
    2: class MemberReadTest(ReadTest):
       
    1:     def _test_member(self, tarinfo, chksum=None, **kwargs):
   13:         if chksum is not None:
    6:             self.assertTrue(md5sum(self.tar.extractfile(tarinfo).read()) == chksum,
    6:                     "wrong md5sum for %s" % tarinfo.name)
       
   13:         kwargs["mtime"] = 07606136617
   13:         kwargs["uid"] = 1000
   13:         kwargs["gid"] = 100
   13:         if "old-v7" not in tarinfo.name:
                   # V7 tar can't handle alphabetic owners.
   12:             kwargs["uname"] = "tarfile"
   12:             kwargs["gname"] = "tarfile"
   95:         for k, v in kwargs.iteritems():
   82:             self.assertTrue(getattr(tarinfo, k) == v,
   82:                     "wrong value in %s field of %s" % (k, tarinfo.name))
       
    1:     def test_find_regtype(self):
    1:         tarinfo = self.tar.getmember("ustar/regtype")
    1:         self._test_member(tarinfo, size=7011, chksum=md5_regtype)
       
    1:     def test_find_conttype(self):
    1:         tarinfo = self.tar.getmember("ustar/conttype")
    1:         self._test_member(tarinfo, size=7011, chksum=md5_regtype)
       
    1:     def test_find_dirtype(self):
    1:         tarinfo = self.tar.getmember("ustar/dirtype")
    1:         self._test_member(tarinfo, size=0)
       
    1:     def test_find_dirtype_with_size(self):
    1:         tarinfo = self.tar.getmember("ustar/dirtype-with-size")
    1:         self._test_member(tarinfo, size=255)
       
    1:     def test_find_lnktype(self):
    1:         tarinfo = self.tar.getmember("ustar/lnktype")
    1:         self._test_member(tarinfo, size=0, linkname="ustar/regtype")
       
    1:     def test_find_symtype(self):
    1:         tarinfo = self.tar.getmember("ustar/symtype")
    1:         self._test_member(tarinfo, size=0, linkname="regtype")
       
    1:     def test_find_blktype(self):
    1:         tarinfo = self.tar.getmember("ustar/blktype")
    1:         self._test_member(tarinfo, size=0, devmajor=3, devminor=0)
       
    1:     def test_find_chrtype(self):
    1:         tarinfo = self.tar.getmember("ustar/chrtype")
    1:         self._test_member(tarinfo, size=0, devmajor=1, devminor=3)
       
    1:     def test_find_fifotype(self):
    1:         tarinfo = self.tar.getmember("ustar/fifotype")
    1:         self._test_member(tarinfo, size=0)
       
    1:     def test_find_sparse(self):
    1:         tarinfo = self.tar.getmember("ustar/sparse")
    1:         self._test_member(tarinfo, size=86016, chksum=md5_sparse)
       
    1:     def test_find_umlauts(self):
    1:         tarinfo = self.tar.getmember("ustar/umlauts-\xc4\xd6\xdc\xe4\xf6\xfc\xdf")
    1:         self._test_member(tarinfo, size=7011, chksum=md5_regtype)
       
    1:     def test_find_ustar_longname(self):
    1:         name = "ustar/" + "12345/" * 39 + "1234567/longname"
    1:         self.assertIn(name, self.tar.getnames())
       
    1:     def test_find_regtype_oldv7(self):
    1:         tarinfo = self.tar.getmember("misc/regtype-old-v7")
    1:         self._test_member(tarinfo, size=7011, chksum=md5_regtype)
       
    1:     def test_find_pax_umlauts(self):
    1:         self.tar = tarfile.open(self.tarname, mode=self.mode, encoding="iso8859-1")
    1:         tarinfo = self.tar.getmember("pax/umlauts-\xc4\xd6\xdc\xe4\xf6\xfc\xdf")
    1:         self._test_member(tarinfo, size=7011, chksum=md5_regtype)
       
       
    2: class LongnameTest(ReadTest):
       
    1:     def test_read_longname(self):
               # Test reading of longname (bug #1471427).
    2:         longname = self.subdir + "/" + "123/" * 125 + "longname"
    2:         try:
    2:             tarinfo = self.tar.getmember(longname)
>>>>>>         except KeyError:
>>>>>>             self.fail("longname not found")
    2:         self.assertTrue(tarinfo.type != tarfile.DIRTYPE, "read longname as dirtype")
       
    1:     def test_read_longlink(self):
    2:         longname = self.subdir + "/" + "123/" * 125 + "longname"
    2:         longlink = self.subdir + "/" + "123/" * 125 + "longlink"
    2:         try:
    2:             tarinfo = self.tar.getmember(longlink)
>>>>>>         except KeyError:
>>>>>>             self.fail("longlink not found")
    2:         self.assertTrue(tarinfo.linkname == longname, "linkname wrong")
       
    1:     def test_truncated_longname(self):
    2:         longname = self.subdir + "/" + "123/" * 125 + "longname"
    2:         tarinfo = self.tar.getmember(longname)
    2:         offset = tarinfo.offset
    2:         self.tar.fileobj.seek(offset)
    2:         fobj = StringIO.StringIO(self.tar.fileobj.read(3 * 512))
    2:         self.assertRaises(tarfile.ReadError, tarfile.open, name="foo.tar", fileobj=fobj)
       
    1:     def test_header_offset(self):
               # Test if the start offset of the TarInfo object includes
               # the preceding extended header.
    2:         longname = self.subdir + "/" + "123/" * 125 + "longname"
    2:         offset = self.tar.getmember(longname).offset
    2:         fobj = open(tarname)
    2:         fobj.seek(offset)
    2:         tarinfo = tarfile.TarInfo.frombuf(fobj.read(512))
    2:         self.assertEqual(tarinfo.type, self.longnametype)
       
       
    2: class GNUReadTest(LongnameTest):
       
    1:     subdir = "gnu"
    1:     longnametype = tarfile.GNUTYPE_LONGNAME
       
    1:     def test_sparse_file(self):
    1:         tarinfo1 = self.tar.getmember("ustar/sparse")
    1:         fobj1 = self.tar.extractfile(tarinfo1)
    1:         tarinfo2 = self.tar.getmember("gnu/sparse")
    1:         fobj2 = self.tar.extractfile(tarinfo2)
    1:         self.assertTrue(fobj1.read() == fobj2.read(),
    1:                 "sparse file extraction failed")
       
       
    2: class PaxReadTest(LongnameTest):
       
    1:     subdir = "pax"
    1:     longnametype = tarfile.XHDTYPE
       
    1:     def test_pax_global_headers(self):
    1:         tar = tarfile.open(tarname, encoding="iso8859-1")
    1:         try:
       
    1:             tarinfo = tar.getmember("pax/regtype1")
    1:             self.assertEqual(tarinfo.uname, "foo")
    1:             self.assertEqual(tarinfo.gname, "bar")
    1:             self.assertEqual(tarinfo.pax_headers.get("VENDOR.umlauts"), u"\xc4\xd6\xdc\xe4\xf6\xfc\xdf")
       
    1:             tarinfo = tar.getmember("pax/regtype2")
    1:             self.assertEqual(tarinfo.uname, "")
    1:             self.assertEqual(tarinfo.gname, "bar")
    1:             self.assertEqual(tarinfo.pax_headers.get("VENDOR.umlauts"), u"\xc4\xd6\xdc\xe4\xf6\xfc\xdf")
       
    1:             tarinfo = tar.getmember("pax/regtype3")
    1:             self.assertEqual(tarinfo.uname, "tarfile")
    1:             self.assertEqual(tarinfo.gname, "tarfile")
    1:             self.assertEqual(tarinfo.pax_headers.get("VENDOR.umlauts"), u"\xc4\xd6\xdc\xe4\xf6\xfc\xdf")
               finally:
    1:             tar.close()
       
    1:     def test_pax_number_fields(self):
               # All following number fields are read from the pax header.
    1:         tar = tarfile.open(tarname, encoding="iso8859-1")
    1:         try:
    1:             tarinfo = tar.getmember("pax/regtype4")
    1:             self.assertEqual(tarinfo.size, 7011)
    1:             self.assertEqual(tarinfo.uid, 123)
    1:             self.assertEqual(tarinfo.gid, 123)
    1:             self.assertEqual(tarinfo.mtime, 1041808783.0)
    1:             self.assertEqual(type(tarinfo.mtime), float)
    1:             self.assertEqual(float(tarinfo.pax_headers["atime"]), 1041808783.0)
    1:             self.assertEqual(float(tarinfo.pax_headers["ctime"]), 1041808783.0)
               finally:
    1:             tar.close()
       
       
    2: class WriteTestBase(unittest.TestCase):
           # Put all write tests in here that are supposed to be tested
           # in all possible mode combinations.
       
    1:     def test_fileobj_no_close(self):
    6:         fobj = StringIO.StringIO()
    6:         tar = tarfile.open(fileobj=fobj, mode=self.mode)
    6:         tar.addfile(tarfile.TarInfo("foo"))
    6:         tar.close()
    6:         self.assertTrue(fobj.closed is False, "external fileobjs must never closed")
               # Issue #20238: Incomplete gzip output with mode="w:gz"
    6:         data = fobj.getvalue()
    6:         del tar
    6:         test_support.gc_collect()
    6:         self.assertFalse(fobj.closed)
    6:         self.assertEqual(data, fobj.getvalue())
       
       
    2: class WriteTest(WriteTestBase):
       
    1:     mode = "w:"
       
    1:     def test_100_char_name(self):
               # The name field in a tar header stores strings of at most 100 chars.
               # If a string is shorter than 100 chars it has to be padded with '\0',
               # which implies that a string of exactly 100 chars is stored without
               # a trailing '\0'.
    3:         name = "0123456789" * 10
    3:         tar = tarfile.open(tmpname, self.mode)
    3:         try:
    3:             t = tarfile.TarInfo(name)
    3:             tar.addfile(t)
               finally:
    3:             tar.close()
       
    3:         tar = tarfile.open(tmpname)
    3:         try:
    3:             self.assertTrue(tar.getnames()[0] == name,
    3:                     "failed to store 100 char filename")
               finally:
    3:             tar.close()
       
    1:     def test_tar_size(self):
               # Test for bug #1013882.
    3:         tar = tarfile.open(tmpname, self.mode)
    3:         try:
    3:             path = os.path.join(TEMPDIR, "file")
    3:             with open(path, "wb") as fobj:
    3:                 fobj.write("aaa")
    3:             tar.add(path)
               finally:
    3:             tar.close()
    3:         self.assertTrue(os.path.getsize(tmpname) > 0,
    3:                 "tarfile is empty")
       
           # The test_*_size tests test for bug #1167128.
    1:     def test_file_size(self):
    3:         tar = tarfile.open(tmpname, self.mode)
    3:         try:
       
    3:             path = os.path.join(TEMPDIR, "file")
    3:             with open(path, "wb"):
    3:                 pass
    3:             tarinfo = tar.gettarinfo(path)
    3:             self.assertEqual(tarinfo.size, 0)
       
    3:             with open(path, "wb") as fobj:
    3:                 fobj.write("aaa")
    3:             tarinfo = tar.gettarinfo(path)
    3:             self.assertEqual(tarinfo.size, 3)
               finally:
    3:             tar.close()
       
    1:     def test_directory_size(self):
    3:         path = os.path.join(TEMPDIR, "directory")
    3:         os.mkdir(path)
    3:         try:
    3:             tar = tarfile.open(tmpname, self.mode)
    3:             try:
    3:                 tarinfo = tar.gettarinfo(path)
    3:                 self.assertEqual(tarinfo.size, 0)
                   finally:
    3:                 tar.close()
               finally:
    3:             os.rmdir(path)
       
    1:     def test_link_size(self):
    3:         if hasattr(os, "link"):
    3:             link = os.path.join(TEMPDIR, "link")
    3:             target = os.path.join(TEMPDIR, "link_target")
    3:             with open(target, "wb") as fobj:
    3:                 fobj.write("aaa")
    3:             os.link(target, link)
    3:             try:
    3:                 tar = tarfile.open(tmpname, self.mode)
    3:                 try:
                           # Record the link target in the inodes list.
    3:                     tar.gettarinfo(target)
    3:                     tarinfo = tar.gettarinfo(link)
    3:                     self.assertEqual(tarinfo.size, 0)
                       finally:
    3:                     tar.close()
                   finally:
    3:                 os.remove(target)
    3:                 os.remove(link)
       
    1:     def test_symlink_size(self):
    3:         if hasattr(os, "symlink"):
    3:             path = os.path.join(TEMPDIR, "symlink")
    3:             os.symlink("link_target", path)
    3:             try:
    3:                 tar = tarfile.open(tmpname, self.mode)
    3:                 try:
    3:                     tarinfo = tar.gettarinfo(path)
    3:                     self.assertEqual(tarinfo.size, 0)
                       finally:
    3:                     tar.close()
                   finally:
    3:                 os.remove(path)
       
    1:     def test_add_self(self):
               # Test for #1257255.
    3:         dstname = os.path.abspath(tmpname)
    3:         tar = tarfile.open(tmpname, self.mode)
    3:         try:
    3:             self.assertTrue(tar.name == dstname, "archive name must be absolute")
    3:             tar.add(dstname)
    3:             self.assertTrue(tar.getnames() == [], "added the archive to itself")
       
    3:             cwd = os.getcwd()
    3:             os.chdir(TEMPDIR)
    3:             tar.add(dstname)
    3:             os.chdir(cwd)
    3:             self.assertTrue(tar.getnames() == [], "added the archive to itself")
               finally:
    3:             tar.close()
       
    1:     def test_exclude(self):
    3:         tempdir = os.path.join(TEMPDIR, "exclude")
    3:         os.mkdir(tempdir)
    3:         try:
   12:             for name in ("foo", "bar", "baz"):
    9:                 name = os.path.join(tempdir, name)
    9:                 open(name, "wb").close()
       
    3:             exclude = os.path.isfile
       
    3:             tar = tarfile.open(tmpname, self.mode, encoding="iso8859-1")
    3:             try:
    3:                 with test_support.check_warnings(("use the filter argument",
    3:                                                 DeprecationWarning)):
    3:                     tar.add(tempdir, arcname="empty_dir", exclude=exclude)
                   finally:
    3:                 tar.close()
       
    3:             tar = tarfile.open(tmpname, "r")
    3:             try:
    3:                 self.assertEqual(len(tar.getmembers()), 1)
    3:                 self.assertEqual(tar.getnames()[0], "empty_dir")
                   finally:
    3:                 tar.close()
               finally:
    3:             shutil.rmtree(tempdir)
       
    1:     def test_filter(self):
    3:         tempdir = os.path.join(TEMPDIR, "filter")
    3:         os.mkdir(tempdir)
    3:         try:
   12:             for name in ("foo", "bar", "baz"):
    9:                 name = os.path.join(tempdir, name)
    9:                 open(name, "wb").close()
       
    3:             def filter(tarinfo):
   12:                 if os.path.basename(tarinfo.name) == "bar":
    3:                     return
    9:                 tarinfo.uid = 123
    9:                 tarinfo.uname = "foo"
    9:                 return tarinfo
       
    3:             tar = tarfile.open(tmpname, self.mode, encoding="iso8859-1")
    3:             try:
    3:                 tar.add(tempdir, arcname="empty_dir", filter=filter)
                   finally:
    3:                 tar.close()
       
    3:             tar = tarfile.open(tmpname, "r")
    3:             try:
   12:                 for tarinfo in tar:
    9:                     self.assertEqual(tarinfo.uid, 123)
    9:                     self.assertEqual(tarinfo.uname, "foo")
    3:                 self.assertEqual(len(tar.getmembers()), 3)
                   finally:
    3:                 tar.close()
               finally:
    3:             shutil.rmtree(tempdir)
       
           # Guarantee that stored pathnames are not modified. Don't
           # remove ./ or ../ or double slashes. Still make absolute
           # pathnames relative.
           # For details see bug #6054.
    1:     def _test_pathname(self, path, cmp_path=None, dir=False):
               # Create a tarfile with an empty member named path
               # and compare the stored name with the original.
   48:         foo = os.path.join(TEMPDIR, "foo")
   48:         if not dir:
   45:             open(foo, "w").close()
               else:
    3:             os.mkdir(foo)
       
   48:         tar = tarfile.open(tmpname, self.mode)
   48:         try:
   48:             tar.add(foo, arcname=path)
               finally:
   48:             tar.close()
       
   48:         tar = tarfile.open(tmpname, "r")
   48:         try:
   48:             t = tar.next()
               finally:
   48:             tar.close()
       
   48:         if not dir:
   45:             os.remove(foo)
               else:
    3:             os.rmdir(foo)
       
   48:         self.assertEqual(t.name, cmp_path or path.replace(os.sep, "/"))
       
    1:     def test_pathnames(self):
    3:         self._test_pathname("foo")
    3:         self._test_pathname(os.path.join("foo", ".", "bar"))
    3:         self._test_pathname(os.path.join("foo", "..", "bar"))
    3:         self._test_pathname(os.path.join(".", "foo"))
    3:         self._test_pathname(os.path.join(".", "foo", "."))
    3:         self._test_pathname(os.path.join(".", "foo", ".", "bar"))
    3:         self._test_pathname(os.path.join(".", "foo", "..", "bar"))
    3:         self._test_pathname(os.path.join(".", "foo", "..", "bar"))
    3:         self._test_pathname(os.path.join("..", "foo"))
    3:         self._test_pathname(os.path.join("..", "foo", ".."))
    3:         self._test_pathname(os.path.join("..", "foo", ".", "bar"))
    3:         self._test_pathname(os.path.join("..", "foo", "..", "bar"))
       
    3:         self._test_pathname("foo" + os.sep + os.sep + "bar")
    3:         self._test_pathname("foo" + os.sep + os.sep, "foo", dir=True)
       
    1:     def test_abs_pathnames(self):
    3:         if sys.platform == "win32":
>>>>>>             self._test_pathname("C:\\foo", "foo")
               else:
    3:             self._test_pathname("/foo", "foo")
    3:             self._test_pathname("///foo", "foo")
       
    1:     def test_cwd(self):
               # Test adding the current working directory.
    3:         with support.change_cwd(TEMPDIR):
    3:             tar = tarfile.open(tmpname, self.mode)
    3:             try:
    3:                 tar.add(".")
                   finally:
    3:                 tar.close()
       
    3:             tar = tarfile.open(tmpname, "r")
    3:             try:
   31:                 for t in tar:
   28:                     self.assertTrue(t.name == "." or t.name.startswith("./"))
                   finally:
    3:                 tar.close()
       
    1:     @unittest.skipUnless(hasattr(os, 'symlink'), "needs os.symlink")
           def test_extractall_symlinks(self):
               # Test if extractall works properly when tarfile contains symlinks
    3:         tempdir = os.path.join(TEMPDIR, "testsymlinks")
    3:         temparchive = os.path.join(TEMPDIR, "testsymlinks.tar")
    3:         os.mkdir(tempdir)
    3:         try:
    3:             source_file = os.path.join(tempdir,'source')
    3:             target_file = os.path.join(tempdir,'symlink')
    3:             with open(source_file,'w') as f:
    3:                 f.write('something\n')
    3:             os.symlink(source_file, target_file)
    3:             tar = tarfile.open(temparchive,'w')
    3:             tar.add(source_file, arcname=os.path.basename(source_file))
    3:             tar.add(target_file, arcname=os.path.basename(target_file))
    3:             tar.close()
                   # Let's extract it to the location which contains the symlink
    3:             tar = tarfile.open(temparchive,'r')
                   # this should not raise OSError: [Errno 17] File exists
    3:             try:
    3:                 tar.extractall(path=tempdir)
>>>>>>             except OSError:
>>>>>>                 self.fail("extractall failed with symlinked files")
                   finally:
    3:                 tar.close()
               finally:
    3:             os.unlink(temparchive)
    3:             shutil.rmtree(tempdir)
       
    1:     @unittest.skipUnless(hasattr(os, 'symlink'), "needs os.symlink")
           def test_extractall_broken_symlinks(self):
               # Test if extractall works properly when tarfile contains broken
               # symlinks
    3:         tempdir = os.path.join(TEMPDIR, "testsymlinks")
    3:         temparchive = os.path.join(TEMPDIR, "testsymlinks.tar")
    3:         os.mkdir(tempdir)
    3:         try:
    3:             source_file = os.path.join(tempdir,'source')
    3:             target_file = os.path.join(tempdir,'symlink')
    3:             with open(source_file,'w') as f:
    3:                 f.write('something\n')
    3:             os.symlink(source_file, target_file)
    3:             tar = tarfile.open(temparchive,'w')
    3:             tar.add(target_file, arcname=os.path.basename(target_file))
    3:             tar.close()
                   # remove the real file
    3:             os.unlink(source_file)
                   # Let's extract it to the location which contains the symlink
    3:             tar = tarfile.open(temparchive,'r')
                   # this should not raise OSError: [Errno 17] File exists
    3:             try:
    3:                 tar.extractall(path=tempdir)
>>>>>>             except OSError:
>>>>>>                 self.fail("extractall failed with broken symlinked files")
                   finally:
    3:                 tar.close()
               finally:
    3:             os.unlink(temparchive)
    3:             shutil.rmtree(tempdir)
       
    1:     @unittest.skipUnless(hasattr(os, 'link'), "needs os.link")
           def test_extractall_hardlinks(self):
               # Test if extractall works properly when tarfile contains symlinks
    3:         tempdir = os.path.join(TEMPDIR, "testsymlinks")
    3:         temparchive = os.path.join(TEMPDIR, "testsymlinks.tar")
    3:         os.mkdir(tempdir)
    3:         try:
    3:             source_file = os.path.join(tempdir,'source')
    3:             target_file = os.path.join(tempdir,'symlink')
    3:             with open(source_file,'w') as f:
    3:                 f.write('something\n')
    3:             os.link(source_file, target_file)
    3:             tar = tarfile.open(temparchive,'w')
    3:             tar.add(source_file, arcname=os.path.basename(source_file))
    3:             tar.add(target_file, arcname=os.path.basename(target_file))
    3:             tar.close()
                   # Let's extract it to the location which contains the symlink
    3:             tar = tarfile.open(temparchive,'r')
                   # this should not raise OSError: [Errno 17] File exists
    3:             try:
    3:                 tar.extractall(path=tempdir)
>>>>>>             except OSError:
>>>>>>                 self.fail("extractall failed with linked files")
                   finally:
    3:                 tar.close()
               finally:
    3:             os.unlink(temparchive)
    3:             shutil.rmtree(tempdir)
       
    1:     def test_open_nonwritable_fileobj(self):
   12:         for exctype in IOError, EOFError, RuntimeError:
   18:             class BadFile(StringIO.StringIO):
    9:                 first = True
    9:                 def write(self, data):
   21:                     if self.first:
    9:                         self.first = False
    9:                         raise exctype
       
    9:             f = BadFile()
    9:             with self.assertRaises(exctype):
    9:                 tar = tarfile.open(tmpname, self.mode, fileobj=f,
    9:                                    format=tarfile.PAX_FORMAT,
    9:                                    pax_headers={'non': 'empty'})
    9:             self.assertFalse(f.closed)
       
    2: class StreamWriteTest(WriteTestBase):
       
    1:     mode = "w|"
       
    1:     def test_stream_padding(self):
               # Test for bug #1543303.
    3:         tar = tarfile.open(tmpname, self.mode)
    3:         tar.close()
       
    3:         if self.mode.endswith("gz"):
    1:             with gzip.GzipFile(tmpname) as fobj:
    1:                 data = fobj.read()
    2:         elif self.mode.endswith("bz2"):
    1:             dec = bz2.BZ2Decompressor()
    1:             with open(tmpname, "rb") as fobj:
    1:                 data = fobj.read()
    1:             data = dec.decompress(data)
    1:             self.assertTrue(len(dec.unused_data) == 0,
    1:                     "found trailing data")
               else:
    1:             with open(tmpname, "rb") as fobj:
    1:                 data = fobj.read()
       
    3:         self.assertTrue(data.count("\0") == tarfile.RECORDSIZE,
    3:                          "incorrect zero padding")
       
    1:     @unittest.skipIf(sys.platform == 'win32', 'not appropriate for Windows')
    1:     @unittest.skipUnless(hasattr(os, 'umask'), 'requires os.umask')
           def test_file_mode(self):
               # Test for issue #8464: Create files with correct
               # permissions.
    3:         if os.path.exists(tmpname):
    3:             os.remove(tmpname)
       
    3:         original_umask = os.umask(0022)
    3:         try:
    3:             tar = tarfile.open(tmpname, self.mode)
    3:             tar.close()
    3:             mode = os.stat(tmpname).st_mode & 0777
    3:             self.assertEqual(mode, 0644, "wrong file permissions")
               finally:
    3:             os.umask(original_umask)
       
    1:     def test_issue13639(self):
    3:         try:
    3:             with tarfile.open(unicode(tmpname, sys.getfilesystemencoding()), self.mode):
    3:                 pass
>>>>>>         except UnicodeDecodeError:
>>>>>>             self.fail("_Stream failed to write unicode filename")
       
       
    2: class GNUWriteTest(unittest.TestCase):
           # This testcase checks for correct creation of GNU Longname
           # and Longlink extended headers (cp. bug #812325).
       
    1:     def _length(self, s):
   12:         blocks, remainder = divmod(len(s) + 1, 512)
   12:         if remainder:
    8:             blocks += 1
   12:         return blocks * 512
       
    1:     def _calc_size(self, name, link=None):
               # Initial tar header
    9:         count = 512
       
    9:         if len(name) > tarfile.LENGTH_NAME:
                   # GNU longname extended header + longname
    6:             count += 512
    6:             count += self._length(name)
    9:         if link is not None and len(link) > tarfile.LENGTH_LINK:
                   # GNU longlink extended header + longlink
    6:             count += 512
    6:             count += self._length(link)
    9:         return count
       
    1:     def _test(self, name, link=None):
    9:         tarinfo = tarfile.TarInfo(name)
    9:         if link:
    6:             tarinfo.linkname = link
    6:             tarinfo.type = tarfile.LNKTYPE
       
    9:         tar = tarfile.open(tmpname, "w")
    9:         try:
    9:             tar.format = tarfile.GNU_FORMAT
    9:             tar.addfile(tarinfo)
       
    9:             v1 = self._calc_size(name, link)
    9:             v2 = tar.offset
    9:             self.assertTrue(v1 == v2, "GNU longname/longlink creation failed")
               finally:
    9:             tar.close()
       
    9:         tar = tarfile.open(tmpname)
    9:         try:
    9:             member = tar.next()
    9:             self.assertIsNotNone(member,
    9:                     "unable to read longname member")
    9:             self.assertEqual(tarinfo.name, member.name,
    9:                     "unable to read longname member")
    9:             self.assertEqual(tarinfo.linkname, member.linkname,
    9:                     "unable to read longname member")
               finally:
    9:             tar.close()
       
    1:     def test_longname_1023(self):
    2:         self._test(("longnam/" * 127) + "longnam")
       
    1:     def test_longname_1024(self):
    2:         self._test(("longnam/" * 127) + "longname")
       
    1:     def test_longname_1025(self):
    2:         self._test(("longnam/" * 127) + "longname_")
       
    1:     def test_longlink_1023(self):
    2:         self._test("name", ("longlnk/" * 127) + "longlnk")
       
    1:     def test_longlink_1024(self):
    2:         self._test("name", ("longlnk/" * 127) + "longlink")
       
    1:     def test_longlink_1025(self):
    2:         self._test("name", ("longlnk/" * 127) + "longlink_")
       
    1:     def test_longnamelink_1023(self):
    2:         self._test(("longnam/" * 127) + "longnam",
    2:                    ("longlnk/" * 127) + "longlnk")
       
    1:     def test_longnamelink_1024(self):
    2:         self._test(("longnam/" * 127) + "longname",
    2:                    ("longlnk/" * 127) + "longlink")
       
    1:     def test_longnamelink_1025(self):
    2:         self._test(("longnam/" * 127) + "longname_",
    2:                    ("longlnk/" * 127) + "longlink_")
       
       
    2: class HardlinkTest(unittest.TestCase):
           # Test the creation of LNKTYPE (hardlink) members in an archive.
       
    1:     def setUp(self):
    3:         self.foo = os.path.join(TEMPDIR, "foo")
    3:         self.bar = os.path.join(TEMPDIR, "bar")
       
    3:         with open(self.foo, "wb") as fobj:
    3:             fobj.write("foo")
       
    3:         os.link(self.foo, self.bar)
       
    3:         self.tar = tarfile.open(tmpname, "w")
    3:         self.tar.add(self.foo)
       
    1:     def tearDown(self):
    3:         self.tar.close()
    3:         support.unlink(self.foo)
    3:         support.unlink(self.bar)
       
    1:     def test_add_twice(self):
               # The same name will be added as a REGTYPE every
               # time regardless of st_nlink.
    1:         tarinfo = self.tar.gettarinfo(self.foo)
    1:         self.assertTrue(tarinfo.type == tarfile.REGTYPE,
    1:                 "add file as regular failed")
       
    1:     def test_add_hardlink(self):
    1:         tarinfo = self.tar.gettarinfo(self.bar)
    1:         self.assertTrue(tarinfo.type == tarfile.LNKTYPE,
    1:                 "add file as hardlink failed")
       
    1:     def test_dereference_hardlink(self):
    1:         self.tar.dereference = True
    1:         tarinfo = self.tar.gettarinfo(self.bar)
    1:         self.assertTrue(tarinfo.type == tarfile.REGTYPE,
    1:                 "dereferencing hardlink failed")
       
       
    2: class PaxWriteTest(GNUWriteTest):
       
    1:     def _test(self, name, link=None):
               # See GNUWriteTest.
    9:         tarinfo = tarfile.TarInfo(name)
    9:         if link:
    6:             tarinfo.linkname = link
    6:             tarinfo.type = tarfile.LNKTYPE
       
    9:         tar = tarfile.open(tmpname, "w", format=tarfile.PAX_FORMAT)
    9:         try:
    9:             tar.addfile(tarinfo)
               finally:
    9:             tar.close()
       
    9:         tar = tarfile.open(tmpname)
    9:         try:
    9:             if link:
    6:                 l = tar.getmembers()[0].linkname
    6:                 self.assertTrue(link == l, "PAX longlink creation failed")
                   else:
    3:                 n = tar.getmembers()[0].name
    3:                 self.assertTrue(name == n, "PAX longname creation failed")
               finally:
    9:             tar.close()
       
    1:     def test_pax_global_header(self):
    1:         pax_headers = {
    1:                 u"foo": u"bar",
    1:                 u"uid": u"0",
    1:                 u"mtime": u"1.23",
    1:                 u"test": u"\xe4\xf6\xfc",
    1:                 u"\xe4\xf6\xfc": u"test"}
       
    1:         tar = tarfile.open(tmpname, "w", format=tarfile.PAX_FORMAT,
    1:                 pax_headers=pax_headers)
    1:         try:
    1:             tar.addfile(tarfile.TarInfo("test"))
               finally:
    1:             tar.close()
       
               # Test if the global header was written correctly.
    1:         tar = tarfile.open(tmpname, encoding="iso8859-1")
    1:         try:
    1:             self.assertEqual(tar.pax_headers, pax_headers)
    1:             self.assertEqual(tar.getmembers()[0].pax_headers, pax_headers)
       
                   # Test if all the fields are unicode.
    6:             for key, val in tar.pax_headers.iteritems():
    5:                 self.assertTrue(type(key) is unicode)
    5:                 self.assertTrue(type(val) is unicode)
    5:                 if key in tarfile.PAX_NUMBER_FIELDS:
    2:                     try:
    2:                         tarfile.PAX_NUMBER_FIELDS[key](val)
>>>>>>                     except (TypeError, ValueError):
>>>>>>                         self.fail("unable to convert pax header field")
               finally:
    1:             tar.close()
       
    1:     def test_pax_extended_header(self):
               # The fields from the pax header have priority over the
               # TarInfo.
    1:         pax_headers = {u"path": u"foo", u"uid": u"123"}
       
    1:         tar = tarfile.open(tmpname, "w", format=tarfile.PAX_FORMAT, encoding="iso8859-1")
    1:         try:
    1:             t = tarfile.TarInfo()
    1:             t.name = u"\xe4\xf6\xfc"     # non-ASCII
    1:             t.uid = 8**8        # too large
    1:             t.pax_headers = pax_headers
    1:             tar.addfile(t)
               finally:
    1:             tar.close()
       
    1:         tar = tarfile.open(tmpname, encoding="iso8859-1")
    1:         try:
    1:             t = tar.getmembers()[0]
    1:             self.assertEqual(t.pax_headers, pax_headers)
    1:             self.assertEqual(t.name, "foo")
    1:             self.assertEqual(t.uid, 123)
               finally:
    1:             tar.close()
       
       
    2: class UstarUnicodeTest(unittest.TestCase):
           # All *UnicodeTests FIXME
       
    1:     format = tarfile.USTAR_FORMAT
       
    1:     def test_iso8859_1_filename(self):
    3:         self._test_unicode_filename("iso8859-1")
       
    1:     def test_utf7_filename(self):
    3:         self._test_unicode_filename("utf7")
       
    1:     def test_utf8_filename(self):
    3:         self._test_unicode_filename("utf8")
       
    1:     def _test_unicode_filename(self, encoding):
    9:         tar = tarfile.open(tmpname, "w", format=self.format, encoding=encoding, errors="strict")
    9:         try:
    9:             name = u"\xe4\xf6\xfc"
    9:             tar.addfile(tarfile.TarInfo(name))
               finally:
    9:             tar.close()
       
    9:         tar = tarfile.open(tmpname, encoding=encoding)
    9:         try:
    9:             self.assertTrue(type(tar.getnames()[0]) is not unicode)
    9:             self.assertEqual(tar.getmembers()[0].name, name.encode(encoding))
               finally:
    9:             tar.close()
       
    1:     def test_unicode_filename_error(self):
    3:         tar = tarfile.open(tmpname, "w", format=self.format, encoding="ascii", errors="strict")
    3:         try:
    3:             tarinfo = tarfile.TarInfo()
       
    3:             tarinfo.name = "\xe4\xf6\xfc"
    3:             if self.format == tarfile.PAX_FORMAT:
    1:                 self.assertRaises(UnicodeError, tar.addfile, tarinfo)
                   else:
    2:                 tar.addfile(tarinfo)
       
    3:             tarinfo.name = u"\xe4\xf6\xfc"
    3:             self.assertRaises(UnicodeError, tar.addfile, tarinfo)
       
    3:             tarinfo.name = "foo"
    3:             tarinfo.uname = u"\xe4\xf6\xfc"
    3:             self.assertRaises(UnicodeError, tar.addfile, tarinfo)
               finally:
    3:             tar.close()
       
    1:     def test_unicode_argument(self):
    3:         tar = tarfile.open(tarname, "r", encoding="iso8859-1", errors="strict")
    3:         try:
  102:             for t in tar:
   99:                 self.assertTrue(type(t.name) is str)
   99:                 self.assertTrue(type(t.linkname) is str)
   99:                 self.assertTrue(type(t.uname) is str)
   99:                 self.assertTrue(type(t.gname) is str)
               finally:
    3:             tar.close()
       
    1:     def test_uname_unicode(self):
    9:         for name in (u"\xe4\xf6\xfc", "\xe4\xf6\xfc"):
    6:             t = tarfile.TarInfo("foo")
    6:             t.uname = name
    6:             t.gname = name
       
    6:             fobj = StringIO.StringIO()
    6:             tar = tarfile.open("foo.tar", mode="w", fileobj=fobj, format=self.format, encoding="iso8859-1")
    6:             try:
    6:                 tar.addfile(t)
                   finally:
    6:                 tar.close()
    6:             fobj.seek(0)
       
    6:             tar = tarfile.open("foo.tar", fileobj=fobj, encoding="iso8859-1")
    6:             t = tar.getmember("foo")
    6:             self.assertEqual(t.uname, "\xe4\xf6\xfc")
    6:             self.assertEqual(t.gname, "\xe4\xf6\xfc")
       
       
    2: class GNUUnicodeTest(UstarUnicodeTest):
       
    1:     format = tarfile.GNU_FORMAT
       
       
    2: class PaxUnicodeTest(UstarUnicodeTest):
       
    1:     format = tarfile.PAX_FORMAT
       
    1:     def _create_unicode_name(self, name):
    2:         tar = tarfile.open(tmpname, "w", format=self.format)
    2:         t = tarfile.TarInfo()
    2:         t.pax_headers["path"] = name
    2:         tar.addfile(t)
    2:         tar.close()
       
    1:     def test_error_handlers(self):
               # Test if the unicode error handlers work correctly for characters
               # that cannot be expressed in a given encoding.
    1:         self._create_unicode_name(u"\xe4\xf6\xfc")
       
    1:         for handler, name in (("utf-8", u"\xe4\xf6\xfc".encode("utf8")),
    4:                     ("replace", "???"), ("ignore", "")):
    3:             tar = tarfile.open(tmpname, format=self.format, encoding="ascii",
    3:                     errors=handler)
    3:             self.assertEqual(tar.getnames()[0], name)
       
    1:         self.assertRaises(UnicodeError, tarfile.open, tmpname,
    1:                 encoding="ascii", errors="strict")
       
    1:     def test_error_handler_utf8(self):
               # Create a pathname that has one component representable using
               # iso8859-1 and the other only in iso8859-15.
    1:         self._create_unicode_name(u"\xe4\xf6\xfc/\u20ac")
       
    1:         tar = tarfile.open(tmpname, format=self.format, encoding="iso8859-1",
    1:                 errors="utf-8")
    1:         self.assertEqual(tar.getnames()[0], "\xe4\xf6\xfc/" + u"\u20ac".encode("utf8"))
       
       
    2: class AppendTest(unittest.TestCase):
           # Test append mode (cp. patch #1652681).
       
    1:     def setUp(self):
   12:         self.tarname = tmpname
   12:         if os.path.exists(self.tarname):
   11:             os.remove(self.tarname)
       
    1:     def _add_testfile(self, fileobj=None):
   10:         with tarfile.open(self.tarname, "a", fileobj=fileobj) as tar:
    5:             tar.addfile(tarfile.TarInfo("bar"))
       
    1:     def _create_testtar(self, mode="w:"):
    4:         with tarfile.open(tarname, encoding="iso8859-1") as src:
    4:             t = src.getmember("ustar/regtype")
    4:             t.name = "foo"
    4:             f = src.extractfile(t)
    4:             with tarfile.open(self.tarname, mode) as tar:
    4:                 tar.addfile(t, f)
       
    1:     def _test(self, names=["bar"], fileobj=None):
    5:         with tarfile.open(self.tarname, fileobj=fileobj) as tar:
    5:             self.assertEqual(tar.getnames(), names)
       
    1:     def test_non_existing(self):
    1:         self._add_testfile()
    1:         self._test()
       
    1:     def test_empty(self):
    1:         tarfile.open(self.tarname, "w:").close()
    1:         self._add_testfile()
    1:         self._test()
       
    1:     def test_empty_fileobj(self):
    1:         fobj = StringIO.StringIO("\0" * 1024)
    1:         self._add_testfile(fobj)
    1:         fobj.seek(0)
    1:         self._test(fileobj=fobj)
       
    1:     def test_fileobj(self):
    1:         self._create_testtar()
    1:         with open(self.tarname) as fobj:
    1:             data = fobj.read()
    1:         fobj = StringIO.StringIO(data)
    1:         self._add_testfile(fobj)
    1:         fobj.seek(0)
    1:         self._test(names=["foo", "bar"], fileobj=fobj)
       
    1:     def test_existing(self):
    1:         self._create_testtar()
    1:         self._add_testfile()
    1:         self._test(names=["foo", "bar"])
       
    1:     @unittest.skipUnless(gzip, 'requires gzip')
           def test_append_gz(self):
    1:         self._create_testtar("w:gz")
    1:         self.assertRaises(tarfile.ReadError, tarfile.open, tmpname, "a")
       
    1:     @unittest.skipUnless(bz2, 'requires bz2')
           def test_append_bz2(self):
    1:         self._create_testtar("w:bz2")
    1:         self.assertRaises(tarfile.ReadError, tarfile.open, tmpname, "a")
       
           # Append mode is supposed to fail if the tarfile to append to
           # does not end with a zero block.
    1:     def _test_error(self, data):
    5:         with open(self.tarname, "wb") as fobj:
    5:             fobj.write(data)
    5:         self.assertRaises(tarfile.ReadError, self._add_testfile)
       
    1:     def test_null(self):
    1:         self._test_error("")
       
    1:     def test_incomplete(self):
    1:         self._test_error("\0" * 13)
       
    1:     def test_premature_eof(self):
    1:         data = tarfile.TarInfo("foo").tobuf()
    1:         self._test_error(data)
       
    1:     def test_trailing_garbage(self):
    1:         data = tarfile.TarInfo("foo").tobuf()
    1:         self._test_error(data + "\0" * 13)
       
    1:     def test_invalid(self):
    1:         self._test_error("a" * 512)
       
       
    2: class LimitsTest(unittest.TestCase):
       
    1:     def test_ustar_limits(self):
               # 100 char name
    1:         tarinfo = tarfile.TarInfo("0123456789" * 10)
    1:         tarinfo.tobuf(tarfile.USTAR_FORMAT)
       
               # 101 char name that cannot be stored
    1:         tarinfo = tarfile.TarInfo("0123456789" * 10 + "0")
    1:         self.assertRaises(ValueError, tarinfo.tobuf, tarfile.USTAR_FORMAT)
       
               # 256 char name with a slash at pos 156
    1:         tarinfo = tarfile.TarInfo("123/" * 62 + "longname")
    1:         tarinfo.tobuf(tarfile.USTAR_FORMAT)
       
               # 256 char name that cannot be stored
    1:         tarinfo = tarfile.TarInfo("1234567/" * 31 + "longname")
    1:         self.assertRaises(ValueError, tarinfo.tobuf, tarfile.USTAR_FORMAT)
       
               # 512 char name
    1:         tarinfo = tarfile.TarInfo("123/" * 126 + "longname")
    1:         self.assertRaises(ValueError, tarinfo.tobuf, tarfile.USTAR_FORMAT)
       
               # 512 char linkname
    1:         tarinfo = tarfile.TarInfo("longlink")
    1:         tarinfo.linkname = "123/" * 126 + "longname"
    1:         self.assertRaises(ValueError, tarinfo.tobuf, tarfile.USTAR_FORMAT)
       
               # uid > 8 digits
    1:         tarinfo = tarfile.TarInfo("name")
    1:         tarinfo.uid = 010000000
    1:         self.assertRaises(ValueError, tarinfo.tobuf, tarfile.USTAR_FORMAT)
       
    1:     def test_gnu_limits(self):
    1:         tarinfo = tarfile.TarInfo("123/" * 126 + "longname")
    1:         tarinfo.tobuf(tarfile.GNU_FORMAT)
       
    1:         tarinfo = tarfile.TarInfo("longlink")
    1:         tarinfo.linkname = "123/" * 126 + "longname"
    1:         tarinfo.tobuf(tarfile.GNU_FORMAT)
       
               # uid >= 256 ** 7
    1:         tarinfo = tarfile.TarInfo("name")
    1:         tarinfo.uid = 04000000000000000000L
    1:         self.assertRaises(ValueError, tarinfo.tobuf, tarfile.GNU_FORMAT)
       
    1:     def test_pax_limits(self):
    1:         tarinfo = tarfile.TarInfo("123/" * 126 + "longname")
    1:         tarinfo.tobuf(tarfile.PAX_FORMAT)
       
    1:         tarinfo = tarfile.TarInfo("longlink")
    1:         tarinfo.linkname = "123/" * 126 + "longname"
    1:         tarinfo.tobuf(tarfile.PAX_FORMAT)
       
    1:         tarinfo = tarfile.TarInfo("name")
    1:         tarinfo.uid = 04000000000000000000L
    1:         tarinfo.tobuf(tarfile.PAX_FORMAT)
       
       
    2: class MiscTest(unittest.TestCase):
       
    1:     def test_read_number_fields(self):
               # Issue 24514: Test if empty number fields are converted to zero.
    1:         self.assertEqual(tarfile.nti("\0"), 0)
    1:         self.assertEqual(tarfile.nti("       \0"), 0)
       
       
    2: class ContextManagerTest(unittest.TestCase):
       
    1:     def test_basic(self):
    1:         with tarfile.open(tarname) as tar:
    1:             self.assertFalse(tar.closed, "closed inside runtime context")
    1:         self.assertTrue(tar.closed, "context manager failed")
       
    1:     def test_closed(self):
               # The __enter__() method is supposed to raise IOError
               # if the TarFile object is already closed.
    1:         tar = tarfile.open(tarname)
    1:         tar.close()
    1:         with self.assertRaises(IOError):
    1:             with tar:
>>>>>>                 pass
       
    1:     def test_exception(self):
               # Test if the IOError exception is passed through properly.
    1:         with self.assertRaises(Exception) as exc:
    1:             with tarfile.open(tarname) as tar:
    1:                 raise IOError
    1:         self.assertIsInstance(exc.exception, IOError,
    1:                               "wrong exception raised in context manager")
    1:         self.assertTrue(tar.closed, "context manager failed")
       
    1:     def test_no_eof(self):
               # __exit__() must not write end-of-archive blocks if an
               # exception was raised.
    1:         try:
    1:             with tarfile.open(tmpname, "w") as tar:
    1:                 raise Exception
    1:         except:
    1:             pass
    1:         self.assertEqual(os.path.getsize(tmpname), 0,
    1:                 "context manager wrote an end-of-archive block")
    1:         self.assertTrue(tar.closed, "context manager failed")
       
    1:     def test_eof(self):
               # __exit__() must write end-of-archive blocks, i.e. call
               # TarFile.close() if there was no error.
    1:         with tarfile.open(tmpname, "w"):
    1:             pass
    1:         self.assertNotEqual(os.path.getsize(tmpname), 0,
    1:                 "context manager wrote no end-of-archive block")
       
    1:     def test_fileobj(self):
               # Test that __exit__() did not close the external file
               # object.
    1:         with open(tmpname, "wb") as fobj:
    1:             try:
    1:                 with tarfile.open(fileobj=fobj, mode="w") as tar:
    1:                     raise Exception
    1:             except:
    1:                 pass
    1:             self.assertFalse(fobj.closed, "external file object was closed")
    1:             self.assertTrue(tar.closed, "context manager failed")
       
       
    2: class LinkEmulationTest(ReadTest):
       
           # Test for issue #8741 regression. On platforms that do not support
           # symbolic or hard links tarfile tries to extract these types of members as
           # the regular files they point to.
    1:     def _test_link_extraction(self, name):
>>>>>>         self.tar.extract(name, TEMPDIR)
>>>>>>         data = open(os.path.join(TEMPDIR, name), "rb").read()
>>>>>>         self.assertEqual(md5sum(data), md5_regtype)
       
    1:     def test_hardlink_extraction1(self):
>>>>>>         self._test_link_extraction("ustar/lnktype")
       
    1:     def test_hardlink_extraction2(self):
>>>>>>         self._test_link_extraction("./ustar/linktest2/lnktype")
       
    1:     def test_symlink_extraction1(self):
>>>>>>         self._test_link_extraction("ustar/symtype")
       
    1:     def test_symlink_extraction2(self):
>>>>>>         self._test_link_extraction("./ustar/linktest2/symtype")
       
       
    2: class GzipMiscReadTest(MiscReadTest):
    1:     tarname = gzipname
    1:     mode = "r:gz"
    1:     taropen = tarfile.TarFile.gzopen
    2: class GzipUstarReadTest(UstarReadTest):
    1:     tarname = gzipname
    1:     mode = "r:gz"
    2: class GzipStreamReadTest(StreamReadTest):
    1:     tarname = gzipname
    1:     mode = "r|gz"
    2: class GzipWriteTest(WriteTest):
    1:     mode = "w:gz"
    2: class GzipStreamWriteTest(StreamWriteTest):
    1:     mode = "w|gz"
       
       
    2: class Bz2MiscReadTest(MiscReadTest):
    1:     tarname = bz2name
    1:     mode = "r:bz2"
    1:     taropen = tarfile.TarFile.bz2open
    2: class Bz2UstarReadTest(UstarReadTest):
    1:     tarname = bz2name
    1:     mode = "r:bz2"
    2: class Bz2StreamReadTest(StreamReadTest):
    1:     tarname = bz2name
    1:     mode = "r|bz2"
    2: class Bz2WriteTest(WriteTest):
    1:     mode = "w:bz2"
    2: class Bz2StreamWriteTest(StreamWriteTest):
    1:     mode = "w|bz2"
       
    2: class Bz2PartialReadTest(unittest.TestCase):
           # Issue5068: The _BZ2Proxy.read() method loops forever
           # on an empty or partial bzipped file.
       
    1:     def _test_partial_input(self, mode):
    4:         class MyStringIO(StringIO.StringIO):
    2:             hit_eof = False
    2:             def read(self, n):
  492:                 if self.hit_eof:
>>>>>>                     raise AssertionError("infinite loop detected in tarfile.open()")
  492:                 self.hit_eof = self.pos == self.len
  492:                 return StringIO.StringIO.read(self, n)
    2:             def seek(self, *args):
  593:                 self.hit_eof = False
  593:                 return StringIO.StringIO.seek(self, *args)
       
    2:         data = bz2.compress(tarfile.TarInfo("foo").tobuf())
  178:         for x in range(len(data) + 1):
  176:             try:
  176:                 tarfile.open(fileobj=MyStringIO(data[:x]), mode=mode)
  154:             except tarfile.ReadError:
  154:                 pass # we have no interest in ReadErrors
       
    1:     def test_partial_input(self):
    1:         self._test_partial_input("r")
       
    1:     def test_partial_input_bz2(self):
    1:         self._test_partial_input("r:bz2")
       
       
    1: def test_main():
    1:     support.unlink(TEMPDIR)
    1:     os.makedirs(TEMPDIR)
       
           tests = [
    1:         UstarReadTest,
    1:         MiscReadTest,
    1:         StreamReadTest,
    1:         DetectReadTest,
    1:         MemberReadTest,
    1:         GNUReadTest,
    1:         PaxReadTest,
    1:         ListTest,
    1:         WriteTest,
    1:         StreamWriteTest,
    1:         GNUWriteTest,
    1:         PaxWriteTest,
    1:         UstarUnicodeTest,
    1:         GNUUnicodeTest,
    1:         PaxUnicodeTest,
    1:         AppendTest,
    1:         LimitsTest,
    1:         MiscTest,
    1:         ContextManagerTest,
           ]
       
    1:     if hasattr(os, "link"):
    1:         tests.append(HardlinkTest)
           else:
>>>>>>         tests.append(LinkEmulationTest)
       
    1:     with open(tarname, "rb") as fobj:
    1:         data = fobj.read()
       
    1:     if gzip:
               # Create testtar.tar.gz and add gzip-specific tests.
    1:         support.unlink(gzipname)
    1:         with gzip.open(gzipname, "wb") as tar:
    1:             tar.write(data)
       
    1:         tests += [
    1:             GzipMiscReadTest,
    1:             GzipUstarReadTest,
    1:             GzipStreamReadTest,
    1:             GzipListTest,
    1:             GzipWriteTest,
    1:             GzipStreamWriteTest,
               ]
       
    1:     if bz2:
               # Create testtar.tar.bz2 and add bz2-specific tests.
    1:         support.unlink(bz2name)
    1:         tar = bz2.BZ2File(bz2name, "wb")
    1:         try:
    1:             tar.write(data)
               finally:
    1:             tar.close()
       
    1:         tests += [
    1:             Bz2MiscReadTest,
    1:             Bz2UstarReadTest,
    1:             Bz2StreamReadTest,
    1:             Bz2ListTest,
    1:             Bz2WriteTest,
    1:             Bz2StreamWriteTest,
    1:             Bz2PartialReadTest,
               ]
       
    1:     try:
    1:         test_support.run_unittest(*tests)
           finally:
    1:         if os.path.exists(TEMPDIR):
    1:             shutil.rmtree(TEMPDIR)
       
    1: if __name__ == "__main__":
>>>>>>     test_main()
