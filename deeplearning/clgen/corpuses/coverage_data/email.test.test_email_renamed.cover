       # Copyright (C) 2001-2007 Python Software Foundation
       # Contact: email-sig@python.org
       # email package unit tests
       
    1: import os
    1: import sys
    1: import time
    1: import base64
    1: import difflib
    1: import unittest
    1: import warnings
    1: from cStringIO import StringIO
       
    1: import email
       
    1: from email.charset import Charset
    1: from email.header import Header, decode_header, make_header
    1: from email.parser import Parser, HeaderParser
    1: from email.generator import Generator, DecodedGenerator
    1: from email.message import Message
    1: from email.mime.application import MIMEApplication
    1: from email.mime.audio import MIMEAudio
    1: from email.mime.text import MIMEText
    1: from email.mime.image import MIMEImage
    1: from email.mime.base import MIMEBase
    1: from email.mime.message import MIMEMessage
    1: from email.mime.multipart import MIMEMultipart
    1: from email import utils
    1: from email import errors
    1: from email import encoders
    1: from email import iterators
    1: from email import base64mime
    1: from email import quoprimime
       
    1: from test.test_support import findfile, run_unittest
    1: from email.test import __file__ as landmark
       
       
    1: NL = '\n'
    1: EMPTYSTRING = ''
    1: SPACE = ' '
       
       
       
    1: def openfile(filename, mode='r'):
  238:     path = os.path.join(os.path.dirname(landmark), 'data', filename)
  238:     return open(path, mode)
       
       
       
       # Base test class
    2: class TestEmailBase(unittest.TestCase):
    1:     def ndiffAssertEqual(self, first, second):
               """Like assertEqual except use ndiff for readable output."""
  160:         if first != second:
>>>>>>             sfirst = str(first)
>>>>>>             ssecond = str(second)
>>>>>>             diff = difflib.ndiff(sfirst.splitlines(), ssecond.splitlines())
>>>>>>             fp = StringIO()
>>>>>>             print >> fp, NL, NL.join(diff)
>>>>>>             raise self.failureException, fp.getvalue()
       
    1:     def _msgobj(self, filename):
  102:         fp = openfile(findfile(filename))
  102:         try:
  102:             msg = email.message_from_file(fp)
               finally:
  102:             fp.close()
  102:         return msg
       
       
       
       # Test various aspects of the Message class's API
    2: class TestMessageAPI(TestEmailBase):
    1:     def test_get_all(self):
    2:         eq = self.assertEqual
    2:         msg = self._msgobj('msg_20.txt')
    2:         eq(msg.get_all('cc'), ['ccc@zzz.org', 'ddd@zzz.org', 'eee@zzz.org'])
    2:         eq(msg.get_all('xx', 'n/a'), 'n/a')
       
    1:     def test_getset_charset(self):
    2:         eq = self.assertEqual
    2:         msg = Message()
    2:         eq(msg.get_charset(), None)
    2:         charset = Charset('iso-8859-1')
    2:         msg.set_charset(charset)
    2:         eq(msg['mime-version'], '1.0')
    2:         eq(msg.get_content_type(), 'text/plain')
    2:         eq(msg['content-type'], 'text/plain; charset="iso-8859-1"')
    2:         eq(msg.get_param('charset'), 'iso-8859-1')
    2:         eq(msg['content-transfer-encoding'], 'quoted-printable')
    2:         eq(msg.get_charset().input_charset, 'iso-8859-1')
               # Remove the charset
    2:         msg.set_charset(None)
    2:         eq(msg.get_charset(), None)
    2:         eq(msg['content-type'], 'text/plain')
               # Try adding a charset when there's already MIME headers present
    2:         msg = Message()
    2:         msg['MIME-Version'] = '2.0'
    2:         msg['Content-Type'] = 'text/x-weird'
    2:         msg['Content-Transfer-Encoding'] = 'quinted-puntable'
    2:         msg.set_charset(charset)
    2:         eq(msg['mime-version'], '2.0')
    2:         eq(msg['content-type'], 'text/x-weird; charset="iso-8859-1"')
    2:         eq(msg['content-transfer-encoding'], 'quinted-puntable')
       
    1:     def test_set_charset_from_string(self):
    2:         eq = self.assertEqual
    2:         msg = Message()
    2:         msg.set_charset('us-ascii')
    2:         eq(msg.get_charset().input_charset, 'us-ascii')
    2:         eq(msg['content-type'], 'text/plain; charset="us-ascii"')
       
    1:     def test_set_payload_with_charset(self):
    2:         msg = Message()
    2:         charset = Charset('iso-8859-1')
    2:         msg.set_payload('This is a string payload', charset)
    2:         self.assertEqual(msg.get_charset().input_charset, 'iso-8859-1')
       
    1:     def test_get_charsets(self):
    2:         eq = self.assertEqual
       
    2:         msg = self._msgobj('msg_08.txt')
    2:         charsets = msg.get_charsets()
    2:         eq(charsets, [None, 'us-ascii', 'iso-8859-1', 'iso-8859-2', 'koi8-r'])
       
    2:         msg = self._msgobj('msg_09.txt')
    2:         charsets = msg.get_charsets('dingbat')
    2:         eq(charsets, ['dingbat', 'us-ascii', 'iso-8859-1', 'dingbat',
    2:                       'koi8-r'])
       
    2:         msg = self._msgobj('msg_12.txt')
    2:         charsets = msg.get_charsets()
    2:         eq(charsets, [None, 'us-ascii', 'iso-8859-1', None, 'iso-8859-2',
    2:                       'iso-8859-3', 'us-ascii', 'koi8-r'])
       
    1:     def test_get_filename(self):
    2:         eq = self.assertEqual
       
    2:         msg = self._msgobj('msg_04.txt')
    6:         filenames = [p.get_filename() for p in msg.get_payload()]
    2:         eq(filenames, ['msg.txt', 'msg.txt'])
       
    2:         msg = self._msgobj('msg_07.txt')
    2:         subpart = msg.get_payload(1)
    2:         eq(subpart.get_filename(), 'dingusfish.gif')
       
    1:     def test_get_filename_with_name_parameter(self):
    2:         eq = self.assertEqual
       
    2:         msg = self._msgobj('msg_44.txt')
    6:         filenames = [p.get_filename() for p in msg.get_payload()]
    2:         eq(filenames, ['msg.txt', 'msg.txt'])
       
    1:     def test_get_boundary(self):
    2:         eq = self.assertEqual
    2:         msg = self._msgobj('msg_07.txt')
               # No quotes!
    2:         eq(msg.get_boundary(), 'BOUNDARY')
       
    1:     def test_set_boundary(self):
    2:         eq = self.assertEqual
               # This one has no existing boundary parameter, but the Content-Type:
               # header appears fifth.
    2:         msg = self._msgobj('msg_01.txt')
    2:         msg.set_boundary('BOUNDARY')
    2:         header, value = msg.items()[4]
    2:         eq(header.lower(), 'content-type')
    2:         eq(value, 'text/plain; charset="us-ascii"; boundary="BOUNDARY"')
               # This one has a Content-Type: header, with a boundary, stuck in the
               # middle of its headers.  Make sure the order is preserved; it should
               # be fifth.
    2:         msg = self._msgobj('msg_04.txt')
    2:         msg.set_boundary('BOUNDARY')
    2:         header, value = msg.items()[4]
    2:         eq(header.lower(), 'content-type')
    2:         eq(value, 'multipart/mixed; boundary="BOUNDARY"')
               # And this one has no Content-Type: header at all.
    2:         msg = self._msgobj('msg_03.txt')
    2:         self.assertRaises(errors.HeaderParseError,
    2:                           msg.set_boundary, 'BOUNDARY')
       
    1:     def test_get_decoded_payload(self):
    2:         eq = self.assertEqual
    2:         msg = self._msgobj('msg_10.txt')
               # The outer message is a multipart
    2:         eq(msg.get_payload(decode=True), None)
               # Subpart 1 is 7bit encoded
    2:         eq(msg.get_payload(0).get_payload(decode=True),
    2:            'This is a 7bit encoded message.\n')
               # Subpart 2 is quopri
    2:         eq(msg.get_payload(1).get_payload(decode=True),
    2:            '\xa1This is a Quoted Printable encoded message!\n')
               # Subpart 3 is base64
    2:         eq(msg.get_payload(2).get_payload(decode=True),
    2:            'This is a Base64 encoded message.')
               # Subpart 4 is base64 with a trailing newline, which
               # used to be stripped (issue 7143).
    2:         eq(msg.get_payload(3).get_payload(decode=True),
    2:            'This is a Base64 encoded message.\n')
               # Subpart 5 has no Content-Transfer-Encoding: header.
    2:         eq(msg.get_payload(4).get_payload(decode=True),
    2:            'This has no Content-Transfer-Encoding: header.\n')
       
    1:     def test_get_decoded_uu_payload(self):
    2:         eq = self.assertEqual
    2:         msg = Message()
    2:         msg.set_payload('begin 666 -\n+:&5L;&\\@=V]R;&0 \n \nend\n')
   10:         for cte in ('x-uuencode', 'uuencode', 'uue', 'x-uue'):
    8:             msg['content-transfer-encoding'] = cte
    8:             eq(msg.get_payload(decode=True), 'hello world')
               # Now try some bogus data
    2:         msg.set_payload('foo')
    2:         eq(msg.get_payload(decode=True), 'foo')
       
    1:     def test_decoded_generator(self):
    2:         eq = self.assertEqual
    2:         msg = self._msgobj('msg_07.txt')
    2:         fp = openfile('msg_17.txt')
    2:         try:
    2:             text = fp.read()
               finally:
    2:             fp.close()
    2:         s = StringIO()
    2:         g = DecodedGenerator(s)
    2:         g.flatten(msg)
    2:         eq(s.getvalue(), text)
       
    1:     def test__contains__(self):
    2:         msg = Message()
    2:         msg['From'] = 'Me'
    2:         msg['to'] = 'You'
               # Check for case insensitivity
    2:         self.assertIn('from', msg)
    2:         self.assertIn('From', msg)
    2:         self.assertIn('FROM', msg)
    2:         self.assertIn('to', msg)
    2:         self.assertIn('To', msg)
    2:         self.assertIn('TO', msg)
       
    1:     def test_as_string(self):
    2:         eq = self.assertEqual
    2:         msg = self._msgobj('msg_01.txt')
    2:         fp = openfile('msg_01.txt')
    2:         try:
                   # BAW 30-Mar-2009 Evil be here.  So, the generator is broken with
                   # respect to long line breaking.  It's also not idempotent when a
                   # header from a parsed message is continued with tabs rather than
                   # spaces.  Before we fixed bug 1974 it was reversedly broken,
                   # i.e. headers that were continued with spaces got continued with
                   # tabs.  For Python 2.x there's really no good fix and in Python
                   # 3.x all this stuff is re-written to be right(er).  Chris Withers
                   # convinced me that using space as the default continuation
                   # character is less bad for more applications.
    2:             text = fp.read().replace('\t', ' ')
               finally:
    2:             fp.close()
    2:         self.ndiffAssertEqual(text, msg.as_string())
    2:         fullrepr = str(msg)
    2:         lines = fullrepr.split('\n')
    2:         self.assertTrue(lines[0].startswith('From '))
    2:         eq(text, NL.join(lines[1:]))
       
    1:     def test_bad_param(self):
    2:         msg = email.message_from_string("Content-Type: blarg; baz; boo\n")
    2:         self.assertEqual(msg.get_param('baz'), '')
       
    1:     def test_missing_filename(self):
    2:         msg = email.message_from_string("From: foo\n")
    2:         self.assertEqual(msg.get_filename(), None)
       
    1:     def test_bogus_filename(self):
    2:         msg = email.message_from_string(
    2:         "Content-Disposition: blarg; filename\n")
    2:         self.assertEqual(msg.get_filename(), '')
       
    1:     def test_missing_boundary(self):
    2:         msg = email.message_from_string("From: foo\n")
    2:         self.assertEqual(msg.get_boundary(), None)
       
    1:     def test_get_params(self):
    2:         eq = self.assertEqual
    2:         msg = email.message_from_string(
    2:             'X-Header: foo=one; bar=two; baz=three\n')
    2:         eq(msg.get_params(header='x-header'),
    2:            [('foo', 'one'), ('bar', 'two'), ('baz', 'three')])
    2:         msg = email.message_from_string(
    2:             'X-Header: foo; bar=one; baz=two\n')
    2:         eq(msg.get_params(header='x-header'),
    2:            [('foo', ''), ('bar', 'one'), ('baz', 'two')])
    2:         eq(msg.get_params(), None)
    2:         msg = email.message_from_string(
    2:             'X-Header: foo; bar="one"; baz=two\n')
    2:         eq(msg.get_params(header='x-header'),
    2:            [('foo', ''), ('bar', 'one'), ('baz', 'two')])
       
    1:     def test_get_param_liberal(self):
    2:         msg = Message()
    2:         msg['Content-Type'] = 'Content-Type: Multipart/mixed; boundary = "CPIMSSMTPC06p5f3tG"'
    2:         self.assertEqual(msg.get_param('boundary'), 'CPIMSSMTPC06p5f3tG')
       
    1:     def test_get_param(self):
    2:         eq = self.assertEqual
    2:         msg = email.message_from_string(
    2:             "X-Header: foo=one; bar=two; baz=three\n")
    2:         eq(msg.get_param('bar', header='x-header'), 'two')
    2:         eq(msg.get_param('quuz', header='x-header'), None)
    2:         eq(msg.get_param('quuz'), None)
    2:         msg = email.message_from_string(
    2:             'X-Header: foo; bar="one"; baz=two\n')
    2:         eq(msg.get_param('foo', header='x-header'), '')
    2:         eq(msg.get_param('bar', header='x-header'), 'one')
    2:         eq(msg.get_param('baz', header='x-header'), 'two')
               # XXX: We are not RFC-2045 compliant!  We cannot parse:
               # msg["Content-Type"] = 'text/plain; weird="hey; dolly? [you] @ <\\"home\\">?"'
               # msg.get_param("weird")
               # yet.
       
    1:     def test_get_param_funky_continuation_lines(self):
    2:         msg = self._msgobj('msg_22.txt')
    2:         self.assertEqual(msg.get_payload(1).get_param('name'), 'wibble.JPG')
       
    1:     def test_get_param_with_semis_in_quotes(self):
    2:         msg = email.message_from_string(
    2:             'Content-Type: image/pjpeg; name="Jim&amp;&amp;Jill"\n')
    2:         self.assertEqual(msg.get_param('name'), 'Jim&amp;&amp;Jill')
    2:         self.assertEqual(msg.get_param('name', unquote=False),
    2:                          '"Jim&amp;&amp;Jill"')
       
    1:     def test_has_key(self):
    2:         msg = email.message_from_string('Header: exists')
    2:         self.assertTrue(msg.has_key('header'))
    2:         self.assertTrue(msg.has_key('Header'))
    2:         self.assertTrue(msg.has_key('HEADER'))
    2:         self.assertFalse(msg.has_key('headeri'))
       
    1:     def test_set_param(self):
    2:         eq = self.assertEqual
    2:         msg = Message()
    2:         msg.set_param('charset', 'iso-2022-jp')
    2:         eq(msg.get_param('charset'), 'iso-2022-jp')
    2:         msg.set_param('importance', 'high value')
    2:         eq(msg.get_param('importance'), 'high value')
    2:         eq(msg.get_param('importance', unquote=False), '"high value"')
    2:         eq(msg.get_params(), [('text/plain', ''),
    2:                               ('charset', 'iso-2022-jp'),
    2:                               ('importance', 'high value')])
    2:         eq(msg.get_params(unquote=False), [('text/plain', ''),
    2:                                        ('charset', '"iso-2022-jp"'),
    2:                                        ('importance', '"high value"')])
    2:         msg.set_param('charset', 'iso-9999-xx', header='X-Jimmy')
    2:         eq(msg.get_param('charset', header='X-Jimmy'), 'iso-9999-xx')
       
    1:     def test_del_param(self):
    2:         eq = self.assertEqual
    2:         msg = self._msgobj('msg_05.txt')
    2:         eq(msg.get_params(),
    2:            [('multipart/report', ''), ('report-type', 'delivery-status'),
    2:             ('boundary', 'D1690A7AC1.996856090/mail.example.com')])
    2:         old_val = msg.get_param("report-type")
    2:         msg.del_param("report-type")
    2:         eq(msg.get_params(),
    2:            [('multipart/report', ''),
    2:             ('boundary', 'D1690A7AC1.996856090/mail.example.com')])
    2:         msg.set_param("report-type", old_val)
    2:         eq(msg.get_params(),
    2:            [('multipart/report', ''),
    2:             ('boundary', 'D1690A7AC1.996856090/mail.example.com'),
    2:             ('report-type', old_val)])
       
    1:     def test_del_param_on_other_header(self):
    2:         msg = Message()
    2:         msg.add_header('Content-Disposition', 'attachment', filename='bud.gif')
    2:         msg.del_param('filename', 'content-disposition')
    2:         self.assertEqual(msg['content-disposition'], 'attachment')
       
    1:     def test_set_type(self):
    2:         eq = self.assertEqual
    2:         msg = Message()
    2:         self.assertRaises(ValueError, msg.set_type, 'text')
    2:         msg.set_type('text/plain')
    2:         eq(msg['content-type'], 'text/plain')
    2:         msg.set_param('charset', 'us-ascii')
    2:         eq(msg['content-type'], 'text/plain; charset="us-ascii"')
    2:         msg.set_type('text/html')
    2:         eq(msg['content-type'], 'text/html; charset="us-ascii"')
       
    1:     def test_set_type_on_other_header(self):
    2:         msg = Message()
    2:         msg['X-Content-Type'] = 'text/plain'
    2:         msg.set_type('application/octet-stream', 'X-Content-Type')
    2:         self.assertEqual(msg['x-content-type'], 'application/octet-stream')
       
    1:     def test_get_content_type_missing(self):
    2:         msg = Message()
    2:         self.assertEqual(msg.get_content_type(), 'text/plain')
       
    1:     def test_get_content_type_missing_with_default_type(self):
    2:         msg = Message()
    2:         msg.set_default_type('message/rfc822')
    2:         self.assertEqual(msg.get_content_type(), 'message/rfc822')
       
    1:     def test_get_content_type_from_message_implicit(self):
    2:         msg = self._msgobj('msg_30.txt')
    2:         self.assertEqual(msg.get_payload(0).get_content_type(),
    2:                          'message/rfc822')
       
    1:     def test_get_content_type_from_message_explicit(self):
    2:         msg = self._msgobj('msg_28.txt')
    2:         self.assertEqual(msg.get_payload(0).get_content_type(),
    2:                          'message/rfc822')
       
    1:     def test_get_content_type_from_message_text_plain_implicit(self):
    2:         msg = self._msgobj('msg_03.txt')
    2:         self.assertEqual(msg.get_content_type(), 'text/plain')
       
    1:     def test_get_content_type_from_message_text_plain_explicit(self):
    2:         msg = self._msgobj('msg_01.txt')
    2:         self.assertEqual(msg.get_content_type(), 'text/plain')
       
    1:     def test_get_content_maintype_missing(self):
    2:         msg = Message()
    2:         self.assertEqual(msg.get_content_maintype(), 'text')
       
    1:     def test_get_content_maintype_missing_with_default_type(self):
    2:         msg = Message()
    2:         msg.set_default_type('message/rfc822')
    2:         self.assertEqual(msg.get_content_maintype(), 'message')
       
    1:     def test_get_content_maintype_from_message_implicit(self):
    2:         msg = self._msgobj('msg_30.txt')
    2:         self.assertEqual(msg.get_payload(0).get_content_maintype(), 'message')
       
    1:     def test_get_content_maintype_from_message_explicit(self):
    2:         msg = self._msgobj('msg_28.txt')
    2:         self.assertEqual(msg.get_payload(0).get_content_maintype(), 'message')
       
    1:     def test_get_content_maintype_from_message_text_plain_implicit(self):
    2:         msg = self._msgobj('msg_03.txt')
    2:         self.assertEqual(msg.get_content_maintype(), 'text')
       
    1:     def test_get_content_maintype_from_message_text_plain_explicit(self):
    2:         msg = self._msgobj('msg_01.txt')
    2:         self.assertEqual(msg.get_content_maintype(), 'text')
       
    1:     def test_get_content_subtype_missing(self):
    2:         msg = Message()
    2:         self.assertEqual(msg.get_content_subtype(), 'plain')
       
    1:     def test_get_content_subtype_missing_with_default_type(self):
    2:         msg = Message()
    2:         msg.set_default_type('message/rfc822')
    2:         self.assertEqual(msg.get_content_subtype(), 'rfc822')
       
    1:     def test_get_content_subtype_from_message_implicit(self):
    2:         msg = self._msgobj('msg_30.txt')
    2:         self.assertEqual(msg.get_payload(0).get_content_subtype(), 'rfc822')
       
    1:     def test_get_content_subtype_from_message_explicit(self):
    2:         msg = self._msgobj('msg_28.txt')
    2:         self.assertEqual(msg.get_payload(0).get_content_subtype(), 'rfc822')
       
    1:     def test_get_content_subtype_from_message_text_plain_implicit(self):
    2:         msg = self._msgobj('msg_03.txt')
    2:         self.assertEqual(msg.get_content_subtype(), 'plain')
       
    1:     def test_get_content_subtype_from_message_text_plain_explicit(self):
    2:         msg = self._msgobj('msg_01.txt')
    2:         self.assertEqual(msg.get_content_subtype(), 'plain')
       
    1:     def test_get_content_maintype_error(self):
    2:         msg = Message()
    2:         msg['Content-Type'] = 'no-slash-in-this-string'
    2:         self.assertEqual(msg.get_content_maintype(), 'text')
       
    1:     def test_get_content_subtype_error(self):
    2:         msg = Message()
    2:         msg['Content-Type'] = 'no-slash-in-this-string'
    2:         self.assertEqual(msg.get_content_subtype(), 'plain')
       
    1:     def test_replace_header(self):
    2:         eq = self.assertEqual
    2:         msg = Message()
    2:         msg.add_header('First', 'One')
    2:         msg.add_header('Second', 'Two')
    2:         msg.add_header('Third', 'Three')
    2:         eq(msg.keys(), ['First', 'Second', 'Third'])
    2:         eq(msg.values(), ['One', 'Two', 'Three'])
    2:         msg.replace_header('Second', 'Twenty')
    2:         eq(msg.keys(), ['First', 'Second', 'Third'])
    2:         eq(msg.values(), ['One', 'Twenty', 'Three'])
    2:         msg.add_header('First', 'Eleven')
    2:         msg.replace_header('First', 'One Hundred')
    2:         eq(msg.keys(), ['First', 'Second', 'Third', 'First'])
    2:         eq(msg.values(), ['One Hundred', 'Twenty', 'Three', 'Eleven'])
    2:         self.assertRaises(KeyError, msg.replace_header, 'Fourth', 'Missing')
       
    1:     def test_broken_base64_payload(self):
    2:         x = 'AwDp0P7//y6LwKEAcPa/6Q=9'
    2:         msg = Message()
    2:         msg['content-type'] = 'audio/x-midi'
    2:         msg['content-transfer-encoding'] = 'base64'
    2:         msg.set_payload(x)
    2:         self.assertEqual(msg.get_payload(decode=True), x)
       
       
       
       # Test the email.encoders module
    2: class TestEncoders(unittest.TestCase):
    1:     def test_encode_empty_payload(self):
    2:         eq = self.assertEqual
    2:         msg = Message()
    2:         msg.set_charset('us-ascii')
    2:         eq(msg['content-transfer-encoding'], '7bit')
       
    1:     def test_default_cte(self):
>>>>>>         eq = self.assertEqual
>>>>>>         msg = MIMEText('hello world')
>>>>>>         eq(msg['content-transfer-encoding'], '7bit')
       
    1:     def test_default_cte(self):
    2:         eq = self.assertEqual
               # With no explicit _charset its us-ascii, and all are 7-bit
    2:         msg = MIMEText('hello world')
    2:         eq(msg['content-transfer-encoding'], '7bit')
               # Similar, but with 8-bit data
    2:         msg = MIMEText('hello \xf8 world')
    2:         eq(msg['content-transfer-encoding'], '8bit')
               # And now with a different charset
    2:         msg = MIMEText('hello \xf8 world', _charset='iso-8859-1')
    2:         eq(msg['content-transfer-encoding'], 'quoted-printable')
       
       
       
       # Test long header wrapping
    2: class TestLongHeaders(TestEmailBase):
    1:     def test_split_long_continuation(self):
    2:         eq = self.ndiffAssertEqual
    2:         msg = email.message_from_string("""\
       Subject: bug demonstration
       \t12345678911234567892123456789312345678941234567895123456789612345678971234567898112345678911234567892123456789112345678911234567892123456789
       \tmore text
       
       test
    2: """)
    2:         sfp = StringIO()
    2:         g = Generator(sfp)
    2:         g.flatten(msg)
    2:         eq(sfp.getvalue(), """\
       Subject: bug demonstration
        12345678911234567892123456789312345678941234567895123456789612345678971234567898112345678911234567892123456789112345678911234567892123456789
        more text
       
       test
    2: """)
       
    1:     def test_another_long_almost_unsplittable_header(self):
    2:         eq = self.ndiffAssertEqual
               hstr = """\
       bug demonstration
       \t12345678911234567892123456789312345678941234567895123456789612345678971234567898112345678911234567892123456789112345678911234567892123456789
    2: \tmore text"""
    2:         h = Header(hstr, continuation_ws='\t')
    2:         eq(h.encode(), """\
       bug demonstration
       \t12345678911234567892123456789312345678941234567895123456789612345678971234567898112345678911234567892123456789112345678911234567892123456789
    2: \tmore text""")
    2:         h = Header(hstr)
    2:         eq(h.encode(), """\
       bug demonstration
        12345678911234567892123456789312345678941234567895123456789612345678971234567898112345678911234567892123456789112345678911234567892123456789
    2:  more text""")
       
    1:     def test_long_nonstring(self):
    2:         eq = self.ndiffAssertEqual
    2:         g = Charset("iso-8859-1")
    2:         cz = Charset("iso-8859-2")
    2:         utf8 = Charset("utf-8")
    2:         g_head = "Die Mieter treten hier ein werden mit einem Foerderband komfortabel den Korridor entlang, an s\xfcdl\xfcndischen Wandgem\xe4lden vorbei, gegen die rotierenden Klingen bef\xf6rdert. "
    2:         cz_head = "Finan\xe8ni metropole se hroutily pod tlakem jejich d\xf9vtipu.. "
    2:         utf8_head = u"\u6b63\u78ba\u306b\u8a00\u3046\u3068\u7ffb\u8a33\u306f\u3055\u308c\u3066\u3044\u307e\u305b\u3093\u3002\u4e00\u90e8\u306f\u30c9\u30a4\u30c4\u8a9e\u3067\u3059\u304c\u3001\u3042\u3068\u306f\u3067\u305f\u3089\u3081\u3067\u3059\u3002\u5b9f\u969b\u306b\u306f\u300cWenn ist das Nunstuck git und Slotermeyer? Ja! Beiherhund das Oder die Flipperwaldt gersput.\u300d\u3068\u8a00\u3063\u3066\u3044\u307e\u3059\u3002".encode("utf-8")
    2:         h = Header(g_head, g, header_name='Subject')
    2:         h.append(cz_head, cz)
    2:         h.append(utf8_head, utf8)
    2:         msg = Message()
    2:         msg['Subject'] = h
    2:         sfp = StringIO()
    2:         g = Generator(sfp)
    2:         g.flatten(msg)
    2:         eq(sfp.getvalue(), """\
       Subject: =?iso-8859-1?q?Die_Mieter_treten_hier_ein_werden_mit_einem_Foerd?=
        =?iso-8859-1?q?erband_komfortabel_den_Korridor_entlang=2C_an_s=FCdl=FCndi?=
        =?iso-8859-1?q?schen_Wandgem=E4lden_vorbei=2C_gegen_die_rotierenden_Kling?=
        =?iso-8859-1?q?en_bef=F6rdert=2E_?= =?iso-8859-2?q?Finan=E8ni_met?=
        =?iso-8859-2?q?ropole_se_hroutily_pod_tlakem_jejich_d=F9vtipu=2E=2E_?=
        =?utf-8?b?5q2j56K644Gr6KiA44GG44Go57+76Kiz44Gv44GV44KM44Gm44GE?=
        =?utf-8?b?44G+44Gb44KT44CC5LiA6YOo44Gv44OJ44Kk44OE6Kqe44Gn44GZ44GM44CB?=
        =?utf-8?b?44GC44Go44Gv44Gn44Gf44KJ44KB44Gn44GZ44CC5a6f6Zqb44Gr44Gv44CM?=
        =?utf-8?q?Wenn_ist_das_Nunstuck_git_und_Slotermeyer=3F_Ja!_Beiherhund_das?=
        =?utf-8?b?IE9kZXIgZGllIEZsaXBwZXJ3YWxkdCBnZXJzcHV0LuOAjeOBqOiogOOBow==?=
        =?utf-8?b?44Gm44GE44G+44GZ44CC?=
       
    2: """)
    2:         eq(h.encode(), """\
       =?iso-8859-1?q?Die_Mieter_treten_hier_ein_werden_mit_einem_Foerd?=
        =?iso-8859-1?q?erband_komfortabel_den_Korridor_entlang=2C_an_s=FCdl=FCndi?=
        =?iso-8859-1?q?schen_Wandgem=E4lden_vorbei=2C_gegen_die_rotierenden_Kling?=
        =?iso-8859-1?q?en_bef=F6rdert=2E_?= =?iso-8859-2?q?Finan=E8ni_met?=
        =?iso-8859-2?q?ropole_se_hroutily_pod_tlakem_jejich_d=F9vtipu=2E=2E_?=
        =?utf-8?b?5q2j56K644Gr6KiA44GG44Go57+76Kiz44Gv44GV44KM44Gm44GE?=
        =?utf-8?b?44G+44Gb44KT44CC5LiA6YOo44Gv44OJ44Kk44OE6Kqe44Gn44GZ44GM44CB?=
        =?utf-8?b?44GC44Go44Gv44Gn44Gf44KJ44KB44Gn44GZ44CC5a6f6Zqb44Gr44Gv44CM?=
        =?utf-8?q?Wenn_ist_das_Nunstuck_git_und_Slotermeyer=3F_Ja!_Beiherhund_das?=
        =?utf-8?b?IE9kZXIgZGllIEZsaXBwZXJ3YWxkdCBnZXJzcHV0LuOAjeOBqOiogOOBow==?=
    2:  =?utf-8?b?44Gm44GE44G+44GZ44CC?=""")
       
    1:     def test_long_header_encode(self):
    2:         eq = self.ndiffAssertEqual
    2:         h = Header('wasnipoop; giraffes="very-long-necked-animals"; '
                          'spooge="yummy"; hippos="gargantuan"; marshmallows="gooey"',
    2:                    header_name='X-Foobar-Spoink-Defrobnit')
    2:         eq(h.encode(), '''\
       wasnipoop; giraffes="very-long-necked-animals";
    2:  spooge="yummy"; hippos="gargantuan"; marshmallows="gooey"''')
       
    1:     def test_long_header_encode_with_tab_continuation(self):
    2:         eq = self.ndiffAssertEqual
    2:         h = Header('wasnipoop; giraffes="very-long-necked-animals"; '
                          'spooge="yummy"; hippos="gargantuan"; marshmallows="gooey"',
    2:                    header_name='X-Foobar-Spoink-Defrobnit',
    2:                    continuation_ws='\t')
    2:         eq(h.encode(), '''\
       wasnipoop; giraffes="very-long-necked-animals";
    2: \tspooge="yummy"; hippos="gargantuan"; marshmallows="gooey"''')
       
    1:     def test_header_splitter(self):
    2:         eq = self.ndiffAssertEqual
    2:         msg = MIMEText('')
               # It'd be great if we could use add_header() here, but that doesn't
               # guarantee an order of the parameters.
               msg['X-Foobar-Spoink-Defrobnit'] = (
    2:             'wasnipoop; giraffes="very-long-necked-animals"; '
                   'spooge="yummy"; hippos="gargantuan"; marshmallows="gooey"')
    2:         sfp = StringIO()
    2:         g = Generator(sfp)
    2:         g.flatten(msg)
    2:         eq(sfp.getvalue(), '''\
       Content-Type: text/plain; charset="us-ascii"
       MIME-Version: 1.0
       Content-Transfer-Encoding: 7bit
       X-Foobar-Spoink-Defrobnit: wasnipoop; giraffes="very-long-necked-animals";
        spooge="yummy"; hippos="gargantuan"; marshmallows="gooey"
       
    2: ''')
       
    1:     def test_no_semis_header_splitter(self):
    2:         eq = self.ndiffAssertEqual
    2:         msg = Message()
    2:         msg['From'] = 'test@dom.ain'
   22:         msg['References'] = SPACE.join(['<%d@dom.ain>' % i for i in range(10)])
    2:         msg.set_payload('Test')
    2:         sfp = StringIO()
    2:         g = Generator(sfp)
    2:         g.flatten(msg)
    2:         eq(sfp.getvalue(), """\
       From: test@dom.ain
       References: <0@dom.ain> <1@dom.ain> <2@dom.ain> <3@dom.ain> <4@dom.ain>
        <5@dom.ain> <6@dom.ain> <7@dom.ain> <8@dom.ain> <9@dom.ain>
       
    2: Test""")
       
    1:     def test_no_split_long_header(self):
    2:         eq = self.ndiffAssertEqual
    2:         hstr = 'References: ' + 'x' * 80
    2:         h = Header(hstr, continuation_ws='\t')
    2:         eq(h.encode(), """\
    2: References: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx""")
       
    1:     def test_splitting_multiple_long_lines(self):
    2:         eq = self.ndiffAssertEqual
               hstr = """\
       from babylon.socal-raves.org (localhost [127.0.0.1]); by babylon.socal-raves.org (Postfix) with ESMTP id B570E51B81; for <mailman-admin@babylon.socal-raves.org>; Sat, 2 Feb 2002 17:00:06 -0800 (PST)
       \tfrom babylon.socal-raves.org (localhost [127.0.0.1]); by babylon.socal-raves.org (Postfix) with ESMTP id B570E51B81; for <mailman-admin@babylon.socal-raves.org>; Sat, 2 Feb 2002 17:00:06 -0800 (PST)
       \tfrom babylon.socal-raves.org (localhost [127.0.0.1]); by babylon.socal-raves.org (Postfix) with ESMTP id B570E51B81; for <mailman-admin@babylon.socal-raves.org>; Sat, 2 Feb 2002 17:00:06 -0800 (PST)
    2: """
    2:         h = Header(hstr, continuation_ws='\t')
    2:         eq(h.encode(), """\
       from babylon.socal-raves.org (localhost [127.0.0.1]);
       \tby babylon.socal-raves.org (Postfix) with ESMTP id B570E51B81;
       \tfor <mailman-admin@babylon.socal-raves.org>;
       \tSat, 2 Feb 2002 17:00:06 -0800 (PST)
       \tfrom babylon.socal-raves.org (localhost [127.0.0.1]);
       \tby babylon.socal-raves.org (Postfix) with ESMTP id B570E51B81;
       \tfor <mailman-admin@babylon.socal-raves.org>;
       \tSat, 2 Feb 2002 17:00:06 -0800 (PST)
       \tfrom babylon.socal-raves.org (localhost [127.0.0.1]);
       \tby babylon.socal-raves.org (Postfix) with ESMTP id B570E51B81;
       \tfor <mailman-admin@babylon.socal-raves.org>;
    2: \tSat, 2 Feb 2002 17:00:06 -0800 (PST)""")
       
    1:     def test_splitting_first_line_only_is_long(self):
    2:         eq = self.ndiffAssertEqual
               hstr = """\
       from modemcable093.139-201-24.que.mc.videotron.ca ([24.201.139.93] helo=cthulhu.gerg.ca)
       \tby kronos.mems-exchange.org with esmtp (Exim 4.05)
       \tid 17k4h5-00034i-00
    2: \tfor test@mems-exchange.org; Wed, 28 Aug 2002 11:25:20 -0400"""
    2:         h = Header(hstr, maxlinelen=78, header_name='Received',
    2:                    continuation_ws='\t')
    2:         eq(h.encode(), """\
       from modemcable093.139-201-24.que.mc.videotron.ca ([24.201.139.93]
       \thelo=cthulhu.gerg.ca)
       \tby kronos.mems-exchange.org with esmtp (Exim 4.05)
       \tid 17k4h5-00034i-00
    2: \tfor test@mems-exchange.org; Wed, 28 Aug 2002 11:25:20 -0400""")
       
    1:     def test_long_8bit_header(self):
    2:         eq = self.ndiffAssertEqual
    2:         msg = Message()
    2:         h = Header('Britische Regierung gibt', 'iso-8859-1',
    2:                     header_name='Subject')
    2:         h.append('gr\xfcnes Licht f\xfcr Offshore-Windkraftprojekte')
    2:         msg['Subject'] = h
    2:         eq(msg.as_string(), """\
       Subject: =?iso-8859-1?q?Britische_Regierung_gibt?= =?iso-8859-1?q?gr=FCnes?=
        =?iso-8859-1?q?_Licht_f=FCr_Offshore-Windkraftprojekte?=
       
    2: """)
       
    1:     def test_long_8bit_header_no_charset(self):
    2:         eq = self.ndiffAssertEqual
    2:         msg = Message()
    2:         msg['Reply-To'] = 'Britische Regierung gibt gr\xfcnes Licht f\xfcr Offshore-Windkraftprojekte <a-very-long-address@example.com>'
    2:         eq(msg.as_string(), """\
       Reply-To: Britische Regierung gibt gr\xfcnes Licht f\xfcr Offshore-Windkraftprojekte <a-very-long-address@example.com>
       
    2: """)
       
    1:     def test_long_to_header(self):
    2:         eq = self.ndiffAssertEqual
    2:         to = '"Someone Test #A" <someone@eecs.umich.edu>,<someone@eecs.umich.edu>,"Someone Test #B" <someone@umich.edu>, "Someone Test #C" <someone@eecs.umich.edu>, "Someone Test #D" <someone@eecs.umich.edu>'
    2:         msg = Message()
    2:         msg['To'] = to
    2:         eq(msg.as_string(0), '''\
       To: "Someone Test #A" <someone@eecs.umich.edu>, <someone@eecs.umich.edu>,
        "Someone Test #B" <someone@umich.edu>,
        "Someone Test #C" <someone@eecs.umich.edu>,
        "Someone Test #D" <someone@eecs.umich.edu>
       
    2: ''')
       
    1:     def test_long_line_after_append(self):
    2:         eq = self.ndiffAssertEqual
    2:         s = 'This is an example of string which has almost the limit of header length.'
    2:         h = Header(s)
    2:         h.append('Add another line.')
    2:         eq(h.encode(), """\
       This is an example of string which has almost the limit of header length.
    2:  Add another line.""")
       
    1:     def test_shorter_line_with_append(self):
    2:         eq = self.ndiffAssertEqual
    2:         s = 'This is a shorter line.'
    2:         h = Header(s)
    2:         h.append('Add another sentence. (Surprise?)')
    2:         eq(h.encode(),
    2:            'This is a shorter line. Add another sentence. (Surprise?)')
       
    1:     def test_long_field_name(self):
    2:         eq = self.ndiffAssertEqual
    2:         fn = 'X-Very-Very-Very-Long-Header-Name'
    2:         gs = "Die Mieter treten hier ein werden mit einem Foerderband komfortabel den Korridor entlang, an s\xfcdl\xfcndischen Wandgem\xe4lden vorbei, gegen die rotierenden Klingen bef\xf6rdert. "
    2:         h = Header(gs, 'iso-8859-1', header_name=fn)
               # BAW: this seems broken because the first line is too long
    2:         eq(h.encode(), """\
       =?iso-8859-1?q?Die_Mieter_treten_hier_?=
        =?iso-8859-1?q?ein_werden_mit_einem_Foerderband_komfortabel_den_Korridor_?=
        =?iso-8859-1?q?entlang=2C_an_s=FCdl=FCndischen_Wandgem=E4lden_vorbei=2C_g?=
    2:  =?iso-8859-1?q?egen_die_rotierenden_Klingen_bef=F6rdert=2E_?=""")
       
    1:     def test_long_received_header(self):
    2:         h = 'from FOO.TLD (vizworld.acl.foo.tld [123.452.678.9]) by hrothgar.la.mastaler.com (tmda-ofmipd) with ESMTP; Wed, 05 Mar 2003 18:10:18 -0700'
    2:         msg = Message()
    2:         msg['Received-1'] = Header(h, continuation_ws='\t')
    2:         msg['Received-2'] = h
    2:         self.ndiffAssertEqual(msg.as_string(), """\
       Received-1: from FOO.TLD (vizworld.acl.foo.tld [123.452.678.9]) by
       \throthgar.la.mastaler.com (tmda-ofmipd) with ESMTP;
       \tWed, 05 Mar 2003 18:10:18 -0700
       Received-2: from FOO.TLD (vizworld.acl.foo.tld [123.452.678.9]) by
        hrothgar.la.mastaler.com (tmda-ofmipd) with ESMTP;
        Wed, 05 Mar 2003 18:10:18 -0700
       
    2: """)
       
    1:     def test_string_headerinst_eq(self):
    2:         h = '<15975.17901.207240.414604@sgigritzmann1.mathematik.tu-muenchen.de> (David Bremner\'s message of "Thu, 6 Mar 2003 13:58:21 +0100")'
    2:         msg = Message()
    2:         msg['Received'] = Header(h, header_name='Received-1',
    2:                                  continuation_ws='\t')
    2:         msg['Received'] = h
    2:         self.ndiffAssertEqual(msg.as_string(), """\
       Received: <15975.17901.207240.414604@sgigritzmann1.mathematik.tu-muenchen.de>
       \t(David Bremner's message of "Thu, 6 Mar 2003 13:58:21 +0100")
       Received: <15975.17901.207240.414604@sgigritzmann1.mathematik.tu-muenchen.de>
        (David Bremner's message of "Thu, 6 Mar 2003 13:58:21 +0100")
       
    2: """)
       
    1:     def test_long_unbreakable_lines_with_continuation(self):
    2:         eq = self.ndiffAssertEqual
    2:         msg = Message()
               t = """\
        iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAAGFBMVEUAAAAkHiJeRUIcGBi9
    2:  locQDQ4zJykFBAXJfWDjAAACYUlEQVR4nF2TQY/jIAyFc6lydlG5x8Nyp1Y69wj1PN2I5gzp"""
    2:         msg['Face-1'] = t
    2:         msg['Face-2'] = Header(t, header_name='Face-2')
    2:         eq(msg.as_string(), """\
       Face-1: iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAAGFBMVEUAAAAkHiJeRUIcGBi9
        locQDQ4zJykFBAXJfWDjAAACYUlEQVR4nF2TQY/jIAyFc6lydlG5x8Nyp1Y69wj1PN2I5gzp
       Face-2: iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAAGFBMVEUAAAAkHiJeRUIcGBi9
        locQDQ4zJykFBAXJfWDjAAACYUlEQVR4nF2TQY/jIAyFc6lydlG5x8Nyp1Y69wj1PN2I5gzp
       
    2: """)
       
    1:     def test_another_long_multiline_header(self):
    2:         eq = self.ndiffAssertEqual
               m = '''\
       Received: from siimage.com ([172.25.1.3]) by zima.siliconimage.com with Microsoft SMTPSVC(5.0.2195.4905);
    2:  Wed, 16 Oct 2002 07:41:11 -0700'''
    2:         msg = email.message_from_string(m)
    2:         eq(msg.as_string(), '''\
       Received: from siimage.com ([172.25.1.3]) by zima.siliconimage.com with
        Microsoft SMTPSVC(5.0.2195.4905); Wed, 16 Oct 2002 07:41:11 -0700
       
    2: ''')
       
    1:     def test_long_lines_with_different_header(self):
    2:         eq = self.ndiffAssertEqual
               h = """\
       List-Unsubscribe: <https://lists.sourceforge.net/lists/listinfo/spamassassin-talk>,
    2:         <mailto:spamassassin-talk-request@lists.sourceforge.net?subject=unsubscribe>"""
    2:         msg = Message()
    2:         msg['List'] = h
    2:         msg['List'] = Header(h, header_name='List')
    2:         self.ndiffAssertEqual(msg.as_string(), """\
       List: List-Unsubscribe: <https://lists.sourceforge.net/lists/listinfo/spamassassin-talk>,
        <mailto:spamassassin-talk-request@lists.sourceforge.net?subject=unsubscribe>
       List: List-Unsubscribe: <https://lists.sourceforge.net/lists/listinfo/spamassassin-talk>,
        <mailto:spamassassin-talk-request@lists.sourceforge.net?subject=unsubscribe>
       
    2: """)
       
       
       
       # Test mangling of "From " lines in the body of a message
    2: class TestFromMangling(unittest.TestCase):
    1:     def setUp(self):
    4:         self.msg = Message()
    4:         self.msg['From'] = 'aaa@bbb.org'
    4:         self.msg.set_payload("""\
       From the desk of A.A.A.:
       Blah blah blah
    4: """)
       
    1:     def test_mangled_from(self):
    2:         s = StringIO()
    2:         g = Generator(s, mangle_from_=True)
    2:         g.flatten(self.msg)
    2:         self.assertEqual(s.getvalue(), """\
       From: aaa@bbb.org
       
       >From the desk of A.A.A.:
       Blah blah blah
    2: """)
       
    1:     def test_dont_mangle_from(self):
    2:         s = StringIO()
    2:         g = Generator(s, mangle_from_=False)
    2:         g.flatten(self.msg)
    2:         self.assertEqual(s.getvalue(), """\
       From: aaa@bbb.org
       
       From the desk of A.A.A.:
       Blah blah blah
    2: """)
       
       
       
       # Test the basic MIMEAudio class
    2: class TestMIMEAudio(unittest.TestCase):
    1:     def setUp(self):
               # Make sure we pick up the audiotest.au that lives in email/test/data.
               # In Python, there's an audiotest.au living in Lib/test but that isn't
               # included in some binary distros that don't include the test
               # package.  The trailing empty string on the .join() is significant
               # since findfile() will do a dirname().
    8:         datadir = os.path.join(os.path.dirname(landmark), 'data', '')
    8:         fp = open(findfile('audiotest.au', datadir), 'rb')
    8:         try:
    8:             self._audiodata = fp.read()
               finally:
    8:             fp.close()
    8:         self._au = MIMEAudio(self._audiodata)
       
    1:     def test_guess_minor_type(self):
    2:         self.assertEqual(self._au.get_content_type(), 'audio/basic')
       
    1:     def test_encoding(self):
    2:         payload = self._au.get_payload()
    2:         self.assertEqual(base64.decodestring(payload), self._audiodata)
       
    1:     def test_checkSetMinor(self):
    2:         au = MIMEAudio(self._audiodata, 'fish')
    2:         self.assertEqual(au.get_content_type(), 'audio/fish')
       
    1:     def test_add_header(self):
    2:         eq = self.assertEqual
    2:         self._au.add_header('Content-Disposition', 'attachment',
    2:                             filename='audiotest.au')
    2:         eq(self._au['content-disposition'],
    2:            'attachment; filename="audiotest.au"')
    2:         eq(self._au.get_params(header='content-disposition'),
    2:            [('attachment', ''), ('filename', 'audiotest.au')])
    2:         eq(self._au.get_param('filename', header='content-disposition'),
    2:            'audiotest.au')
    2:         missing = []
    2:         eq(self._au.get_param('attachment', header='content-disposition'), '')
    2:         self.assertIs(self._au.get_param('foo', failobj=missing,
    2:                                          header='content-disposition'),
    2:                       missing)
               # Try some missing stuff
    2:         self.assertIs(self._au.get_param('foobar', missing), missing)
    2:         self.assertIs(self._au.get_param('attachment', missing,
    2:                                          header='foobar'), missing)
       
       
       
       # Test the basic MIMEImage class
    2: class TestMIMEImage(unittest.TestCase):
    1:     def setUp(self):
    8:         fp = openfile('PyBanner048.gif')
    8:         try:
    8:             self._imgdata = fp.read()
               finally:
    8:             fp.close()
    8:         self._im = MIMEImage(self._imgdata)
       
    1:     def test_guess_minor_type(self):
    2:         self.assertEqual(self._im.get_content_type(), 'image/gif')
       
    1:     def test_encoding(self):
    2:         payload = self._im.get_payload()
    2:         self.assertEqual(base64.decodestring(payload), self._imgdata)
       
    1:     def test_checkSetMinor(self):
    2:         im = MIMEImage(self._imgdata, 'fish')
    2:         self.assertEqual(im.get_content_type(), 'image/fish')
       
    1:     def test_add_header(self):
    2:         eq = self.assertEqual
    2:         self._im.add_header('Content-Disposition', 'attachment',
    2:                             filename='dingusfish.gif')
    2:         eq(self._im['content-disposition'],
    2:            'attachment; filename="dingusfish.gif"')
    2:         eq(self._im.get_params(header='content-disposition'),
    2:            [('attachment', ''), ('filename', 'dingusfish.gif')])
    2:         eq(self._im.get_param('filename', header='content-disposition'),
    2:            'dingusfish.gif')
    2:         missing = []
    2:         eq(self._im.get_param('attachment', header='content-disposition'), '')
    2:         self.assertIs(self._im.get_param('foo', failobj=missing,
    2:                                          header='content-disposition'),
    2:                       missing)
               # Try some missing stuff
    2:         self.assertIs(self._im.get_param('foobar', missing), missing)
    2:         self.assertIs(self._im.get_param('attachment', missing,
    2:                                          header='foobar'), missing)
       
       
       
       # Test the basic MIMEApplication class
    2: class TestMIMEApplication(unittest.TestCase):
    1:     def test_headers(self):
    2:         eq = self.assertEqual
    2:         msg = MIMEApplication('\xfa\xfb\xfc\xfd\xfe\xff')
    2:         eq(msg.get_content_type(), 'application/octet-stream')
    2:         eq(msg['content-transfer-encoding'], 'base64')
       
    1:     def test_body(self):
    2:         eq = self.assertEqual
    2:         bytes = '\xfa\xfb\xfc\xfd\xfe\xff'
    2:         msg = MIMEApplication(bytes)
    2:         eq(msg.get_payload(), '+vv8/f7/')
    2:         eq(msg.get_payload(decode=True), bytes)
       
    1:     def test_binary_body_with_encode_7or8bit(self):
               # Issue 17171.
    2:         bytesdata = b'\xfa\xfb\xfc\xfd\xfe\xff'
    2:         msg = MIMEApplication(bytesdata, _encoder=encoders.encode_7or8bit)
               # Treated as a string, this will be invalid code points.
    2:         self.assertEqual(msg.get_payload(), bytesdata)
    2:         self.assertEqual(msg.get_payload(decode=True), bytesdata)
    2:         self.assertEqual(msg['Content-Transfer-Encoding'], '8bit')
    2:         s = StringIO()
    2:         g = Generator(s)
    2:         g.flatten(msg)
    2:         wireform = s.getvalue()
    2:         msg2 = email.message_from_string(wireform)
    2:         self.assertEqual(msg.get_payload(), bytesdata)
    2:         self.assertEqual(msg2.get_payload(decode=True), bytesdata)
    2:         self.assertEqual(msg2['Content-Transfer-Encoding'], '8bit')
       
    1:     def test_binary_body_with_encode_noop(self):
               # Issue 16564: This does not produce an RFC valid message, since to be
               # valid it should have a CTE of binary.  But the below works, and is
               # documented as working this way.
    2:         bytesdata = b'\xfa\xfb\xfc\xfd\xfe\xff'
    2:         msg = MIMEApplication(bytesdata, _encoder=encoders.encode_noop)
    2:         self.assertEqual(msg.get_payload(), bytesdata)
    2:         self.assertEqual(msg.get_payload(decode=True), bytesdata)
    2:         s = StringIO()
    2:         g = Generator(s)
    2:         g.flatten(msg)
    2:         wireform = s.getvalue()
    2:         msg2 = email.message_from_string(wireform)
    2:         self.assertEqual(msg.get_payload(), bytesdata)
    2:         self.assertEqual(msg2.get_payload(decode=True), bytesdata)
       
       
       # Test the basic MIMEText class
    2: class TestMIMEText(unittest.TestCase):
    1:     def setUp(self):
    6:         self._msg = MIMEText('hello there')
       
    1:     def test_types(self):
    2:         eq = self.assertEqual
    2:         eq(self._msg.get_content_type(), 'text/plain')
    2:         eq(self._msg.get_param('charset'), 'us-ascii')
    2:         missing = []
    2:         self.assertIs(self._msg.get_param('foobar', missing), missing)
    2:         self.assertIs(self._msg.get_param('charset', missing, header='foobar'),
    2:                       missing)
       
    1:     def test_payload(self):
    2:         self.assertEqual(self._msg.get_payload(), 'hello there')
    2:         self.assertFalse(self._msg.is_multipart())
       
    1:     def test_charset(self):
    2:         eq = self.assertEqual
    2:         msg = MIMEText('hello there', _charset='us-ascii')
    2:         eq(msg.get_charset().input_charset, 'us-ascii')
    2:         eq(msg['content-type'], 'text/plain; charset="us-ascii"')
       
       
       
       # Test complicated multipart/* messages
    2: class TestMultipart(TestEmailBase):
    1:     def setUp(self):
   34:         fp = openfile('PyBanner048.gif')
   34:         try:
   34:             data = fp.read()
               finally:
   34:             fp.close()
       
   34:         container = MIMEBase('multipart', 'mixed', boundary='BOUNDARY')
   34:         image = MIMEImage(data, name='dingusfish.gif')
   34:         image.add_header('content-disposition', 'attachment',
   34:                          filename='dingusfish.gif')
   34:         intro = MIMEText('''\
       Hi there,
       
       This is the dingus fish.
   34: ''')
   34:         container.attach(intro)
   34:         container.attach(image)
   34:         container['From'] = 'Barry <barry@digicool.com>'
   34:         container['To'] = 'Dingus Lovers <cravindogs@cravindogs.com>'
   34:         container['Subject'] = 'Here is your dingus fish'
       
   34:         now = 987809702.54848599
   34:         timetuple = time.localtime(now)
   34:         if timetuple[-1] == 0:
>>>>>>             tzsecs = time.timezone
               else:
   34:             tzsecs = time.altzone
   34:         if tzsecs > 0:
   34:             sign = '-'
               else:
>>>>>>             sign = '+'
   34:         tzoffset = ' %s%04d' % (sign, tzsecs // 36)
   34:         container['Date'] = time.strftime(
   34:             '%a, %d %b %Y %H:%M:%S',
   34:             time.localtime(now)) + tzoffset
   34:         self._msg = container
   34:         self._im = image
   34:         self._txt = intro
       
    1:     def test_hierarchy(self):
               # convenience
    2:         eq = self.assertEqual
    2:         raises = self.assertRaises
               # tests
    2:         m = self._msg
    2:         self.assertTrue(m.is_multipart())
    2:         eq(m.get_content_type(), 'multipart/mixed')
    2:         eq(len(m.get_payload()), 2)
    2:         raises(IndexError, m.get_payload, 2)
    2:         m0 = m.get_payload(0)
    2:         m1 = m.get_payload(1)
    2:         self.assertIs(m0, self._txt)
    2:         self.assertIs(m1, self._im)
    2:         eq(m.get_payload(), [m0, m1])
    2:         self.assertFalse(m0.is_multipart())
    2:         self.assertFalse(m1.is_multipart())
       
    1:     def test_empty_multipart_idempotent(self):
               text = """\
       Content-Type: multipart/mixed; boundary="BOUNDARY"
       MIME-Version: 1.0
       Subject: A subject
       To: aperson@dom.ain
       From: bperson@dom.ain
       
       
       --BOUNDARY
       
       
       --BOUNDARY--
    2: """
    2:         msg = Parser().parsestr(text)
    2:         self.ndiffAssertEqual(text, msg.as_string())
       
    1:     def test_no_parts_in_a_multipart_with_none_epilogue(self):
    2:         outer = MIMEBase('multipart', 'mixed')
    2:         outer['Subject'] = 'A subject'
    2:         outer['To'] = 'aperson@dom.ain'
    2:         outer['From'] = 'bperson@dom.ain'
    2:         outer.set_boundary('BOUNDARY')
    2:         self.ndiffAssertEqual(outer.as_string(), '''\
       Content-Type: multipart/mixed; boundary="BOUNDARY"
       MIME-Version: 1.0
       Subject: A subject
       To: aperson@dom.ain
       From: bperson@dom.ain
       
       --BOUNDARY
       
       --BOUNDARY--
    2: ''')
       
    1:     def test_no_parts_in_a_multipart_with_empty_epilogue(self):
    2:         outer = MIMEBase('multipart', 'mixed')
    2:         outer['Subject'] = 'A subject'
    2:         outer['To'] = 'aperson@dom.ain'
    2:         outer['From'] = 'bperson@dom.ain'
    2:         outer.preamble = ''
    2:         outer.epilogue = ''
    2:         outer.set_boundary('BOUNDARY')
    2:         self.ndiffAssertEqual(outer.as_string(), '''\
       Content-Type: multipart/mixed; boundary="BOUNDARY"
       MIME-Version: 1.0
       Subject: A subject
       To: aperson@dom.ain
       From: bperson@dom.ain
       
       
       --BOUNDARY
       
       --BOUNDARY--
    2: ''')
       
    1:     def test_one_part_in_a_multipart(self):
    2:         eq = self.ndiffAssertEqual
    2:         outer = MIMEBase('multipart', 'mixed')
    2:         outer['Subject'] = 'A subject'
    2:         outer['To'] = 'aperson@dom.ain'
    2:         outer['From'] = 'bperson@dom.ain'
    2:         outer.set_boundary('BOUNDARY')
    2:         msg = MIMEText('hello world')
    2:         outer.attach(msg)
    2:         eq(outer.as_string(), '''\
       Content-Type: multipart/mixed; boundary="BOUNDARY"
       MIME-Version: 1.0
       Subject: A subject
       To: aperson@dom.ain
       From: bperson@dom.ain
       
       --BOUNDARY
       Content-Type: text/plain; charset="us-ascii"
       MIME-Version: 1.0
       Content-Transfer-Encoding: 7bit
       
       hello world
       --BOUNDARY--
    2: ''')
       
    1:     def test_seq_parts_in_a_multipart_with_empty_preamble(self):
    2:         eq = self.ndiffAssertEqual
    2:         outer = MIMEBase('multipart', 'mixed')
    2:         outer['Subject'] = 'A subject'
    2:         outer['To'] = 'aperson@dom.ain'
    2:         outer['From'] = 'bperson@dom.ain'
    2:         outer.preamble = ''
    2:         msg = MIMEText('hello world')
    2:         outer.attach(msg)
    2:         outer.set_boundary('BOUNDARY')
    2:         eq(outer.as_string(), '''\
       Content-Type: multipart/mixed; boundary="BOUNDARY"
       MIME-Version: 1.0
       Subject: A subject
       To: aperson@dom.ain
       From: bperson@dom.ain
       
       
       --BOUNDARY
       Content-Type: text/plain; charset="us-ascii"
       MIME-Version: 1.0
       Content-Transfer-Encoding: 7bit
       
       hello world
       --BOUNDARY--
    2: ''')
       
       
    1:     def test_seq_parts_in_a_multipart_with_none_preamble(self):
    2:         eq = self.ndiffAssertEqual
    2:         outer = MIMEBase('multipart', 'mixed')
    2:         outer['Subject'] = 'A subject'
    2:         outer['To'] = 'aperson@dom.ain'
    2:         outer['From'] = 'bperson@dom.ain'
    2:         outer.preamble = None
    2:         msg = MIMEText('hello world')
    2:         outer.attach(msg)
    2:         outer.set_boundary('BOUNDARY')
    2:         eq(outer.as_string(), '''\
       Content-Type: multipart/mixed; boundary="BOUNDARY"
       MIME-Version: 1.0
       Subject: A subject
       To: aperson@dom.ain
       From: bperson@dom.ain
       
       --BOUNDARY
       Content-Type: text/plain; charset="us-ascii"
       MIME-Version: 1.0
       Content-Transfer-Encoding: 7bit
       
       hello world
       --BOUNDARY--
    2: ''')
       
       
    1:     def test_seq_parts_in_a_multipart_with_none_epilogue(self):
    2:         eq = self.ndiffAssertEqual
    2:         outer = MIMEBase('multipart', 'mixed')
    2:         outer['Subject'] = 'A subject'
    2:         outer['To'] = 'aperson@dom.ain'
    2:         outer['From'] = 'bperson@dom.ain'
    2:         outer.epilogue = None
    2:         msg = MIMEText('hello world')
    2:         outer.attach(msg)
    2:         outer.set_boundary('BOUNDARY')
    2:         eq(outer.as_string(), '''\
       Content-Type: multipart/mixed; boundary="BOUNDARY"
       MIME-Version: 1.0
       Subject: A subject
       To: aperson@dom.ain
       From: bperson@dom.ain
       
       --BOUNDARY
       Content-Type: text/plain; charset="us-ascii"
       MIME-Version: 1.0
       Content-Transfer-Encoding: 7bit
       
       hello world
       --BOUNDARY--
    2: ''')
       
       
    1:     def test_seq_parts_in_a_multipart_with_empty_epilogue(self):
    2:         eq = self.ndiffAssertEqual
    2:         outer = MIMEBase('multipart', 'mixed')
    2:         outer['Subject'] = 'A subject'
    2:         outer['To'] = 'aperson@dom.ain'
    2:         outer['From'] = 'bperson@dom.ain'
    2:         outer.epilogue = ''
    2:         msg = MIMEText('hello world')
    2:         outer.attach(msg)
    2:         outer.set_boundary('BOUNDARY')
    2:         eq(outer.as_string(), '''\
       Content-Type: multipart/mixed; boundary="BOUNDARY"
       MIME-Version: 1.0
       Subject: A subject
       To: aperson@dom.ain
       From: bperson@dom.ain
       
       --BOUNDARY
       Content-Type: text/plain; charset="us-ascii"
       MIME-Version: 1.0
       Content-Transfer-Encoding: 7bit
       
       hello world
       --BOUNDARY--
    2: ''')
       
       
    1:     def test_seq_parts_in_a_multipart_with_nl_epilogue(self):
    2:         eq = self.ndiffAssertEqual
    2:         outer = MIMEBase('multipart', 'mixed')
    2:         outer['Subject'] = 'A subject'
    2:         outer['To'] = 'aperson@dom.ain'
    2:         outer['From'] = 'bperson@dom.ain'
    2:         outer.epilogue = '\n'
    2:         msg = MIMEText('hello world')
    2:         outer.attach(msg)
    2:         outer.set_boundary('BOUNDARY')
    2:         eq(outer.as_string(), '''\
       Content-Type: multipart/mixed; boundary="BOUNDARY"
       MIME-Version: 1.0
       Subject: A subject
       To: aperson@dom.ain
       From: bperson@dom.ain
       
       --BOUNDARY
       Content-Type: text/plain; charset="us-ascii"
       MIME-Version: 1.0
       Content-Transfer-Encoding: 7bit
       
       hello world
       --BOUNDARY--
       
    2: ''')
       
    1:     def test_message_external_body(self):
    2:         eq = self.assertEqual
    2:         msg = self._msgobj('msg_36.txt')
    2:         eq(len(msg.get_payload()), 2)
    2:         msg1 = msg.get_payload(1)
    2:         eq(msg1.get_content_type(), 'multipart/alternative')
    2:         eq(len(msg1.get_payload()), 2)
    6:         for subpart in msg1.get_payload():
    4:             eq(subpart.get_content_type(), 'message/external-body')
    4:             eq(len(subpart.get_payload()), 1)
    4:             subsubpart = subpart.get_payload(0)
    4:             eq(subsubpart.get_content_type(), 'text/plain')
       
    1:     def test_double_boundary(self):
               # msg_37.txt is a multipart that contains two dash-boundary's in a
               # row.  Our interpretation of RFC 2046 calls for ignoring the second
               # and subsequent boundaries.
    2:         msg = self._msgobj('msg_37.txt')
    2:         self.assertEqual(len(msg.get_payload()), 3)
       
    1:     def test_nested_inner_contains_outer_boundary(self):
    2:         eq = self.ndiffAssertEqual
               # msg_38.txt has an inner part that contains outer boundaries.  My
               # interpretation of RFC 2046 (based on sections 5.1 and 5.1.2) say
               # these are illegal and should be interpreted as unterminated inner
               # parts.
    2:         msg = self._msgobj('msg_38.txt')
    2:         sfp = StringIO()
    2:         iterators._structure(msg, sfp)
    2:         eq(sfp.getvalue(), """\
       multipart/mixed
           multipart/mixed
               multipart/alternative
                   text/plain
               text/plain
           text/plain
           text/plain
    2: """)
       
    1:     def test_nested_with_same_boundary(self):
    2:         eq = self.ndiffAssertEqual
               # msg 39.txt is similarly evil in that it's got inner parts that use
               # the same boundary as outer parts.  Again, I believe the way this is
               # parsed is closest to the spirit of RFC 2046
    2:         msg = self._msgobj('msg_39.txt')
    2:         sfp = StringIO()
    2:         iterators._structure(msg, sfp)
    2:         eq(sfp.getvalue(), """\
       multipart/mixed
           multipart/mixed
               multipart/alternative
               application/octet-stream
               application/octet-stream
           text/plain
    2: """)
       
    1:     def test_boundary_in_non_multipart(self):
    2:         msg = self._msgobj('msg_40.txt')
    2:         self.assertEqual(msg.as_string(), '''\
       MIME-Version: 1.0
       Content-Type: text/html; boundary="--961284236552522269"
       
       ----961284236552522269
       Content-Type: text/html;
       Content-Transfer-Encoding: 7Bit
       
       <html></html>
       
       ----961284236552522269--
    2: ''')
       
    1:     def test_boundary_with_leading_space(self):
    2:         eq = self.assertEqual
    2:         msg = email.message_from_string('''\
       MIME-Version: 1.0
       Content-Type: multipart/mixed; boundary="    XXXX"
       
       --    XXXX
       Content-Type: text/plain
       
       
       --    XXXX
       Content-Type: text/plain
       
       --    XXXX--
    2: ''')
    2:         self.assertTrue(msg.is_multipart())
    2:         eq(msg.get_boundary(), '    XXXX')
    2:         eq(len(msg.get_payload()), 2)
       
    1:     def test_boundary_without_trailing_newline(self):
    2:         m = Parser().parsestr("""\
       Content-Type: multipart/mixed; boundary="===============0012394164=="
       MIME-Version: 1.0
       
       --===============0012394164==
       Content-Type: image/file1.jpg
       MIME-Version: 1.0
       Content-Transfer-Encoding: base64
       
       YXNkZg==
    2: --===============0012394164==--""")
    2:         self.assertEqual(m.get_payload(0).get_payload(), 'YXNkZg==')
       
       
       
       # Test some badly formatted messages
    2: class TestNonConformant(TestEmailBase):
    1:     def test_parse_missing_minor_type(self):
    2:         eq = self.assertEqual
    2:         msg = self._msgobj('msg_14.txt')
    2:         eq(msg.get_content_type(), 'text/plain')
    2:         eq(msg.get_content_maintype(), 'text')
    2:         eq(msg.get_content_subtype(), 'plain')
       
    1:     def test_same_boundary_inner_outer(self):
    2:         msg = self._msgobj('msg_15.txt')
               # XXX We can probably eventually do better
    2:         inner = msg.get_payload(0)
    2:         self.assertTrue(hasattr(inner, 'defects'))
    2:         self.assertEqual(len(inner.defects), 1)
    2:         self.assertIsInstance(inner.defects[0],
    2:                               errors.StartBoundaryNotFoundDefect)
       
    1:     def test_multipart_no_boundary(self):
    2:         msg = self._msgobj('msg_25.txt')
    2:         self.assertIsInstance(msg.get_payload(), str)
    2:         self.assertEqual(len(msg.defects), 2)
    2:         self.assertIsInstance(msg.defects[0],
    2:                               errors.NoBoundaryInMultipartDefect)
    2:         self.assertIsInstance(msg.defects[1],
    2:                               errors.MultipartInvariantViolationDefect)
       
    1:     def test_invalid_content_type(self):
    2:         eq = self.assertEqual
    2:         neq = self.ndiffAssertEqual
    2:         msg = Message()
               # RFC 2045, $5.2 says invalid yields text/plain
    2:         msg['Content-Type'] = 'text'
    2:         eq(msg.get_content_maintype(), 'text')
    2:         eq(msg.get_content_subtype(), 'plain')
    2:         eq(msg.get_content_type(), 'text/plain')
               # Clear the old value and try something /really/ invalid
    2:         del msg['content-type']
    2:         msg['Content-Type'] = 'foo'
    2:         eq(msg.get_content_maintype(), 'text')
    2:         eq(msg.get_content_subtype(), 'plain')
    2:         eq(msg.get_content_type(), 'text/plain')
               # Still, make sure that the message is idempotently generated
    2:         s = StringIO()
    2:         g = Generator(s)
    2:         g.flatten(msg)
    2:         neq(s.getvalue(), 'Content-Type: foo\n\n')
       
    1:     def test_no_start_boundary(self):
    2:         eq = self.ndiffAssertEqual
    2:         msg = self._msgobj('msg_31.txt')
    2:         eq(msg.get_payload(), """\
       --BOUNDARY
       Content-Type: text/plain
       
       message 1
       
       --BOUNDARY
       Content-Type: text/plain
       
       message 2
       
       --BOUNDARY--
    2: """)
       
    1:     def test_no_separating_blank_line(self):
    2:         eq = self.ndiffAssertEqual
    2:         msg = self._msgobj('msg_35.txt')
    2:         eq(msg.as_string(), """\
       From: aperson@dom.ain
       To: bperson@dom.ain
       Subject: here's something interesting
       
       counter to RFC 2822, there's no separating newline here
    2: """)
       
    1:     def test_lying_multipart(self):
    2:         msg = self._msgobj('msg_41.txt')
    2:         self.assertTrue(hasattr(msg, 'defects'))
    2:         self.assertEqual(len(msg.defects), 2)
    2:         self.assertIsInstance(msg.defects[0],
    2:                               errors.NoBoundaryInMultipartDefect)
    2:         self.assertIsInstance(msg.defects[1],
    2:                               errors.MultipartInvariantViolationDefect)
       
    1:     def test_missing_start_boundary(self):
    2:         outer = self._msgobj('msg_42.txt')
               # The message structure is:
               #
               # multipart/mixed
               #    text/plain
               #    message/rfc822
               #        multipart/mixed [*]
               #
               # [*] This message is missing its start boundary
    2:         bad = outer.get_payload(1).get_payload(0)
    2:         self.assertEqual(len(bad.defects), 1)
    2:         self.assertIsInstance(bad.defects[0],
    2:                               errors.StartBoundaryNotFoundDefect)
       
    1:     def test_first_line_is_continuation_header(self):
    2:         eq = self.assertEqual
    2:         m = ' Line 1\nLine 2\nLine 3'
    2:         msg = email.message_from_string(m)
    2:         eq(msg.keys(), [])
    2:         eq(msg.get_payload(), 'Line 2\nLine 3')
    2:         eq(len(msg.defects), 1)
    2:         self.assertIsInstance(msg.defects[0],
    2:                               errors.FirstHeaderLineIsContinuationDefect)
    2:         eq(msg.defects[0].line, ' Line 1\n')
       
       
       
       # Test RFC 2047 header encoding and decoding
    2: class TestRFC2047(unittest.TestCase):
    1:     def test_rfc2047_multiline(self):
    2:         eq = self.assertEqual
               s = """Re: =?mac-iceland?q?r=8Aksm=9Arg=8Cs?= baz
    2:  foo bar =?mac-iceland?q?r=8Aksm=9Arg=8Cs?="""
    2:         dh = decode_header(s)
    2:         eq(dh, [
    2:             ('Re:', None),
    2:             ('r\x8aksm\x9arg\x8cs', 'mac-iceland'),
    2:             ('baz foo bar', None),
    2:             ('r\x8aksm\x9arg\x8cs', 'mac-iceland')])
    2:         eq(str(make_header(dh)),
                  """Re: =?mac-iceland?q?r=8Aksm=9Arg=8Cs?= baz foo bar
    2:  =?mac-iceland?q?r=8Aksm=9Arg=8Cs?=""")
       
    1:     def test_whitespace_eater_unicode(self):
    2:         eq = self.assertEqual
    2:         s = '=?ISO-8859-1?Q?Andr=E9?= Pirard <pirard@dom.ain>'
    2:         dh = decode_header(s)
    2:         eq(dh, [('Andr\xe9', 'iso-8859-1'), ('Pirard <pirard@dom.ain>', None)])
    2:         hu = unicode(make_header(dh)).encode('latin-1')
    2:         eq(hu, 'Andr\xe9 Pirard <pirard@dom.ain>')
       
    1:     def test_whitespace_eater_unicode_2(self):
    2:         eq = self.assertEqual
    2:         s = 'The =?iso-8859-1?b?cXVpY2sgYnJvd24gZm94?= jumped over the =?iso-8859-1?b?bGF6eSBkb2c=?='
    2:         dh = decode_header(s)
    2:         eq(dh, [('The', None), ('quick brown fox', 'iso-8859-1'),
    2:                 ('jumped over the', None), ('lazy dog', 'iso-8859-1')])
    2:         hu = make_header(dh).__unicode__()
    2:         eq(hu, u'The quick brown fox jumped over the lazy dog')
       
    1:     def test_rfc2047_missing_whitespace(self):
    2:         s = 'Sm=?ISO-8859-1?B?9g==?=rg=?ISO-8859-1?B?5Q==?=sbord'
    2:         dh = decode_header(s)
    2:         self.assertEqual(dh, [(s, None)])
       
    1:     def test_rfc2047_with_whitespace(self):
    2:         s = 'Sm =?ISO-8859-1?B?9g==?= rg =?ISO-8859-1?B?5Q==?= sbord'
    2:         dh = decode_header(s)
    2:         self.assertEqual(dh, [('Sm', None), ('\xf6', 'iso-8859-1'),
    2:                               ('rg', None), ('\xe5', 'iso-8859-1'),
    2:                               ('sbord', None)])
       
       
       
       # Test the MIMEMessage class
    2: class TestMIMEMessage(TestEmailBase):
    1:     def setUp(self):
   24:         fp = openfile('msg_11.txt')
   24:         try:
   24:             self._text = fp.read()
               finally:
   24:             fp.close()
       
    1:     def test_type_error(self):
    2:         self.assertRaises(TypeError, MIMEMessage, 'a plain string')
       
    1:     def test_valid_argument(self):
    2:         eq = self.assertEqual
    2:         subject = 'A sub-message'
    2:         m = Message()
    2:         m['Subject'] = subject
    2:         r = MIMEMessage(m)
    2:         eq(r.get_content_type(), 'message/rfc822')
    2:         payload = r.get_payload()
    2:         self.assertIsInstance(payload, list)
    2:         eq(len(payload), 1)
    2:         subpart = payload[0]
    2:         self.assertIs(subpart, m)
    2:         eq(subpart['subject'], subject)
       
    1:     def test_bad_multipart(self):
    2:         eq = self.assertEqual
    2:         msg1 = Message()
    2:         msg1['Subject'] = 'subpart 1'
    2:         msg2 = Message()
    2:         msg2['Subject'] = 'subpart 2'
    2:         r = MIMEMessage(msg1)
    2:         self.assertRaises(errors.MultipartConversionError, r.attach, msg2)
       
    1:     def test_generate(self):
               # First craft the message to be encapsulated
    2:         m = Message()
    2:         m['Subject'] = 'An enclosed message'
    2:         m.set_payload('Here is the body of the message.\n')
    2:         r = MIMEMessage(m)
    2:         r['Subject'] = 'The enclosing message'
    2:         s = StringIO()
    2:         g = Generator(s)
    2:         g.flatten(r)
    2:         self.assertEqual(s.getvalue(), """\
       Content-Type: message/rfc822
       MIME-Version: 1.0
       Subject: The enclosing message
       
       Subject: An enclosed message
       
       Here is the body of the message.
    2: """)
       
    1:     def test_parse_message_rfc822(self):
    2:         eq = self.assertEqual
    2:         msg = self._msgobj('msg_11.txt')
    2:         eq(msg.get_content_type(), 'message/rfc822')
    2:         payload = msg.get_payload()
    2:         self.assertIsInstance(payload, list)
    2:         eq(len(payload), 1)
    2:         submsg = payload[0]
    2:         self.assertIsInstance(submsg, Message)
    2:         eq(submsg['subject'], 'An enclosed message')
    2:         eq(submsg.get_payload(), 'Here is the body of the message.\n')
       
    1:     def test_dsn(self):
    2:         eq = self.assertEqual
               # msg 16 is a Delivery Status Notification, see RFC 1894
    2:         msg = self._msgobj('msg_16.txt')
    2:         eq(msg.get_content_type(), 'multipart/report')
    2:         self.assertTrue(msg.is_multipart())
    2:         eq(len(msg.get_payload()), 3)
               # Subpart 1 is a text/plain, human readable section
    2:         subpart = msg.get_payload(0)
    2:         eq(subpart.get_content_type(), 'text/plain')
    2:         eq(subpart.get_payload(), """\
       This report relates to a message you sent with the following header fields:
       
         Message-id: <002001c144a6$8752e060$56104586@oxy.edu>
         Date: Sun, 23 Sep 2001 20:10:55 -0700
         From: "Ian T. Henry" <henryi@oxy.edu>
         To: SoCal Raves <scr@socal-raves.org>
         Subject: [scr] yeah for Ians!!
       
       Your message cannot be delivered to the following recipients:
       
         Recipient address: jangel1@cougar.noc.ucla.edu
         Reason: recipient reached disk quota
       
    2: """)
               # Subpart 2 contains the machine parsable DSN information.  It
               # consists of two blocks of headers, represented by two nested Message
               # objects.
    2:         subpart = msg.get_payload(1)
    2:         eq(subpart.get_content_type(), 'message/delivery-status')
    2:         eq(len(subpart.get_payload()), 2)
               # message/delivery-status should treat each block as a bunch of
               # headers, i.e. a bunch of Message objects.
    2:         dsn1 = subpart.get_payload(0)
    2:         self.assertIsInstance(dsn1, Message)
    2:         eq(dsn1['original-envelope-id'], '0GK500B4HD0888@cougar.noc.ucla.edu')
    2:         eq(dsn1.get_param('dns', header='reporting-mta'), '')
               # Try a missing one <wink>
    2:         eq(dsn1.get_param('nsd', header='reporting-mta'), None)
    2:         dsn2 = subpart.get_payload(1)
    2:         self.assertIsInstance(dsn2, Message)
    2:         eq(dsn2['action'], 'failed')
    2:         eq(dsn2.get_params(header='original-recipient'),
    2:            [('rfc822', ''), ('jangel1@cougar.noc.ucla.edu', '')])
    2:         eq(dsn2.get_param('rfc822', header='final-recipient'), '')
               # Subpart 3 is the original message
    2:         subpart = msg.get_payload(2)
    2:         eq(subpart.get_content_type(), 'message/rfc822')
    2:         payload = subpart.get_payload()
    2:         self.assertIsInstance(payload, list)
    2:         eq(len(payload), 1)
    2:         subsubpart = payload[0]
    2:         self.assertIsInstance(subsubpart, Message)
    2:         eq(subsubpart.get_content_type(), 'text/plain')
    2:         eq(subsubpart['message-id'],
    2:            '<002001c144a6$8752e060$56104586@oxy.edu>')
       
    1:     def test_epilogue(self):
    2:         eq = self.ndiffAssertEqual
    2:         fp = openfile('msg_21.txt')
    2:         try:
    2:             text = fp.read()
               finally:
    2:             fp.close()
    2:         msg = Message()
    2:         msg['From'] = 'aperson@dom.ain'
    2:         msg['To'] = 'bperson@dom.ain'
    2:         msg['Subject'] = 'Test'
    2:         msg.preamble = 'MIME message'
    2:         msg.epilogue = 'End of MIME message\n'
    2:         msg1 = MIMEText('One')
    2:         msg2 = MIMEText('Two')
    2:         msg.add_header('Content-Type', 'multipart/mixed', boundary='BOUNDARY')
    2:         msg.attach(msg1)
    2:         msg.attach(msg2)
    2:         sfp = StringIO()
    2:         g = Generator(sfp)
    2:         g.flatten(msg)
    2:         eq(sfp.getvalue(), text)
       
    1:     def test_no_nl_preamble(self):
    2:         eq = self.ndiffAssertEqual
    2:         msg = Message()
    2:         msg['From'] = 'aperson@dom.ain'
    2:         msg['To'] = 'bperson@dom.ain'
    2:         msg['Subject'] = 'Test'
    2:         msg.preamble = 'MIME message'
    2:         msg.epilogue = ''
    2:         msg1 = MIMEText('One')
    2:         msg2 = MIMEText('Two')
    2:         msg.add_header('Content-Type', 'multipart/mixed', boundary='BOUNDARY')
    2:         msg.attach(msg1)
    2:         msg.attach(msg2)
    2:         eq(msg.as_string(), """\
       From: aperson@dom.ain
       To: bperson@dom.ain
       Subject: Test
       Content-Type: multipart/mixed; boundary="BOUNDARY"
       
       MIME message
       --BOUNDARY
       Content-Type: text/plain; charset="us-ascii"
       MIME-Version: 1.0
       Content-Transfer-Encoding: 7bit
       
       One
       --BOUNDARY
       Content-Type: text/plain; charset="us-ascii"
       MIME-Version: 1.0
       Content-Transfer-Encoding: 7bit
       
       Two
       --BOUNDARY--
    2: """)
       
    1:     def test_default_type(self):
    2:         eq = self.assertEqual
    2:         fp = openfile('msg_30.txt')
    2:         try:
    2:             msg = email.message_from_file(fp)
               finally:
    2:             fp.close()
    2:         container1 = msg.get_payload(0)
    2:         eq(container1.get_default_type(), 'message/rfc822')
    2:         eq(container1.get_content_type(), 'message/rfc822')
    2:         container2 = msg.get_payload(1)
    2:         eq(container2.get_default_type(), 'message/rfc822')
    2:         eq(container2.get_content_type(), 'message/rfc822')
    2:         container1a = container1.get_payload(0)
    2:         eq(container1a.get_default_type(), 'text/plain')
    2:         eq(container1a.get_content_type(), 'text/plain')
    2:         container2a = container2.get_payload(0)
    2:         eq(container2a.get_default_type(), 'text/plain')
    2:         eq(container2a.get_content_type(), 'text/plain')
       
    1:     def test_default_type_with_explicit_container_type(self):
    2:         eq = self.assertEqual
    2:         fp = openfile('msg_28.txt')
    2:         try:
    2:             msg = email.message_from_file(fp)
               finally:
    2:             fp.close()
    2:         container1 = msg.get_payload(0)
    2:         eq(container1.get_default_type(), 'message/rfc822')
    2:         eq(container1.get_content_type(), 'message/rfc822')
    2:         container2 = msg.get_payload(1)
    2:         eq(container2.get_default_type(), 'message/rfc822')
    2:         eq(container2.get_content_type(), 'message/rfc822')
    2:         container1a = container1.get_payload(0)
    2:         eq(container1a.get_default_type(), 'text/plain')
    2:         eq(container1a.get_content_type(), 'text/plain')
    2:         container2a = container2.get_payload(0)
    2:         eq(container2a.get_default_type(), 'text/plain')
    2:         eq(container2a.get_content_type(), 'text/plain')
       
    1:     def test_default_type_non_parsed(self):
    2:         eq = self.assertEqual
    2:         neq = self.ndiffAssertEqual
               # Set up container
    2:         container = MIMEMultipart('digest', 'BOUNDARY')
    2:         container.epilogue = ''
               # Set up subparts
    2:         subpart1a = MIMEText('message 1\n')
    2:         subpart2a = MIMEText('message 2\n')
    2:         subpart1 = MIMEMessage(subpart1a)
    2:         subpart2 = MIMEMessage(subpart2a)
    2:         container.attach(subpart1)
    2:         container.attach(subpart2)
    2:         eq(subpart1.get_content_type(), 'message/rfc822')
    2:         eq(subpart1.get_default_type(), 'message/rfc822')
    2:         eq(subpart2.get_content_type(), 'message/rfc822')
    2:         eq(subpart2.get_default_type(), 'message/rfc822')
    2:         neq(container.as_string(0), '''\
       Content-Type: multipart/digest; boundary="BOUNDARY"
       MIME-Version: 1.0
       
       --BOUNDARY
       Content-Type: message/rfc822
       MIME-Version: 1.0
       
       Content-Type: text/plain; charset="us-ascii"
       MIME-Version: 1.0
       Content-Transfer-Encoding: 7bit
       
       message 1
       
       --BOUNDARY
       Content-Type: message/rfc822
       MIME-Version: 1.0
       
       Content-Type: text/plain; charset="us-ascii"
       MIME-Version: 1.0
       Content-Transfer-Encoding: 7bit
       
       message 2
       
       --BOUNDARY--
    2: ''')
    2:         del subpart1['content-type']
    2:         del subpart1['mime-version']
    2:         del subpart2['content-type']
    2:         del subpart2['mime-version']
    2:         eq(subpart1.get_content_type(), 'message/rfc822')
    2:         eq(subpart1.get_default_type(), 'message/rfc822')
    2:         eq(subpart2.get_content_type(), 'message/rfc822')
    2:         eq(subpart2.get_default_type(), 'message/rfc822')
    2:         neq(container.as_string(0), '''\
       Content-Type: multipart/digest; boundary="BOUNDARY"
       MIME-Version: 1.0
       
       --BOUNDARY
       
       Content-Type: text/plain; charset="us-ascii"
       MIME-Version: 1.0
       Content-Transfer-Encoding: 7bit
       
       message 1
       
       --BOUNDARY
       
       Content-Type: text/plain; charset="us-ascii"
       MIME-Version: 1.0
       Content-Transfer-Encoding: 7bit
       
       message 2
       
       --BOUNDARY--
    2: ''')
       
    1:     def test_mime_attachments_in_constructor(self):
    2:         eq = self.assertEqual
    2:         text1 = MIMEText('')
    2:         text2 = MIMEText('')
    2:         msg = MIMEMultipart(_subparts=(text1, text2))
    2:         eq(len(msg.get_payload()), 2)
    2:         eq(msg.get_payload(0), text1)
    2:         eq(msg.get_payload(1), text2)
       
       
       
       # A general test of parser->model->generator idempotency.  IOW, read a message
       # in, parse it into a message object tree, then without touching the tree,
       # regenerate the plain text.  The original text and the transformed text
       # should be identical.  Note: that we ignore the Unix-From since that may
       # contain a changed date.
    2: class TestIdempotent(TestEmailBase):
    1:     def _msgobj(self, filename):
   40:         fp = openfile(filename)
   40:         try:
   40:             data = fp.read()
               finally:
   40:             fp.close()
   40:         msg = email.message_from_string(data)
   40:         return msg, data
       
    1:     def _idempotent(self, msg, text):
   36:         eq = self.ndiffAssertEqual
   36:         s = StringIO()
   36:         g = Generator(s, maxheaderlen=0)
   36:         g.flatten(msg)
   36:         eq(text, s.getvalue())
       
    1:     def test_parse_text_message(self):
    2:         eq = self.assertEqual
    2:         msg, text = self._msgobj('msg_01.txt')
    2:         eq(msg.get_content_type(), 'text/plain')
    2:         eq(msg.get_content_maintype(), 'text')
    2:         eq(msg.get_content_subtype(), 'plain')
    2:         eq(msg.get_params()[1], ('charset', 'us-ascii'))
    2:         eq(msg.get_param('charset'), 'us-ascii')
    2:         eq(msg.preamble, None)
    2:         eq(msg.epilogue, None)
    2:         self._idempotent(msg, text)
       
    1:     def test_parse_untyped_message(self):
    2:         eq = self.assertEqual
    2:         msg, text = self._msgobj('msg_03.txt')
    2:         eq(msg.get_content_type(), 'text/plain')
    2:         eq(msg.get_params(), None)
    2:         eq(msg.get_param('charset'), None)
    2:         self._idempotent(msg, text)
       
    1:     def test_simple_multipart(self):
    2:         msg, text = self._msgobj('msg_04.txt')
    2:         self._idempotent(msg, text)
       
    1:     def test_MIME_digest(self):
    2:         msg, text = self._msgobj('msg_02.txt')
    2:         self._idempotent(msg, text)
       
    1:     def test_long_header(self):
    2:         msg, text = self._msgobj('msg_27.txt')
    2:         self._idempotent(msg, text)
       
    1:     def test_MIME_digest_with_part_headers(self):
    2:         msg, text = self._msgobj('msg_28.txt')
    2:         self._idempotent(msg, text)
       
    1:     def test_mixed_with_image(self):
    2:         msg, text = self._msgobj('msg_06.txt')
    2:         self._idempotent(msg, text)
       
    1:     def test_multipart_report(self):
    2:         msg, text = self._msgobj('msg_05.txt')
    2:         self._idempotent(msg, text)
       
    1:     def test_dsn(self):
    2:         msg, text = self._msgobj('msg_16.txt')
    2:         self._idempotent(msg, text)
       
    1:     def test_preamble_epilogue(self):
    2:         msg, text = self._msgobj('msg_21.txt')
    2:         self._idempotent(msg, text)
       
    1:     def test_multipart_one_part(self):
    2:         msg, text = self._msgobj('msg_23.txt')
    2:         self._idempotent(msg, text)
       
    1:     def test_multipart_no_parts(self):
    2:         msg, text = self._msgobj('msg_24.txt')
    2:         self._idempotent(msg, text)
       
    1:     def test_no_start_boundary(self):
    2:         msg, text = self._msgobj('msg_31.txt')
    2:         self._idempotent(msg, text)
       
    1:     def test_rfc2231_charset(self):
    2:         msg, text = self._msgobj('msg_32.txt')
    2:         self._idempotent(msg, text)
       
    1:     def test_more_rfc2231_parameters(self):
    2:         msg, text = self._msgobj('msg_33.txt')
    2:         self._idempotent(msg, text)
       
    1:     def test_text_plain_in_a_multipart_digest(self):
    2:         msg, text = self._msgobj('msg_34.txt')
    2:         self._idempotent(msg, text)
       
    1:     def test_nested_multipart_mixeds(self):
    2:         msg, text = self._msgobj('msg_12a.txt')
    2:         self._idempotent(msg, text)
       
    1:     def test_message_external_body_idempotent(self):
    2:         msg, text = self._msgobj('msg_36.txt')
    2:         self._idempotent(msg, text)
       
    1:     def test_content_type(self):
    2:         eq = self.assertEqual
               # Get a message object and reset the seek pointer for other tests
    2:         msg, text = self._msgobj('msg_05.txt')
    2:         eq(msg.get_content_type(), 'multipart/report')
               # Test the Content-Type: parameters
    2:         params = {}
    8:         for pk, pv in msg.get_params():
    6:             params[pk] = pv
    2:         eq(params['report-type'], 'delivery-status')
    2:         eq(params['boundary'], 'D1690A7AC1.996856090/mail.example.com')
    2:         eq(msg.preamble, 'This is a MIME-encapsulated message.\n')
    2:         eq(msg.epilogue, '\n')
    2:         eq(len(msg.get_payload()), 3)
               # Make sure the subparts are what we expect
    2:         msg1 = msg.get_payload(0)
    2:         eq(msg1.get_content_type(), 'text/plain')
    2:         eq(msg1.get_payload(), 'Yadda yadda yadda\n')
    2:         msg2 = msg.get_payload(1)
    2:         eq(msg2.get_content_type(), 'text/plain')
    2:         eq(msg2.get_payload(), 'Yadda yadda yadda\n')
    2:         msg3 = msg.get_payload(2)
    2:         eq(msg3.get_content_type(), 'message/rfc822')
    2:         self.assertIsInstance(msg3, Message)
    2:         payload = msg3.get_payload()
    2:         self.assertIsInstance(payload, list)
    2:         eq(len(payload), 1)
    2:         msg4 = payload[0]
    2:         self.assertIsInstance(msg4, Message)
    2:         eq(msg4.get_payload(), 'Yadda yadda yadda\n')
       
    1:     def test_parser(self):
    2:         eq = self.assertEqual
    2:         msg, text = self._msgobj('msg_06.txt')
               # Check some of the outer headers
    2:         eq(msg.get_content_type(), 'message/rfc822')
               # Make sure the payload is a list of exactly one sub-Message, and that
               # that submessage has a type of text/plain
    2:         payload = msg.get_payload()
    2:         self.assertIsInstance(payload, list)
    2:         eq(len(payload), 1)
    2:         msg1 = payload[0]
    2:         self.assertIsInstance(msg1, Message)
    2:         eq(msg1.get_content_type(), 'text/plain')
    2:         self.assertIsInstance(msg1.get_payload(), str)
    2:         eq(msg1.get_payload(), '\n')
       
       
       
       # Test various other bits of the package's functionality
    2: class TestMiscellaneous(TestEmailBase):
    1:     def test_message_from_string(self):
    2:         fp = openfile('msg_01.txt')
    2:         try:
    2:             text = fp.read()
               finally:
    2:             fp.close()
    2:         msg = email.message_from_string(text)
    2:         s = StringIO()
               # Don't wrap/continue long headers since we're trying to test
               # idempotency.
    2:         g = Generator(s, maxheaderlen=0)
    2:         g.flatten(msg)
    2:         self.assertEqual(text, s.getvalue())
       
    1:     def test_message_from_file(self):
    2:         fp = openfile('msg_01.txt')
    2:         try:
    2:             text = fp.read()
    2:             fp.seek(0)
    2:             msg = email.message_from_file(fp)
    2:             s = StringIO()
                   # Don't wrap/continue long headers since we're trying to test
                   # idempotency.
    2:             g = Generator(s, maxheaderlen=0)
    2:             g.flatten(msg)
    2:             self.assertEqual(text, s.getvalue())
               finally:
    2:             fp.close()
       
    1:     def test_message_from_string_with_class(self):
    2:         fp = openfile('msg_01.txt')
    2:         try:
    2:             text = fp.read()
               finally:
    2:             fp.close()
               # Create a subclass
    4:         class MyMessage(Message):
    2:             pass
       
    2:         msg = email.message_from_string(text, MyMessage)
    2:         self.assertIsInstance(msg, MyMessage)
               # Try something more complicated
    2:         fp = openfile('msg_02.txt')
    2:         try:
    2:             text = fp.read()
               finally:
    2:             fp.close()
    2:         msg = email.message_from_string(text, MyMessage)
   32:         for subpart in msg.walk():
   30:             self.assertIsInstance(subpart, MyMessage)
       
    1:     def test_message_from_file_with_class(self):
               # Create a subclass
    4:         class MyMessage(Message):
    2:             pass
       
    2:         fp = openfile('msg_01.txt')
    2:         try:
    2:             msg = email.message_from_file(fp, MyMessage)
               finally:
    2:             fp.close()
    2:         self.assertIsInstance(msg, MyMessage)
               # Try something more complicated
    2:         fp = openfile('msg_02.txt')
    2:         try:
    2:             msg = email.message_from_file(fp, MyMessage)
               finally:
    2:             fp.close()
   32:         for subpart in msg.walk():
   30:             self.assertIsInstance(subpart, MyMessage)
       
    1:     def test__all__(self):
    2:         module = __import__('email')
               # Can't use sorted() here due to Python 2.3 compatibility
    2:         all = module.__all__[:]
    2:         all.sort()
    2:         self.assertEqual(all, [
                   # Old names
    2:             'Charset', 'Encoders', 'Errors', 'Generator',
    2:             'Header', 'Iterators', 'MIMEAudio', 'MIMEBase',
    2:             'MIMEImage', 'MIMEMessage', 'MIMEMultipart',
    2:             'MIMENonMultipart', 'MIMEText', 'Message',
    2:             'Parser', 'Utils', 'base64MIME',
                   # new names
    2:             'base64mime', 'charset', 'encoders', 'errors', 'generator',
    2:             'header', 'iterators', 'message', 'message_from_file',
    2:             'message_from_string', 'mime', 'parser',
    2:             'quopriMIME', 'quoprimime', 'utils',
                   ])
       
    1:     def test_formatdate(self):
    2:         now = time.time()
    2:         self.assertEqual(utils.parsedate(utils.formatdate(now))[:6],
    2:                          time.gmtime(now)[:6])
       
    1:     def test_formatdate_localtime(self):
    2:         now = time.time()
    2:         self.assertEqual(
    2:             utils.parsedate(utils.formatdate(now, localtime=True))[:6],
    2:             time.localtime(now)[:6])
       
    1:     def test_formatdate_usegmt(self):
    2:         now = time.time()
    2:         self.assertEqual(
    2:             utils.formatdate(now, localtime=False),
    2:             time.strftime('%a, %d %b %Y %H:%M:%S -0000', time.gmtime(now)))
    2:         self.assertEqual(
    2:             utils.formatdate(now, localtime=False, usegmt=True),
    2:             time.strftime('%a, %d %b %Y %H:%M:%S GMT', time.gmtime(now)))
       
    1:     def test_parsedate_none(self):
    2:         self.assertEqual(utils.parsedate(''), None)
       
    1:     def test_parsedate_compact(self):
               # The FWS after the comma is optional
    2:         self.assertEqual(utils.parsedate('Wed,3 Apr 2002 14:58:26 +0800'),
    2:                          utils.parsedate('Wed, 3 Apr 2002 14:58:26 +0800'))
       
    1:     def test_parsedate_no_dayofweek(self):
    2:         eq = self.assertEqual
    2:         eq(utils.parsedate_tz('25 Feb 2003 13:47:26 -0800'),
    2:            (2003, 2, 25, 13, 47, 26, 0, 1, -1, -28800))
       
    1:     def test_parsedate_compact_no_dayofweek(self):
    2:         eq = self.assertEqual
    2:         eq(utils.parsedate_tz('5 Feb 2003 13:47:26 -0800'),
    2:            (2003, 2, 5, 13, 47, 26, 0, 1, -1, -28800))
       
    1:     def test_parsedate_acceptable_to_time_functions(self):
    2:         eq = self.assertEqual
    2:         timetup = utils.parsedate('5 Feb 2003 13:47:26 -0800')
    2:         t = int(time.mktime(timetup))
    2:         eq(time.localtime(t)[:6], timetup[:6])
    2:         eq(int(time.strftime('%Y', timetup)), 2003)
    2:         timetup = utils.parsedate_tz('5 Feb 2003 13:47:26 -0800')
    2:         t = int(time.mktime(timetup[:9]))
    2:         eq(time.localtime(t)[:6], timetup[:6])
    2:         eq(int(time.strftime('%Y', timetup[:9])), 2003)
       
    1:     def test_parseaddr_empty(self):
    2:         self.assertEqual(utils.parseaddr('<>'), ('', ''))
    2:         self.assertEqual(utils.formataddr(utils.parseaddr('<>')), '')
       
    1:     def test_noquote_dump(self):
    2:         self.assertEqual(
    2:             utils.formataddr(('A Silly Person', 'person@dom.ain')),
    2:             'A Silly Person <person@dom.ain>')
       
    1:     def test_escape_dump(self):
    2:         self.assertEqual(
    2:             utils.formataddr(('A (Very) Silly Person', 'person@dom.ain')),
    2:             r'"A \(Very\) Silly Person" <person@dom.ain>')
    2:         a = r'A \(Special\) Person'
    2:         b = 'person@dom.ain'
    2:         self.assertEqual(utils.parseaddr(utils.formataddr((a, b))), (a, b))
       
    1:     def test_escape_backslashes(self):
    2:         self.assertEqual(
    2:             utils.formataddr(('Arthur \Backslash\ Foobar', 'person@dom.ain')),
    2:             r'"Arthur \\Backslash\\ Foobar" <person@dom.ain>')
    2:         a = r'Arthur \Backslash\ Foobar'
    2:         b = 'person@dom.ain'
    2:         self.assertEqual(utils.parseaddr(utils.formataddr((a, b))), (a, b))
       
    1:     def test_name_with_dot(self):
    2:         x = 'John X. Doe <jxd@example.com>'
    2:         y = '"John X. Doe" <jxd@example.com>'
    2:         a, b = ('John X. Doe', 'jxd@example.com')
    2:         self.assertEqual(utils.parseaddr(x), (a, b))
    2:         self.assertEqual(utils.parseaddr(y), (a, b))
               # formataddr() quotes the name if there's a dot in it
    2:         self.assertEqual(utils.formataddr((a, b)), y)
       
    1:     def test_multiline_from_comment(self):
               x = """\
       Foo
    2: \tBar <foo@example.com>"""
    2:         self.assertEqual(utils.parseaddr(x), ('Foo Bar', 'foo@example.com'))
       
    1:     def test_quote_dump(self):
    2:         self.assertEqual(
    2:             utils.formataddr(('A Silly; Person', 'person@dom.ain')),
    2:             r'"A Silly; Person" <person@dom.ain>')
       
    1:     def test_fix_eols(self):
    2:         eq = self.assertEqual
    2:         eq(utils.fix_eols('hello'), 'hello')
    2:         eq(utils.fix_eols('hello\n'), 'hello\r\n')
    2:         eq(utils.fix_eols('hello\r'), 'hello\r\n')
    2:         eq(utils.fix_eols('hello\r\n'), 'hello\r\n')
    2:         eq(utils.fix_eols('hello\n\r'), 'hello\r\n\r\n')
       
    1:     def test_charset_richcomparisons(self):
    2:         eq = self.assertEqual
    2:         ne = self.assertNotEqual
    2:         cset1 = Charset()
    2:         cset2 = Charset()
    2:         eq(cset1, 'us-ascii')
    2:         eq(cset1, 'US-ASCII')
    2:         eq(cset1, 'Us-AsCiI')
    2:         eq('us-ascii', cset1)
    2:         eq('US-ASCII', cset1)
    2:         eq('Us-AsCiI', cset1)
    2:         ne(cset1, 'usascii')
    2:         ne(cset1, 'USASCII')
    2:         ne(cset1, 'UsAsCiI')
    2:         ne('usascii', cset1)
    2:         ne('USASCII', cset1)
    2:         ne('UsAsCiI', cset1)
    2:         eq(cset1, cset2)
    2:         eq(cset2, cset1)
       
    1:     def test_getaddresses(self):
    2:         eq = self.assertEqual
    2:         eq(utils.getaddresses(['aperson@dom.ain (Al Person)',
    2:                                'Bud Person <bperson@dom.ain>']),
    2:            [('Al Person', 'aperson@dom.ain'),
    2:             ('Bud Person', 'bperson@dom.ain')])
       
    1:     def test_getaddresses_nasty(self):
    2:         eq = self.assertEqual
    2:         eq(utils.getaddresses(['foo: ;']), [('', '')])
    2:         eq(utils.getaddresses(
    2:            ['[]*-- =~$']),
    2:            [('', ''), ('', ''), ('', '*--')])
    2:         eq(utils.getaddresses(
    2:            ['foo: ;', '"Jason R. Mastaler" <jason@dom.ain>']),
    2:            [('', ''), ('Jason R. Mastaler', 'jason@dom.ain')])
       
    1:     def test_getaddresses_embedded_comment(self):
               """Test proper handling of a nested comment"""
    2:         eq = self.assertEqual
    2:         addrs = utils.getaddresses(['User ((nested comment)) <foo@bar.com>'])
    2:         eq(addrs[0][1], 'foo@bar.com')
       
    1:     def test_utils_quote_unquote(self):
    2:         eq = self.assertEqual
    2:         msg = Message()
    2:         msg.add_header('content-disposition', 'attachment',
    2:                        filename='foo\\wacky"name')
    2:         eq(msg.get_filename(), 'foo\\wacky"name')
       
    1:     def test_get_body_encoding_with_bogus_charset(self):
    2:         charset = Charset('not a charset')
    2:         self.assertEqual(charset.get_body_encoding(), 'base64')
       
    1:     def test_get_body_encoding_with_uppercase_charset(self):
    2:         eq = self.assertEqual
    2:         msg = Message()
    2:         msg['Content-Type'] = 'text/plain; charset=UTF-8'
    2:         eq(msg['content-type'], 'text/plain; charset=UTF-8')
    2:         charsets = msg.get_charsets()
    2:         eq(len(charsets), 1)
    2:         eq(charsets[0], 'utf-8')
    2:         charset = Charset(charsets[0])
    2:         eq(charset.get_body_encoding(), 'base64')
    2:         msg.set_payload('hello world', charset=charset)
    2:         eq(msg.get_payload(), 'aGVsbG8gd29ybGQ=\n')
    2:         eq(msg.get_payload(decode=True), 'hello world')
    2:         eq(msg['content-transfer-encoding'], 'base64')
               # Try another one
    2:         msg = Message()
    2:         msg['Content-Type'] = 'text/plain; charset="US-ASCII"'
    2:         charsets = msg.get_charsets()
    2:         eq(len(charsets), 1)
    2:         eq(charsets[0], 'us-ascii')
    2:         charset = Charset(charsets[0])
    2:         eq(charset.get_body_encoding(), encoders.encode_7or8bit)
    2:         msg.set_payload('hello world', charset=charset)
    2:         eq(msg.get_payload(), 'hello world')
    2:         eq(msg['content-transfer-encoding'], '7bit')
       
    1:     def test_charsets_case_insensitive(self):
    2:         lc = Charset('us-ascii')
    2:         uc = Charset('US-ASCII')
    2:         self.assertEqual(lc.get_body_encoding(), uc.get_body_encoding())
       
    1:     def test_partial_falls_inside_message_delivery_status(self):
    2:         eq = self.ndiffAssertEqual
               # The Parser interface provides chunks of data to FeedParser in 8192
               # byte gulps.  SF bug #1076485 found one of those chunks inside
               # message/delivery-status header block, which triggered an
               # unreadline() of NeedMoreData.
    2:         msg = self._msgobj('msg_43.txt')
    2:         sfp = StringIO()
    2:         iterators._structure(msg, sfp)
    2:         eq(sfp.getvalue(), """\
       multipart/report
           text/plain
           message/delivery-status
               text/plain
               text/plain
               text/plain
               text/plain
               text/plain
               text/plain
               text/plain
               text/plain
               text/plain
               text/plain
               text/plain
               text/plain
               text/plain
               text/plain
               text/plain
               text/plain
               text/plain
               text/plain
               text/plain
               text/plain
               text/plain
               text/plain
               text/plain
               text/plain
               text/plain
               text/plain
           text/rfc822-headers
    2: """)
       
       
       
       # Test the iterator/generators
    2: class TestIterators(TestEmailBase):
    1:     def test_body_line_iterator(self):
    2:         eq = self.assertEqual
    2:         neq = self.ndiffAssertEqual
               # First a simple non-multipart message
    2:         msg = self._msgobj('msg_01.txt')
    2:         it = iterators.body_line_iterator(msg)
    2:         lines = list(it)
    2:         eq(len(lines), 6)
    2:         neq(EMPTYSTRING.join(lines), msg.get_payload())
               # Now a more complicated multipart
    2:         msg = self._msgobj('msg_02.txt')
    2:         it = iterators.body_line_iterator(msg)
    2:         lines = list(it)
    2:         eq(len(lines), 43)
    2:         fp = openfile('msg_19.txt')
    2:         try:
    2:             neq(EMPTYSTRING.join(lines), fp.read())
               finally:
    2:             fp.close()
       
    1:     def test_typed_subpart_iterator(self):
    2:         eq = self.assertEqual
    2:         msg = self._msgobj('msg_04.txt')
    2:         it = iterators.typed_subpart_iterator(msg, 'text')
    2:         lines = []
    2:         subparts = 0
    6:         for subpart in it:
    4:             subparts += 1
    4:             lines.append(subpart.get_payload())
    2:         eq(subparts, 2)
    2:         eq(EMPTYSTRING.join(lines), """\
       a simple kind of mirror
       to reflect upon our own
       a simple kind of mirror
       to reflect upon our own
    2: """)
       
    1:     def test_typed_subpart_iterator_default_type(self):
    2:         eq = self.assertEqual
    2:         msg = self._msgobj('msg_03.txt')
    2:         it = iterators.typed_subpart_iterator(msg, 'text', 'plain')
    2:         lines = []
    2:         subparts = 0
    4:         for subpart in it:
    2:             subparts += 1
    2:             lines.append(subpart.get_payload())
    2:         eq(subparts, 1)
    2:         eq(EMPTYSTRING.join(lines), """\
       
       Hi,
       
       Do you like this message?
       
       -Me
    2: """)
       
       
       
    2: class TestParsers(TestEmailBase):
    1:     def test_header_parser(self):
    2:         eq = self.assertEqual
               # Parse only the headers of a complex multipart MIME document
    2:         fp = openfile('msg_02.txt')
    2:         try:
    2:             msg = HeaderParser().parse(fp)
               finally:
    2:             fp.close()
    2:         eq(msg['from'], 'ppp-request@zzz.org')
    2:         eq(msg['to'], 'ppp@zzz.org')
    2:         eq(msg.get_content_type(), 'multipart/mixed')
    2:         self.assertFalse(msg.is_multipart())
    2:         self.assertIsInstance(msg.get_payload(), str)
       
    1:     def test_whitespace_continuation(self):
    2:         eq = self.assertEqual
               # This message contains a line after the Subject: header that has only
               # whitespace, but it is not empty!
    2:         msg = email.message_from_string("""\
       From: aperson@dom.ain
       To: bperson@dom.ain
       Subject: the next line has a space on it
       \x20
       Date: Mon, 8 Apr 2002 15:09:19 -0400
       Message-ID: spam
       
       Here's the message body
    2: """)
    2:         eq(msg['subject'], 'the next line has a space on it\n ')
    2:         eq(msg['message-id'], 'spam')
    2:         eq(msg.get_payload(), "Here's the message body\n")
       
    1:     def test_whitespace_continuation_last_header(self):
    2:         eq = self.assertEqual
               # Like the previous test, but the subject line is the last
               # header.
    2:         msg = email.message_from_string("""\
       From: aperson@dom.ain
       To: bperson@dom.ain
       Date: Mon, 8 Apr 2002 15:09:19 -0400
       Message-ID: spam
       Subject: the next line has a space on it
       \x20
       
       Here's the message body
    2: """)
    2:         eq(msg['subject'], 'the next line has a space on it\n ')
    2:         eq(msg['message-id'], 'spam')
    2:         eq(msg.get_payload(), "Here's the message body\n")
       
    1:     def test_crlf_separation(self):
    2:         eq = self.assertEqual
    2:         fp = openfile('msg_26.txt', mode='rb')
    2:         try:
    2:             msg = Parser().parse(fp)
               finally:
    2:             fp.close()
    2:         eq(len(msg.get_payload()), 2)
    2:         part1 = msg.get_payload(0)
    2:         eq(part1.get_content_type(), 'text/plain')
    2:         eq(part1.get_payload(), 'Simple email with attachment.\r\n\r\n')
    2:         part2 = msg.get_payload(1)
    2:         eq(part2.get_content_type(), 'application/riscos')
       
    1:     def test_multipart_digest_with_extra_mime_headers(self):
    2:         eq = self.assertEqual
    2:         neq = self.ndiffAssertEqual
    2:         fp = openfile('msg_28.txt')
    2:         try:
    2:             msg = email.message_from_file(fp)
               finally:
    2:             fp.close()
               # Structure is:
               # multipart/digest
               #   message/rfc822
               #     text/plain
               #   message/rfc822
               #     text/plain
    2:         eq(msg.is_multipart(), 1)
    2:         eq(len(msg.get_payload()), 2)
    2:         part1 = msg.get_payload(0)
    2:         eq(part1.get_content_type(), 'message/rfc822')
    2:         eq(part1.is_multipart(), 1)
    2:         eq(len(part1.get_payload()), 1)
    2:         part1a = part1.get_payload(0)
    2:         eq(part1a.is_multipart(), 0)
    2:         eq(part1a.get_content_type(), 'text/plain')
    2:         neq(part1a.get_payload(), 'message 1\n')
               # next message/rfc822
    2:         part2 = msg.get_payload(1)
    2:         eq(part2.get_content_type(), 'message/rfc822')
    2:         eq(part2.is_multipart(), 1)
    2:         eq(len(part2.get_payload()), 1)
    2:         part2a = part2.get_payload(0)
    2:         eq(part2a.is_multipart(), 0)
    2:         eq(part2a.get_content_type(), 'text/plain')
    2:         neq(part2a.get_payload(), 'message 2\n')
       
    1:     def test_three_lines(self):
               # A bug report by Andrew McNamara
    2:         lines = ['From: Andrew Person <aperson@dom.ain',
    2:                  'Subject: Test',
    2:                  'Date: Tue, 20 Aug 2002 16:43:45 +1000']
    2:         msg = email.message_from_string(NL.join(lines))
    2:         self.assertEqual(msg['date'], 'Tue, 20 Aug 2002 16:43:45 +1000')
       
    1:     def test_strip_line_feed_and_carriage_return_in_headers(self):
    2:         eq = self.assertEqual
               # For [ 1002475 ] email message parser doesn't handle \r\n correctly
    2:         value1 = 'text'
    2:         value2 = 'more text'
    2:         m = 'Header: %s\r\nNext-Header: %s\r\n\r\nBody\r\n\r\n' % (
    2:             value1, value2)
    2:         msg = email.message_from_string(m)
    2:         eq(msg.get('Header'), value1)
    2:         eq(msg.get('Next-Header'), value2)
       
    1:     def test_rfc2822_header_syntax(self):
    2:         eq = self.assertEqual
    2:         m = '>From: foo\nFrom: bar\n!"#QUX;~: zoo\n\nbody'
    2:         msg = email.message_from_string(m)
    2:         eq(len(msg.keys()), 3)
    2:         keys = msg.keys()
    2:         keys.sort()
    2:         eq(keys, ['!"#QUX;~', '>From', 'From'])
    2:         eq(msg.get_payload(), 'body')
       
    1:     def test_rfc2822_space_not_allowed_in_header(self):
    2:         eq = self.assertEqual
    2:         m = '>From foo@example.com 11:25:53\nFrom: bar\n!"#QUX;~: zoo\n\nbody'
    2:         msg = email.message_from_string(m)
    2:         eq(len(msg.keys()), 0)
       
    1:     def test_rfc2822_one_character_header(self):
    2:         eq = self.assertEqual
    2:         m = 'A: first header\nB: second header\nCC: third header\n\nbody'
    2:         msg = email.message_from_string(m)
    2:         headers = msg.keys()
    2:         headers.sort()
    2:         eq(headers, ['A', 'B', 'CC'])
    2:         eq(msg.get_payload(), 'body')
       
       
       
    2: class TestBase64(unittest.TestCase):
    1:     def test_len(self):
    2:         eq = self.assertEqual
    2:         eq(base64mime.base64_len('hello'),
    2:            len(base64mime.encode('hello', eol='')))
   32:         for size in range(15):
   30:             if   size == 0 : bsize = 0
   28:             elif size <= 3 : bsize = 4
   22:             elif size <= 6 : bsize = 8
   16:             elif size <= 9 : bsize = 12
   10:             elif size <= 12: bsize = 16
    4:             else           : bsize = 20
   30:             eq(base64mime.base64_len('x'*size), bsize)
       
    1:     def test_decode(self):
    2:         eq = self.assertEqual
    2:         eq(base64mime.decode(''), '')
    2:         eq(base64mime.decode('aGVsbG8='), 'hello')
    2:         eq(base64mime.decode('aGVsbG8=', 'X'), 'hello')
    2:         eq(base64mime.decode('aGVsbG8NCndvcmxk\n', 'X'), 'helloXworld')
       
    1:     def test_encode(self):
    2:         eq = self.assertEqual
    2:         eq(base64mime.encode(''), '')
    2:         eq(base64mime.encode('hello'), 'aGVsbG8=\n')
               # Test the binary flag
    2:         eq(base64mime.encode('hello\n'), 'aGVsbG8K\n')
    2:         eq(base64mime.encode('hello\n', 0), 'aGVsbG8NCg==\n')
               # Test the maxlinelen arg
    2:         eq(base64mime.encode('xxxx ' * 20, maxlinelen=40), """\
       eHh4eCB4eHh4IHh4eHggeHh4eCB4eHh4IHh4eHgg
       eHh4eCB4eHh4IHh4eHggeHh4eCB4eHh4IHh4eHgg
       eHh4eCB4eHh4IHh4eHggeHh4eCB4eHh4IHh4eHgg
       eHh4eCB4eHh4IA==
    2: """)
               # Test the eol argument
    2:         eq(base64mime.encode('xxxx ' * 20, maxlinelen=40, eol='\r\n'), """\
       eHh4eCB4eHh4IHh4eHggeHh4eCB4eHh4IHh4eHgg\r
       eHh4eCB4eHh4IHh4eHggeHh4eCB4eHh4IHh4eHgg\r
       eHh4eCB4eHh4IHh4eHggeHh4eCB4eHh4IHh4eHgg\r
       eHh4eCB4eHh4IA==\r
    2: """)
       
    1:     def test_header_encode(self):
    2:         eq = self.assertEqual
    2:         he = base64mime.header_encode
    2:         eq(he('hello'), '=?iso-8859-1?b?aGVsbG8=?=')
    2:         eq(he('hello\nworld'), '=?iso-8859-1?b?aGVsbG8NCndvcmxk?=')
               # Test the charset option
    2:         eq(he('hello', charset='iso-8859-2'), '=?iso-8859-2?b?aGVsbG8=?=')
               # Test the keep_eols flag
    2:         eq(he('hello\nworld', keep_eols=True),
    2:            '=?iso-8859-1?b?aGVsbG8Kd29ybGQ=?=')
               # Test the maxlinelen argument
    2:         eq(he('xxxx ' * 20, maxlinelen=40), """\
       =?iso-8859-1?b?eHh4eCB4eHh4IHh4eHggeHg=?=
        =?iso-8859-1?b?eHggeHh4eCB4eHh4IHh4eHg=?=
        =?iso-8859-1?b?IHh4eHggeHh4eCB4eHh4IHg=?=
        =?iso-8859-1?b?eHh4IHh4eHggeHh4eCB4eHg=?=
        =?iso-8859-1?b?eCB4eHh4IHh4eHggeHh4eCA=?=
    2:  =?iso-8859-1?b?eHh4eCB4eHh4IHh4eHgg?=""")
               # Test the eol argument
    2:         eq(he('xxxx ' * 20, maxlinelen=40, eol='\r\n'), """\
       =?iso-8859-1?b?eHh4eCB4eHh4IHh4eHggeHg=?=\r
        =?iso-8859-1?b?eHggeHh4eCB4eHh4IHh4eHg=?=\r
        =?iso-8859-1?b?IHh4eHggeHh4eCB4eHh4IHg=?=\r
        =?iso-8859-1?b?eHh4IHh4eHggeHh4eCB4eHg=?=\r
        =?iso-8859-1?b?eCB4eHh4IHh4eHggeHh4eCA=?=\r
    2:  =?iso-8859-1?b?eHh4eCB4eHh4IHh4eHgg?=""")
       
       
       
    2: class TestQuopri(unittest.TestCase):
    1:     def setUp(self):
               self.hlit = [chr(x) for x in range(ord('a'), ord('z')+1)] + \
                           [chr(x) for x in range(ord('A'), ord('Z')+1)] + \
 1008:                     [chr(x) for x in range(ord('0'), ord('9')+1)] + \
   16:                     ['!', '*', '+', '-', '/', ' ']
 4112:         self.hnon = [chr(x) for x in range(256) if chr(x) not in self.hlit]
   16:         assert len(self.hlit) + len(self.hnon) == 256
 1536:         self.blit = [chr(x) for x in range(ord(' '), ord('~')+1)] + ['\t']
   16:         self.blit.remove('=')
 4112:         self.bnon = [chr(x) for x in range(256) if chr(x) not in self.blit]
   16:         assert len(self.blit) + len(self.bnon) == 256
       
    1:     def test_header_quopri_check(self):
  138:         for c in self.hlit:
  136:             self.assertFalse(quoprimime.header_quopri_check(c))
  378:         for c in self.hnon:
  376:             self.assertTrue(quoprimime.header_quopri_check(c))
       
    1:     def test_body_quopri_check(self):
  192:         for c in self.blit:
  190:             self.assertFalse(quoprimime.body_quopri_check(c))
  324:         for c in self.bnon:
  322:             self.assertTrue(quoprimime.body_quopri_check(c))
       
    1:     def test_header_quopri_len(self):
    2:         eq = self.assertEqual
    2:         hql = quoprimime.header_quopri_len
    2:         enc = quoprimime.header_encode
    6:         for s in ('hello', 'h@e@l@l@o@'):
                   # Empty charset and no line-endings.  7 == RFC chrome
    4:             eq(hql(s), len(enc(s, charset='', eol=''))-7)
  138:         for c in self.hlit:
  136:             eq(hql(c), 1)
  378:         for c in self.hnon:
  376:             eq(hql(c), 3)
       
    1:     def test_body_quopri_len(self):
    2:         eq = self.assertEqual
    2:         bql = quoprimime.body_quopri_len
  192:         for c in self.blit:
  190:             eq(bql(c), 1)
  324:         for c in self.bnon:
  322:             eq(bql(c), 3)
       
    1:     def test_quote_unquote_idempotent(self):
  514:         for x in range(256):
  512:             c = chr(x)
  512:             self.assertEqual(quoprimime.unquote(quoprimime.quote(c)), c)
       
    1:     def test_header_encode(self):
    2:         eq = self.assertEqual
    2:         he = quoprimime.header_encode
    2:         eq(he('hello'), '=?iso-8859-1?q?hello?=')
    2:         eq(he('hello\nworld'), '=?iso-8859-1?q?hello=0D=0Aworld?=')
               # Test the charset option
    2:         eq(he('hello', charset='iso-8859-2'), '=?iso-8859-2?q?hello?=')
               # Test the keep_eols flag
    2:         eq(he('hello\nworld', keep_eols=True), '=?iso-8859-1?q?hello=0Aworld?=')
               # Test a non-ASCII character
    2:         eq(he('hello\xc7there'), '=?iso-8859-1?q?hello=C7there?=')
               # Test the maxlinelen argument
    2:         eq(he('xxxx ' * 20, maxlinelen=40), """\
       =?iso-8859-1?q?xxxx_xxxx_xxxx_xxxx_xx?=
        =?iso-8859-1?q?xx_xxxx_xxxx_xxxx_xxxx?=
        =?iso-8859-1?q?_xxxx_xxxx_xxxx_xxxx_x?=
        =?iso-8859-1?q?xxx_xxxx_xxxx_xxxx_xxx?=
    2:  =?iso-8859-1?q?x_xxxx_xxxx_?=""")
               # Test the eol argument
    2:         eq(he('xxxx ' * 20, maxlinelen=40, eol='\r\n'), """\
       =?iso-8859-1?q?xxxx_xxxx_xxxx_xxxx_xx?=\r
        =?iso-8859-1?q?xx_xxxx_xxxx_xxxx_xxxx?=\r
        =?iso-8859-1?q?_xxxx_xxxx_xxxx_xxxx_x?=\r
        =?iso-8859-1?q?xxx_xxxx_xxxx_xxxx_xxx?=\r
    2:  =?iso-8859-1?q?x_xxxx_xxxx_?=""")
       
    1:     def test_decode(self):
    2:         eq = self.assertEqual
    2:         eq(quoprimime.decode(''), '')
    2:         eq(quoprimime.decode('hello'), 'hello')
    2:         eq(quoprimime.decode('hello', 'X'), 'hello')
    2:         eq(quoprimime.decode('hello\nworld', 'X'), 'helloXworld')
       
    1:     def test_encode(self):
    2:         eq = self.assertEqual
    2:         eq(quoprimime.encode(''), '')
    2:         eq(quoprimime.encode('hello'), 'hello')
               # Test the binary flag
    2:         eq(quoprimime.encode('hello\r\nworld'), 'hello\nworld')
    2:         eq(quoprimime.encode('hello\r\nworld', 0), 'hello\nworld')
               # Test the maxlinelen arg
    2:         eq(quoprimime.encode('xxxx ' * 20, maxlinelen=40), """\
       xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx=
        xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxx=
    2: x xxxx xxxx xxxx xxxx=20""")
               # Test the eol argument
    2:         eq(quoprimime.encode('xxxx ' * 20, maxlinelen=40, eol='\r\n'), """\
       xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx=\r
        xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxx=\r
    2: x xxxx xxxx xxxx xxxx=20""")
    2:         eq(quoprimime.encode("""\
       one line
       
    2: two line"""), """\
       one line
       
    2: two line""")
       
       
       
       # Test the Charset class
    2: class TestCharset(unittest.TestCase):
    1:     def tearDown(self):
    6:         from email import charset as CharsetModule
    6:         try:
    6:             del CharsetModule.CHARSETS['fake']
    4:         except KeyError:
    4:             pass
       
    1:     def test_idempotent(self):
    2:         eq = self.assertEqual
               # Make sure us-ascii = no Unicode conversion
    2:         c = Charset('us-ascii')
    2:         s = 'Hello World!'
    2:         sp = c.to_splittable(s)
    2:         eq(s, c.from_splittable(sp))
               # test 8-bit idempotency with us-ascii
    2:         s = '\xa4\xa2\xa4\xa4\xa4\xa6\xa4\xa8\xa4\xaa'
    2:         sp = c.to_splittable(s)
    2:         eq(s, c.from_splittable(sp))
       
    1:     def test_body_encode(self):
    2:         eq = self.assertEqual
               # Try a charset with QP body encoding
    2:         c = Charset('iso-8859-1')
    2:         eq('hello w=F6rld', c.body_encode('hello w\xf6rld'))
               # Try a charset with Base64 body encoding
    2:         c = Charset('utf-8')
    2:         eq('aGVsbG8gd29ybGQ=\n', c.body_encode('hello world'))
               # Try a charset with None body encoding
    2:         c = Charset('us-ascii')
    2:         eq('hello world', c.body_encode('hello world'))
               # Try the convert argument, where input codec != output codec
    2:         c = Charset('euc-jp')
               # With apologies to Tokio Kikuchi ;)
    2:         try:
    2:             eq('\x1b$B5FCO;~IW\x1b(B',
    2:                c.body_encode('\xb5\xc6\xc3\xcf\xbb\xfe\xc9\xd7'))
    2:             eq('\xb5\xc6\xc3\xcf\xbb\xfe\xc9\xd7',
    2:                c.body_encode('\xb5\xc6\xc3\xcf\xbb\xfe\xc9\xd7', False))
>>>>>>         except LookupError:
                   # We probably don't have the Japanese codecs installed
>>>>>>             pass
               # Testing SF bug #625509, which we have to fake, since there are no
               # built-in encodings where the header encoding is QP but the body
               # encoding is not.
    2:         from email import charset as CharsetModule
    2:         CharsetModule.add_charset('fake', CharsetModule.QP, None)
    2:         c = Charset('fake')
    2:         eq('hello w\xf6rld', c.body_encode('hello w\xf6rld'))
       
    1:     def test_unicode_charset_name(self):
    2:         charset = Charset(u'us-ascii')
    2:         self.assertEqual(str(charset), 'us-ascii')
    2:         self.assertRaises(errors.CharsetError, Charset, 'asc\xffii')
       
       
       
       # Test multilingual MIME headers.
    2: class TestHeader(TestEmailBase):
    1:     def test_simple(self):
    2:         eq = self.ndiffAssertEqual
    2:         h = Header('Hello World!')
    2:         eq(h.encode(), 'Hello World!')
    2:         h.append(' Goodbye World!')
    2:         eq(h.encode(), 'Hello World!  Goodbye World!')
       
    1:     def test_simple_surprise(self):
    2:         eq = self.ndiffAssertEqual
    2:         h = Header('Hello World!')
    2:         eq(h.encode(), 'Hello World!')
    2:         h.append('Goodbye World!')
    2:         eq(h.encode(), 'Hello World! Goodbye World!')
       
    1:     def test_header_needs_no_decoding(self):
    2:         h = 'no decoding needed'
    2:         self.assertEqual(decode_header(h), [(h, None)])
       
    1:     def test_long(self):
    2:         h = Header("I am the very model of a modern Major-General; I've information vegetable, animal, and mineral; I know the kings of England, and I quote the fights historical from Marathon to Waterloo, in order categorical; I'm very well acquainted, too, with matters mathematical; I understand equations, both the simple and quadratical; about binomial theorem I'm teeming with a lot o' news, with many cheerful facts about the square of the hypotenuse.",
    2:                    maxlinelen=76)
   14:         for l in h.encode(splitchars=' ').split('\n '):
   12:             self.assertLessEqual(len(l), 76)
       
    1:     def test_multilingual(self):
    2:         eq = self.ndiffAssertEqual
    2:         g = Charset("iso-8859-1")
    2:         cz = Charset("iso-8859-2")
    2:         utf8 = Charset("utf-8")
    2:         g_head = "Die Mieter treten hier ein werden mit einem Foerderband komfortabel den Korridor entlang, an s\xfcdl\xfcndischen Wandgem\xe4lden vorbei, gegen die rotierenden Klingen bef\xf6rdert. "
    2:         cz_head = "Finan\xe8ni metropole se hroutily pod tlakem jejich d\xf9vtipu.. "
    2:         utf8_head = u"\u6b63\u78ba\u306b\u8a00\u3046\u3068\u7ffb\u8a33\u306f\u3055\u308c\u3066\u3044\u307e\u305b\u3093\u3002\u4e00\u90e8\u306f\u30c9\u30a4\u30c4\u8a9e\u3067\u3059\u304c\u3001\u3042\u3068\u306f\u3067\u305f\u3089\u3081\u3067\u3059\u3002\u5b9f\u969b\u306b\u306f\u300cWenn ist das Nunstuck git und Slotermeyer? Ja! Beiherhund das Oder die Flipperwaldt gersput.\u300d\u3068\u8a00\u3063\u3066\u3044\u307e\u3059\u3002".encode("utf-8")
    2:         h = Header(g_head, g)
    2:         h.append(cz_head, cz)
    2:         h.append(utf8_head, utf8)
    2:         enc = h.encode()
    2:         eq(enc, """\
       =?iso-8859-1?q?Die_Mieter_treten_hier_ein_werden_mit_einem_Foerderband_ko?=
        =?iso-8859-1?q?mfortabel_den_Korridor_entlang=2C_an_s=FCdl=FCndischen_Wan?=
        =?iso-8859-1?q?dgem=E4lden_vorbei=2C_gegen_die_rotierenden_Klingen_bef=F6?=
        =?iso-8859-1?q?rdert=2E_?= =?iso-8859-2?q?Finan=E8ni_metropole_se_hroutily?=
        =?iso-8859-2?q?_pod_tlakem_jejich_d=F9vtipu=2E=2E_?= =?utf-8?b?5q2j56K6?=
        =?utf-8?b?44Gr6KiA44GG44Go57+76Kiz44Gv44GV44KM44Gm44GE44G+44Gb44KT44CC?=
        =?utf-8?b?5LiA6YOo44Gv44OJ44Kk44OE6Kqe44Gn44GZ44GM44CB44GC44Go44Gv44Gn?=
        =?utf-8?b?44Gf44KJ44KB44Gn44GZ44CC5a6f6Zqb44Gr44Gv44CMV2VubiBpc3QgZGFz?=
        =?utf-8?q?_Nunstuck_git_und_Slotermeyer=3F_Ja!_Beiherhund_das_Oder_die_Fl?=
        =?utf-8?b?aXBwZXJ3YWxkdCBnZXJzcHV0LuOAjeOBqOiogOOBo+OBpuOBhOOBvuOBmQ==?=
    2:  =?utf-8?b?44CC?=""")
    2:         eq(decode_header(enc),
    2:            [(g_head, "iso-8859-1"), (cz_head, "iso-8859-2"),
    2:             (utf8_head, "utf-8")])
    2:         ustr = unicode(h)
    2:         eq(ustr.encode('utf-8'),
    2:            'Die Mieter treten hier ein werden mit einem Foerderband '
                  'komfortabel den Korridor entlang, an s\xc3\xbcdl\xc3\xbcndischen '
                  'Wandgem\xc3\xa4lden vorbei, gegen die rotierenden Klingen '
                  'bef\xc3\xb6rdert. Finan\xc4\x8dni metropole se hroutily pod '
                  'tlakem jejich d\xc5\xafvtipu.. \xe6\xad\xa3\xe7\xa2\xba\xe3\x81'
                  '\xab\xe8\xa8\x80\xe3\x81\x86\xe3\x81\xa8\xe7\xbf\xbb\xe8\xa8\xb3'
                  '\xe3\x81\xaf\xe3\x81\x95\xe3\x82\x8c\xe3\x81\xa6\xe3\x81\x84\xe3'
                  '\x81\xbe\xe3\x81\x9b\xe3\x82\x93\xe3\x80\x82\xe4\xb8\x80\xe9\x83'
                  '\xa8\xe3\x81\xaf\xe3\x83\x89\xe3\x82\xa4\xe3\x83\x84\xe8\xaa\x9e'
                  '\xe3\x81\xa7\xe3\x81\x99\xe3\x81\x8c\xe3\x80\x81\xe3\x81\x82\xe3'
                  '\x81\xa8\xe3\x81\xaf\xe3\x81\xa7\xe3\x81\x9f\xe3\x82\x89\xe3\x82'
                  '\x81\xe3\x81\xa7\xe3\x81\x99\xe3\x80\x82\xe5\xae\x9f\xe9\x9a\x9b'
                  '\xe3\x81\xab\xe3\x81\xaf\xe3\x80\x8cWenn ist das Nunstuck git '
                  'und Slotermeyer? Ja! Beiherhund das Oder die Flipperwaldt '
                  'gersput.\xe3\x80\x8d\xe3\x81\xa8\xe8\xa8\x80\xe3\x81\xa3\xe3\x81'
                  '\xa6\xe3\x81\x84\xe3\x81\xbe\xe3\x81\x99\xe3\x80\x82')
               # Test make_header()
    2:         newh = make_header(decode_header(enc))
    2:         eq(newh, enc)
       
    1:     def test_header_ctor_default_args(self):
    2:         eq = self.ndiffAssertEqual
    2:         h = Header()
    2:         eq(h, '')
    2:         h.append('foo', Charset('iso-8859-1'))
    2:         eq(h, '=?iso-8859-1?q?foo?=')
       
    1:     def test_explicit_maxlinelen(self):
    2:         eq = self.ndiffAssertEqual
    2:         hstr = 'A very long line that must get split to something other than at the 76th character boundary to test the non-default behavior'
    2:         h = Header(hstr)
    2:         eq(h.encode(), '''\
       A very long line that must get split to something other than at the 76th
    2:  character boundary to test the non-default behavior''')
    2:         h = Header(hstr, header_name='Subject')
    2:         eq(h.encode(), '''\
       A very long line that must get split to something other than at the
    2:  76th character boundary to test the non-default behavior''')
    2:         h = Header(hstr, maxlinelen=1024, header_name='Subject')
    2:         eq(h.encode(), hstr)
       
    1:     def test_us_ascii_header(self):
    2:         eq = self.assertEqual
    2:         s = 'hello'
    2:         x = decode_header(s)
    2:         eq(x, [('hello', None)])
    2:         h = make_header(x)
    2:         eq(s, h.encode())
       
    1:     def test_string_charset(self):
    2:         eq = self.assertEqual
    2:         h = Header()
    2:         h.append('hello', 'iso-8859-1')
    2:         eq(h, '=?iso-8859-1?q?hello?=')
       
       ##    def test_unicode_error(self):
       ##        raises = self.assertRaises
       ##        raises(UnicodeError, Header, u'[P\xf6stal]', 'us-ascii')
       ##        raises(UnicodeError, Header, '[P\xf6stal]', 'us-ascii')
       ##        h = Header()
       ##        raises(UnicodeError, h.append, u'[P\xf6stal]', 'us-ascii')
       ##        raises(UnicodeError, h.append, '[P\xf6stal]', 'us-ascii')
       ##        raises(UnicodeError, Header, u'\u83ca\u5730\u6642\u592b', 'iso-8859-1')
       
    1:     def test_utf8_shortest(self):
    2:         eq = self.assertEqual
    2:         h = Header(u'p\xf6stal', 'utf-8')
    2:         eq(h.encode(), '=?utf-8?q?p=C3=B6stal?=')
    2:         h = Header(u'\u83ca\u5730\u6642\u592b', 'utf-8')
    2:         eq(h.encode(), '=?utf-8?b?6I+K5Zyw5pmC5aSr?=')
       
    1:     def test_bad_8bit_header(self):
    2:         raises = self.assertRaises
    2:         eq = self.assertEqual
    2:         x = 'Ynwp4dUEbay Auction Semiar- No Charge \x96 Earn Big'
    2:         raises(UnicodeError, Header, x)
    2:         h = Header()
    2:         raises(UnicodeError, h.append, x)
    2:         eq(str(Header(x, errors='replace')), x)
    2:         h.append(x, errors='replace')
    2:         eq(str(h), x)
       
    1:     def test_encoded_adjacent_nonencoded(self):
    2:         eq = self.assertEqual
    2:         h = Header()
    2:         h.append('hello', 'iso-8859-1')
    2:         h.append('world')
    2:         s = h.encode()
    2:         eq(s, '=?iso-8859-1?q?hello?= world')
    2:         h = make_header(decode_header(s))
    2:         eq(h.encode(), s)
       
    1:     def test_whitespace_eater(self):
    2:         eq = self.assertEqual
    2:         s = 'Subject: =?koi8-r?b?8NLP18XSy8EgzsEgxsnOwczYztk=?= =?koi8-r?q?=CA?= zz.'
    2:         parts = decode_header(s)
    2:         eq(parts, [('Subject:', None), ('\xf0\xd2\xcf\xd7\xc5\xd2\xcb\xc1 \xce\xc1 \xc6\xc9\xce\xc1\xcc\xd8\xce\xd9\xca', 'koi8-r'), ('zz.', None)])
    2:         hdr = make_header(parts)
    2:         eq(hdr.encode(),
    2:            'Subject: =?koi8-r?b?8NLP18XSy8EgzsEgxsnOwczYztnK?= zz.')
       
    1:     def test_broken_base64_header(self):
    2:         raises = self.assertRaises
    2:         s = 'Subject: =?EUC-KR?B?CSixpLDtKSC/7Liuvsax4iC6uLmwMcijIKHaILzSwd/H0SC8+LCjwLsgv7W/+Mj3I ?='
    2:         raises(errors.HeaderParseError, decode_header, s)
       
       
       
       # Test RFC 2231 header parameters (en/de)coding
    2: class TestRFC2231(TestEmailBase):
    1:     def test_get_param(self):
    2:         eq = self.assertEqual
    2:         msg = self._msgobj('msg_29.txt')
    2:         eq(msg.get_param('title'),
    2:            ('us-ascii', 'en', 'This is even more ***fun*** isn\'t it!'))
    2:         eq(msg.get_param('title', unquote=False),
    2:            ('us-ascii', 'en', '"This is even more ***fun*** isn\'t it!"'))
       
    1:     def test_set_param(self):
    2:         eq = self.assertEqual
    2:         msg = Message()
    2:         msg.set_param('title', 'This is even more ***fun*** isn\'t it!',
    2:                       charset='us-ascii')
    2:         eq(msg.get_param('title'),
    2:            ('us-ascii', '', 'This is even more ***fun*** isn\'t it!'))
    2:         msg.set_param('title', 'This is even more ***fun*** isn\'t it!',
    2:                       charset='us-ascii', language='en')
    2:         eq(msg.get_param('title'),
    2:            ('us-ascii', 'en', 'This is even more ***fun*** isn\'t it!'))
    2:         msg = self._msgobj('msg_01.txt')
    2:         msg.set_param('title', 'This is even more ***fun*** isn\'t it!',
    2:                       charset='us-ascii', language='en')
    2:         self.ndiffAssertEqual(msg.as_string(), """\
       Return-Path: <bbb@zzz.org>
       Delivered-To: bbb@zzz.org
       Received: by mail.zzz.org (Postfix, from userid 889)
        id 27CEAD38CC; Fri,  4 May 2001 14:05:44 -0400 (EDT)
       MIME-Version: 1.0
       Content-Transfer-Encoding: 7bit
       Message-ID: <15090.61304.110929.45684@aaa.zzz.org>
       From: bbb@ddd.com (John X. Doe)
       To: bbb@zzz.org
       Subject: This is a test message
       Date: Fri, 4 May 2001 14:05:44 -0400
       Content-Type: text/plain; charset=us-ascii;
        title*="us-ascii'en'This%20is%20even%20more%20%2A%2A%2Afun%2A%2A%2A%20isn%27t%20it%21"
       
       
       Hi,
       
       Do you like this message?
       
       -Me
    2: """)
       
    1:     def test_del_param(self):
    2:         eq = self.ndiffAssertEqual
    2:         msg = self._msgobj('msg_01.txt')
    2:         msg.set_param('foo', 'bar', charset='us-ascii', language='en')
    2:         msg.set_param('title', 'This is even more ***fun*** isn\'t it!',
    2:             charset='us-ascii', language='en')
    2:         msg.del_param('foo', header='Content-Type')
    2:         eq(msg.as_string(), """\
       Return-Path: <bbb@zzz.org>
       Delivered-To: bbb@zzz.org
       Received: by mail.zzz.org (Postfix, from userid 889)
        id 27CEAD38CC; Fri,  4 May 2001 14:05:44 -0400 (EDT)
       MIME-Version: 1.0
       Content-Transfer-Encoding: 7bit
       Message-ID: <15090.61304.110929.45684@aaa.zzz.org>
       From: bbb@ddd.com (John X. Doe)
       To: bbb@zzz.org
       Subject: This is a test message
       Date: Fri, 4 May 2001 14:05:44 -0400
       Content-Type: text/plain; charset="us-ascii";
        title*="us-ascii'en'This%20is%20even%20more%20%2A%2A%2Afun%2A%2A%2A%20isn%27t%20it%21"
       
       
       Hi,
       
       Do you like this message?
       
       -Me
    2: """)
       
    1:     def test_rfc2231_get_content_charset(self):
    2:         eq = self.assertEqual
    2:         msg = self._msgobj('msg_32.txt')
    2:         eq(msg.get_content_charset(), 'us-ascii')
       
    1:     def test_rfc2231_no_language_or_charset(self):
               m = '''\
       Content-Transfer-Encoding: 8bit
       Content-Disposition: inline; filename="file____C__DOCUMENTS_20AND_20SETTINGS_FABIEN_LOCAL_20SETTINGS_TEMP_nsmail.htm"
       Content-Type: text/html; NAME*0=file____C__DOCUMENTS_20AND_20SETTINGS_FABIEN_LOCAL_20SETTINGS_TEM; NAME*1=P_nsmail.htm
       
    2: '''
    2:         msg = email.message_from_string(m)
    2:         param = msg.get_param('NAME')
    2:         self.assertFalse(isinstance(param, tuple))
    2:         self.assertEqual(
    2:             param,
    2:             'file____C__DOCUMENTS_20AND_20SETTINGS_FABIEN_LOCAL_20SETTINGS_TEMP_nsmail.htm')
       
    1:     def test_rfc2231_no_language_or_charset_in_filename(self):
               m = '''\
       Content-Disposition: inline;
       \tfilename*0*="''This%20is%20even%20more%20";
       \tfilename*1*="%2A%2A%2Afun%2A%2A%2A%20";
       \tfilename*2="is it not.pdf"
       
    2: '''
    2:         msg = email.message_from_string(m)
    2:         self.assertEqual(msg.get_filename(),
    2:                          'This is even more ***fun*** is it not.pdf')
       
    1:     def test_rfc2231_no_language_or_charset_in_filename_encoded(self):
               m = '''\
       Content-Disposition: inline;
       \tfilename*0*="''This%20is%20even%20more%20";
       \tfilename*1*="%2A%2A%2Afun%2A%2A%2A%20";
       \tfilename*2="is it not.pdf"
       
    2: '''
    2:         msg = email.message_from_string(m)
    2:         self.assertEqual(msg.get_filename(),
    2:                          'This is even more ***fun*** is it not.pdf')
       
    1:     def test_rfc2231_partly_encoded(self):
               m = '''\
       Content-Disposition: inline;
       \tfilename*0="''This%20is%20even%20more%20";
       \tfilename*1*="%2A%2A%2Afun%2A%2A%2A%20";
       \tfilename*2="is it not.pdf"
       
    2: '''
    2:         msg = email.message_from_string(m)
    2:         self.assertEqual(
    2:             msg.get_filename(),
    2:             'This%20is%20even%20more%20***fun*** is it not.pdf')
       
    1:     def test_rfc2231_partly_nonencoded(self):
               m = '''\
       Content-Disposition: inline;
       \tfilename*0="This%20is%20even%20more%20";
       \tfilename*1="%2A%2A%2Afun%2A%2A%2A%20";
       \tfilename*2="is it not.pdf"
       
    2: '''
    2:         msg = email.message_from_string(m)
    2:         self.assertEqual(
    2:             msg.get_filename(),
    2:             'This%20is%20even%20more%20%2A%2A%2Afun%2A%2A%2A%20is it not.pdf')
       
    1:     def test_rfc2231_no_language_or_charset_in_boundary(self):
               m = '''\
       Content-Type: multipart/alternative;
       \tboundary*0*="''This%20is%20even%20more%20";
       \tboundary*1*="%2A%2A%2Afun%2A%2A%2A%20";
       \tboundary*2="is it not.pdf"
       
    2: '''
    2:         msg = email.message_from_string(m)
    2:         self.assertEqual(msg.get_boundary(),
    2:                          'This is even more ***fun*** is it not.pdf')
       
    1:     def test_rfc2231_no_language_or_charset_in_charset(self):
               # This is a nonsensical charset value, but tests the code anyway
               m = '''\
       Content-Type: text/plain;
       \tcharset*0*="This%20is%20even%20more%20";
       \tcharset*1*="%2A%2A%2Afun%2A%2A%2A%20";
       \tcharset*2="is it not.pdf"
       
    2: '''
    2:         msg = email.message_from_string(m)
    2:         self.assertEqual(msg.get_content_charset(),
    2:                          'this is even more ***fun*** is it not.pdf')
       
    1:     def test_rfc2231_bad_encoding_in_filename(self):
               m = '''\
       Content-Disposition: inline;
       \tfilename*0*="bogus'xx'This%20is%20even%20more%20";
       \tfilename*1*="%2A%2A%2Afun%2A%2A%2A%20";
       \tfilename*2="is it not.pdf"
       
    2: '''
    2:         msg = email.message_from_string(m)
    2:         self.assertEqual(msg.get_filename(),
    2:                          'This is even more ***fun*** is it not.pdf')
       
    1:     def test_rfc2231_bad_encoding_in_charset(self):
               m = """\
       Content-Type: text/plain; charset*=bogus''utf-8%E2%80%9D
       
    2: """
    2:         msg = email.message_from_string(m)
               # This should return None because non-ascii characters in the charset
               # are not allowed.
    2:         self.assertEqual(msg.get_content_charset(), None)
       
    1:     def test_rfc2231_bad_character_in_charset(self):
               m = """\
       Content-Type: text/plain; charset*=ascii''utf-8%E2%80%9D
       
    2: """
    2:         msg = email.message_from_string(m)
               # This should return None because non-ascii characters in the charset
               # are not allowed.
    2:         self.assertEqual(msg.get_content_charset(), None)
       
    1:     def test_rfc2231_bad_character_in_filename(self):
               m = '''\
       Content-Disposition: inline;
       \tfilename*0*="ascii'xx'This%20is%20even%20more%20";
       \tfilename*1*="%2A%2A%2Afun%2A%2A%2A%20";
       \tfilename*2*="is it not.pdf%E2"
       
    2: '''
    2:         msg = email.message_from_string(m)
    2:         self.assertEqual(msg.get_filename(),
    2:                          u'This is even more ***fun*** is it not.pdf\ufffd')
       
    1:     def test_rfc2231_unknown_encoding(self):
               m = """\
       Content-Transfer-Encoding: 8bit
       Content-Disposition: inline; filename*=X-UNKNOWN''myfile.txt
       
    2: """
    2:         msg = email.message_from_string(m)
    2:         self.assertEqual(msg.get_filename(), 'myfile.txt')
       
    1:     def test_rfc2231_single_tick_in_filename_extended(self):
    2:         eq = self.assertEqual
               m = """\
       Content-Type: application/x-foo;
       \tname*0*=\"Frank's\"; name*1*=\" Document\"
       
    2: """
    2:         msg = email.message_from_string(m)
    2:         charset, language, s = msg.get_param('name')
    2:         eq(charset, None)
    2:         eq(language, None)
    2:         eq(s, "Frank's Document")
       
    1:     def test_rfc2231_single_tick_in_filename(self):
               m = """\
       Content-Type: application/x-foo; name*0=\"Frank's\"; name*1=\" Document\"
       
    2: """
    2:         msg = email.message_from_string(m)
    2:         param = msg.get_param('name')
    2:         self.assertFalse(isinstance(param, tuple))
    2:         self.assertEqual(param, "Frank's Document")
       
    1:     def test_rfc2231_tick_attack_extended(self):
    2:         eq = self.assertEqual
               m = """\
       Content-Type: application/x-foo;
       \tname*0*=\"us-ascii'en-us'Frank's\"; name*1*=\" Document\"
       
    2: """
    2:         msg = email.message_from_string(m)
    2:         charset, language, s = msg.get_param('name')
    2:         eq(charset, 'us-ascii')
    2:         eq(language, 'en-us')
    2:         eq(s, "Frank's Document")
       
    1:     def test_rfc2231_tick_attack(self):
               m = """\
       Content-Type: application/x-foo;
       \tname*0=\"us-ascii'en-us'Frank's\"; name*1=\" Document\"
       
    2: """
    2:         msg = email.message_from_string(m)
    2:         param = msg.get_param('name')
    2:         self.assertFalse(isinstance(param, tuple))
    2:         self.assertEqual(param, "us-ascii'en-us'Frank's Document")
       
    1:     def test_rfc2231_no_extended_values(self):
    2:         eq = self.assertEqual
               m = """\
       Content-Type: application/x-foo; name=\"Frank's Document\"
       
    2: """
    2:         msg = email.message_from_string(m)
    2:         eq(msg.get_param('name'), "Frank's Document")
       
    1:     def test_rfc2231_encoded_then_unencoded_segments(self):
    2:         eq = self.assertEqual
               m = """\
       Content-Type: application/x-foo;
       \tname*0*=\"us-ascii'en-us'My\";
       \tname*1=\" Document\";
       \tname*2*=\" For You\"
       
    2: """
    2:         msg = email.message_from_string(m)
    2:         charset, language, s = msg.get_param('name')
    2:         eq(charset, 'us-ascii')
    2:         eq(language, 'en-us')
    2:         eq(s, 'My Document For You')
       
    1:     def test_rfc2231_unencoded_then_encoded_segments(self):
    2:         eq = self.assertEqual
               m = """\
       Content-Type: application/x-foo;
       \tname*0=\"us-ascii'en-us'My\";
       \tname*1*=\" Document\";
       \tname*2*=\" For You\"
       
    2: """
    2:         msg = email.message_from_string(m)
    2:         charset, language, s = msg.get_param('name')
    2:         eq(charset, 'us-ascii')
    2:         eq(language, 'en-us')
    2:         eq(s, 'My Document For You')
       
       
       
    1: def _testclasses():
    2:     mod = sys.modules[__name__]
  138:     return [getattr(mod, name) for name in dir(mod) if name.startswith('Test')]
       
       
    1: def suite():
    2:     suite = unittest.TestSuite()
   46:     for testclass in _testclasses():
   44:         suite.addTest(unittest.makeSuite(testclass))
    2:     return suite
       
       
    1: def test_main():
>>>>>>     for testclass in _testclasses():
>>>>>>         run_unittest(testclass)
       
       
       
    1: if __name__ == '__main__':
>>>>>>     unittest.main(defaultTest='suite')
