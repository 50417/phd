       '''"Executable documentation" for the pickle module.
       
       Extensive comments about the pickle protocols and pickle-machine opcodes
       can be found here.  Some functions meant for external use:
       
       genops(pickle)
          Generate all the opcodes in a pickle, as (opcode, arg, position) triples.
       
       dis(pickle, out=None, memo=None, indentlevel=4)
          Print a symbolic disassembly of a pickle.
    1: '''
       
    1: __all__ = ['dis', 'genops', 'optimize']
       
       # Other ideas:
       #
       # - A pickle verifier:  read a pickle and check it exhaustively for
       #   well-formedness.  dis() does a lot of this already.
       #
       # - A protocol identifier:  examine a pickle and return its protocol number
       #   (== the highest .proto attr value among all the opcodes in the pickle).
       #   dis() already prints this info at the end.
       #
       # - A pickle optimizer:  for example, tuple-building code is sometimes more
       #   elaborate than necessary, catering for the possibility that the tuple
       #   is recursive.  Or lots of times a PUT is generated that's never accessed
       #   by a later GET.
       
       
       """
       "A pickle" is a program for a virtual pickle machine (PM, but more accurately
       called an unpickling machine).  It's a sequence of opcodes, interpreted by the
       PM, building an arbitrarily complex Python object.
       
       For the most part, the PM is very simple:  there are no looping, testing, or
       conditional instructions, no arithmetic and no function calls.  Opcodes are
       executed once each, from first to last, until a STOP opcode is reached.
       
       The PM has two data areas, "the stack" and "the memo".
       
       Many opcodes push Python objects onto the stack; e.g., INT pushes a Python
       integer object on the stack, whose value is gotten from a decimal string
       literal immediately following the INT opcode in the pickle bytestream.  Other
       opcodes take Python objects off the stack.  The result of unpickling is
       whatever object is left on the stack when the final STOP opcode is executed.
       
       The memo is simply an array of objects, or it can be implemented as a dict
       mapping little integers to objects.  The memo serves as the PM's "long term
       memory", and the little integers indexing the memo are akin to variable
       names.  Some opcodes pop a stack object into the memo at a given index,
       and others push a memo object at a given index onto the stack again.
       
       At heart, that's all the PM has.  Subtleties arise for these reasons:
       
       + Object identity.  Objects can be arbitrarily complex, and subobjects
         may be shared (for example, the list [a, a] refers to the same object a
         twice).  It can be vital that unpickling recreate an isomorphic object
         graph, faithfully reproducing sharing.
       
       + Recursive objects.  For example, after "L = []; L.append(L)", L is a
         list, and L[0] is the same list.  This is related to the object identity
         point, and some sequences of pickle opcodes are subtle in order to
         get the right result in all cases.
       
       + Things pickle doesn't know everything about.  Examples of things pickle
         does know everything about are Python's builtin scalar and container
         types, like ints and tuples.  They generally have opcodes dedicated to
         them.  For things like module references and instances of user-defined
         classes, pickle's knowledge is limited.  Historically, many enhancements
         have been made to the pickle protocol in order to do a better (faster,
         and/or more compact) job on those.
       
       + Backward compatibility and micro-optimization.  As explained below,
         pickle opcodes never go away, not even when better ways to do a thing
         get invented.  The repertoire of the PM just keeps growing over time.
         For example, protocol 0 had two opcodes for building Python integers (INT
         and LONG), protocol 1 added three more for more-efficient pickling of short
         integers, and protocol 2 added two more for more-efficient pickling of
         long integers (before protocol 2, the only ways to pickle a Python long
         took time quadratic in the number of digits, for both pickling and
         unpickling).  "Opcode bloat" isn't so much a subtlety as a source of
         wearying complication.
       
       
       Pickle protocols:
       
       For compatibility, the meaning of a pickle opcode never changes.  Instead new
       pickle opcodes get added, and each version's unpickler can handle all the
       pickle opcodes in all protocol versions to date.  So old pickles continue to
       be readable forever.  The pickler can generally be told to restrict itself to
       the subset of opcodes available under previous protocol versions too, so that
       users can create pickles under the current version readable by older
       versions.  However, a pickle does not contain its version number embedded
       within it.  If an older unpickler tries to read a pickle using a later
       protocol, the result is most likely an exception due to seeing an unknown (in
       the older unpickler) opcode.
       
       The original pickle used what's now called "protocol 0", and what was called
       "text mode" before Python 2.3.  The entire pickle bytestream is made up of
       printable 7-bit ASCII characters, plus the newline character, in protocol 0.
       That's why it was called text mode.  Protocol 0 is small and elegant, but
       sometimes painfully inefficient.
       
       The second major set of additions is now called "protocol 1", and was called
       "binary mode" before Python 2.3.  This added many opcodes with arguments
       consisting of arbitrary bytes, including NUL bytes and unprintable "high bit"
       bytes.  Binary mode pickles can be substantially smaller than equivalent
       text mode pickles, and sometimes faster too; e.g., BININT represents a 4-byte
       int as 4 bytes following the opcode, which is cheaper to unpickle than the
       (perhaps) 11-character decimal string attached to INT.  Protocol 1 also added
       a number of opcodes that operate on many stack elements at once (like APPENDS
       and SETITEMS), and "shortcut" opcodes (like EMPTY_DICT and EMPTY_TUPLE).
       
       The third major set of additions came in Python 2.3, and is called "protocol
       2".  This added:
       
       - A better way to pickle instances of new-style classes (NEWOBJ).
       
       - A way for a pickle to identify its protocol (PROTO).
       
       - Time- and space- efficient pickling of long ints (LONG{1,4}).
       
       - Shortcuts for small tuples (TUPLE{1,2,3}}.
       
       - Dedicated opcodes for bools (NEWTRUE, NEWFALSE).
       
       - The "extension registry", a vector of popular objects that can be pushed
         efficiently by index (EXT{1,2,4}).  This is akin to the memo and GET, but
         the registry contents are predefined (there's nothing akin to the memo's
         PUT).
       
       Another independent change with Python 2.3 is the abandonment of any
       pretense that it might be safe to load pickles received from untrusted
       parties -- no sufficient security analysis has been done to guarantee
       this and there isn't a use case that warrants the expense of such an
       analysis.
       
       To this end, all tests for __safe_for_unpickling__ or for
       copy_reg.safe_constructors are removed from the unpickling code.
       References to these variables in the descriptions below are to be seen
       as describing unpickling in Python 2.2 and before.
       """
       
       # Meta-rule:  Descriptions are stored in instances of descriptor objects,
       # with plain constructors.  No meta-language is defined from which
       # descriptors could be constructed.  If you want, e.g., XML, write a little
       # program to generate XML from the objects.
       
       ##############################################################################
       # Some pickle opcodes have an argument, following the opcode in the
       # bytestream.  An argument is of a specific type, described by an instance
       # of ArgumentDescriptor.  These are not to be confused with arguments taken
       # off the stack -- ArgumentDescriptor applies only to arguments embedded in
       # the opcode stream, immediately following an opcode.
       
       # Represents the number of bytes consumed by an argument delimited by the
       # next newline character.
    1: UP_TO_NEWLINE = -1
       
       # Represents the number of bytes consumed by a two-argument opcode where
       # the first argument gives the number of bytes in the second argument.
    1: TAKEN_FROM_ARGUMENT1 = -2   # num bytes is 1-byte unsigned int
    1: TAKEN_FROM_ARGUMENT4 = -3   # num bytes is 4-byte signed little-endian int
       
    2: class ArgumentDescriptor(object):
           __slots__ = (
               # name of descriptor record, also a module global name; a string
               'name',
       
               # length of argument, in bytes; an int; UP_TO_NEWLINE and
               # TAKEN_FROM_ARGUMENT{1,4} are negative values for variable-length
               # cases
               'n',
       
               # a function taking a file-like object, reading this kind of argument
               # from the object at the current position, advancing the current
               # position by n bytes, and returning the value of the argument
               'reader',
       
               # human-readable docs for this arg descriptor; a string
    1:         'doc',
           )
       
    1:     def __init__(self, name, n, reader, doc):
   16:         assert isinstance(name, str)
   16:         self.name = name
       
   16:         assert isinstance(n, (int, long)) and (n >= 0 or
   12:                                        n in (UP_TO_NEWLINE,
   12:                                              TAKEN_FROM_ARGUMENT1,
   12:                                              TAKEN_FROM_ARGUMENT4))
   16:         self.n = n
       
   16:         self.reader = reader
       
   16:         assert isinstance(doc, str)
   16:         self.doc = doc
       
    1: from struct import unpack as _unpack
       
    1: def read_uint1(f):
           r"""
           >>> import StringIO
           >>> read_uint1(StringIO.StringIO('\xff'))
           255
           """
       
20925:     data = f.read(1)
20925:     if data:
20925:         return ord(data)
>>>>>>     raise ValueError("not enough data in stream to read uint1")
       
    1: uint1 = ArgumentDescriptor(
    1:             name='uint1',
    1:             n=1,
    1:             reader=read_uint1,
    1:             doc="One-byte unsigned integer.")
       
       
    1: def read_uint2(f):
           r"""
           >>> import StringIO
           >>> read_uint2(StringIO.StringIO('\xff\x00'))
           255
           >>> read_uint2(StringIO.StringIO('\xff\xff'))
           65535
           """
       
125805:     data = f.read(2)
125805:     if len(data) == 2:
125805:         return _unpack("<H", data)[0]
>>>>>>     raise ValueError("not enough data in stream to read uint2")
       
    1: uint2 = ArgumentDescriptor(
    1:             name='uint2',
    1:             n=2,
    1:             reader=read_uint2,
    1:             doc="Two-byte unsigned integer, little-endian.")
       
       
    1: def read_int4(f):
           r"""
           >>> import StringIO
           >>> read_int4(StringIO.StringIO('\xff\x00\x00\x00'))
           255
           >>> read_int4(StringIO.StringIO('\x00\x00\x00\x80')) == -(2**31)
           True
           """
       
  320:     data = f.read(4)
  320:     if len(data) == 4:
  320:         return _unpack("<i", data)[0]
>>>>>>     raise ValueError("not enough data in stream to read int4")
       
    1: int4 = ArgumentDescriptor(
    1:            name='int4',
    1:            n=4,
    1:            reader=read_int4,
    1:            doc="Four-byte signed integer, little-endian, 2's complement.")
       
       
    1: def read_stringnl(f, decode=True, stripquotes=True):
           r"""
           >>> import StringIO
           >>> read_stringnl(StringIO.StringIO("'abcd'\nefg\n"))
           'abcd'
       
           >>> read_stringnl(StringIO.StringIO("\n"))
           Traceback (most recent call last):
           ...
           ValueError: no string quotes around ''
       
           >>> read_stringnl(StringIO.StringIO("\n"), stripquotes=False)
           ''
       
           >>> read_stringnl(StringIO.StringIO("''\n"))
           ''
       
           >>> read_stringnl(StringIO.StringIO('"abcd"'))
           Traceback (most recent call last):
           ...
           ValueError: no newline found when trying to read stringnl
       
           Embedded escapes are undone in the result.
           >>> read_stringnl(StringIO.StringIO(r"'a\n\\b\x00c\td'" + "\n'e'"))
           'a\n\\b\x00c\td'
           """
       
74630:     data = f.readline()
74630:     if not data.endswith('\n'):
    1:         raise ValueError("no newline found when trying to read stringnl")
74629:     data = data[:-1]    # lose the newline
       
74629:     if stripquotes:
  193:         for q in "'\"":
  192:             if data.startswith(q):
  190:                 if not data.endswith(q):
>>>>>>                     raise ValueError("strinq quote %r not found at both "
>>>>>>                                      "ends of %r" % (q, data))
  190:                 data = data[1:-1]
  190:                 break
               else:
    1:             raise ValueError("no string quotes around %r" % data)
       
           # I'm not sure when 'string_escape' was added to the std codecs; it's
           # crazy not to use it if it's there.
74628:     if decode:
  191:         data = data.decode('string_escape')
74628:     return data
       
    1: stringnl = ArgumentDescriptor(
    1:                name='stringnl',
    1:                n=UP_TO_NEWLINE,
    1:                reader=read_stringnl,
                      doc="""A newline-terminated string.
       
                          This is a repr-style string, with embedded escapes, and
                          bracketing quotes.
    1:                    """)
       
    1: def read_stringnl_noescape(f):
 1774:     return read_stringnl(f, decode=False, stripquotes=False)
       
    1: stringnl_noescape = ArgumentDescriptor(
    1:                         name='stringnl_noescape',
    1:                         n=UP_TO_NEWLINE,
    1:                         reader=read_stringnl_noescape,
                               doc="""A newline-terminated string.
       
                               This is a str-style string, without embedded escapes,
                               or bracketing quotes.  It should consist solely of
                               printable ASCII characters.
    1:                         """)
       
    1: def read_stringnl_noescape_pair(f):
           r"""
           >>> import StringIO
           >>> read_stringnl_noescape_pair(StringIO.StringIO("Queue\nEmpty\njunk"))
           'Queue Empty'
           """
       
  887:     return "%s %s" % (read_stringnl_noescape(f), read_stringnl_noescape(f))
       
    1: stringnl_noescape_pair = ArgumentDescriptor(
    1:                              name='stringnl_noescape_pair',
    1:                              n=UP_TO_NEWLINE,
    1:                              reader=read_stringnl_noescape_pair,
                                    doc="""A pair of newline-terminated strings.
       
                                    These are str-style strings, without embedded
                                    escapes, or bracketing quotes.  They should
                                    consist solely of printable ASCII characters.
                                    The pair is returned as a single string, with
                                    a single blank separating the two strings.
    1:                              """)
       
    1: def read_string4(f):
           r"""
           >>> import StringIO
           >>> read_string4(StringIO.StringIO("\x00\x00\x00\x00abc"))
           ''
           >>> read_string4(StringIO.StringIO("\x03\x00\x00\x00abcdef"))
           'abc'
           >>> read_string4(StringIO.StringIO("\x00\x00\x00\x03abcdef"))
           Traceback (most recent call last):
           ...
           ValueError: expected 50331648 bytes in a string4, but only 6 remain
           """
       
    5:     n = read_int4(f)
    5:     if n < 0:
>>>>>>         raise ValueError("string4 byte count < 0: %d" % n)
    5:     data = f.read(n)
    5:     if len(data) == n:
    4:         return data
    1:     raise ValueError("expected %d bytes in a string4, but only %d remain" %
    1:                      (n, len(data)))
       
    1: string4 = ArgumentDescriptor(
    1:               name="string4",
    1:               n=TAKEN_FROM_ARGUMENT4,
    1:               reader=read_string4,
                     doc="""A counted string.
       
                     The first argument is a 4-byte little-endian signed int giving
                     the number of bytes in the string, and the second argument is
                     that many bytes.
    1:               """)
       
       
    1: def read_string1(f):
           r"""
           >>> import StringIO
           >>> read_string1(StringIO.StringIO("\x00"))
           ''
           >>> read_string1(StringIO.StringIO("\x03abcdef"))
           'abc'
           """
       
  724:     n = read_uint1(f)
  724:     assert n >= 0
  724:     data = f.read(n)
  724:     if len(data) == n:
  724:         return data
>>>>>>     raise ValueError("expected %d bytes in a string1, but only %d remain" %
>>>>>>                      (n, len(data)))
       
    1: string1 = ArgumentDescriptor(
    1:               name="string1",
    1:               n=TAKEN_FROM_ARGUMENT1,
    1:               reader=read_string1,
                     doc="""A counted string.
       
                     The first argument is a 1-byte unsigned int giving the number
                     of bytes in the string, and the second argument is that many
                     bytes.
    1:               """)
       
       
    1: def read_unicodestringnl(f):
           r"""
           >>> import StringIO
           >>> read_unicodestringnl(StringIO.StringIO("abc\uabcd\njunk"))
           u'abc\uabcd'
           """
       
   12:     data = f.readline()
   12:     if not data.endswith('\n'):
>>>>>>         raise ValueError("no newline found when trying to read "
                                "unicodestringnl")
   12:     data = data[:-1]    # lose the newline
   12:     return unicode(data, 'raw-unicode-escape')
       
    1: unicodestringnl = ArgumentDescriptor(
    1:                       name='unicodestringnl',
    1:                       n=UP_TO_NEWLINE,
    1:                       reader=read_unicodestringnl,
                             doc="""A newline-terminated Unicode string.
       
                             This is raw-unicode-escape encoded, so consists of
                             printable ASCII characters, and may contain embedded
                             escape sequences.
    1:                       """)
       
    1: def read_unicodestring4(f):
           r"""
           >>> import StringIO
           >>> s = u'abcd\uabcd'
           >>> enc = s.encode('utf-8')
           >>> enc
           'abcd\xea\xaf\x8d'
           >>> n = chr(len(enc)) + chr(0) * 3  # little-endian 4-byte length
           >>> t = read_unicodestring4(StringIO.StringIO(n + enc + 'junk'))
           >>> s == t
           True
       
           >>> read_unicodestring4(StringIO.StringIO(n + enc[:-1]))
           Traceback (most recent call last):
           ...
           ValueError: expected 7 bytes in a unicodestring4, but only 6 remain
           """
       
   23:     n = read_int4(f)
   23:     if n < 0:
>>>>>>         raise ValueError("unicodestring4 byte count < 0: %d" % n)
   23:     data = f.read(n)
   23:     if len(data) == n:
   22:         return unicode(data, 'utf-8')
    1:     raise ValueError("expected %d bytes in a unicodestring4, but only %d "
    1:                      "remain" % (n, len(data)))
       
    1: unicodestring4 = ArgumentDescriptor(
    1:                     name="unicodestring4",
    1:                     n=TAKEN_FROM_ARGUMENT4,
    1:                     reader=read_unicodestring4,
                           doc="""A counted Unicode string.
       
                           The first argument is a 4-byte little-endian signed int
                           giving the number of bytes in the string, and the second
                           argument-- the UTF-8 encoding of the Unicode string --
                           contains that many bytes.
    1:                     """)
       
       
    1: def read_decimalnl_short(f):
           r"""
           >>> import StringIO
           >>> read_decimalnl_short(StringIO.StringIO("1234\n56"))
           1234
       
           >>> read_decimalnl_short(StringIO.StringIO("1234L\n56"))
           Traceback (most recent call last):
           ...
           ValueError: trailing 'L' not allowed in '1234L'
           """
       
72491:     s = read_stringnl(f, decode=False, stripquotes=False)
72491:     if s.endswith("L"):
    1:         raise ValueError("trailing 'L' not allowed in %r" % s)
       
           # It's not necessarily true that the result fits in a Python short int:
           # the pickle may have been written on a 64-bit box.  There's also a hack
           # for True and False here.
72490:     if s == "00":
   26:         return False
72464:     elif s == "01":
   26:         return True
       
72438:     try:
72438:         return int(s)
>>>>>>     except OverflowError:
>>>>>>         return long(s)
       
    1: def read_decimalnl_long(f):
           r"""
           >>> import StringIO
       
           >>> read_decimalnl_long(StringIO.StringIO("1234\n56"))
           Traceback (most recent call last):
           ...
           ValueError: trailing 'L' required in '1234'
       
           Someday the trailing 'L' will probably go away from this output.
       
           >>> read_decimalnl_long(StringIO.StringIO("1234L\n56"))
           1234L
       
           >>> read_decimalnl_long(StringIO.StringIO("123456789012345678901234L\n6"))
           123456789012345678901234L
           """
       
  135:     s = read_stringnl(f, decode=False, stripquotes=False)
  135:     if not s.endswith("L"):
    1:         raise ValueError("trailing 'L' required in %r" % s)
  134:     return long(s)
       
       
    1: decimalnl_short = ArgumentDescriptor(
    1:                       name='decimalnl_short',
    1:                       n=UP_TO_NEWLINE,
    1:                       reader=read_decimalnl_short,
                             doc="""A newline-terminated decimal integer literal.
       
                                 This never has a trailing 'L', and the integer fit
                                 in a short Python int on the box where the pickle
                                 was written -- but there's no guarantee it will fit
                                 in a short Python int on the box where the pickle
                                 is read.
    1:                           """)
       
    1: decimalnl_long = ArgumentDescriptor(
    1:                      name='decimalnl_long',
    1:                      n=UP_TO_NEWLINE,
    1:                      reader=read_decimalnl_long,
                            doc="""A newline-terminated decimal integer literal.
       
                                This has a trailing 'L', and can represent integers
                                of any size.
    1:                          """)
       
       
    1: def read_floatnl(f):
           r"""
           >>> import StringIO
           >>> read_floatnl(StringIO.StringIO("-1.25\n6"))
           -1.25
           """
   37:     s = read_stringnl(f, decode=False, stripquotes=False)
   37:     return float(s)
       
    1: floatnl = ArgumentDescriptor(
    1:               name='floatnl',
    1:               n=UP_TO_NEWLINE,
    1:               reader=read_floatnl,
                     doc="""A newline-terminated decimal floating literal.
       
                     In general this requires 17 significant digits for roundtrip
                     identity, and pickling then unpickling infinities, NaNs, and
                     minus zero doesn't work across boxes, or on some boxes even
                     on itself (e.g., Windows can't read the strings it produces
                     for infinities or NaNs).
    1:               """)
       
    1: def read_float8(f):
           r"""
           >>> import StringIO, struct
           >>> raw = struct.pack(">d", -1.25)
           >>> raw
           '\xbf\xf4\x00\x00\x00\x00\x00\x00'
           >>> read_float8(StringIO.StringIO(raw + "\n"))
           -1.25
           """
       
   71:     data = f.read(8)
   71:     if len(data) == 8:
   71:         return _unpack(">d", data)[0]
>>>>>>     raise ValueError("not enough data in stream to read float8")
       
       
    1: float8 = ArgumentDescriptor(
    1:              name='float8',
    1:              n=8,
    1:              reader=read_float8,
                    doc="""An 8-byte binary representation of a float, big-endian.
       
                    The format is unique to Python, and shared with the struct
                    module (format string '>d') "in theory" (the struct and cPickle
                    implementations don't share the code -- they should).  It's
                    strongly related to the IEEE-754 double format, and, in normal
                    cases, is in fact identical to the big-endian 754 double format.
                    On other boxes the dynamic range is limited to that of a 754
                    double, and "add a half and chop" rounding is used to reduce
                    the precision to 53 bits.  However, even on a 754 box,
                    infinities, NaNs, and minus zero may not be handled correctly
                    (may not survive roundtrip pickling intact).
    1:              """)
       
       # Protocol 2 formats
       
    1: from pickle import decode_long
       
    1: def read_long1(f):
           r"""
           >>> import StringIO
           >>> read_long1(StringIO.StringIO("\x00"))
           0L
           >>> read_long1(StringIO.StringIO("\x02\xff\x00"))
           255L
           >>> read_long1(StringIO.StringIO("\x02\xff\x7f"))
           32767L
           >>> read_long1(StringIO.StringIO("\x02\x00\xff"))
           -256L
           >>> read_long1(StringIO.StringIO("\x02\x00\x80"))
           -32768L
           """
       
   40:     n = read_uint1(f)
   40:     data = f.read(n)
   40:     if len(data) != n:
>>>>>>         raise ValueError("not enough data in stream to read long1")
   40:     return decode_long(data)
       
    1: long1 = ArgumentDescriptor(
    1:     name="long1",
    1:     n=TAKEN_FROM_ARGUMENT1,
    1:     reader=read_long1,
           doc="""A binary long, little-endian, using 1-byte size.
       
           This first reads one byte as an unsigned size, then reads that
           many bytes and interprets them as a little-endian 2's-complement long.
           If the size is 0, that's taken as a shortcut for the long 0L.
    1:     """)
       
    1: def read_long4(f):
           r"""
           >>> import StringIO
           >>> read_long4(StringIO.StringIO("\x02\x00\x00\x00\xff\x00"))
           255L
           >>> read_long4(StringIO.StringIO("\x02\x00\x00\x00\xff\x7f"))
           32767L
           >>> read_long4(StringIO.StringIO("\x02\x00\x00\x00\x00\xff"))
           -256L
           >>> read_long4(StringIO.StringIO("\x02\x00\x00\x00\x00\x80"))
           -32768L
           >>> read_long1(StringIO.StringIO("\x00\x00\x00\x00"))
           0L
           """
       
   38:     n = read_int4(f)
   38:     if n < 0:
>>>>>>         raise ValueError("long4 byte count < 0: %d" % n)
   38:     data = f.read(n)
   38:     if len(data) != n:
>>>>>>         raise ValueError("not enough data in stream to read long4")
   38:     return decode_long(data)
       
    1: long4 = ArgumentDescriptor(
    1:     name="long4",
    1:     n=TAKEN_FROM_ARGUMENT4,
    1:     reader=read_long4,
           doc="""A binary representation of a long, little-endian.
       
           This first reads four bytes as a signed size (but requires the
           size to be >= 0), then reads that many bytes and interprets them
           as a little-endian 2's-complement long.  If the size is 0, that's taken
           as a shortcut for the long 0L, although LONG1 should really be used
           then instead (and in any case where # of bytes < 256).
    1:     """)
       
       
       ##############################################################################
       # Object descriptors.  The stack used by the pickle machine holds objects,
       # and in the stack_before and stack_after attributes of OpcodeInfo
       # descriptors we need names to describe the various types of objects that can
       # appear on the stack.
       
    2: class StackObject(object):
           __slots__ = (
               # name of descriptor record, for info only
               'name',
       
               # type of object, or tuple of type objects (meaning the object can
               # be of any type in the tuple)
               'obtype',
       
               # human-readable docs for this kind of stack object; a string
    1:         'doc',
           )
       
    1:     def __init__(self, name, obtype, doc):
   14:         assert isinstance(name, str)
   14:         self.name = name
       
   14:         assert isinstance(obtype, type) or isinstance(obtype, tuple)
   14:         if isinstance(obtype, tuple):
    6:             for contained in obtype:
    4:                 assert isinstance(contained, type)
   14:         self.obtype = obtype
       
   14:         assert isinstance(doc, str)
   14:         self.doc = doc
       
    1:     def __repr__(self):
    1:         return self.name
       
       
    1: pyint = StackObject(
    1:             name='int',
    1:             obtype=int,
    1:             doc="A short (as opposed to long) Python integer object.")
       
    1: pylong = StackObject(
    1:              name='long',
    1:              obtype=long,
    1:              doc="A long (as opposed to short) Python integer object.")
       
    1: pyinteger_or_bool = StackObject(
    1:                         name='int_or_bool',
    1:                         obtype=(int, long, bool),
    1:                         doc="A Python integer object (short or long), or "
                                   "a Python bool.")
       
    1: pybool = StackObject(
    1:              name='bool',
    1:              obtype=(bool,),
    1:              doc="A Python bool object.")
       
    1: pyfloat = StackObject(
    1:               name='float',
    1:               obtype=float,
    1:               doc="A Python float object.")
       
    1: pystring = StackObject(
    1:                name='str',
    1:                obtype=str,
    1:                doc="A Python string object.")
       
    1: pyunicode = StackObject(
    1:                 name='unicode',
    1:                 obtype=unicode,
    1:                 doc="A Python Unicode string object.")
       
    1: pynone = StackObject(
    1:              name="None",
    1:              obtype=type(None),
    1:              doc="The Python None object.")
       
    1: pytuple = StackObject(
    1:               name="tuple",
    1:               obtype=tuple,
    1:               doc="A Python tuple object.")
       
    1: pylist = StackObject(
    1:              name="list",
    1:              obtype=list,
    1:              doc="A Python list object.")
       
    1: pydict = StackObject(
    1:              name="dict",
    1:              obtype=dict,
    1:              doc="A Python dict object.")
       
    1: anyobject = StackObject(
    1:                 name='any',
    1:                 obtype=object,
    1:                 doc="Any kind of object whatsoever.")
       
    1: markobject = StackObject(
    1:                  name="mark",
    1:                  obtype=StackObject,
                        doc="""'The mark' is a unique object.
       
                        Opcodes that operate on a variable number of objects
                        generally don't embed the count of objects in the opcode,
                        or pull it off the stack.  Instead the MARK opcode is used
                        to push a special marker object on the stack, and then
                        some other opcodes grab all the objects from the top of
                        the stack down to (but not including) the topmost marker
                        object.
    1:                  """)
       
    1: stackslice = StackObject(
    1:                  name="stackslice",
    1:                  obtype=StackObject,
                        doc="""An object representing a contiguous slice of the stack.
       
                        This is used in conjunction with markobject, to represent all
                        of the stack following the topmost markobject.  For example,
                        the POP_MARK opcode changes the stack from
       
                            [..., markobject, stackslice]
                        to
                            [...]
       
                        No matter how many object are on the stack after the topmost
                        markobject, POP_MARK gets rid of all of them (including the
                        topmost markobject too).
    1:                  """)
       
       ##############################################################################
       # Descriptors for pickle opcodes.
       
    2: class OpcodeInfo(object):
       
           __slots__ = (
               # symbolic name of opcode; a string
               'name',
       
               # the code used in a bytestream to represent the opcode; a
               # one-character string
               'code',
       
               # If the opcode has an argument embedded in the byte string, an
               # instance of ArgumentDescriptor specifying its type.  Note that
               # arg.reader(s) can be used to read and decode the argument from
               # the bytestream s, and arg.doc documents the format of the raw
               # argument bytes.  If the opcode doesn't have an argument embedded
               # in the bytestream, arg should be None.
               'arg',
       
               # what the stack looks like before this opcode runs; a list
               'stack_before',
       
               # what the stack looks like after this opcode runs; a list
               'stack_after',
       
               # the protocol number in which this opcode was introduced; an int
               'proto',
       
               # human-readable docs for this opcode; a string
    1:         'doc',
           )
       
    1:     def __init__(self, name, code, arg,
                        stack_before, stack_after, proto, doc):
   53:         assert isinstance(name, str)
   53:         self.name = name
       
   53:         assert isinstance(code, str)
   53:         assert len(code) == 1
   53:         self.code = code
       
   53:         assert arg is None or isinstance(arg, ArgumentDescriptor)
   53:         self.arg = arg
       
   53:         assert isinstance(stack_before, list)
   93:         for x in stack_before:
   40:             assert isinstance(x, StackObject)
   53:         self.stack_before = stack_before
       
   53:         assert isinstance(stack_after, list)
  100:         for x in stack_after:
   47:             assert isinstance(x, StackObject)
   53:         self.stack_after = stack_after
       
   53:         assert isinstance(proto, (int, long)) and 0 <= proto <= 2
   53:         self.proto = proto
       
   53:         assert isinstance(doc, str)
   53:         self.doc = doc
       
    1: I = OpcodeInfo
       opcodes = [
       
           # Ways to spell integers.
       
    1:     I(name='INT',
    1:       code='I',
    1:       arg=decimalnl_short,
    1:       stack_before=[],
    1:       stack_after=[pyinteger_or_bool],
    1:       proto=0,
             doc="""Push an integer or bool.
       
             The argument is a newline-terminated decimal literal string.
       
             The intent may have been that this always fit in a short Python int,
             but INT can be generated in pickles written on a 64-bit box that
             require a Python long on a 32-bit box.  The difference between this
             and LONG then is that INT skips a trailing 'L', and produces a short
             int whenever possible.
       
             Another difference is due to that, when bool was introduced as a
             distinct type in 2.3, builtin names True and False were also added to
             2.2.2, mapping to ints 1 and 0.  For compatibility in both directions,
             True gets pickled as INT + "I01\\n", and False as INT + "I00\\n".
             Leading zeroes are never produced for a genuine integer.  The 2.3
             (and later) unpicklers special-case these and return bool instead;
             earlier unpicklers ignore the leading "0" and return the int.
    1:       """),
       
    1:     I(name='BININT',
    1:       code='J',
    1:       arg=int4,
    1:       stack_before=[],
    1:       stack_after=[pyint],
    1:       proto=1,
             doc="""Push a four-byte signed integer.
       
             This handles the full range of Python (short) integers on a 32-bit
             box, directly as binary bytes (1 for the opcode and 4 for the integer).
             If the integer is non-negative and fits in 1 or 2 bytes, pickling via
             BININT1 or BININT2 saves space.
    1:       """),
       
    1:     I(name='BININT1',
    1:       code='K',
    1:       arg=uint1,
    1:       stack_before=[],
    1:       stack_after=[pyint],
    1:       proto=1,
             doc="""Push a one-byte unsigned integer.
       
             This is a space optimization for pickling very small non-negative ints,
             in range(256).
    1:       """),
       
    1:     I(name='BININT2',
    1:       code='M',
    1:       arg=uint2,
    1:       stack_before=[],
    1:       stack_after=[pyint],
    1:       proto=1,
             doc="""Push a two-byte unsigned integer.
       
             This is a space optimization for pickling small positive ints, in
             range(256, 2**16).  Integers in range(256) can also be pickled via
             BININT2, but BININT1 instead saves a byte.
    1:       """),
       
    1:     I(name='LONG',
    1:       code='L',
    1:       arg=decimalnl_long,
    1:       stack_before=[],
    1:       stack_after=[pylong],
    1:       proto=0,
             doc="""Push a long integer.
       
             The same as INT, except that the literal ends with 'L', and always
             unpickles to a Python long.  There doesn't seem a real purpose to the
             trailing 'L'.
       
             Note that LONG takes time quadratic in the number of digits when
             unpickling (this is simply due to the nature of decimal->binary
             conversion).  Proto 2 added linear-time (in C; still quadratic-time
             in Python) LONG1 and LONG4 opcodes.
    1:       """),
       
    1:     I(name="LONG1",
    1:       code='\x8a',
    1:       arg=long1,
    1:       stack_before=[],
    1:       stack_after=[pylong],
    1:       proto=2,
             doc="""Long integer using one-byte length.
       
             A more efficient encoding of a Python long; the long1 encoding
    1:       says it all."""),
       
    1:     I(name="LONG4",
    1:       code='\x8b',
    1:       arg=long4,
    1:       stack_before=[],
    1:       stack_after=[pylong],
    1:       proto=2,
             doc="""Long integer using found-byte length.
       
             A more efficient encoding of a Python long; the long4 encoding
    1:       says it all."""),
       
           # Ways to spell strings (8-bit, not Unicode).
       
    1:     I(name='STRING',
    1:       code='S',
    1:       arg=stringnl,
    1:       stack_before=[],
    1:       stack_after=[pystring],
    1:       proto=0,
             doc="""Push a Python string object.
       
             The argument is a repr-style string, with bracketing quote characters,
             and perhaps embedded escapes.  The argument extends until the next
             newline character.
    1:       """),
       
    1:     I(name='BINSTRING',
    1:       code='T',
    1:       arg=string4,
    1:       stack_before=[],
    1:       stack_after=[pystring],
    1:       proto=1,
             doc="""Push a Python string object.
       
             There are two arguments:  the first is a 4-byte little-endian signed int
             giving the number of bytes in the string, and the second is that many
             bytes, which are taken literally as the string content.
    1:       """),
       
    1:     I(name='SHORT_BINSTRING',
    1:       code='U',
    1:       arg=string1,
    1:       stack_before=[],
    1:       stack_after=[pystring],
    1:       proto=1,
             doc="""Push a Python string object.
       
             There are two arguments:  the first is a 1-byte unsigned int giving
             the number of bytes in the string, and the second is that many bytes,
             which are taken literally as the string content.
    1:       """),
       
           # Ways to spell None.
       
    1:     I(name='NONE',
    1:       code='N',
    1:       arg=None,
    1:       stack_before=[],
    1:       stack_after=[pynone],
    1:       proto=0,
    1:       doc="Push None on the stack."),
       
           # Ways to spell bools, starting with proto 2.  See INT for how this was
           # done before proto 2.
       
    1:     I(name='NEWTRUE',
    1:       code='\x88',
    1:       arg=None,
    1:       stack_before=[],
    1:       stack_after=[pybool],
    1:       proto=2,
             doc="""True.
       
    1:       Push True onto the stack."""),
       
    1:     I(name='NEWFALSE',
    1:       code='\x89',
    1:       arg=None,
    1:       stack_before=[],
    1:       stack_after=[pybool],
    1:       proto=2,
             doc="""True.
       
    1:       Push False onto the stack."""),
       
           # Ways to spell Unicode strings.
       
    1:     I(name='UNICODE',
    1:       code='V',
    1:       arg=unicodestringnl,
    1:       stack_before=[],
    1:       stack_after=[pyunicode],
    1:       proto=0,  # this may be pure-text, but it's a later addition
             doc="""Push a Python Unicode string object.
       
             The argument is a raw-unicode-escape encoding of a Unicode string,
             and so may contain embedded escape sequences.  The argument extends
             until the next newline character.
    1:       """),
       
    1:     I(name='BINUNICODE',
    1:       code='X',
    1:       arg=unicodestring4,
    1:       stack_before=[],
    1:       stack_after=[pyunicode],
    1:       proto=1,
             doc="""Push a Python Unicode string object.
       
             There are two arguments:  the first is a 4-byte little-endian signed int
             giving the number of bytes in the string.  The second is that many
             bytes, and is the UTF-8 encoding of the Unicode string.
    1:       """),
       
           # Ways to spell floats.
       
    1:     I(name='FLOAT',
    1:       code='F',
    1:       arg=floatnl,
    1:       stack_before=[],
    1:       stack_after=[pyfloat],
    1:       proto=0,
             doc="""Newline-terminated decimal float literal.
       
             The argument is repr(a_float), and in general requires 17 significant
             digits for roundtrip conversion to be an identity (this is so for
             IEEE-754 double precision values, which is what Python float maps to
             on most boxes).
       
             In general, FLOAT cannot be used to transport infinities, NaNs, or
             minus zero across boxes (or even on a single box, if the platform C
             library can't read the strings it produces for such things -- Windows
             is like that), but may do less damage than BINFLOAT on boxes with
             greater precision or dynamic range than IEEE-754 double.
    1:       """),
       
    1:     I(name='BINFLOAT',
    1:       code='G',
    1:       arg=float8,
    1:       stack_before=[],
    1:       stack_after=[pyfloat],
    1:       proto=1,
             doc="""Float stored in binary form, with 8 bytes of data.
       
             This generally requires less than half the space of FLOAT encoding.
             In general, BINFLOAT cannot be used to transport infinities, NaNs, or
             minus zero, raises an exception if the exponent exceeds the range of
             an IEEE-754 double, and retains no more than 53 bits of precision (if
             there are more than that, "add a half and chop" rounding is used to
             cut it back to 53 significant bits).
    1:       """),
       
           # Ways to build lists.
       
    1:     I(name='EMPTY_LIST',
    1:       code=']',
    1:       arg=None,
    1:       stack_before=[],
    1:       stack_after=[pylist],
    1:       proto=1,
    1:       doc="Push an empty list."),
       
    1:     I(name='APPEND',
    1:       code='a',
    1:       arg=None,
    1:       stack_before=[pylist, anyobject],
    1:       stack_after=[pylist],
    1:       proto=0,
             doc="""Append an object to a list.
       
             Stack before:  ... pylist anyobject
             Stack after:   ... pylist+[anyobject]
       
             although pylist is really extended in-place.
    1:       """),
       
    1:     I(name='APPENDS',
    1:       code='e',
    1:       arg=None,
    1:       stack_before=[pylist, markobject, stackslice],
    1:       stack_after=[pylist],
    1:       proto=1,
             doc="""Extend a list by a slice of stack objects.
       
             Stack before:  ... pylist markobject stackslice
             Stack after:   ... pylist+stackslice
       
             although pylist is really extended in-place.
    1:       """),
       
    1:     I(name='LIST',
    1:       code='l',
    1:       arg=None,
    1:       stack_before=[markobject, stackslice],
    1:       stack_after=[pylist],
    1:       proto=0,
             doc="""Build a list out of the topmost stack slice, after markobject.
       
             All the stack entries following the topmost markobject are placed into
             a single Python list, which single list object replaces all of the
             stack from the topmost markobject onward.  For example,
       
             Stack before: ... markobject 1 2 3 'abc'
             Stack after:  ... [1, 2, 3, 'abc']
    1:       """),
       
           # Ways to build tuples.
       
    1:     I(name='EMPTY_TUPLE',
    1:       code=')',
    1:       arg=None,
    1:       stack_before=[],
    1:       stack_after=[pytuple],
    1:       proto=1,
    1:       doc="Push an empty tuple."),
       
    1:     I(name='TUPLE',
    1:       code='t',
    1:       arg=None,
    1:       stack_before=[markobject, stackslice],
    1:       stack_after=[pytuple],
    1:       proto=0,
             doc="""Build a tuple out of the topmost stack slice, after markobject.
       
             All the stack entries following the topmost markobject are placed into
             a single Python tuple, which single tuple object replaces all of the
             stack from the topmost markobject onward.  For example,
       
             Stack before: ... markobject 1 2 3 'abc'
             Stack after:  ... (1, 2, 3, 'abc')
    1:       """),
       
    1:     I(name='TUPLE1',
    1:       code='\x85',
    1:       arg=None,
    1:       stack_before=[anyobject],
    1:       stack_after=[pytuple],
    1:       proto=2,
             doc="""Build a one-tuple out of the topmost item on the stack.
       
             This code pops one value off the stack and pushes a tuple of
             length 1 whose one item is that value back onto it.  In other
             words:
       
                 stack[-1] = tuple(stack[-1:])
    1:       """),
       
    1:     I(name='TUPLE2',
    1:       code='\x86',
    1:       arg=None,
    1:       stack_before=[anyobject, anyobject],
    1:       stack_after=[pytuple],
    1:       proto=2,
             doc="""Build a two-tuple out of the top two items on the stack.
       
             This code pops two values off the stack and pushes a tuple of
             length 2 whose items are those values back onto it.  In other
             words:
       
                 stack[-2:] = [tuple(stack[-2:])]
    1:       """),
       
    1:     I(name='TUPLE3',
    1:       code='\x87',
    1:       arg=None,
    1:       stack_before=[anyobject, anyobject, anyobject],
    1:       stack_after=[pytuple],
    1:       proto=2,
             doc="""Build a three-tuple out of the top three items on the stack.
       
             This code pops three values off the stack and pushes a tuple of
             length 3 whose items are those values back onto it.  In other
             words:
       
                 stack[-3:] = [tuple(stack[-3:])]
    1:       """),
       
           # Ways to build dicts.
       
    1:     I(name='EMPTY_DICT',
    1:       code='}',
    1:       arg=None,
    1:       stack_before=[],
    1:       stack_after=[pydict],
    1:       proto=1,
    1:       doc="Push an empty dict."),
       
    1:     I(name='DICT',
    1:       code='d',
    1:       arg=None,
    1:       stack_before=[markobject, stackslice],
    1:       stack_after=[pydict],
    1:       proto=0,
             doc="""Build a dict out of the topmost stack slice, after markobject.
       
             All the stack entries following the topmost markobject are placed into
             a single Python dict, which single dict object replaces all of the
             stack from the topmost markobject onward.  The stack slice alternates
             key, value, key, value, ....  For example,
       
             Stack before: ... markobject 1 2 3 'abc'
             Stack after:  ... {1: 2, 3: 'abc'}
    1:       """),
       
    1:     I(name='SETITEM',
    1:       code='s',
    1:       arg=None,
    1:       stack_before=[pydict, anyobject, anyobject],
    1:       stack_after=[pydict],
    1:       proto=0,
             doc="""Add a key+value pair to an existing dict.
       
             Stack before:  ... pydict key value
             Stack after:   ... pydict
       
             where pydict has been modified via pydict[key] = value.
    1:       """),
       
    1:     I(name='SETITEMS',
    1:       code='u',
    1:       arg=None,
    1:       stack_before=[pydict, markobject, stackslice],
    1:       stack_after=[pydict],
    1:       proto=1,
             doc="""Add an arbitrary number of key+value pairs to an existing dict.
       
             The slice of the stack following the topmost markobject is taken as
             an alternating sequence of keys and values, added to the dict
             immediately under the topmost markobject.  Everything at and after the
             topmost markobject is popped, leaving the mutated dict at the top
             of the stack.
       
             Stack before:  ... pydict markobject key_1 value_1 ... key_n value_n
             Stack after:   ... pydict
       
             where pydict has been modified via pydict[key_i] = value_i for i in
             1, 2, ..., n, and in that order.
    1:       """),
       
           # Stack manipulation.
       
    1:     I(name='POP',
    1:       code='0',
    1:       arg=None,
    1:       stack_before=[anyobject],
    1:       stack_after=[],
    1:       proto=0,
    1:       doc="Discard the top stack item, shrinking the stack by one item."),
       
    1:     I(name='DUP',
    1:       code='2',
    1:       arg=None,
    1:       stack_before=[anyobject],
    1:       stack_after=[anyobject, anyobject],
    1:       proto=0,
    1:       doc="Push the top stack item onto the stack again, duplicating it."),
       
    1:     I(name='MARK',
    1:       code='(',
    1:       arg=None,
    1:       stack_before=[],
    1:       stack_after=[markobject],
    1:       proto=0,
             doc="""Push markobject onto the stack.
       
             markobject is a unique object, used by other opcodes to identify a
             region of the stack containing a variable number of objects for them
             to work on.  See markobject.doc for more detail.
    1:       """),
       
    1:     I(name='POP_MARK',
    1:       code='1',
    1:       arg=None,
    1:       stack_before=[markobject, stackslice],
    1:       stack_after=[],
    1:       proto=1,
             doc="""Pop all the stack objects at and above the topmost markobject.
       
             When an opcode using a variable number of stack objects is done,
             POP_MARK is used to remove those objects, and to remove the markobject
             that delimited their starting position on the stack.
    1:       """),
       
           # Memo manipulation.  There are really only two operations (get and put),
           # each in all-text, "short binary", and "long binary" flavors.
       
    1:     I(name='GET',
    1:       code='g',
    1:       arg=decimalnl_short,
    1:       stack_before=[],
    1:       stack_after=[anyobject],
    1:       proto=0,
             doc="""Read an object from the memo and push it on the stack.
       
             The index of the memo object to push is given by the newline-terminated
             decimal string following.  BINGET and LONG_BINGET are space-optimized
             versions.
    1:       """),
       
    1:     I(name='BINGET',
    1:       code='h',
    1:       arg=uint1,
    1:       stack_before=[],
    1:       stack_after=[anyobject],
    1:       proto=1,
             doc="""Read an object from the memo and push it on the stack.
       
             The index of the memo object to push is given by the 1-byte unsigned
             integer following.
    1:       """),
       
    1:     I(name='LONG_BINGET',
    1:       code='j',
    1:       arg=int4,
    1:       stack_before=[],
    1:       stack_after=[anyobject],
    1:       proto=1,
             doc="""Read an object from the memo and push it on the stack.
       
             The index of the memo object to push is given by the 4-byte signed
             little-endian integer following.
    1:       """),
       
    1:     I(name='PUT',
    1:       code='p',
    1:       arg=decimalnl_short,
    1:       stack_before=[],
    1:       stack_after=[],
    1:       proto=0,
             doc="""Store the stack top into the memo.  The stack is not popped.
       
             The index of the memo location to write into is given by the newline-
             terminated decimal string following.  BINPUT and LONG_BINPUT are
             space-optimized versions.
    1:       """),
       
    1:     I(name='BINPUT',
    1:       code='q',
    1:       arg=uint1,
    1:       stack_before=[],
    1:       stack_after=[],
    1:       proto=1,
             doc="""Store the stack top into the memo.  The stack is not popped.
       
             The index of the memo location to write into is given by the 1-byte
             unsigned integer following.
    1:       """),
       
    1:     I(name='LONG_BINPUT',
    1:       code='r',
    1:       arg=int4,
    1:       stack_before=[],
    1:       stack_after=[],
    1:       proto=1,
             doc="""Store the stack top into the memo.  The stack is not popped.
       
             The index of the memo location to write into is given by the 4-byte
             signed little-endian integer following.
    1:       """),
       
           # Access the extension registry (predefined objects).  Akin to the GET
           # family.
       
    1:     I(name='EXT1',
    1:       code='\x82',
    1:       arg=uint1,
    1:       stack_before=[],
    1:       stack_after=[anyobject],
    1:       proto=2,
             doc="""Extension code.
       
             This code and the similar EXT2 and EXT4 allow using a registry
             of popular objects that are pickled by name, typically classes.
             It is envisioned that through a global negotiation and
             registration process, third parties can set up a mapping between
             ints and object names.
       
             In order to guarantee pickle interchangeability, the extension
             code registry ought to be global, although a range of codes may
             be reserved for private use.
       
             EXT1 has a 1-byte integer argument.  This is used to index into the
             extension registry, and the object at that index is pushed on the stack.
    1:       """),
       
    1:     I(name='EXT2',
    1:       code='\x83',
    1:       arg=uint2,
    1:       stack_before=[],
    1:       stack_after=[anyobject],
    1:       proto=2,
             doc="""Extension code.
       
             See EXT1.  EXT2 has a two-byte integer argument.
    1:       """),
       
    1:     I(name='EXT4',
    1:       code='\x84',
    1:       arg=int4,
    1:       stack_before=[],
    1:       stack_after=[anyobject],
    1:       proto=2,
             doc="""Extension code.
       
             See EXT1.  EXT4 has a four-byte integer argument.
    1:       """),
       
           # Push a class object, or module function, on the stack, via its module
           # and name.
       
    1:     I(name='GLOBAL',
    1:       code='c',
    1:       arg=stringnl_noescape_pair,
    1:       stack_before=[],
    1:       stack_after=[anyobject],
    1:       proto=0,
             doc="""Push a global object (module.attr) on the stack.
       
             Two newline-terminated strings follow the GLOBAL opcode.  The first is
             taken as a module name, and the second as a class name.  The class
             object module.class is pushed on the stack.  More accurately, the
             object returned by self.find_class(module, class) is pushed on the
             stack, so unpickling subclasses can override this form of lookup.
    1:       """),
       
           # Ways to build objects of classes pickle doesn't know about directly
           # (user-defined classes).  I despair of documenting this accurately
           # and comprehensibly -- you really have to read the pickle code to
           # find all the special cases.
       
    1:     I(name='REDUCE',
    1:       code='R',
    1:       arg=None,
    1:       stack_before=[anyobject, anyobject],
    1:       stack_after=[anyobject],
    1:       proto=0,
             doc="""Push an object built from a callable and an argument tuple.
       
             The opcode is named to remind of the __reduce__() method.
       
             Stack before: ... callable pytuple
             Stack after:  ... callable(*pytuple)
       
             The callable and the argument tuple are the first two items returned
             by a __reduce__ method.  Applying the callable to the argtuple is
             supposed to reproduce the original object, or at least get it started.
             If the __reduce__ method returns a 3-tuple, the last component is an
             argument to be passed to the object's __setstate__, and then the REDUCE
             opcode is followed by code to create setstate's argument, and then a
             BUILD opcode to apply  __setstate__ to that argument.
       
             If type(callable) is not ClassType, REDUCE complains unless the
             callable has been registered with the copy_reg module's
             safe_constructors dict, or the callable has a magic
             '__safe_for_unpickling__' attribute with a true value.  I'm not sure
             why it does this, but I've sure seen this complaint often enough when
             I didn't want to <wink>.
    1:       """),
       
    1:     I(name='BUILD',
    1:       code='b',
    1:       arg=None,
    1:       stack_before=[anyobject, anyobject],
    1:       stack_after=[anyobject],
    1:       proto=0,
             doc="""Finish building an object, via __setstate__ or dict update.
       
             Stack before: ... anyobject argument
             Stack after:  ... anyobject
       
             where anyobject may have been mutated, as follows:
       
             If the object has a __setstate__ method,
       
                 anyobject.__setstate__(argument)
       
             is called.
       
             Else the argument must be a dict, the object must have a __dict__, and
             the object is updated via
       
                 anyobject.__dict__.update(argument)
       
             This may raise RuntimeError in restricted execution mode (which
             disallows access to __dict__ directly); in that case, the object
             is updated instead via
       
                 for k, v in argument.items():
                     anyobject[k] = v
    1:       """),
       
    1:     I(name='INST',
    1:       code='i',
    1:       arg=stringnl_noescape_pair,
    1:       stack_before=[markobject, stackslice],
    1:       stack_after=[anyobject],
    1:       proto=0,
             doc="""Build a class instance.
       
             This is the protocol 0 version of protocol 1's OBJ opcode.
             INST is followed by two newline-terminated strings, giving a
             module and class name, just as for the GLOBAL opcode (and see
             GLOBAL for more details about that).  self.find_class(module, name)
             is used to get a class object.
       
             In addition, all the objects on the stack following the topmost
             markobject are gathered into a tuple and popped (along with the
             topmost markobject), just as for the TUPLE opcode.
       
             Now it gets complicated.  If all of these are true:
       
               + The argtuple is empty (markobject was at the top of the stack
                 at the start).
       
               + It's an old-style class object (the type of the class object is
                 ClassType).
       
               + The class object does not have a __getinitargs__ attribute.
       
             then we want to create an old-style class instance without invoking
             its __init__() method (pickle has waffled on this over the years; not
             calling __init__() is current wisdom).  In this case, an instance of
             an old-style dummy class is created, and then we try to rebind its
             __class__ attribute to the desired class object.  If this succeeds,
             the new instance object is pushed on the stack, and we're done.  In
             restricted execution mode it can fail (assignment to __class__ is
             disallowed), and I'm not really sure what happens then -- it looks
             like the code ends up calling the class object's __init__ anyway,
             via falling into the next case.
       
             Else (the argtuple is not empty, it's not an old-style class object,
             or the class object does have a __getinitargs__ attribute), the code
             first insists that the class object have a __safe_for_unpickling__
             attribute.  Unlike as for the __safe_for_unpickling__ check in REDUCE,
             it doesn't matter whether this attribute has a true or false value, it
             only matters whether it exists (XXX this is a bug; cPickle
             requires the attribute to be true).  If __safe_for_unpickling__
             doesn't exist, UnpicklingError is raised.
       
             Else (the class object does have a __safe_for_unpickling__ attr),
             the class object obtained from INST's arguments is applied to the
             argtuple obtained from the stack, and the resulting instance object
             is pushed on the stack.
       
             NOTE:  checks for __safe_for_unpickling__ went away in Python 2.3.
    1:       """),
       
    1:     I(name='OBJ',
    1:       code='o',
    1:       arg=None,
    1:       stack_before=[markobject, anyobject, stackslice],
    1:       stack_after=[anyobject],
    1:       proto=1,
             doc="""Build a class instance.
       
             This is the protocol 1 version of protocol 0's INST opcode, and is
             very much like it.  The major difference is that the class object
             is taken off the stack, allowing it to be retrieved from the memo
             repeatedly if several instances of the same class are created.  This
             can be much more efficient (in both time and space) than repeatedly
             embedding the module and class names in INST opcodes.
       
             Unlike INST, OBJ takes no arguments from the opcode stream.  Instead
             the class object is taken off the stack, immediately above the
             topmost markobject:
       
             Stack before: ... markobject classobject stackslice
             Stack after:  ... new_instance_object
       
             As for INST, the remainder of the stack above the markobject is
             gathered into an argument tuple, and then the logic seems identical,
             except that no __safe_for_unpickling__ check is done (XXX this is
             a bug; cPickle does test __safe_for_unpickling__).  See INST for
             the gory details.
       
             NOTE:  In Python 2.3, INST and OBJ are identical except for how they
             get the class object.  That was always the intent; the implementations
             had diverged for accidental reasons.
    1:       """),
       
    1:     I(name='NEWOBJ',
    1:       code='\x81',
    1:       arg=None,
    1:       stack_before=[anyobject, anyobject],
    1:       stack_after=[anyobject],
    1:       proto=2,
             doc="""Build an object instance.
       
             The stack before should be thought of as containing a class
             object followed by an argument tuple (the tuple being the stack
             top).  Call these cls and args.  They are popped off the stack,
             and the value returned by cls.__new__(cls, *args) is pushed back
             onto the stack.
    1:       """),
       
           # Machine control.
       
    1:     I(name='PROTO',
    1:       code='\x80',
    1:       arg=uint1,
    1:       stack_before=[],
    1:       stack_after=[],
    1:       proto=2,
             doc="""Protocol version indicator.
       
             For protocol 2 and above, a pickle must start with this opcode.
             The argument is the protocol version, an int in range(2, 256).
    1:       """),
       
    1:     I(name='STOP',
    1:       code='.',
    1:       arg=None,
    1:       stack_before=[anyobject],
    1:       stack_after=[],
    1:       proto=0,
             doc="""Stop the unpickling machine.
       
             Every pickle ends with this opcode.  The object at the top of the stack
             is popped, and that's the result of unpickling.  The stack should be
             empty then.
    1:       """),
       
           # Ways to deal with persistent IDs.
       
    1:     I(name='PERSID',
    1:       code='P',
    1:       arg=stringnl_noescape,
    1:       stack_before=[],
    1:       stack_after=[anyobject],
    1:       proto=0,
             doc="""Push an object identified by a persistent ID.
       
             The pickle module doesn't define what a persistent ID means.  PERSID's
             argument is a newline-terminated str-style (no embedded escapes, no
             bracketing quote characters) string, which *is* "the persistent ID".
             The unpickler passes this string to self.persistent_load().  Whatever
             object that returns is pushed on the stack.  There is no implementation
             of persistent_load() in Python's unpickler:  it must be supplied by an
             unpickler subclass.
    1:       """),
       
    1:     I(name='BINPERSID',
    1:       code='Q',
    1:       arg=None,
    1:       stack_before=[anyobject],
    1:       stack_after=[anyobject],
    1:       proto=1,
             doc="""Push an object identified by a persistent ID.
       
             Like PERSID, except the persistent ID is popped off the stack (instead
             of being a string embedded in the opcode bytestream).  The persistent
             ID is passed to self.persistent_load(), and whatever object that
             returns is pushed on the stack.  See PERSID for more detail.
    1:       """),
       ]
    1: del I
       
       # Verify uniqueness of .name and .code members.
    1: name2i = {}
    1: code2i = {}
       
   54: for i, d in enumerate(opcodes):
   53:     if d.name in name2i:
>>>>>>         raise ValueError("repeated name %r at indices %d and %d" %
>>>>>>                          (d.name, name2i[d.name], i))
   53:     if d.code in code2i:
>>>>>>         raise ValueError("repeated code %r at indices %d and %d" %
>>>>>>                          (d.code, code2i[d.code], i))
       
   53:     name2i[d.name] = i
   53:     code2i[d.code] = i
       
    1: del name2i, code2i, i, d
       
       ##############################################################################
       # Build a code2op dict, mapping opcode characters to OpcodeInfo records.
       # Also ensure we've got the same stuff as pickle.py, although the
       # introspection here is dicey.
       
    1: code2op = {}
   54: for d in opcodes:
   53:     code2op[d.code] = d
    1: del d
       
    1: def assure_pickle_consistency(verbose=False):
    1:     import pickle, re
       
    1:     copy = code2op.copy()
   66:     for name in pickle.__all__:
   65:         if not re.match("[A-Z][A-Z0-9_]+$", name):
    9:             if verbose:
>>>>>>                 print "skipping %r: it doesn't look like an opcode name" % name
>>>>>>             continue
   56:         picklecode = getattr(pickle, name)
   56:         if not isinstance(picklecode, str) or len(picklecode) != 1:
    3:             if verbose:
>>>>>>                 print ("skipping %r: value %r doesn't look like a pickle "
>>>>>>                        "code" % (name, picklecode))
>>>>>>             continue
   53:         if picklecode in copy:
   53:             if verbose:
>>>>>>                 print "checking name %r w/ code %r for consistency" % (
>>>>>>                       name, picklecode)
   53:             d = copy[picklecode]
   53:             if d.name != name:
>>>>>>                 raise ValueError("for pickle code %r, pickle.py uses name %r "
>>>>>>                                  "but we're using name %r" % (picklecode,
>>>>>>                                                               name,
>>>>>>                                                               d.name))
                   # Forget this one.  Any left over in copy at the end are a problem
                   # of a different kind.
   53:             del copy[picklecode]
               else:
>>>>>>             raise ValueError("pickle.py appears to have a pickle opcode with "
                                    "name %r and code %r, but we don't" %
>>>>>>                              (name, picklecode))
    1:     if copy:
>>>>>>         msg = ["we appear to have pickle opcodes that pickle.py doesn't have:"]
>>>>>>         for code, d in copy.items():
>>>>>>             msg.append("    name %r with code %r" % (d.name, code))
>>>>>>         raise ValueError("\n".join(msg))
       
    1: assure_pickle_consistency()
    1: del assure_pickle_consistency
       
       ##############################################################################
       # A pickle opcode generator.
       
    1: def genops(pickle):
           """Generate all the opcodes in a pickle.
       
           'pickle' is a file-like object, or string, containing the pickle.
       
           Each opcode in the pickle is generated, from the current pickle position,
           stopping after a STOP opcode is delivered.  A triple is generated for
           each opcode:
       
               opcode, arg, pos
       
           opcode is an OpcodeInfo record, describing the current opcode.
       
           If the opcode has an argument embedded in the pickle, arg is its decoded
           value, as a Python object.  If the opcode doesn't have an argument, arg
           is None.
       
           If the pickle has a tell() method, pos was the value of pickle.tell()
           before reading the current opcode.  If the pickle is a string object,
           it's wrapped in a StringIO object, and the latter's tell() result is
           used.  Else (the pickle doesn't have a tell(), and it's not obvious how
           to query its current position) pos is None.
           """
       
 1692:     import cStringIO as StringIO
       
 1692:     if isinstance(pickle, str):
 1690:         pickle = StringIO.StringIO(pickle)
       
 1692:     if hasattr(pickle, "tell"):
 1692:         getpos = pickle.tell
           else:
>>>>>>         getpos = lambda: None
       
403331:     while True:
403331:         pos = getpos()
403331:         code = pickle.read(1)
403331:         opcode = code2op.get(code)
403331:         if opcode is None:
>>>>>>             if code == "":
>>>>>>                 raise ValueError("pickle exhausted before seeing STOP")
                   else:
>>>>>>                 raise ValueError("at position %s, opcode %r unknown" % (
>>>>>>                                  pos is None and "<unknown>" or pos,
>>>>>>                                  code))
403331:         if opcode.arg is None:
182492:             arg = None
               else:
220839:             arg = opcode.arg.reader(pickle)
403331:         yield opcode, arg, pos
402813:         if code == '.':
 1174:             assert opcode.name == 'STOP'
 1174:             break
       
       ##############################################################################
       # A pickle optimizer.
       
    1: def optimize(p):
           'Optimize a pickle string by removing unused PUT opcodes'
  799:     gets = set()            # set of args used by a GET opcode
  799:     puts = []               # (arg, startpos, stoppos) for the PUT opcodes
  799:     prevpos = None          # set to pos if previous opcode was a PUT
38246:     for opcode, arg, pos in genops(p):
37447:         if prevpos is not None:
 1770:             puts.append((prevarg, prevpos, pos))
 1770:             prevpos = None
37447:         if 'PUT' in opcode.name:
 1770:             prevarg, prevpos = arg, pos
35677:         elif 'GET' in opcode.name:
 1312:             gets.add(arg)
       
           # Copy the pickle string except for PUTS without a corresponding GET
  799:     s = []
  799:     i = 0
 2569:     for arg, start, stop in puts:
 1770:         j = stop if (arg in gets) else start
 1770:         s.append(p[i:j])
 1770:         i = stop
  799:     s.append(p[i:])
  799:     return ''.join(s)
       
       ##############################################################################
       # A symbolic pickle disassembler.
       
    1: def dis(pickle, out=None, memo=None, indentlevel=4):
           """Produce a symbolic disassembly of a pickle.
       
           'pickle' is a file-like object, or string, containing a (at least one)
           pickle.  The pickle is disassembled from the current position, through
           the first STOP opcode encountered.
       
           Optional arg 'out' is a file-like object to which the disassembly is
           printed.  It defaults to sys.stdout.
       
           Optional arg 'memo' is a Python dict, used as the pickle's memo.  It
           may be mutated by dis(), if the pickle contains PUT or BINPUT opcodes.
           Passing the same memo object to another dis() call then allows disassembly
           to proceed across multiple pickles that were all created by the same
           pickler with the same memo.  Ordinarily you don't need to worry about this.
       
           Optional arg indentlevel is the number of blanks by which to indent
           a new MARK level.  It defaults to 4.
       
           In addition to printing the disassembly, some sanity checks are made:
       
           + All embedded opcode arguments "make sense".
       
           + Explicit and implicit pop operations have enough items on the stack.
       
           + When an opcode implicitly refers to a markobject, a markobject is
             actually on the stack.
       
           + A memo entry isn't referenced before it's defined.
       
           + The markobject isn't stored in the memo.
       
           + A memo entry isn't redefined.
           """
       
           # Most of the hair here is for sanity checks, but most of it is needed
           # anyway to detect when a protocol 0 POP takes a MARK off the stack
           # (which in turn is needed to indent MARK blocks correctly).
       
   13:     stack = []          # crude emulation of unpickler stack
   13:     if memo is None:
   11:         memo = {}       # crude emulation of unpickler memo
   13:     maxproto = -1       # max protocol number seen
   13:     markstack = []      # bytecode positions of MARK opcodes
   13:     indentchunk = ' ' * indentlevel
   13:     errormsg = None
  165:     for opcode, arg, pos in genops(pickle):
  152:         if pos is not None:
  152:             print >> out, "%5d:" % pos,
       
  152:         line = "%-4s %s%s" % (repr(opcode.code)[1:-1],
  152:                               indentchunk * len(markstack),
  152:                               opcode.name)
       
  152:         maxproto = max(maxproto, opcode.proto)
  152:         before = opcode.stack_before    # don't mutate
  152:         after = opcode.stack_after      # don't mutate
  152:         numtopop = len(before)
       
               # See whether a MARK should be popped.
  152:         markmsg = None
  152:         if markobject in before or (opcode.name == "POP" and
    3:                                     stack and
    3:                                     stack[-1] is markobject):
   19:             assert markobject not in after
                   if __debug__:
   19:                 if markobject in before:
   18:                     assert before[-1] is stackslice
   19:             if markstack:
   19:                 markpos = markstack.pop()
   19:                 if markpos is None:
>>>>>>                     markmsg = "(MARK at unknown opcode offset)"
                       else:
   19:                     markmsg = "(MARK at %d)" % markpos
                       # Pop everything at and after the topmost markobject.
   38:                 while stack[-1] is not markobject:
   19:                     stack.pop()
   19:                 stack.pop()
                       # Stop later code from popping too much.
   19:                 try:
   19:                     numtopop = before.index(markobject)
    1:                 except ValueError:
    1:                     assert opcode.name == "POP"
    1:                     numtopop = 0
                   else:
>>>>>>                 errormsg = markmsg = "no MARK exists on stack"
       
               # Check for correct memo usage.
  152:         if opcode.name in ("PUT", "BINPUT", "LONG_BINPUT"):
   33:             assert arg is not None
   33:             if arg in memo:
>>>>>>                 errormsg = "memo key %r already defined" % arg
   33:             elif not stack:
>>>>>>                 errormsg = "stack is empty -- can't store into memo"
   33:             elif stack[-1] is markobject:
>>>>>>                 errormsg = "can't store markobject in the memo"
                   else:
   33:                 memo[arg] = stack[-1]
       
  119:         elif opcode.name in ("GET", "BINGET", "LONG_BINGET"):
   12:             if arg in memo:
   12:                 assert len(after) == 1
   12:                 after = [memo[arg]]     # for better stack emulation
                   else:
>>>>>>                 errormsg = "memo key %r has never been stored into" % arg
       
  152:         if arg is not None or markmsg:
                   # make a mild effort to align arguments
   89:             line += ' ' * (10 - len(opcode.name))
   89:             if arg is not None:
   71:                 line += ' ' + repr(arg)
   89:             if markmsg:
   19:                 line += ' ' + markmsg
  152:         print >> out, line
       
  152:         if errormsg:
                   # Note that we delayed complaining until the offending opcode
                   # was printed.
>>>>>>             raise ValueError(errormsg)
       
               # Emulate the stack effects.
  152:         if len(stack) < numtopop:
>>>>>>             raise ValueError("tries to pop %d items from stack with "
>>>>>>                              "only %d items" % (numtopop, len(stack)))
  152:         if numtopop:
   38:             del stack[-numtopop:]
  152:         if markobject in after:
   19:             assert markobject not in before
   19:             markstack.append(pos)
       
  152:         stack.extend(after)
       
   13:     print >> out, "highest protocol among opcodes =", maxproto
   13:     if stack:
>>>>>>         raise ValueError("stack not empty after STOP: %r" % stack)
       
       # For use in the doctest, simply as an example of a class to pickle.
    2: class _Example:
    1:     def __init__(self, value):
    1:         self.value = value
       
       _dis_test = r"""
       >>> import pickle
       >>> x = [1, 2, (3, 4), {'abc': u"def"}]
       >>> pkl = pickle.dumps(x, 0)
       >>> dis(pkl)
           0: (    MARK
           1: l        LIST       (MARK at 0)
           2: p    PUT        0
           5: I    INT        1
           8: a    APPEND
           9: I    INT        2
          12: a    APPEND
          13: (    MARK
          14: I        INT        3
          17: I        INT        4
          20: t        TUPLE      (MARK at 13)
          21: p    PUT        1
          24: a    APPEND
          25: (    MARK
          26: d        DICT       (MARK at 25)
          27: p    PUT        2
          30: S    STRING     'abc'
          37: p    PUT        3
          40: V    UNICODE    u'def'
          45: p    PUT        4
          48: s    SETITEM
          49: a    APPEND
          50: .    STOP
       highest protocol among opcodes = 0
       
       Try again with a "binary" pickle.
       
       >>> pkl = pickle.dumps(x, 1)
       >>> dis(pkl)
           0: ]    EMPTY_LIST
           1: q    BINPUT     0
           3: (    MARK
           4: K        BININT1    1
           6: K        BININT1    2
           8: (        MARK
           9: K            BININT1    3
          11: K            BININT1    4
          13: t            TUPLE      (MARK at 8)
          14: q        BINPUT     1
          16: }        EMPTY_DICT
          17: q        BINPUT     2
          19: U        SHORT_BINSTRING 'abc'
          24: q        BINPUT     3
          26: X        BINUNICODE u'def'
          34: q        BINPUT     4
          36: s        SETITEM
          37: e        APPENDS    (MARK at 3)
          38: .    STOP
       highest protocol among opcodes = 1
       
       Exercise the INST/OBJ/BUILD family.
       
       >>> import pickletools
       >>> dis(pickle.dumps(pickletools.dis, 0))
           0: c    GLOBAL     'pickletools dis'
          17: p    PUT        0
          20: .    STOP
       highest protocol among opcodes = 0
       
       >>> from pickletools import _Example
       >>> x = [_Example(42)] * 2
       >>> dis(pickle.dumps(x, 0))
           0: (    MARK
           1: l        LIST       (MARK at 0)
           2: p    PUT        0
           5: (    MARK
           6: i        INST       'pickletools _Example' (MARK at 5)
          28: p    PUT        1
          31: (    MARK
          32: d        DICT       (MARK at 31)
          33: p    PUT        2
          36: S    STRING     'value'
          45: p    PUT        3
          48: I    INT        42
          52: s    SETITEM
          53: b    BUILD
          54: a    APPEND
          55: g    GET        1
          58: a    APPEND
          59: .    STOP
       highest protocol among opcodes = 0
       
       >>> dis(pickle.dumps(x, 1))
           0: ]    EMPTY_LIST
           1: q    BINPUT     0
           3: (    MARK
           4: (        MARK
           5: c            GLOBAL     'pickletools _Example'
          27: q            BINPUT     1
          29: o            OBJ        (MARK at 4)
          30: q        BINPUT     2
          32: }        EMPTY_DICT
          33: q        BINPUT     3
          35: U        SHORT_BINSTRING 'value'
          42: q        BINPUT     4
          44: K        BININT1    42
          46: s        SETITEM
          47: b        BUILD
          48: h        BINGET     2
          50: e        APPENDS    (MARK at 3)
          51: .    STOP
       highest protocol among opcodes = 1
       
       Try "the canonical" recursive-object test.
       
       >>> L = []
       >>> T = L,
       >>> L.append(T)
       >>> L[0] is T
       True
       >>> T[0] is L
       True
       >>> L[0][0] is L
       True
       >>> T[0][0] is T
       True
       >>> dis(pickle.dumps(L, 0))
           0: (    MARK
           1: l        LIST       (MARK at 0)
           2: p    PUT        0
           5: (    MARK
           6: g        GET        0
           9: t        TUPLE      (MARK at 5)
          10: p    PUT        1
          13: a    APPEND
          14: .    STOP
       highest protocol among opcodes = 0
       
       >>> dis(pickle.dumps(L, 1))
           0: ]    EMPTY_LIST
           1: q    BINPUT     0
           3: (    MARK
           4: h        BINGET     0
           6: t        TUPLE      (MARK at 3)
           7: q    BINPUT     1
           9: a    APPEND
          10: .    STOP
       highest protocol among opcodes = 1
       
       Note that, in the protocol 0 pickle of the recursive tuple, the disassembler
       has to emulate the stack in order to realize that the POP opcode at 16 gets
       rid of the MARK at 0.
       
       >>> dis(pickle.dumps(T, 0))
           0: (    MARK
           1: (        MARK
           2: l            LIST       (MARK at 1)
           3: p        PUT        0
           6: (        MARK
           7: g            GET        0
          10: t            TUPLE      (MARK at 6)
          11: p        PUT        1
          14: a        APPEND
          15: 0        POP
          16: 0        POP        (MARK at 0)
          17: g    GET        1
          20: .    STOP
       highest protocol among opcodes = 0
       
       >>> dis(pickle.dumps(T, 1))
           0: (    MARK
           1: ]        EMPTY_LIST
           2: q        BINPUT     0
           4: (        MARK
           5: h            BINGET     0
           7: t            TUPLE      (MARK at 4)
           8: q        BINPUT     1
          10: a        APPEND
          11: 1        POP_MARK   (MARK at 0)
          12: h    BINGET     1
          14: .    STOP
       highest protocol among opcodes = 1
       
       Try protocol 2.
       
       >>> dis(pickle.dumps(L, 2))
           0: \x80 PROTO      2
           2: ]    EMPTY_LIST
           3: q    BINPUT     0
           5: h    BINGET     0
           7: \x85 TUPLE1
           8: q    BINPUT     1
          10: a    APPEND
          11: .    STOP
       highest protocol among opcodes = 2
       
       >>> dis(pickle.dumps(T, 2))
           0: \x80 PROTO      2
           2: ]    EMPTY_LIST
           3: q    BINPUT     0
           5: h    BINGET     0
           7: \x85 TUPLE1
           8: q    BINPUT     1
          10: a    APPEND
          11: 0    POP
          12: h    BINGET     1
          14: .    STOP
       highest protocol among opcodes = 2
    1: """
       
       _memo_test = r"""
       >>> import pickle
       >>> from StringIO import StringIO
       >>> f = StringIO()
       >>> p = pickle.Pickler(f, 2)
       >>> x = [1, 2, 3]
       >>> p.dump(x)
       >>> p.dump(x)
       >>> f.seek(0)
       >>> memo = {}
       >>> dis(f, memo=memo)
           0: \x80 PROTO      2
           2: ]    EMPTY_LIST
           3: q    BINPUT     0
           5: (    MARK
           6: K        BININT1    1
           8: K        BININT1    2
          10: K        BININT1    3
          12: e        APPENDS    (MARK at 5)
          13: .    STOP
       highest protocol among opcodes = 2
       >>> dis(f, memo=memo)
          14: \x80 PROTO      2
          16: h    BINGET     0
          18: .    STOP
       highest protocol among opcodes = 2
    1: """
       
    1: __test__ = {'disassembler_test': _dis_test,
    1:             'disassembler_memo_test': _memo_test,
                  }
       
    1: def _test():
>>>>>>     import doctest
>>>>>>     return doctest.testmod()
       
    1: if __name__ == "__main__":
>>>>>>     _test()
