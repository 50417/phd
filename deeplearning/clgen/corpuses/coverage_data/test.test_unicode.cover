       """ Test script for the Unicode implementation.
       
       Written by Marc-Andre Lemburg (mal@lemburg.com).
       
       (c) Copyright CNRI, All Rights Reserved. NO WARRANTY.
       
    1: """#"
    1: import sys
    1: import struct
    1: import codecs
    1: import unittest
    1: from test import test_support, string_tests
       
       # decorator to skip tests on narrow builds
    1: requires_wide_build = unittest.skipIf(sys.maxunicode == 65535,
    1:                                       'requires wide build')
       
       # Error handling (bad decoder return)
    1: def search_function(encoding):
    3:     def decode1(input, errors="strict"):
    1:         return 42 # not a tuple
    3:     def encode1(input, errors="strict"):
    1:         return 42 # not a tuple
    3:     def encode2(input, errors="strict"):
    1:         return (42, 42) # no unicode
    3:     def decode2(input, errors="strict"):
    1:         return (42, 42) # no unicode
    3:     if encoding=="test.unicode1":
    1:         return (encode1, decode1, None, None)
    2:     elif encoding=="test.unicode2":
    1:         return (encode2, decode2, None, None)
           else:
    1:         return None
    1: codecs.register(search_function)
       
    2: class UnicodeSubclass(unicode):
    1:     pass
       
    2: class UnicodeTest(
    1:     string_tests.CommonTest,
    1:     string_tests.MixinStrUnicodeUserStringTest,
    1:     string_tests.MixinStrUnicodeTest,
           ):
    1:     type2test = unicode
       
    1:     def assertEqual(self, first, second, msg=None):
               # strict assertEqual method: reject implicit bytes/unicode equality
213191:         super(UnicodeTest, self).assertEqual(first, second, msg)
213191:         if isinstance(first, unicode) or isinstance(second, unicode):
79974:             self.assertIsInstance(first, unicode)
79974:             self.assertIsInstance(second, unicode)
133217:         elif isinstance(first, str) or isinstance(second, str):
  264:             self.assertIsInstance(first, str)
  264:             self.assertIsInstance(second, str)
       
    1:     def checkequalnofix(self, result, object, methodname, *args):
   75:         method = getattr(object, methodname)
   75:         realresult = method(*args)
   75:         self.assertEqual(realresult, result)
   75:         self.assertTrue(type(realresult) is type(result))
       
               # if the original is returned make sure that
               # this doesn't happen with subclasses
   75:         if realresult is object:
>>>>>>             class usub(unicode):
>>>>>>                 def __repr__(self):
>>>>>>                     return 'usub(%r)' % unicode.__repr__(self)
>>>>>>             object = usub(object)
>>>>>>             method = getattr(object, methodname)
>>>>>>             realresult = method(*args)
>>>>>>             self.assertEqual(realresult, result)
>>>>>>             self.assertTrue(object is not realresult)
       
    1:     def test_literals(self):
    1:         self.assertEqual(u'\xff', u'\u00ff')
    1:         self.assertEqual(u'\uffff', u'\U0000ffff')
    1:         self.assertRaises(SyntaxError, eval, 'u\'\\Ufffffffe\'')
    1:         self.assertRaises(SyntaxError, eval, 'u\'\\Uffffffff\'')
    1:         self.assertRaises(SyntaxError, eval, 'u\'\\U%08x\'' % 0x110000)
       
    1:     def test_repr(self):
    1:         if not sys.platform.startswith('java'):
                   # Test basic sanity of repr()
    1:             self.assertEqual(repr(u'abc'), "u'abc'")
    1:             self.assertEqual(repr(u'ab\\c'), "u'ab\\\\c'")
    1:             self.assertEqual(repr(u'ab\\'), "u'ab\\\\'")
    1:             self.assertEqual(repr(u'\\c'), "u'\\\\c'")
    1:             self.assertEqual(repr(u'\\'), "u'\\\\'")
    1:             self.assertEqual(repr(u'\n'), "u'\\n'")
    1:             self.assertEqual(repr(u'\r'), "u'\\r'")
    1:             self.assertEqual(repr(u'\t'), "u'\\t'")
    1:             self.assertEqual(repr(u'\b'), "u'\\x08'")
    1:             self.assertEqual(repr(u"'\""), """u'\\'"'""")
    1:             self.assertEqual(repr(u"'\""), """u'\\'"'""")
    1:             self.assertEqual(repr(u"'"), '''u"'"''')
    1:             self.assertEqual(repr(u'"'), """u'"'""")
                   latin1repr = (
    1:                 "u'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\\r"
                       "\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a"
                       "\\x1b\\x1c\\x1d\\x1e\\x1f !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHI"
                       "JKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\x7f"
                       "\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d"
                       "\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b"
                       "\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9"
                       "\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7"
                       "\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5"
                       "\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\\xd2\\xd3"
                       "\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\\xe1"
                       "\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef"
                       "\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd"
                       "\\xfe\\xff'")
    1:             testrepr = repr(u''.join(map(unichr, xrange(256))))
    1:             self.assertEqual(testrepr, latin1repr)
                   # Test repr works on wide unicode escapes without overflow.
    1:             self.assertEqual(repr(u"\U00010000" * 39 + u"\uffff" * 4096),
    1:                              repr(u"\U00010000" * 39 + u"\uffff" * 4096))
       
       
    1:     def test_count(self):
    1:         string_tests.CommonTest.test_count(self)
               # check mixed argument types
    1:         self.checkequalnofix(3,  'aaa', 'count', u'a')
    1:         self.checkequalnofix(0,  'aaa', 'count', u'b')
    1:         self.checkequalnofix(3, u'aaa', 'count',  'a')
    1:         self.checkequalnofix(0, u'aaa', 'count',  'b')
    1:         self.checkequalnofix(0, u'aaa', 'count',  'b')
    1:         self.checkequalnofix(1, u'aaa', 'count',  'a', -1)
    1:         self.checkequalnofix(3, u'aaa', 'count',  'a', -10)
    1:         self.checkequalnofix(2, u'aaa', 'count',  'a', 0, -1)
    1:         self.checkequalnofix(0, u'aaa', 'count',  'a', 0, -10)
       
    1:     def test_find(self):
    1:         self.checkequalnofix(0,  u'abcdefghiabc', 'find', u'abc')
    1:         self.checkequalnofix(9,  u'abcdefghiabc', 'find', u'abc', 1)
    1:         self.checkequalnofix(-1, u'abcdefghiabc', 'find', u'def', 4)
       
    1:         self.assertRaises(TypeError, u'hello'.find)
    1:         self.assertRaises(TypeError, u'hello'.find, 42)
       
    1:     def test_rfind(self):
    1:         string_tests.CommonTest.test_rfind(self)
               # check mixed argument types
    1:         self.checkequalnofix(9,   'abcdefghiabc', 'rfind', u'abc')
    1:         self.checkequalnofix(12,  'abcdefghiabc', 'rfind', u'')
    1:         self.checkequalnofix(12, u'abcdefghiabc', 'rfind',  '')
       
    1:     def test_index(self):
    1:         string_tests.CommonTest.test_index(self)
               # check mixed argument types
    3:         for (t1, t2) in ((str, unicode), (unicode, str)):
    2:             self.checkequalnofix(0, t1('abcdefghiabc'), 'index',  t2(''))
    2:             self.checkequalnofix(3, t1('abcdefghiabc'), 'index',  t2('def'))
    2:             self.checkequalnofix(0, t1('abcdefghiabc'), 'index',  t2('abc'))
    2:             self.checkequalnofix(9, t1('abcdefghiabc'), 'index',  t2('abc'), 1)
    2:             self.assertRaises(ValueError, t1('abcdefghiabc').index, t2('hib'))
    2:             self.assertRaises(ValueError, t1('abcdefghiab').index,  t2('abc'), 1)
    2:             self.assertRaises(ValueError, t1('abcdefghi').index,  t2('ghi'), 8)
    2:             self.assertRaises(ValueError, t1('abcdefghi').index,  t2('ghi'), -1)
       
    1:     def test_rindex(self):
    1:         string_tests.CommonTest.test_rindex(self)
               # check mixed argument types
    3:         for (t1, t2) in ((str, unicode), (unicode, str)):
    2:             self.checkequalnofix(12, t1('abcdefghiabc'), 'rindex',  t2(''))
    2:             self.checkequalnofix(3,  t1('abcdefghiabc'), 'rindex',  t2('def'))
    2:             self.checkequalnofix(9,  t1('abcdefghiabc'), 'rindex',  t2('abc'))
    2:             self.checkequalnofix(0,  t1('abcdefghiabc'), 'rindex',  t2('abc'), 0, -1)
       
    2:             self.assertRaises(ValueError, t1('abcdefghiabc').rindex,  t2('hib'))
    2:             self.assertRaises(ValueError, t1('defghiabc').rindex,  t2('def'), 1)
    2:             self.assertRaises(ValueError, t1('defghiabc').rindex,  t2('abc'), 0, -1)
    2:             self.assertRaises(ValueError, t1('abcdefghi').rindex,  t2('ghi'), 0, 8)
    2:             self.assertRaises(ValueError, t1('abcdefghi').rindex,  t2('ghi'), 0, -1)
       
    1:     def test_translate(self):
    1:         self.checkequalnofix(u'bbbc', u'abababc', 'translate', {ord('a'):None})
    1:         self.checkequalnofix(u'iiic', u'abababc', 'translate', {ord('a'):None, ord('b'):ord('i')})
    1:         self.checkequalnofix(u'iiix', u'abababc', 'translate', {ord('a'):None, ord('b'):ord('i'), ord('c'):u'x'})
    1:         self.checkequalnofix(u'<i><i><i>c', u'abababc', 'translate', {ord('a'):None, ord('b'):u'<i>'})
    1:         self.checkequalnofix(u'c', u'abababc', 'translate', {ord('a'):None, ord('b'):u''})
    1:         self.checkequalnofix(u'xyyx', u'xzx', 'translate', {ord('z'):u'yy'})
       
    1:         self.assertRaises(TypeError, u'hello'.translate)
    1:         self.assertRaises(TypeError, u'abababc'.translate, {ord('a'):''})
       
    1:     def test_split(self):
    1:         string_tests.CommonTest.test_split(self)
       
               # Mixed arguments
    1:         self.checkequalnofix([u'a', u'b', u'c', u'd'], u'a//b//c//d', 'split', '//')
    1:         self.checkequalnofix([u'a', u'b', u'c', u'd'], 'a//b//c//d', 'split', u'//')
    1:         self.checkequalnofix([u'endcase ', u''], u'endcase test', 'split', 'test')
       
    1:     def test_join(self):
    1:         string_tests.MixinStrUnicodeUserStringTest.test_join(self)
       
               # mixed arguments
    1:         self.checkequalnofix(u'a b c d', u' ', 'join', ['a', 'b', u'c', u'd'])
    1:         self.checkequalnofix(u'abcd', u'', 'join', (u'a', u'b', u'c', u'd'))
    1:         self.checkequalnofix(u'w x y z', u' ', 'join', string_tests.Sequence('wxyz'))
    1:         self.checkequalnofix(u'a b c d', ' ', 'join', [u'a', u'b', u'c', u'd'])
    1:         self.checkequalnofix(u'a b c d', ' ', 'join', ['a', 'b', u'c', u'd'])
    1:         self.checkequalnofix(u'abcd', '', 'join', (u'a', u'b', u'c', u'd'))
    1:         self.checkequalnofix(u'w x y z', ' ', 'join', string_tests.Sequence(u'wxyz'))
       
    1:     def test_strip(self):
    1:         string_tests.CommonTest.test_strip(self)
    1:         self.assertRaises(UnicodeError, u"hello".strip, "\xff")
       
    1:     def test_replace(self):
    1:         string_tests.CommonTest.test_replace(self)
       
               # method call forwarded from str implementation because of unicode argument
    1:         self.checkequalnofix(u'one@two!three!', 'one!two!three!', 'replace', u'!', u'@', 1)
    1:         self.assertRaises(TypeError, 'replace'.replace, u"r", 42)
       
    1:     def test_comparison(self):
               # Comparisons:
    1:         self.assertTrue(u'abc' == 'abc')
    1:         self.assertTrue('abc' == u'abc')
    1:         self.assertTrue(u'abc' == u'abc')
    1:         self.assertTrue(u'abcd' > 'abc')
    1:         self.assertTrue('abcd' > u'abc')
    1:         self.assertTrue(u'abcd' > u'abc')
    1:         self.assertTrue(u'abc' < 'abcd')
    1:         self.assertTrue('abc' < u'abcd')
    1:         self.assertTrue(u'abc' < u'abcd')
       
               if 0:
                   # Move these tests to a Unicode collation module test...
                   # Testing UTF-16 code point order comparisons...
       
                   # No surrogates, no fixup required.
                   self.assertTrue(u'\u0061' < u'\u20ac')
                   # Non surrogate below surrogate value, no fixup required
                   self.assertTrue(u'\u0061' < u'\ud800\udc02')
       
                   # Non surrogate above surrogate value, fixup required
                   def test_lecmp(s, s2):
                       self.assertTrue(s < s2)
       
                   def test_fixup(s):
                       s2 = u'\ud800\udc01'
                       test_lecmp(s, s2)
                       s2 = u'\ud900\udc01'
                       test_lecmp(s, s2)
                       s2 = u'\uda00\udc01'
                       test_lecmp(s, s2)
                       s2 = u'\udb00\udc01'
                       test_lecmp(s, s2)
                       s2 = u'\ud800\udd01'
                       test_lecmp(s, s2)
                       s2 = u'\ud900\udd01'
                       test_lecmp(s, s2)
                       s2 = u'\uda00\udd01'
                       test_lecmp(s, s2)
                       s2 = u'\udb00\udd01'
                       test_lecmp(s, s2)
                       s2 = u'\ud800\ude01'
                       test_lecmp(s, s2)
                       s2 = u'\ud900\ude01'
                       test_lecmp(s, s2)
                       s2 = u'\uda00\ude01'
                       test_lecmp(s, s2)
                       s2 = u'\udb00\ude01'
                       test_lecmp(s, s2)
                       s2 = u'\ud800\udfff'
                       test_lecmp(s, s2)
                       s2 = u'\ud900\udfff'
                       test_lecmp(s, s2)
                       s2 = u'\uda00\udfff'
                       test_lecmp(s, s2)
                       s2 = u'\udb00\udfff'
                       test_lecmp(s, s2)
       
                       test_fixup(u'\ue000')
                       test_fixup(u'\uff61')
       
               # Surrogates on both sides, no fixup required
    1:         self.assertTrue(u'\ud800\udc02' < u'\ud84d\udc56')
       
    1:     def test_capitalize(self):
    1:         string_tests.CommonTest.test_capitalize(self)
               # check that titlecased chars are lowered correctly
               # \u1ffc is the titlecased char
    1:         self.checkequal(u'\u1ffc\u1ff3\u1ff3\u1ff3',
    1:                         u'\u1ff3\u1ff3\u1ffc\u1ffc', 'capitalize')
               # check with cased non-letter chars
    1:         self.checkequal(u'\u24c5\u24e8\u24e3\u24d7\u24de\u24dd',
    1:                         u'\u24c5\u24ce\u24c9\u24bd\u24c4\u24c3', 'capitalize')
    1:         self.checkequal(u'\u24c5\u24e8\u24e3\u24d7\u24de\u24dd',
    1:                         u'\u24df\u24e8\u24e3\u24d7\u24de\u24dd', 'capitalize')
    1:         self.checkequal(u'\u2160\u2171\u2172',
    1:                         u'\u2160\u2161\u2162', 'capitalize')
    1:         self.checkequal(u'\u2160\u2171\u2172',
    1:                         u'\u2170\u2171\u2172', 'capitalize')
               # check with Ll chars with no upper - nothing changes here
    1:         self.checkequal(u'\u019b\u1d00\u1d86\u0221\u1fb7',
    1:                         u'\u019b\u1d00\u1d86\u0221\u1fb7', 'capitalize')
       
    1:     def test_islower(self):
    1:         string_tests.MixinStrUnicodeUserStringTest.test_islower(self)
    1:         self.checkequalnofix(False, u'\u1FFc', 'islower')
       
    1:     @requires_wide_build
           def test_islower_non_bmp(self):
               # non-BMP, uppercase
>>>>>>         self.assertFalse(u'\U00010401'.islower())
>>>>>>         self.assertFalse(u'\U00010427'.islower())
               # non-BMP, lowercase
>>>>>>         self.assertTrue(u'\U00010429'.islower())
>>>>>>         self.assertTrue(u'\U0001044E'.islower())
               # non-BMP, non-cased
>>>>>>         self.assertFalse(u'\U0001F40D'.islower())
>>>>>>         self.assertFalse(u'\U0001F46F'.islower())
       
    1:     def test_isupper(self):
    1:         string_tests.MixinStrUnicodeUserStringTest.test_isupper(self)
    1:         if not sys.platform.startswith('java'):
    1:             self.checkequalnofix(False, u'\u1FFc', 'isupper')
       
    1:     @requires_wide_build
           def test_isupper_non_bmp(self):
               # non-BMP, uppercase
>>>>>>         self.assertTrue(u'\U00010401'.isupper())
>>>>>>         self.assertTrue(u'\U00010427'.isupper())
               # non-BMP, lowercase
>>>>>>         self.assertFalse(u'\U00010429'.isupper())
>>>>>>         self.assertFalse(u'\U0001044E'.isupper())
               # non-BMP, non-cased
>>>>>>         self.assertFalse(u'\U0001F40D'.isupper())
>>>>>>         self.assertFalse(u'\U0001F46F'.isupper())
       
    1:     def test_istitle(self):
    1:         string_tests.MixinStrUnicodeUserStringTest.test_istitle(self)
    1:         self.checkequalnofix(True, u'\u1FFc', 'istitle')
    1:         self.checkequalnofix(True, u'Greek \u1FFcitlecases ...', 'istitle')
       
    1:     @requires_wide_build
           def test_istitle_non_bmp(self):
               # non-BMP, uppercase + lowercase
>>>>>>         self.assertTrue(u'\U00010401\U00010429'.istitle())
>>>>>>         self.assertTrue(u'\U00010427\U0001044E'.istitle())
               # apparently there are no titlecased (Lt) non-BMP chars in Unicode 6
>>>>>>         for ch in [u'\U00010429', u'\U0001044E', u'\U0001F40D', u'\U0001F46F']:
>>>>>>             self.assertFalse(ch.istitle(), '{!r} is not title'.format(ch))
       
    1:     def test_isspace(self):
    1:         string_tests.MixinStrUnicodeUserStringTest.test_isspace(self)
    1:         self.checkequalnofix(True, u'\u2000', 'isspace')
    1:         self.checkequalnofix(True, u'\u200a', 'isspace')
    1:         self.checkequalnofix(False, u'\u2014', 'isspace')
       
    1:     @requires_wide_build
           def test_isspace_non_bmp(self):
               # apparently there are no non-BMP spaces chars in Unicode 6
>>>>>>         for ch in [u'\U00010401', u'\U00010427', u'\U00010429', u'\U0001044E',
>>>>>>                    u'\U0001F40D', u'\U0001F46F']:
>>>>>>             self.assertFalse(ch.isspace(), '{!r} is not space.'.format(ch))
       
    1:     @requires_wide_build
           def test_isalnum_non_bmp(self):
>>>>>>         for ch in [u'\U00010401', u'\U00010427', u'\U00010429', u'\U0001044E',
>>>>>>                    u'\U0001D7F6', u'\U000104A0', u'\U000104A0', u'\U0001F107']:
>>>>>>             self.assertTrue(ch.isalnum(), '{!r} is alnum.'.format(ch))
       
    1:     def test_isalpha(self):
    1:         string_tests.MixinStrUnicodeUserStringTest.test_isalpha(self)
    1:         self.checkequalnofix(True, u'\u1FFc', 'isalpha')
       
    1:     @requires_wide_build
           def test_isalpha_non_bmp(self):
               # non-BMP, cased
>>>>>>         self.assertTrue(u'\U00010401'.isalpha())
>>>>>>         self.assertTrue(u'\U00010427'.isalpha())
>>>>>>         self.assertTrue(u'\U00010429'.isalpha())
>>>>>>         self.assertTrue(u'\U0001044E'.isalpha())
               # non-BMP, non-cased
>>>>>>         self.assertFalse(u'\U0001F40D'.isalpha())
>>>>>>         self.assertFalse(u'\U0001F46F'.isalpha())
       
    1:     def test_isdecimal(self):
    1:         self.checkequalnofix(False, u'', 'isdecimal')
    1:         self.checkequalnofix(False, u'a', 'isdecimal')
    1:         self.checkequalnofix(True, u'0', 'isdecimal')
    1:         self.checkequalnofix(False, u'\u2460', 'isdecimal') # CIRCLED DIGIT ONE
    1:         self.checkequalnofix(False, u'\xbc', 'isdecimal') # VULGAR FRACTION ONE QUARTER
    1:         self.checkequalnofix(True, u'\u0660', 'isdecimal') # ARABIC-INDIC DIGIT ZERO
    1:         self.checkequalnofix(True, u'0123456789', 'isdecimal')
    1:         self.checkequalnofix(False, u'0123456789a', 'isdecimal')
       
    1:         self.checkraises(TypeError, 'abc', 'isdecimal', 42)
       
    1:     @requires_wide_build
           def test_isdecimal_non_bmp(self):
>>>>>>         for ch in [u'\U00010401', u'\U00010427', u'\U00010429', u'\U0001044E',
>>>>>>                    u'\U0001F40D', u'\U0001F46F', u'\U00011065', u'\U0001F107']:
>>>>>>             self.assertFalse(ch.isdecimal(), '{!r} is not decimal.'.format(ch))
>>>>>>         for ch in [u'\U0001D7F6', u'\U000104A0', u'\U000104A0']:
>>>>>>             self.assertTrue(ch.isdecimal(), '{!r} is decimal.'.format(ch))
       
    1:     def test_isdigit(self):
    1:         string_tests.MixinStrUnicodeUserStringTest.test_isdigit(self)
    1:         self.checkequalnofix(True, u'\u2460', 'isdigit')
    1:         self.checkequalnofix(False, u'\xbc', 'isdigit')
    1:         self.checkequalnofix(True, u'\u0660', 'isdigit')
       
    1:     @requires_wide_build
           def test_isdigit_non_bmp(self):
>>>>>>         for ch in [u'\U00010401', u'\U00010427', u'\U00010429', u'\U0001044E',
>>>>>>                    u'\U0001F40D', u'\U0001F46F', u'\U00011065']:
>>>>>>             self.assertFalse(ch.isdigit(), '{!r} is not a digit.'.format(ch))
>>>>>>         for ch in [u'\U0001D7F6', u'\U000104A0', u'\U000104A0', u'\U0001F107']:
>>>>>>             self.assertTrue(ch.isdigit(), '{!r} is a digit.'.format(ch))
       
    1:     def test_isnumeric(self):
    1:         self.checkequalnofix(False, u'', 'isnumeric')
    1:         self.checkequalnofix(False, u'a', 'isnumeric')
    1:         self.checkequalnofix(True, u'0', 'isnumeric')
    1:         self.checkequalnofix(True, u'\u2460', 'isnumeric')
    1:         self.checkequalnofix(True, u'\xbc', 'isnumeric')
    1:         self.checkequalnofix(True, u'\u0660', 'isnumeric')
    1:         self.checkequalnofix(True, u'0123456789', 'isnumeric')
    1:         self.checkequalnofix(False, u'0123456789a', 'isnumeric')
       
    1:         self.assertRaises(TypeError, u"abc".isnumeric, 42)
       
    1:     @requires_wide_build
           def test_isnumeric_non_bmp(self):
>>>>>>         for ch in [u'\U00010401', u'\U00010427', u'\U00010429', u'\U0001044E',
>>>>>>                    u'\U0001F40D', u'\U0001F46F']:
>>>>>>             self.assertFalse(ch.isnumeric(), '{!r} is not numeric.'.format(ch))
>>>>>>         for ch in [u'\U00010107', u'\U0001D7F6', u'\U00023b1b',
>>>>>>                    u'\U000104A0', u'\U0001F107']:
>>>>>>             self.assertTrue(ch.isnumeric(), '{!r} is numeric.'.format(ch))
       
    1:     @requires_wide_build
           def test_surrogates(self):
               # this test actually passes on narrow too, but it's just by accident.
               # Surrogates are seen as non-cased chars, so u'X\uD800X' is as
               # uppercase as 'X X'
>>>>>>         for s in (u'a\uD800b\uDFFF', u'a\uDFFFb\uD800',
>>>>>>                   u'a\uD800b\uDFFFa', u'a\uDFFFb\uD800a'):
>>>>>>             self.assertTrue(s.islower())
>>>>>>             self.assertFalse(s.isupper())
>>>>>>             self.assertFalse(s.istitle())
>>>>>>         for s in (u'A\uD800B\uDFFF', u'A\uDFFFB\uD800',
>>>>>>                   u'A\uD800B\uDFFFA', u'A\uDFFFB\uD800A'):
>>>>>>             self.assertFalse(s.islower())
>>>>>>             self.assertTrue(s.isupper())
>>>>>>             self.assertTrue(s.istitle())
       
>>>>>>         for meth_name in ('islower', 'isupper', 'istitle'):
>>>>>>             meth = getattr(unicode, meth_name)
>>>>>>             for s in (u'\uD800', u'\uDFFF', u'\uD800\uD800', u'\uDFFF\uDFFF'):
>>>>>>                 self.assertFalse(meth(s), '%r.%s() is False' % (s, meth_name))
       
>>>>>>         for meth_name in ('isalpha', 'isalnum', 'isdigit', 'isspace',
>>>>>>                           'isdecimal', 'isnumeric'):
>>>>>>             meth = getattr(unicode, meth_name)
>>>>>>             for s in (u'\uD800', u'\uDFFF', u'\uD800\uD800', u'\uDFFF\uDFFF',
                             u'a\uD800b\uDFFF', u'a\uDFFFb\uD800',
>>>>>>                       u'a\uD800b\uDFFFa', u'a\uDFFFb\uD800a'):
>>>>>>                 self.assertFalse(meth(s), '%r.%s() is False' % (s, meth_name))
       
       
    1:     @requires_wide_build
           def test_lower(self):
>>>>>>         string_tests.CommonTest.test_lower(self)
>>>>>>         self.assertEqual(u'\U00010427'.lower(), u'\U0001044F')
>>>>>>         self.assertEqual(u'\U00010427\U00010427'.lower(),
>>>>>>                          u'\U0001044F\U0001044F')
>>>>>>         self.assertEqual(u'\U00010427\U0001044F'.lower(),
>>>>>>                          u'\U0001044F\U0001044F')
>>>>>>         self.assertEqual(u'X\U00010427x\U0001044F'.lower(),
>>>>>>                          u'x\U0001044Fx\U0001044F')
       
    1:     @requires_wide_build
           def test_upper(self):
>>>>>>         string_tests.CommonTest.test_upper(self)
>>>>>>         self.assertEqual(u'\U0001044F'.upper(), u'\U00010427')
>>>>>>         self.assertEqual(u'\U0001044F\U0001044F'.upper(),
>>>>>>                          u'\U00010427\U00010427')
>>>>>>         self.assertEqual(u'\U00010427\U0001044F'.upper(),
>>>>>>                          u'\U00010427\U00010427')
>>>>>>         self.assertEqual(u'X\U00010427x\U0001044F'.upper(),
>>>>>>                          u'X\U00010427X\U00010427')
       
    1:     @requires_wide_build
           def test_capitalize_wide_build(self):
>>>>>>         string_tests.CommonTest.test_capitalize(self)
>>>>>>         self.assertEqual(u'\U0001044F'.capitalize(), u'\U00010427')
>>>>>>         self.assertEqual(u'\U0001044F\U0001044F'.capitalize(),
>>>>>>                          u'\U00010427\U0001044F')
>>>>>>         self.assertEqual(u'\U00010427\U0001044F'.capitalize(),
>>>>>>                          u'\U00010427\U0001044F')
>>>>>>         self.assertEqual(u'\U0001044F\U00010427'.capitalize(),
>>>>>>                          u'\U00010427\U0001044F')
>>>>>>         self.assertEqual(u'X\U00010427x\U0001044F'.capitalize(),
>>>>>>                          u'X\U0001044Fx\U0001044F')
       
    1:     @requires_wide_build
           def test_title(self):
>>>>>>         string_tests.MixinStrUnicodeUserStringTest.test_title(self)
>>>>>>         self.assertEqual(u'\U0001044F'.title(), u'\U00010427')
>>>>>>         self.assertEqual(u'\U0001044F\U0001044F'.title(),
>>>>>>                          u'\U00010427\U0001044F')
>>>>>>         self.assertEqual(u'\U0001044F\U0001044F \U0001044F\U0001044F'.title(),
>>>>>>                          u'\U00010427\U0001044F \U00010427\U0001044F')
>>>>>>         self.assertEqual(u'\U00010427\U0001044F \U00010427\U0001044F'.title(),
>>>>>>                          u'\U00010427\U0001044F \U00010427\U0001044F')
>>>>>>         self.assertEqual(u'\U0001044F\U00010427 \U0001044F\U00010427'.title(),
>>>>>>                          u'\U00010427\U0001044F \U00010427\U0001044F')
>>>>>>         self.assertEqual(u'X\U00010427x\U0001044F X\U00010427x\U0001044F'.title(),
>>>>>>                          u'X\U0001044Fx\U0001044F X\U0001044Fx\U0001044F')
       
    1:     @requires_wide_build
           def test_swapcase(self):
>>>>>>         string_tests.CommonTest.test_swapcase(self)
>>>>>>         self.assertEqual(u'\U0001044F'.swapcase(), u'\U00010427')
>>>>>>         self.assertEqual(u'\U00010427'.swapcase(), u'\U0001044F')
>>>>>>         self.assertEqual(u'\U0001044F\U0001044F'.swapcase(),
>>>>>>                          u'\U00010427\U00010427')
>>>>>>         self.assertEqual(u'\U00010427\U0001044F'.swapcase(),
>>>>>>                          u'\U0001044F\U00010427')
>>>>>>         self.assertEqual(u'\U0001044F\U00010427'.swapcase(),
>>>>>>                          u'\U00010427\U0001044F')
>>>>>>         self.assertEqual(u'X\U00010427x\U0001044F'.swapcase(),
>>>>>>                          u'x\U0001044FX\U00010427')
       
    1:     def test_contains(self):
               # Testing Unicode contains method
    1:         self.assertIn('a', u'abdb')
    1:         self.assertIn('a', u'bdab')
    1:         self.assertIn('a', u'bdaba')
    1:         self.assertIn('a', u'bdba')
    1:         self.assertIn('a', u'bdba')
    1:         self.assertIn(u'a', u'bdba')
    1:         self.assertNotIn(u'a', u'bdb')
    1:         self.assertNotIn(u'a', 'bdb')
    1:         self.assertIn(u'a', 'bdba')
    1:         self.assertIn(u'a', ('a',1,None))
    1:         self.assertIn(u'a', (1,None,'a'))
    1:         self.assertIn(u'a', (1,None,u'a'))
    1:         self.assertIn('a', ('a',1,None))
    1:         self.assertIn('a', (1,None,'a'))
    1:         self.assertIn('a', (1,None,u'a'))
    1:         self.assertNotIn('a', ('x',1,u'y'))
    1:         self.assertNotIn('a', ('x',1,None))
    1:         self.assertNotIn(u'abcd', u'abcxxxx')
    1:         self.assertIn(u'ab', u'abcd')
    1:         self.assertIn('ab', u'abc')
    1:         self.assertIn(u'ab', 'abc')
    1:         self.assertIn(u'ab', (1,None,u'ab'))
    1:         self.assertIn(u'', u'abc')
    1:         self.assertIn('', u'abc')
       
               # If the following fails either
               # the contains operator does not propagate UnicodeErrors or
               # someone has changed the default encoding
    1:         self.assertRaises(UnicodeDecodeError, 'g\xe2teau'.__contains__, u'\xe2')
    1:         self.assertRaises(UnicodeDecodeError, u'g\xe2teau'.__contains__, '\xe2')
       
    1:         self.assertIn(u'', '')
    1:         self.assertIn('', u'')
    1:         self.assertIn(u'', u'')
    1:         self.assertIn(u'', 'abc')
    1:         self.assertIn('', u'abc')
    1:         self.assertIn(u'', u'abc')
    1:         self.assertNotIn(u'\0', 'abc')
    1:         self.assertNotIn('\0', u'abc')
    1:         self.assertNotIn(u'\0', u'abc')
    1:         self.assertIn(u'\0', '\0abc')
    1:         self.assertIn('\0', u'\0abc')
    1:         self.assertIn(u'\0', u'\0abc')
    1:         self.assertIn(u'\0', 'abc\0')
    1:         self.assertIn('\0', u'abc\0')
    1:         self.assertIn(u'\0', u'abc\0')
    1:         self.assertIn(u'a', '\0abc')
    1:         self.assertIn('a', u'\0abc')
    1:         self.assertIn(u'a', u'\0abc')
    1:         self.assertIn(u'asdf', 'asdf')
    1:         self.assertIn('asdf', u'asdf')
    1:         self.assertIn(u'asdf', u'asdf')
    1:         self.assertNotIn(u'asdf', 'asd')
    1:         self.assertNotIn('asdf', u'asd')
    1:         self.assertNotIn(u'asdf', u'asd')
    1:         self.assertNotIn(u'asdf', '')
    1:         self.assertNotIn('asdf', u'')
    1:         self.assertNotIn(u'asdf', u'')
       
    1:         self.assertRaises(TypeError, u"abc".__contains__)
    1:         self.assertRaises(TypeError, u"abc".__contains__, object())
       
    1:     def test_formatting(self):
    1:         string_tests.MixinStrUnicodeUserStringTest.test_formatting(self)
               # Testing Unicode formatting strings...
    1:         self.assertEqual(u"%s, %s" % (u"abc", "abc"), u'abc, abc')
    1:         self.assertEqual(u"%s, %s, %i, %f, %5.2f" % (u"abc", "abc", 1, 2, 3), u'abc, abc, 1, 2.000000,  3.00')
    1:         self.assertEqual(u"%s, %s, %i, %f, %5.2f" % (u"abc", "abc", 1, -2, 3), u'abc, abc, 1, -2.000000,  3.00')
    1:         self.assertEqual(u"%s, %s, %i, %f, %5.2f" % (u"abc", "abc", -1, -2, 3.5), u'abc, abc, -1, -2.000000,  3.50')
    1:         self.assertEqual(u"%s, %s, %i, %f, %5.2f" % (u"abc", "abc", -1, -2, 3.57), u'abc, abc, -1, -2.000000,  3.57')
    1:         self.assertEqual(u"%s, %s, %i, %f, %5.2f" % (u"abc", "abc", -1, -2, 1003.57), u'abc, abc, -1, -2.000000, 1003.57')
    1:         if not sys.platform.startswith('java'):
    1:             self.assertEqual(u"%r, %r" % (u"abc", "abc"), u"u'abc', 'abc'")
    1:         self.assertEqual(u"%(x)s, %(y)s" % {'x':u"abc", 'y':"def"}, u'abc, def')
    1:         self.assertEqual(u"%(x)s, %(\xfc)s" % {'x':u"abc", u'\xfc':"def"}, u'abc, def')
       
    1:         self.assertEqual(u'%c' % 0x1234, u'\u1234')
    1:         self.assertRaises(OverflowError, u"%c".__mod__, (sys.maxunicode+1,))
    1:         self.assertRaises(ValueError, u"%.1\u1032f".__mod__, (1.0/3))
       
  129:         for num in range(0x00,0x80):
  128:             char = chr(num)
  128:             self.assertEqual(u"%c" % char, unicode(char))
  128:             self.assertEqual(u"%c" % num, unicode(char))
  128:             self.assertTrue(char == u"%c" % char)
  128:             self.assertTrue(char == u"%c" % num)
               # Issue 7649
  129:         for num in range(0x80,0x100):
  128:             uchar = unichr(num)
  128:             self.assertEqual(uchar, u"%c" % num)   # works only with ints
  128:             self.assertEqual(uchar, u"%c" % uchar) # and unicode chars
                   # the implicit decoding should fail for non-ascii chars
  128:             self.assertRaises(UnicodeDecodeError, u"%c".__mod__, chr(num))
  128:             self.assertRaises(UnicodeDecodeError, u"%s".__mod__, chr(num))
       
               # formatting jobs delegated from the string implementation:
    1:         self.assertEqual('...%(foo)s...' % {'foo':u"abc"}, u'...abc...')
    1:         self.assertEqual('...%(foo)s...' % {'foo':"abc"}, '...abc...')
    1:         self.assertEqual('...%(foo)s...' % {u'foo':"abc"}, '...abc...')
    1:         self.assertEqual('...%(foo)s...' % {u'foo':u"abc"}, u'...abc...')
    1:         self.assertEqual('...%(foo)s...' % {u'foo':u"abc",'def':123},  u'...abc...')
    1:         self.assertEqual('...%(foo)s...' % {u'foo':u"abc",u'def':123}, u'...abc...')
    1:         self.assertEqual('...%s...%s...%s...%s...' % (1,2,3,u"abc"), u'...1...2...3...abc...')
    1:         self.assertEqual('...%%...%%s...%s...%s...%s...%s...' % (1,2,3,u"abc"), u'...%...%s...1...2...3...abc...')
    1:         self.assertEqual('...%s...' % u"abc", u'...abc...')
    1:         self.assertEqual('%*s' % (5,u'abc',), u'  abc')
    1:         self.assertEqual('%*s' % (-5,u'abc',), u'abc  ')
    1:         self.assertEqual('%*.*s' % (5,2,u'abc',), u'   ab')
    1:         self.assertEqual('%*.*s' % (5,3,u'abc',), u'  abc')
    1:         self.assertEqual('%i %*.*s' % (10, 5,3,u'abc',), u'10   abc')
    1:         self.assertEqual('%i%s %*.*s' % (10, 3, 5, 3, u'abc',), u'103   abc')
    1:         self.assertEqual('%c' % u'a', u'a')
    2:         class Wrapper:
    1:             def __str__(self):
    2:                 return u'\u1234'
    1:         self.assertEqual('%s' % Wrapper(), u'\u1234')
       
    1:     def test_formatting_huge_precision(self):
    1:         format_string = u"%.{}f".format(sys.maxsize + 1)
    1:         with self.assertRaises(ValueError):
    1:             result = format_string % 2.34
       
    1:     @test_support.cpython_only
           def test_formatting_huge_precision_c_limits(self):
    1:         from _testcapi import INT_MAX
    1:         format_string = u"%.{}f".format(INT_MAX + 1)
    1:         with self.assertRaises(ValueError):
    1:             result = format_string % 2.34
       
    1:     def test_formatting_huge_width(self):
    1:         format_string = u"%{}f".format(sys.maxsize + 1)
    1:         with self.assertRaises(ValueError):
    1:             result = format_string % 2.34
       
    1:     def test_startswith_endswith_errors(self):
    3:         for meth in (u'foo'.startswith, u'foo'.endswith):
    2:             with self.assertRaises(UnicodeDecodeError):
    2:                 meth('\xff')
    2:             with self.assertRaises(TypeError) as cm:
    2:                 meth(['f'])
    2:             exc = str(cm.exception)
    2:             self.assertIn('unicode', exc)
    2:             self.assertIn('str', exc)
    2:             self.assertIn('tuple', exc)
       
    1:     @test_support.run_with_locale('LC_ALL', 'de_DE', 'fr_FR')
           def test_format_float(self):
               # should not format with a comma, but always with C locale
    1:         self.assertEqual(u'1.0', u'%.1f' % 1.0)
       
    1:     def test_constructor(self):
               # unicode(obj) tests (this maps to PyObject_Unicode() at C level)
       
    1:         self.assertEqual(
    1:             unicode(u'unicode remains unicode'),
    1:             u'unicode remains unicode'
               )
       
    1:         self.assertEqual(
    1:             unicode(UnicodeSubclass('unicode subclass becomes unicode')),
    1:             u'unicode subclass becomes unicode'
               )
       
    1:         self.assertEqual(
    1:             unicode('strings are converted to unicode'),
    1:             u'strings are converted to unicode'
               )
       
    2:         class UnicodeCompat:
    1:             def __init__(self, x):
    3:                 self.x = x
    1:             def __unicode__(self):
    3:                 return self.x
       
    1:         self.assertEqual(
    1:             unicode(UnicodeCompat('__unicode__ compatible objects are recognized')),
    1:             u'__unicode__ compatible objects are recognized')
       
    2:         class StringCompat:
    1:             def __init__(self, x):
    2:                 self.x = x
    1:             def __str__(self):
    3:                 return self.x
       
    1:         self.assertEqual(
    1:             unicode(StringCompat('__str__ compatible objects are recognized')),
    1:             u'__str__ compatible objects are recognized'
               )
       
               # unicode(obj) is compatible to str():
       
    1:         o = StringCompat('unicode(obj) is compatible to str()')
    1:         self.assertEqual(unicode(o), u'unicode(obj) is compatible to str()')
    1:         self.assertEqual(str(o), 'unicode(obj) is compatible to str()')
       
               # %-formatting and .__unicode__()
    1:         self.assertEqual(u'%s' %
    1:                          UnicodeCompat(u"u'%s' % obj uses obj.__unicode__()"),
    1:                          u"u'%s' % obj uses obj.__unicode__()")
    1:         self.assertEqual(u'%s' %
    1:                          UnicodeCompat(u"u'%s' % obj falls back to obj.__str__()"),
    1:                          u"u'%s' % obj falls back to obj.__str__()")
       
    4:         for obj in (123, 123.45, 123L):
    3:             self.assertEqual(unicode(obj), unicode(str(obj)))
       
               # unicode(obj, encoding, error) tests (this maps to
               # PyUnicode_FromEncodedObject() at C level)
       
    1:         if not sys.platform.startswith('java'):
    1:             self.assertRaises(
    1:                 TypeError,
    1:                 unicode,
    1:                 u'decoding unicode is not supported',
    1:                 'utf-8',
    1:                 'strict'
                   )
       
    1:         self.assertEqual(
    1:             unicode('strings are decoded to unicode', 'utf-8', 'strict'),
    1:             u'strings are decoded to unicode'
               )
       
    1:         if not sys.platform.startswith('java'):
    1:             with test_support.check_py3k_warnings():
    1:                 buf = buffer('character buffers are decoded to unicode')
    1:             self.assertEqual(
    1:                 unicode(
    1:                     buf,
    1:                     'utf-8',
    1:                     'strict'
                       ),
    1:                 u'character buffers are decoded to unicode'
                   )
       
    1:         self.assertRaises(TypeError, unicode, 42, 42, 42)
       
    1:     def test_codecs_utf7(self):
               utfTests = [
    1:             (u'A\u2262\u0391.', 'A+ImIDkQ.'),             # RFC2152 example
    1:             (u'Hi Mom -\u263a-!', 'Hi Mom -+Jjo--!'),     # RFC2152 example
    1:             (u'\u65E5\u672C\u8A9E', '+ZeVnLIqe-'),        # RFC2152 example
    1:             (u'Item 3 is \u00a31.', 'Item 3 is +AKM-1.'), # RFC2152 example
    1:             (u'+', '+-'),
    1:             (u'+-', '+--'),
    1:             (u'+?', '+-?'),
    1:             (u'\?', '+AFw?'),
    1:             (u'+?', '+-?'),
    1:             (ur'\\?', '+AFwAXA?'),
    1:             (ur'\\\?', '+AFwAXABc?'),
    1:             (ur'++--', '+-+---'),
    1:             (u'\U000abcde', '+2m/c3g-'),                  # surrogate pairs
    1:             (u'/', '/'),
               ]
       
   15:         for (x, y) in utfTests:
   14:             self.assertEqual(x.encode('utf-7'), y)
       
               # Unpaired surrogates are passed through
    1:         self.assertEqual(u'\uD801'.encode('utf-7'), '+2AE-')
    1:         self.assertEqual(u'\uD801x'.encode('utf-7'), '+2AE-x')
    1:         self.assertEqual(u'\uDC01'.encode('utf-7'), '+3AE-')
    1:         self.assertEqual(u'\uDC01x'.encode('utf-7'), '+3AE-x')
    1:         self.assertEqual('+2AE-'.decode('utf-7'), u'\uD801')
    1:         self.assertEqual('+2AE-x'.decode('utf-7'), u'\uD801x')
    1:         self.assertEqual('+3AE-'.decode('utf-7'), u'\uDC01')
    1:         self.assertEqual('+3AE-x'.decode('utf-7'), u'\uDC01x')
       
    1:         self.assertEqual(u'\uD801\U000abcde'.encode('utf-7'), '+2AHab9ze-')
    1:         self.assertEqual('+2AHab9ze-'.decode('utf-7'), u'\uD801\U000abcde')
       
               # Direct encoded characters
    1:         set_d = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'(),-./:?"
               # Optional direct characters
    1:         set_o = '!"#$%&*;<=>@[]^_`{|}'
   72:         for c in set_d:
   71:             self.assertEqual(c.encode('utf7'), c.encode('ascii'))
   71:             self.assertEqual(c.encode('ascii').decode('utf7'), unicode(c))
   71:             self.assertTrue(c == c.encode('ascii').decode('utf7'))
   21:         for c in set_o:
   20:             self.assertEqual(c.encode('ascii').decode('utf7'), unicode(c))
   20:             self.assertTrue(c == c.encode('ascii').decode('utf7'))
       
    1:     def test_codecs_utf8(self):
    1:         self.assertEqual(u''.encode('utf-8'), '')
    1:         self.assertEqual(u'\u20ac'.encode('utf-8'), '\xe2\x82\xac')
    1:         self.assertEqual(u'\ud800\udc02'.encode('utf-8'), '\xf0\x90\x80\x82')
    1:         self.assertEqual(u'\ud84d\udc56'.encode('utf-8'), '\xf0\xa3\x91\x96')
    1:         self.assertEqual(u'\ud800'.encode('utf-8'), '\xed\xa0\x80')
    1:         self.assertEqual(u'\udc00'.encode('utf-8'), '\xed\xb0\x80')
    1:         self.assertEqual(
    1:             (u'\ud800\udc02'*1000).encode('utf-8'),
    1:             '\xf0\x90\x80\x82'*1000
               )
    1:         self.assertEqual(
    1:             u'\u6b63\u78ba\u306b\u8a00\u3046\u3068\u7ffb\u8a33\u306f'
                   u'\u3055\u308c\u3066\u3044\u307e\u305b\u3093\u3002\u4e00'
                   u'\u90e8\u306f\u30c9\u30a4\u30c4\u8a9e\u3067\u3059\u304c'
                   u'\u3001\u3042\u3068\u306f\u3067\u305f\u3089\u3081\u3067'
                   u'\u3059\u3002\u5b9f\u969b\u306b\u306f\u300cWenn ist das'
    1:             u' Nunstuck git und'.encode('utf-8'),
    1:             '\xe6\xad\xa3\xe7\xa2\xba\xe3\x81\xab\xe8\xa8\x80\xe3\x81'
                   '\x86\xe3\x81\xa8\xe7\xbf\xbb\xe8\xa8\xb3\xe3\x81\xaf\xe3'
                   '\x81\x95\xe3\x82\x8c\xe3\x81\xa6\xe3\x81\x84\xe3\x81\xbe'
                   '\xe3\x81\x9b\xe3\x82\x93\xe3\x80\x82\xe4\xb8\x80\xe9\x83'
                   '\xa8\xe3\x81\xaf\xe3\x83\x89\xe3\x82\xa4\xe3\x83\x84\xe8'
                   '\xaa\x9e\xe3\x81\xa7\xe3\x81\x99\xe3\x81\x8c\xe3\x80\x81'
                   '\xe3\x81\x82\xe3\x81\xa8\xe3\x81\xaf\xe3\x81\xa7\xe3\x81'
                   '\x9f\xe3\x82\x89\xe3\x82\x81\xe3\x81\xa7\xe3\x81\x99\xe3'
                   '\x80\x82\xe5\xae\x9f\xe9\x9a\x9b\xe3\x81\xab\xe3\x81\xaf'
                   '\xe3\x80\x8cWenn ist das Nunstuck git und'
               )
       
               # UTF-8 specific decoding tests
    1:         self.assertEqual(unicode('\xf0\xa3\x91\x96', 'utf-8'), u'\U00023456')
    1:         self.assertEqual(unicode('\xf0\x90\x80\x82', 'utf-8'), u'\U00010002')
    1:         self.assertEqual(unicode('\xe2\x82\xac', 'utf-8'), u'\u20ac')
       
               # Other possible utf-8 test cases:
               # * strict decoding testing for all of the
               #   UTF8_ERROR cases in PyUnicode_DecodeUTF8
       
    1:     def test_utf8_decode_valid_sequences(self):
               sequences = [
                   # single byte
    1:             ('\x00', u'\x00'), ('a', u'a'), ('\x7f', u'\x7f'),
                   # 2 bytes
    1:             ('\xc2\x80', u'\x80'), ('\xdf\xbf', u'\u07ff'),
                   # 3 bytes
    1:             ('\xe0\xa0\x80', u'\u0800'), ('\xed\x9f\xbf', u'\ud7ff'),
    1:             ('\xee\x80\x80', u'\uE000'), ('\xef\xbf\xbf', u'\uffff'),
                   # 4 bytes
    1:             ('\xF0\x90\x80\x80', u'\U00010000'),
    1:             ('\xf4\x8f\xbf\xbf', u'\U0010FFFF')
               ]
   12:         for seq, res in sequences:
   11:             self.assertEqual(seq.decode('utf-8'), res)
       
65536:         for ch in map(unichr, range(0, sys.maxunicode)):
65535:             self.assertEqual(ch, ch.encode('utf-8').decode('utf-8'))
       
    1:     def test_utf8_decode_invalid_sequences(self):
               # continuation bytes in a sequence of 2, 3, or 4 bytes
    1:         continuation_bytes = map(chr, range(0x80, 0xC0))
               # start bytes of a 2-byte sequence equivalent to code points < 0x7F
    1:         invalid_2B_seq_start_bytes = map(chr, range(0xC0, 0xC2))
               # start bytes of a 4-byte sequence equivalent to code points > 0x10FFFF
    1:         invalid_4B_seq_start_bytes = map(chr, range(0xF5, 0xF8))
               invalid_start_bytes = (
                   continuation_bytes + invalid_2B_seq_start_bytes +
    1:             invalid_4B_seq_start_bytes + map(chr, range(0xF7, 0x100))
               )
       
   79:         for byte in invalid_start_bytes:
   78:             self.assertRaises(UnicodeDecodeError, byte.decode, 'utf-8')
       
    3:         for sb in invalid_2B_seq_start_bytes:
  130:             for cb in continuation_bytes:
  128:                 self.assertRaises(UnicodeDecodeError, (sb+cb).decode, 'utf-8')
       
    4:         for sb in invalid_4B_seq_start_bytes:
   12:             for cb1 in continuation_bytes[:3]:
   36:                 for cb3 in continuation_bytes[:3]:
   27:                     self.assertRaises(UnicodeDecodeError,
   27:                                       (sb+cb1+'\x80'+cb3).decode, 'utf-8')
       
   33:         for cb in map(chr, range(0x80, 0xA0)):
   32:             self.assertRaises(UnicodeDecodeError,
   32:                               ('\xE0'+cb+'\x80').decode, 'utf-8')
   32:             self.assertRaises(UnicodeDecodeError,
   32:                               ('\xE0'+cb+'\xBF').decode, 'utf-8')
               # XXX: surrogates shouldn't be valid UTF-8!
               # see http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf
               # (table 3-7) and http://www.rfc-editor.org/rfc/rfc3629.txt
               #for cb in map(chr, range(0xA0, 0xC0)):
                   #self.assertRaises(UnicodeDecodeError,
                                     #('\xED'+cb+'\x80').decode, 'utf-8')
                   #self.assertRaises(UnicodeDecodeError,
                                     #('\xED'+cb+'\xBF').decode, 'utf-8')
               # but since they are valid on Python 2 add a test for that:
    1:         for cb, surrogate in zip(map(chr, range(0xA0, 0xC0)),
   33:                                  map(unichr, range(0xd800, 0xe000, 64))):
   32:             encoded = '\xED'+cb+'\x80'
   32:             self.assertEqual(encoded.decode('utf-8'), surrogate)
   32:             self.assertEqual(surrogate.encode('utf-8'), encoded)
       
   17:         for cb in map(chr, range(0x80, 0x90)):
   16:             self.assertRaises(UnicodeDecodeError,
   16:                               ('\xF0'+cb+'\x80\x80').decode, 'utf-8')
   16:             self.assertRaises(UnicodeDecodeError,
   16:                               ('\xF0'+cb+'\xBF\xBF').decode, 'utf-8')
   49:         for cb in map(chr, range(0x90, 0xC0)):
   48:             self.assertRaises(UnicodeDecodeError,
   48:                               ('\xF4'+cb+'\x80\x80').decode, 'utf-8')
   48:             self.assertRaises(UnicodeDecodeError,
   48:                               ('\xF4'+cb+'\xBF\xBF').decode, 'utf-8')
       
    1:     def test_issue8271(self):
               # Issue #8271: during the decoding of an invalid UTF-8 byte sequence,
               # only the start byte and the continuation byte(s) are now considered
               # invalid, instead of the number of bytes specified by the start byte.
               # See http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf (page 95,
               # table 3-8, Row 2) for more information about the algorithm used.
    1:         FFFD = u'\ufffd'
               sequences = [
                   # invalid start bytes
    1:             ('\x80', FFFD), # continuation byte
    1:             ('\x80\x80', FFFD*2), # 2 continuation bytes
    1:             ('\xc0', FFFD),
    1:             ('\xc0\xc0', FFFD*2),
    1:             ('\xc1', FFFD),
    1:             ('\xc1\xc0', FFFD*2),
    1:             ('\xc0\xc1', FFFD*2),
                   # with start byte of a 2-byte sequence
    1:             ('\xc2', FFFD), # only the start byte
    1:             ('\xc2\xc2', FFFD*2), # 2 start bytes
    1:             ('\xc2\xc2\xc2', FFFD*3), # 2 start bytes
    1:             ('\xc2\x41', FFFD+'A'), # invalid continuation byte
                   # with start byte of a 3-byte sequence
    1:             ('\xe1', FFFD), # only the start byte
    1:             ('\xe1\xe1', FFFD*2), # 2 start bytes
    1:             ('\xe1\xe1\xe1', FFFD*3), # 3 start bytes
    1:             ('\xe1\xe1\xe1\xe1', FFFD*4), # 4 start bytes
    1:             ('\xe1\x80', FFFD), # only 1 continuation byte
    1:             ('\xe1\x41', FFFD+'A'), # invalid continuation byte
    1:             ('\xe1\x41\x80', FFFD+'A'+FFFD), # invalid cb followed by valid cb
    1:             ('\xe1\x41\x41', FFFD+'AA'), # 2 invalid continuation bytes
    1:             ('\xe1\x80\x41', FFFD+'A'), # only 1 valid continuation byte
    1:             ('\xe1\x80\xe1\x41', FFFD*2+'A'), # 1 valid and the other invalid
    1:             ('\xe1\x41\xe1\x80', FFFD+'A'+FFFD), # 1 invalid and the other valid
                   # with start byte of a 4-byte sequence
    1:             ('\xf1', FFFD), # only the start byte
    1:             ('\xf1\xf1', FFFD*2), # 2 start bytes
    1:             ('\xf1\xf1\xf1', FFFD*3), # 3 start bytes
    1:             ('\xf1\xf1\xf1\xf1', FFFD*4), # 4 start bytes
    1:             ('\xf1\xf1\xf1\xf1\xf1', FFFD*5), # 5 start bytes
    1:             ('\xf1\x80', FFFD), # only 1 continuation bytes
    1:             ('\xf1\x80\x80', FFFD), # only 2 continuation bytes
    1:             ('\xf1\x80\x41', FFFD+'A'), # 1 valid cb and 1 invalid
    1:             ('\xf1\x80\x41\x41', FFFD+'AA'), # 1 valid cb and 1 invalid
    1:             ('\xf1\x80\x80\x41', FFFD+'A'), # 2 valid cb and 1 invalid
    1:             ('\xf1\x41\x80', FFFD+'A'+FFFD), # 1 invalid cv and 1 valid
    1:             ('\xf1\x41\x80\x80', FFFD+'A'+FFFD*2), # 1 invalid cb and 2 invalid
    1:             ('\xf1\x41\x80\x41', FFFD+'A'+FFFD+'A'), # 2 invalid cb and 1 invalid
    1:             ('\xf1\x41\x41\x80', FFFD+'AA'+FFFD), # 1 valid cb and 1 invalid
    1:             ('\xf1\x41\xf1\x80', FFFD+'A'+FFFD),
    1:             ('\xf1\x41\x80\xf1', FFFD+'A'+FFFD*2),
    1:             ('\xf1\xf1\x80\x41', FFFD*2+'A'),
    1:             ('\xf1\x41\xf1\xf1', FFFD+'A'+FFFD*2),
                   # with invalid start byte of a 4-byte sequence (rfc2279)
    1:             ('\xf5', FFFD), # only the start byte
    1:             ('\xf5\xf5', FFFD*2), # 2 start bytes
    1:             ('\xf5\x80', FFFD*2), # only 1 continuation byte
    1:             ('\xf5\x80\x80', FFFD*3), # only 2 continuation byte
    1:             ('\xf5\x80\x80\x80', FFFD*4), # 3 continuation bytes
    1:             ('\xf5\x80\x41', FFFD*2+'A'), #  1 valid cb and 1 invalid
    1:             ('\xf5\x80\x41\xf5', FFFD*2+'A'+FFFD),
    1:             ('\xf5\x41\x80\x80\x41', FFFD+'A'+FFFD*2+'A'),
                   # with invalid start byte of a 5-byte sequence (rfc2279)
    1:             ('\xf8', FFFD), # only the start byte
    1:             ('\xf8\xf8', FFFD*2), # 2 start bytes
    1:             ('\xf8\x80', FFFD*2), # only one continuation byte
    1:             ('\xf8\x80\x41', FFFD*2 + 'A'), # 1 valid cb and 1 invalid
    1:             ('\xf8\x80\x80\x80\x80', FFFD*5), # invalid 5 bytes seq with 5 bytes
                   # with invalid start byte of a 6-byte sequence (rfc2279)
    1:             ('\xfc', FFFD), # only the start byte
    1:             ('\xfc\xfc', FFFD*2), # 2 start bytes
    1:             ('\xfc\x80\x80', FFFD*3), # only 2 continuation bytes
    1:             ('\xfc\x80\x80\x80\x80\x80', FFFD*6), # 6 continuation bytes
                   # invalid start byte
    1:             ('\xfe', FFFD),
    1:             ('\xfe\x80\x80', FFFD*3),
                   # other sequences
    1:             ('\xf1\x80\x41\x42\x43', u'\ufffd\x41\x42\x43'),
    1:             ('\xf1\x80\xff\x42\x43', u'\ufffd\ufffd\x42\x43'),
    1:             ('\xf1\x80\xc2\x81\x43', u'\ufffd\x81\x43'),
                   ('\x61\xF1\x80\x80\xE1\x80\xC2\x62\x80\x63\x80\xBF\x64',
    1:              u'\x61\uFFFD\uFFFD\uFFFD\x62\uFFFD\x63\uFFFD\uFFFD\x64'),
               ]
   64:         for n, (seq, res) in enumerate(sequences):
   63:             self.assertRaises(UnicodeDecodeError, seq.decode, 'utf-8', 'strict')
   63:             self.assertEqual(seq.decode('utf-8', 'replace'), res)
   63:             self.assertEqual((seq+'b').decode('utf-8', 'replace'), res+'b')
   63:             self.assertEqual(seq.decode('utf-8', 'ignore'),
   63:                              res.replace(u'\uFFFD', ''))
       
    1:     def test_codecs_idna(self):
               # Test whether trailing dot is preserved
    1:         self.assertEqual(u"www.python.org.".encode("idna"), "www.python.org.")
       
    1:     def test_codecs_errors(self):
               # Error handling (encoding)
    1:         self.assertRaises(UnicodeError, u'Andr\202 x'.encode, 'ascii')
    1:         self.assertRaises(UnicodeError, u'Andr\202 x'.encode, 'ascii','strict')
    1:         self.assertEqual(u'Andr\202 x'.encode('ascii','ignore'), "Andr x")
    1:         self.assertEqual(u'Andr\202 x'.encode('ascii','replace'), "Andr? x")
    1:         self.assertEqual(u'Andr\202 x'.encode('ascii', 'replace'),
    1:                          u'Andr\202 x'.encode('ascii', errors='replace'))
    1:         self.assertEqual(u'Andr\202 x'.encode('ascii', 'ignore'),
    1:                          u'Andr\202 x'.encode(encoding='ascii', errors='ignore'))
       
               # Error handling (decoding)
    1:         self.assertRaises(UnicodeError, unicode, 'Andr\202 x', 'ascii')
    1:         self.assertRaises(UnicodeError, unicode, 'Andr\202 x', 'ascii','strict')
    1:         self.assertEqual(unicode('Andr\202 x','ascii','ignore'), u"Andr x")
    1:         self.assertEqual(unicode('Andr\202 x','ascii','replace'), u'Andr\uFFFD x')
    1:         self.assertEqual(unicode('\202 x', 'ascii', 'replace'), u'\uFFFD x')
    1:         with test_support.check_py3k_warnings():
    1:             self.assertEqual(u'abcde'.decode('ascii', 'ignore'),
    1:                              u'abcde'.decode('ascii', errors='ignore'))
    1:         with test_support.check_py3k_warnings():
    1:             self.assertEqual(u'abcde'.decode('ascii', 'replace'),
    1:                              u'abcde'.decode(encoding='ascii', errors='replace'))
       
               # Error handling (unknown character names)
    1:         self.assertEqual("\\N{foo}xx".decode("unicode-escape", "ignore"), u"xx")
       
               # Error handling (truncated escape sequence)
    1:         self.assertRaises(UnicodeError, "\\".decode, "unicode-escape")
       
    1:         self.assertRaises(TypeError, "hello".decode, "test.unicode1")
    1:         self.assertRaises(TypeError, unicode, "hello", "test.unicode2")
    1:         self.assertRaises(TypeError, u"hello".encode, "test.unicode1")
    1:         self.assertRaises(TypeError, u"hello".encode, "test.unicode2")
               # executes PyUnicode_Encode()
    1:         import imp
    1:         self.assertRaises(
    1:             ImportError,
    1:             imp.find_module,
    1:             "non-existing module",
    1:             [u"non-existing dir"]
               )
       
               # Error handling (wrong arguments)
    1:         self.assertRaises(TypeError, u"hello".encode, 42, 42, 42)
       
               # Error handling (PyUnicode_EncodeDecimal())
    1:         self.assertRaises(UnicodeError, int, u"\u0200")
       
    1:     def test_codecs(self):
               # Encoding
    1:         self.assertEqual(u'hello'.encode('ascii'), 'hello')
    1:         self.assertEqual(u'hello'.encode('utf-7'), 'hello')
    1:         self.assertEqual(u'hello'.encode('utf-8'), 'hello')
    1:         self.assertEqual(u'hello'.encode('utf8'), 'hello')
    1:         self.assertEqual(u'hello'.encode('utf-16-le'), 'h\000e\000l\000l\000o\000')
    1:         self.assertEqual(u'hello'.encode('utf-16-be'), '\000h\000e\000l\000l\000o')
    1:         self.assertEqual(u'hello'.encode('latin-1'), 'hello')
       
               # Roundtrip safety for BMP (just the first 1024 chars)
 1025:         for c in xrange(1024):
 1024:             u = unichr(c)
 1024:             for encoding in ('utf-7', 'utf-8', 'utf-16', 'utf-16-le',
                                    'utf-16-be', 'raw_unicode_escape',
 9216:                              'unicode_escape', 'unicode_internal'):
 8192:                 self.assertEqual(unicode(u.encode(encoding),encoding), u)
       
               # Roundtrip safety for BMP (just the first 256 chars)
  257:         for c in xrange(256):
  256:             u = unichr(c)
  512:             for encoding in ('latin-1',):
  256:                 self.assertEqual(unicode(u.encode(encoding),encoding), u)
       
               # Roundtrip safety for BMP (just the first 128 chars)
  129:         for c in xrange(128):
  128:             u = unichr(c)
  256:             for encoding in ('ascii',):
  128:                 self.assertEqual(unicode(u.encode(encoding),encoding), u)
       
               # Roundtrip safety for non-BMP (just a few chars)
    1:         u = u'\U00010001\U00020002\U00030003\U00040004\U00050005'
    1:         for encoding in ('utf-8', 'utf-16', 'utf-16-le', 'utf-16-be',
                                #'raw_unicode_escape',
    7:                          'unicode_escape', 'unicode_internal'):
    6:             self.assertEqual(unicode(u.encode(encoding),encoding), u)
       
               # UTF-8 must be roundtrip safe for all UCS-2 code points
               # This excludes surrogates: in the full range, there would be
               # a surrogate pair (\udbff\udc00), which gets converted back
               # to a non-BMP character (\U0010fc00)
    1:         u = u''.join(map(unichr, range(0,0xd800)+range(0xe000,0x10000)))
    2:         for encoding in ('utf-8',):
    1:             self.assertEqual(unicode(u.encode(encoding),encoding), u)
       
    1:     def test_codecs_charmap(self):
               # 0-127
    1:         s = ''.join(map(chr, xrange(128)))
    1:         for encoding in (
                   'cp037', 'cp1026',
                   'cp437', 'cp500', 'cp720', 'cp737', 'cp775', 'cp850',
                   'cp852', 'cp855', 'cp858', 'cp860', 'cp861', 'cp862',
                   'cp863', 'cp865', 'cp866',
                   'iso8859_10', 'iso8859_13', 'iso8859_14', 'iso8859_15',
                   'iso8859_2', 'iso8859_3', 'iso8859_4', 'iso8859_5', 'iso8859_6',
                   'iso8859_7', 'iso8859_9', 'koi8_r', 'latin_1',
                   'mac_cyrillic', 'mac_latin2',
       
                   'cp1250', 'cp1251', 'cp1252', 'cp1253', 'cp1254', 'cp1255',
                   'cp1256', 'cp1257', 'cp1258',
                   'cp856', 'cp857', 'cp864', 'cp869', 'cp874',
       
                   'mac_greek', 'mac_iceland','mac_roman', 'mac_turkish',
   53:             'cp1006', 'iso8859_8',
       
                   ### These have undefined mappings:
                   #'cp424',
       
                   ### These fail the round-trip:
                   #'cp875'
       
                   ):
   52:             self.assertEqual(unicode(s, encoding).encode(encoding), s)
       
               # 128-255
    1:         s = ''.join(map(chr, xrange(128, 256)))
    1:         for encoding in (
                   'cp037', 'cp1026',
                   'cp437', 'cp500', 'cp720', 'cp737', 'cp775', 'cp850',
                   'cp852', 'cp855', 'cp858', 'cp860', 'cp861', 'cp862',
                   'cp863', 'cp865', 'cp866',
                   'iso8859_10', 'iso8859_13', 'iso8859_14', 'iso8859_15',
                   'iso8859_2', 'iso8859_4', 'iso8859_5',
                   'iso8859_9', 'koi8_r', 'latin_1',
   30:             'mac_cyrillic', 'mac_latin2',
       
                   ### These have undefined mappings:
                   #'cp1250', 'cp1251', 'cp1252', 'cp1253', 'cp1254', 'cp1255',
                   #'cp1256', 'cp1257', 'cp1258',
                   #'cp424', 'cp856', 'cp857', 'cp864', 'cp869', 'cp874',
                   #'iso8859_3', 'iso8859_6', 'iso8859_7',
                   #'mac_greek', 'mac_iceland','mac_roman', 'mac_turkish',
       
                   ### These fail the round-trip:
                   #'cp1006', 'cp875', 'iso8859_8',
       
                   ):
   29:             self.assertEqual(unicode(s, encoding).encode(encoding), s)
       
    1:     def test_concatenation(self):
    1:         self.assertEqual((u"abc" u"def"), u"abcdef")
    1:         self.assertEqual(("abc" u"def"), u"abcdef")
    1:         self.assertEqual((u"abc" "def"), u"abcdef")
    1:         self.assertEqual((u"abc" u"def" "ghi"), u"abcdefghi")
    1:         self.assertEqual(("abc" "def" u"ghi"), u"abcdefghi")
       
    1:     def test_printing(self):
    2:         class BitBucket:
    1:             def write(self, text):
   22:                 pass
       
    1:         out = BitBucket()
    1:         print >>out, u'abc'
    1:         print >>out, u'abc', u'def'
    1:         print >>out, u'abc', 'def'
    1:         print >>out, 'abc', u'def'
    1:         print >>out, u'abc\n'
    1:         print >>out, u'abc\n',
    1:         print >>out, u'abc\n',
    1:         print >>out, u'def\n'
    1:         print >>out, u'def\n'
       
    1:     def test_ucs4(self):
    1:         x = u'\U00100000'
    1:         y = x.encode("raw-unicode-escape").decode("raw-unicode-escape")
    1:         self.assertEqual(x, y)
       
    1:         y = r'\U00100000'
    1:         x = y.decode("raw-unicode-escape").encode("raw-unicode-escape")
    1:         self.assertEqual(x, y)
    1:         y = r'\U00010000'
    1:         x = y.decode("raw-unicode-escape").encode("raw-unicode-escape")
    1:         self.assertEqual(x, y)
       
    1:         try:
    1:             '\U11111111'.decode("raw-unicode-escape")
    1:         except UnicodeDecodeError as e:
    1:             self.assertEqual(e.start, 0)
    1:             self.assertEqual(e.end, 10)
               else:
>>>>>>             self.fail("Should have raised UnicodeDecodeError")
       
    1:     def test_conversion(self):
               # Make sure __unicode__() works properly
    2:         class Foo0:
    1:             def __str__(self):
    1:                 return "foo"
       
    2:         class Foo1:
    1:             def __unicode__(self):
    1:                 return u"foo"
       
    2:         class Foo2(object):
    1:             def __unicode__(self):
    1:                 return u"foo"
       
    2:         class Foo3(object):
    1:             def __unicode__(self):
    1:                 return "foo"
       
    2:         class Foo4(str):
    1:             def __unicode__(self):
    1:                 return "foo"
       
    2:         class Foo5(unicode):
    1:             def __unicode__(self):
    1:                 return "foo"
       
    2:         class Foo6(str):
    1:             def __str__(self):
>>>>>>                 return "foos"
       
    1:             def __unicode__(self):
    1:                 return u"foou"
       
    2:         class Foo7(unicode):
    1:             def __str__(self):
>>>>>>                 return "foos"
    1:             def __unicode__(self):
    1:                 return u"foou"
       
    2:         class Foo8(unicode):
    1:             def __new__(cls, content=""):
    4:                 return unicode.__new__(cls, 2*content)
    1:             def __unicode__(self):
    4:                 return self
       
    2:         class Foo9(unicode):
    1:             def __str__(self):
    1:                 return "string"
    1:             def __unicode__(self):
    1:                 return "not unicode"
       
    1:         self.assertEqual(unicode(Foo0()), u"foo")
    1:         self.assertEqual(unicode(Foo1()), u"foo")
    1:         self.assertEqual(unicode(Foo2()), u"foo")
    1:         self.assertEqual(unicode(Foo3()), u"foo")
    1:         self.assertEqual(unicode(Foo4("bar")), u"foo")
    1:         self.assertEqual(unicode(Foo5("bar")), u"foo")
    1:         self.assertEqual(unicode(Foo6("bar")), u"foou")
    1:         self.assertEqual(unicode(Foo7("bar")), u"foou")
    1:         self.assertEqual(unicode(Foo8("foo")), u"foofoo")
    1:         self.assertIs(type(unicode(Foo8("foo"))), Foo8)
    1:         self.assertEqual(UnicodeSubclass(Foo8("foo")), u"foofoo")
    1:         self.assertIs(type(UnicodeSubclass(Foo8("foo"))), UnicodeSubclass)
    1:         self.assertEqual(str(Foo9("foo")), "string")
    1:         self.assertEqual(unicode(Foo9("foo")), u"not unicode")
       
    1:     def test_unicode_repr(self):
    2:         class s1:
    1:             def __repr__(self):
    1:                 return '\\n'
       
    2:         class s2:
    1:             def __repr__(self):
    1:                 return u'\\n'
       
    1:         self.assertEqual(repr(s1()), '\\n')
    1:         self.assertEqual(repr(s2()), '\\n')
       
           # This test only affects 32-bit platforms because expandtabs can only take
           # an int as the max value, not a 64-bit C long.  If expandtabs is changed
           # to take a 64-bit long, this test should apply to all platforms.
    1:     @unittest.skipIf(sys.maxint > (1 << 32) or struct.calcsize('P') != 4,
    1:                      'only applies to 32-bit platforms')
           def test_expandtabs_overflows_gracefully(self):
>>>>>>         self.assertRaises(OverflowError, u't\tt\t'.expandtabs, sys.maxint)
       
    1:     def test__format__(self):
    1:         def test(value, format, expected):
                   # test both with and without the trailing 's'
   25:             self.assertEqual(value.__format__(format), expected)
   25:             self.assertEqual(value.__format__(format + u's'), expected)
       
    1:         test(u'', u'', u'')
    1:         test(u'abc', u'', u'abc')
    1:         test(u'abc', u'.3', u'abc')
    1:         test(u'ab', u'.3', u'ab')
    1:         test(u'abcdef', u'.3', u'abc')
    1:         test(u'abcdef', u'.0', u'')
    1:         test(u'abc', u'3.3', u'abc')
    1:         test(u'abc', u'2.3', u'abc')
    1:         test(u'abc', u'2.2', u'ab')
    1:         test(u'abc', u'3.2', u'ab ')
    1:         test(u'result', u'x<0', u'result')
    1:         test(u'result', u'x<5', u'result')
    1:         test(u'result', u'x<6', u'result')
    1:         test(u'result', u'x<7', u'resultx')
    1:         test(u'result', u'x<8', u'resultxx')
    1:         test(u'result', u' <7', u'result ')
    1:         test(u'result', u'<7', u'result ')
    1:         test(u'result', u'>7', u' result')
    1:         test(u'result', u'>8', u'  result')
    1:         test(u'result', u'^8', u' result ')
    1:         test(u'result', u'^9', u' result  ')
    1:         test(u'result', u'^10', u'  result  ')
    1:         test(u'a', u'10000', u'a' + u' ' * 9999)
    1:         test(u'', u'10000', u' ' * 10000)
    1:         test(u'', u'10000000', u' ' * 10000000)
       
               # test mixing unicode and str
    1:         self.assertEqual(u'abc'.__format__('s'), u'abc')
    1:         self.assertEqual(u'abc'.__format__('->10s'), u'-------abc')
       
    1:     def test_format(self):
    1:         self.assertEqual(u''.format(), u'')
    1:         self.assertEqual(u'a'.format(), u'a')
    1:         self.assertEqual(u'ab'.format(), u'ab')
    1:         self.assertEqual(u'a{{'.format(), u'a{')
    1:         self.assertEqual(u'a}}'.format(), u'a}')
    1:         self.assertEqual(u'{{b'.format(), u'{b')
    1:         self.assertEqual(u'}}b'.format(), u'}b')
    1:         self.assertEqual(u'a{{b'.format(), u'a{b')
       
               # examples from the PEP:
    1:         import datetime
    1:         self.assertEqual(u"My name is {0}".format(u'Fred'), u"My name is Fred")
    1:         self.assertEqual(u"My name is {0[name]}".format(dict(name=u'Fred')),
    1:                          u"My name is Fred")
    1:         self.assertEqual(u"My name is {0} :-{{}}".format(u'Fred'),
    1:                          u"My name is Fred :-{}")
       
               # datetime.__format__ doesn't work with unicode
               #d = datetime.date(2007, 8, 18)
               #self.assertEqual("The year is {0.year}".format(d),
               #                 "The year is 2007")
       
               # classes we'll use for testing
    2:         class C:
    1:             def __init__(self, x=100):
    3:                 self._x = x
    1:             def __format__(self, spec):
    1:                 return spec
       
    2:         class D:
    1:             def __init__(self, x):
    4:                 self.x = x
    1:             def __format__(self, spec):
    2:                 return str(self.x)
       
               # class with __str__, but no __format__
    2:         class E:
    1:             def __init__(self, x):
    3:                 self.x = x
    1:             def __str__(self):
    3:                 return u'E(' + self.x + u')'
       
               # class with __repr__, but no __format__ or __str__
    2:         class F:
    1:             def __init__(self, x):
    1:                 self.x = x
    1:             def __repr__(self):
    1:                 return u'F(' + self.x + u')'
       
               # class with __format__ that forwards to string, for some format_spec's
    2:         class G:
    1:             def __init__(self, x):
    3:                 self.x = x
    1:             def __str__(self):
    2:                 return u"string is " + self.x
    1:             def __format__(self, format_spec):
    2:                 if format_spec == 'd':
    1:                     return u'G(' + self.x + u')'
    1:                 return object.__format__(self, format_spec)
       
               # class that returns a bad type from __format__
    2:         class H:
    1:             def __format__(self, format_spec):
>>>>>>                 return 1.0
       
    2:         class I(datetime.date):
    1:             def __format__(self, format_spec):
    1:                 return self.strftime(format_spec)
       
    2:         class J(int):
    1:             def __format__(self, format_spec):
    1:                 return int.__format__(self * 2, format_spec)
       
       
    1:         self.assertEqual(u''.format(), u'')
    1:         self.assertEqual(u'abc'.format(), u'abc')
    1:         self.assertEqual(u'{0}'.format(u'abc'), u'abc')
    1:         self.assertEqual(u'{0:}'.format(u'abc'), u'abc')
    1:         self.assertEqual(u'X{0}'.format(u'abc'), u'Xabc')
    1:         self.assertEqual(u'{0}X'.format(u'abc'), u'abcX')
    1:         self.assertEqual(u'X{0}Y'.format(u'abc'), u'XabcY')
    1:         self.assertEqual(u'{1}'.format(1, u'abc'), u'abc')
    1:         self.assertEqual(u'X{1}'.format(1, u'abc'), u'Xabc')
    1:         self.assertEqual(u'{1}X'.format(1, u'abc'), u'abcX')
    1:         self.assertEqual(u'X{1}Y'.format(1, u'abc'), u'XabcY')
    1:         self.assertEqual(u'{0}'.format(-15), u'-15')
    1:         self.assertEqual(u'{0}{1}'.format(-15, u'abc'), u'-15abc')
    1:         self.assertEqual(u'{0}X{1}'.format(-15, u'abc'), u'-15Xabc')
    1:         self.assertEqual(u'{{'.format(), u'{')
    1:         self.assertEqual(u'}}'.format(), u'}')
    1:         self.assertEqual(u'{{}}'.format(), u'{}')
    1:         self.assertEqual(u'{{x}}'.format(), u'{x}')
    1:         self.assertEqual(u'{{{0}}}'.format(123), u'{123}')
    1:         self.assertEqual(u'{{{{0}}}}'.format(), u'{{0}}')
    1:         self.assertEqual(u'}}{{'.format(), u'}{')
    1:         self.assertEqual(u'}}x{{'.format(), u'}x{')
       
               # weird field names
    1:         self.assertEqual(u"{0[foo-bar]}".format({u'foo-bar':u'baz'}), u'baz')
    1:         self.assertEqual(u"{0[foo bar]}".format({u'foo bar':u'baz'}), u'baz')
    1:         self.assertEqual(u"{0[ ]}".format({u' ':3}), u'3')
       
    1:         self.assertEqual(u'{foo._x}'.format(foo=C(20)), u'20')
    1:         self.assertEqual(u'{1}{0}'.format(D(10), D(20)), u'2010')
    1:         self.assertEqual(u'{0._x.x}'.format(C(D(u'abc'))), u'abc')
    1:         self.assertEqual(u'{0[0]}'.format([u'abc', u'def']), u'abc')
    1:         self.assertEqual(u'{0[1]}'.format([u'abc', u'def']), u'def')
    1:         self.assertEqual(u'{0[1][0]}'.format([u'abc', [u'def']]), u'def')
    1:         self.assertEqual(u'{0[1][0].x}'.format(['abc', [D(u'def')]]), u'def')
       
               # strings
    1:         self.assertEqual(u'{0:.3s}'.format(u'abc'), u'abc')
    1:         self.assertEqual(u'{0:.3s}'.format(u'ab'), u'ab')
    1:         self.assertEqual(u'{0:.3s}'.format(u'abcdef'), u'abc')
    1:         self.assertEqual(u'{0:.0s}'.format(u'abcdef'), u'')
    1:         self.assertEqual(u'{0:3.3s}'.format(u'abc'), u'abc')
    1:         self.assertEqual(u'{0:2.3s}'.format(u'abc'), u'abc')
    1:         self.assertEqual(u'{0:2.2s}'.format(u'abc'), u'ab')
    1:         self.assertEqual(u'{0:3.2s}'.format(u'abc'), u'ab ')
    1:         self.assertEqual(u'{0:x<0s}'.format(u'result'), u'result')
    1:         self.assertEqual(u'{0:x<5s}'.format(u'result'), u'result')
    1:         self.assertEqual(u'{0:x<6s}'.format(u'result'), u'result')
    1:         self.assertEqual(u'{0:x<7s}'.format(u'result'), u'resultx')
    1:         self.assertEqual(u'{0:x<8s}'.format(u'result'), u'resultxx')
    1:         self.assertEqual(u'{0: <7s}'.format(u'result'), u'result ')
    1:         self.assertEqual(u'{0:<7s}'.format(u'result'), u'result ')
    1:         self.assertEqual(u'{0:>7s}'.format(u'result'), u' result')
    1:         self.assertEqual(u'{0:>8s}'.format(u'result'), u'  result')
    1:         self.assertEqual(u'{0:^8s}'.format(u'result'), u' result ')
    1:         self.assertEqual(u'{0:^9s}'.format(u'result'), u' result  ')
    1:         self.assertEqual(u'{0:^10s}'.format(u'result'), u'  result  ')
    1:         self.assertEqual(u'{0:10000}'.format(u'a'), u'a' + u' ' * 9999)
    1:         self.assertEqual(u'{0:10000}'.format(u''), u' ' * 10000)
    1:         self.assertEqual(u'{0:10000000}'.format(u''), u' ' * 10000000)
       
               # issue 12546: use \x00 as a fill character
    1:         self.assertEqual('{0:\x00<6s}'.format('foo'), 'foo\x00\x00\x00')
    1:         self.assertEqual('{0:\x01<6s}'.format('foo'), 'foo\x01\x01\x01')
    1:         self.assertEqual('{0:\x00^6s}'.format('foo'), '\x00foo\x00\x00')
    1:         self.assertEqual('{0:^6s}'.format('foo'), ' foo  ')
       
    1:         self.assertEqual('{0:\x00<6}'.format(3), '3\x00\x00\x00\x00\x00')
    1:         self.assertEqual('{0:\x01<6}'.format(3), '3\x01\x01\x01\x01\x01')
    1:         self.assertEqual('{0:\x00^6}'.format(3), '\x00\x003\x00\x00\x00')
    1:         self.assertEqual('{0:<6}'.format(3), '3     ')
       
    1:         self.assertEqual('{0:\x00<6}'.format(3.14), '3.14\x00\x00')
    1:         self.assertEqual('{0:\x01<6}'.format(3.14), '3.14\x01\x01')
    1:         self.assertEqual('{0:\x00^6}'.format(3.14), '\x003.14\x00')
    1:         self.assertEqual('{0:^6}'.format(3.14), ' 3.14 ')
       
    1:         self.assertEqual('{0:\x00<12}'.format(3+2.0j), '(3+2j)\x00\x00\x00\x00\x00\x00')
    1:         self.assertEqual('{0:\x01<12}'.format(3+2.0j), '(3+2j)\x01\x01\x01\x01\x01\x01')
    1:         self.assertEqual('{0:\x00^12}'.format(3+2.0j), '\x00\x00\x00(3+2j)\x00\x00\x00')
    1:         self.assertEqual('{0:^12}'.format(3+2.0j), '   (3+2j)   ')
       
               # format specifiers for user defined type
    1:         self.assertEqual(u'{0:abc}'.format(C()), u'abc')
       
               # !r and !s coercions
    1:         self.assertEqual(u'{0!s}'.format(u'Hello'), u'Hello')
    1:         self.assertEqual(u'{0!s:}'.format(u'Hello'), u'Hello')
    1:         self.assertEqual(u'{0!s:15}'.format(u'Hello'), u'Hello          ')
    1:         self.assertEqual(u'{0!s:15s}'.format(u'Hello'), u'Hello          ')
    1:         self.assertEqual(u'{0!r}'.format(u'Hello'), u"u'Hello'")
    1:         self.assertEqual(u'{0!r:}'.format(u'Hello'), u"u'Hello'")
    1:         self.assertEqual(u'{0!r}'.format(F(u'Hello')), u'F(Hello)')
       
               # test fallback to object.__format__
    1:         self.assertEqual(u'{0}'.format({}), u'{}')
    1:         self.assertEqual(u'{0}'.format([]), u'[]')
    1:         self.assertEqual(u'{0}'.format([1]), u'[1]')
    1:         self.assertEqual(u'{0}'.format(E(u'data')), u'E(data)')
    1:         self.assertEqual(u'{0:d}'.format(G(u'data')), u'G(data)')
    1:         self.assertEqual(u'{0!s}'.format(G(u'data')), u'string is data')
       
    1:         msg = 'object.__format__ with a non-empty format string is deprecated'
    1:         with test_support.check_warnings((msg, PendingDeprecationWarning)):
    1:             self.assertEqual(u'{0:^10}'.format(E(u'data')), u' E(data)  ')
    1:             self.assertEqual(u'{0:^10s}'.format(E(u'data')), u' E(data)  ')
    1:             self.assertEqual(u'{0:>15s}'.format(G(u'data')), u' string is data')
       
    1:         self.assertEqual(u"{0:date: %Y-%m-%d}".format(I(year=2007,
    1:                                                         month=8,
    1:                                                         day=27)),
    1:                          u"date: 2007-08-27")
       
               # test deriving from a builtin type and overriding __format__
    1:         self.assertEqual(u"{0}".format(J(10)), u"20")
       
       
               # string format specifiers
    1:         self.assertEqual(u'{0:}'.format('a'), u'a')
       
               # computed format specifiers
    1:         self.assertEqual(u"{0:.{1}}".format(u'hello world', 5), u'hello')
    1:         self.assertEqual(u"{0:.{1}s}".format(u'hello world', 5), u'hello')
    1:         self.assertEqual(u"{0:.{precision}s}".format('hello world', precision=5), u'hello')
    1:         self.assertEqual(u"{0:{width}.{precision}s}".format('hello world', width=10, precision=5), u'hello     ')
    1:         self.assertEqual(u"{0:{width}.{precision}s}".format('hello world', width='10', precision='5'), u'hello     ')
       
               # test various errors
    1:         self.assertRaises(ValueError, u'{'.format)
    1:         self.assertRaises(ValueError, u'}'.format)
    1:         self.assertRaises(ValueError, u'a{'.format)
    1:         self.assertRaises(ValueError, u'a}'.format)
    1:         self.assertRaises(ValueError, u'{a'.format)
    1:         self.assertRaises(ValueError, u'}a'.format)
    1:         self.assertRaises(IndexError, u'{0}'.format)
    1:         self.assertRaises(IndexError, u'{1}'.format, u'abc')
    1:         self.assertRaises(KeyError,   u'{x}'.format)
    1:         self.assertRaises(ValueError, u"}{".format)
    1:         self.assertRaises(ValueError, u"{".format)
    1:         self.assertRaises(ValueError, u"}".format)
    1:         self.assertRaises(ValueError, u"abc{0:{}".format)
    1:         self.assertRaises(ValueError, u"{0".format)
    1:         self.assertRaises(IndexError, u"{0.}".format)
    1:         self.assertRaises(ValueError, u"{0.}".format, 0)
    1:         self.assertRaises(IndexError, u"{0[}".format)
    1:         self.assertRaises(ValueError, u"{0[}".format, [])
    1:         self.assertRaises(KeyError,   u"{0]}".format)
    1:         self.assertRaises(ValueError, u"{0.[]}".format, 0)
    1:         self.assertRaises(ValueError, u"{0..foo}".format, 0)
    1:         self.assertRaises(ValueError, u"{0[0}".format, 0)
    1:         self.assertRaises(ValueError, u"{0[0:foo}".format, 0)
    1:         self.assertRaises(KeyError,   u"{c]}".format)
    1:         self.assertRaises(ValueError, u"{{ {{{0}}".format, 0)
    1:         self.assertRaises(ValueError, u"{0}}".format, 0)
    1:         self.assertRaises(KeyError,   u"{foo}".format, bar=3)
    1:         self.assertRaises(ValueError, u"{0!x}".format, 3)
    1:         self.assertRaises(ValueError, u"{0!}".format, 0)
    1:         self.assertRaises(ValueError, u"{0!rs}".format, 0)
    1:         self.assertRaises(ValueError, u"{!}".format)
    1:         self.assertRaises(IndexError, u"{:}".format)
    1:         self.assertRaises(IndexError, u"{:s}".format)
    1:         self.assertRaises(IndexError, u"{}".format)
    1:         big = u"23098475029384702983476098230754973209482573"
    1:         self.assertRaises(ValueError, (u"{" + big + u"}").format)
    1:         self.assertRaises(ValueError, (u"{[" + big + u"]}").format, [0])
       
               # issue 6089
    1:         self.assertRaises(ValueError, u"{0[0]x}".format, [None])
    1:         self.assertRaises(ValueError, u"{0[0](10)}".format, [None])
       
               # can't have a replacement on the field name portion
    1:         self.assertRaises(TypeError, u'{0[{1}]}'.format, u'abcdefg', 4)
       
               # exceed maximum recursion depth
    1:         self.assertRaises(ValueError, u"{0:{1:{2}}}".format, u'abc', u's', u'')
    1:         self.assertRaises(ValueError, u"{0:{1:{2:{3:{4:{5:{6}}}}}}}".format,
    1:                           0, 1, 2, 3, 4, 5, 6, 7)
       
               # string format spec errors
    1:         self.assertRaises(ValueError, u"{0:-s}".format, u'')
    1:         self.assertRaises(ValueError, format, u"", u"-")
    1:         self.assertRaises(ValueError, u"{0:=s}".format, u'')
       
               # test combining string and unicode
    1:         self.assertEqual(u"foo{0}".format('bar'), u'foobar')
               # This will try to convert the argument from unicode to str, which
               #  will succeed
    1:         self.assertEqual("foo{0}".format(u'bar'), 'foobar')
               # This will try to convert the argument from unicode to str, which
               #  will fail
    1:         self.assertRaises(UnicodeEncodeError, "foo{0}".format, u'\u1000bar')
       
    1:     def test_format_huge_precision(self):
    1:         format_string = u".{}f".format(sys.maxsize + 1)
    1:         with self.assertRaises(ValueError):
    1:             result = format(2.34, format_string)
       
    1:     def test_format_huge_width(self):
    1:         format_string = u"{}f".format(sys.maxsize + 1)
    1:         with self.assertRaises(ValueError):
    1:             result = format(2.34, format_string)
       
    1:     def test_format_huge_item_number(self):
    1:         format_string = u"{{{}:.6f}}".format(sys.maxsize + 1)
    1:         with self.assertRaises(ValueError):
    1:             result = format_string.format(2.34)
       
    1:     def test_format_auto_numbering(self):
    2:         class C:
    1:             def __init__(self, x=100):
    1:                 self._x = x
    1:             def __format__(self, spec):
>>>>>>                 return spec
       
    1:         self.assertEqual(u'{}'.format(10), u'10')
    1:         self.assertEqual(u'{:5}'.format('s'), u's    ')
    1:         self.assertEqual(u'{!r}'.format('s'), u"'s'")
    1:         self.assertEqual(u'{._x}'.format(C(10)), u'10')
    1:         self.assertEqual(u'{[1]}'.format([1, 2]), u'2')
    1:         self.assertEqual(u'{[a]}'.format({'a':4, 'b':2}), u'4')
    1:         self.assertEqual(u'a{}b{}c'.format(0, 1), u'a0b1c')
       
    1:         self.assertEqual(u'a{:{}}b'.format('x', '^10'), u'a    x     b')
    1:         self.assertEqual(u'a{:{}x}b'.format(20, '#'), u'a0x14b')
       
               # can't mix and match numbering and auto-numbering
    1:         self.assertRaises(ValueError, u'{}{1}'.format, 1, 2)
    1:         self.assertRaises(ValueError, u'{1}{}'.format, 1, 2)
    1:         self.assertRaises(ValueError, u'{:{1}}'.format, 1, 2)
    1:         self.assertRaises(ValueError, u'{0:{}}'.format, 1, 2)
       
               # can mix and match auto-numbering and named
    1:         self.assertEqual(u'{f}{}'.format(4, f='test'), u'test4')
    1:         self.assertEqual(u'{}{f}'.format(4, f='test'), u'4test')
    1:         self.assertEqual(u'{:{f}}{g}{}'.format(1, 3, g='g', f=2), u' 1g3')
    1:         self.assertEqual(u'{f:{}}{}{g}'.format(2, 4, f=1, g='g'), u' 14g')
       
    1:     def test_raiseMemError(self):
               # Ensure that the freelist contains a consistent object, even
               # when a string allocation fails with a MemoryError.
               # This used to crash the interpreter,
               # or leak references when the number was smaller.
    1:         charwidth = 4 if sys.maxunicode >= 0x10000 else 2
               # Note: sys.maxsize is half of the actual max allocation because of
               # the signedness of Py_ssize_t.
    3:         alloc = lambda: u"a" * (sys.maxsize // charwidth * 2)
    1:         self.assertRaises(MemoryError, alloc)
    1:         self.assertRaises(MemoryError, alloc)
       
    1:     def test_format_subclass(self):
    2:         class U(unicode):
    1:             def __unicode__(self):
    2:                 return u'__unicode__ overridden'
    1:         u = U(u'xxx')
    1:         self.assertEqual("%s" % u, u'__unicode__ overridden')
    1:         self.assertEqual("{}".format(u), '__unicode__ overridden')
       
    1:     def test_free_after_iterating(self):
    1:         test_support.check_free_after_iterating(self, iter, unicode)
    1:         test_support.check_free_after_iterating(self, reversed, unicode)
       
       
    2: class CAPITest(unittest.TestCase):
       
           # Test PyUnicode_FromFormat()
    1:     def test_from_format(self):
    1:         test_support.import_module('ctypes')
    1:         from ctypes import (
                   pythonapi, py_object, sizeof,
                   c_int, c_long, c_longlong, c_ssize_t,
                   c_uint, c_ulong, c_ulonglong, c_size_t, c_void_p)
    1:         if sys.maxunicode == 0xffff:
    1:             name = "PyUnicodeUCS2_FromFormat"
               else:
>>>>>>             name = "PyUnicodeUCS4_FromFormat"
    1:         _PyUnicode_FromFormat = getattr(pythonapi, name)
    1:         _PyUnicode_FromFormat.restype = py_object
       
    1:         def PyUnicode_FromFormat(format, *args):
   43:             cargs = tuple(
  127:                 py_object(arg) if isinstance(arg, unicode) else arg
   84:                 for arg in args)
   43:             return _PyUnicode_FromFormat(format, *cargs)
       
    1:         def check_format(expected, format, *args):
   40:             text = PyUnicode_FromFormat(format, *args)
   40:             self.assertEqual(expected, text)
       
               # ascii format, non-ascii argument
    1:         check_format(u'ascii\x7f=unicode\xe9',
    1:                      b'ascii\x7f=%U', u'unicode\xe9')
       
               # non-ascii format, ascii argument: ensure that PyUnicode_FromFormatV()
               # raises an error
               #self.assertRaisesRegex(ValueError,
               #    '^PyUnicode_FromFormatV\(\) expects an ASCII-encoded format '
               #    'string, got a non-ASCII byte: 0xe9$',
               #    PyUnicode_FromFormat, b'unicode\xe9=%s', u'ascii')
       
               # test "%c"
    1:         check_format(u'\uabcd',
    1:                      b'%c', c_int(0xabcd))
    1:         if sys.maxunicode > 0xffff:
>>>>>>             check_format(u'\U0010ffff',
>>>>>>                          b'%c', c_int(0x10ffff))
               else:
    1:             with self.assertRaises(OverflowError):
    1:                 PyUnicode_FromFormat(b'%c', c_int(0x10000))
    1:         with self.assertRaises(OverflowError):
    1:             PyUnicode_FromFormat(b'%c', c_int(0x110000))
               # Issue #18183
    1:         if sys.maxunicode > 0xffff:
>>>>>>             check_format(u'\U00010000\U00100000',
>>>>>>                          b'%c%c', c_int(0x10000), c_int(0x100000))
       
               # test "%"
    1:         check_format(u'%',
    1:                      b'%')
    1:         check_format(u'%',
    1:                      b'%%')
    1:         check_format(u'%s',
    1:                      b'%%s')
    1:         check_format(u'[%]',
    1:                      b'[%%]')
    1:         check_format(u'%abc',
    1:                      b'%%%s', b'abc')
       
               # test %S
    1:         check_format(u"repr=abc",
    1:                      b'repr=%S', u'abc')
       
               # test %R
    1:         check_format(u"repr=u'abc'",
    1:                      b'repr=%R', u'abc')
       
               # test integer formats (%i, %d, %u)
    1:         check_format(u'010',
    1:                      b'%03i', c_int(10))
    1:         check_format(u'0010',
    1:                      b'%0.4i', c_int(10))
    1:         check_format(u'-123',
    1:                      b'%i', c_int(-123))
       
    1:         check_format(u'-123',
    1:                      b'%d', c_int(-123))
    1:         check_format(u'-123',
    1:                      b'%ld', c_long(-123))
    1:         check_format(u'-123',
    1:                      b'%zd', c_ssize_t(-123))
       
    1:         check_format(u'123',
    1:                      b'%u', c_uint(123))
    1:         check_format(u'123',
    1:                      b'%lu', c_ulong(123))
    1:         check_format(u'123',
    1:                      b'%zu', c_size_t(123))
       
               # test long output
    1:         min_long = -(2 ** (8 * sizeof(c_long) - 1))
    1:         max_long = -min_long - 1
    1:         check_format(unicode(min_long),
    1:                      b'%ld', c_long(min_long))
    1:         check_format(unicode(max_long),
    1:                      b'%ld', c_long(max_long))
    1:         max_ulong = 2 ** (8 * sizeof(c_ulong)) - 1
    1:         check_format(unicode(max_ulong),
    1:                      b'%lu', c_ulong(max_ulong))
    1:         PyUnicode_FromFormat(b'%p', c_void_p(-1))
       
               # test padding (width and/or precision)
    1:         check_format(u'123'.rjust(10, u'0'),
    1:                      b'%010i', c_int(123))
    1:         check_format(u'123'.rjust(100),
    1:                      b'%100i', c_int(123))
    1:         check_format(u'123'.rjust(100, u'0'),
    1:                      b'%.100i', c_int(123))
    1:         check_format(u'123'.rjust(80, u'0').rjust(100),
    1:                      b'%100.80i', c_int(123))
       
    1:         check_format(u'123'.rjust(10, u'0'),
    1:                      b'%010u', c_uint(123))
    1:         check_format(u'123'.rjust(100),
    1:                      b'%100u', c_uint(123))
    1:         check_format(u'123'.rjust(100, u'0'),
    1:                      b'%.100u', c_uint(123))
    1:         check_format(u'123'.rjust(80, u'0').rjust(100),
    1:                      b'%100.80u', c_uint(123))
       
    1:         check_format(u'123'.rjust(10, u'0'),
    1:                      b'%010x', c_int(0x123))
    1:         check_format(u'123'.rjust(100),
    1:                      b'%100x', c_int(0x123))
    1:         check_format(u'123'.rjust(100, u'0'),
    1:                      b'%.100x', c_int(0x123))
    1:         check_format(u'123'.rjust(80, u'0').rjust(100),
    1:                      b'%100.80x', c_int(0x123))
       
               # test %V
    1:         check_format(u'repr=abc',
    1:                      b'repr=%V', u'abc', b'xyz')
    1:         check_format(u'repr=\xe4\xba\xba\xe6\xb0\x91',
    1:                      b'repr=%V', None, b'\xe4\xba\xba\xe6\xb0\x91')
    1:         check_format(u'repr=abc\xff',
    1:                      b'repr=%V', None, b'abc\xff')
       
               # not supported: copy the raw format string. these tests are just here
               # to check for crashes and should not be considered as specifications
    1:         check_format(u'%s',
    1:                      b'%1%s', b'abc')
    1:         check_format(u'%1abc',
    1:                      b'%1abc')
    1:         check_format(u'%+i',
    1:                      b'%+i', c_int(10))
    1:         check_format(u'%s',
    1:                      b'%.%s', b'abc')
       
    1:     @test_support.cpython_only
           def test_encode_decimal(self):
    1:         from _testcapi import unicode_encodedecimal
    1:         self.assertEqual(unicode_encodedecimal(u'123'),
    1:                          b'123')
    1:         self.assertEqual(unicode_encodedecimal(u'\u0663.\u0661\u0664'),
    1:                          b'3.14')
    1:         self.assertEqual(unicode_encodedecimal(u"\N{EM SPACE}3.14\N{EN SPACE}"),
    1:                          b' 3.14 ')
    1:         self.assertRaises(UnicodeEncodeError,
    1:                           unicode_encodedecimal, u"123\u20ac", "strict")
    1:         self.assertEqual(unicode_encodedecimal(u"123\u20ac", "replace"),
    1:                          b'123?')
    1:         self.assertEqual(unicode_encodedecimal(u"123\u20ac", "ignore"),
    1:                          b'123')
    1:         self.assertEqual(unicode_encodedecimal(u"123\u20ac", "xmlcharrefreplace"),
    1:                          b'123&#8364;')
    1:         self.assertEqual(unicode_encodedecimal(u"123\u20ac", "backslashreplace"),
    1:                          b'123\\u20ac')
    1:         self.assertEqual(unicode_encodedecimal(u"123\u20ac\N{EM SPACE}", "replace"),
    1:                          b'123? ')
    1:         self.assertEqual(unicode_encodedecimal(u"123\u20ac\u20ac", "replace"),
    1:                          b'123??')
    1:         self.assertEqual(unicode_encodedecimal(u"123\u20ac\u0660", "replace"),
    1:                          b'123?0')
       
    1:     @test_support.cpython_only
           def test_encode_decimal_with_surrogates(self):
    1:         from _testcapi import unicode_encodedecimal
    1:         tests = [(u'\U0001f49d', '&#128157;'),
    1:                  (u'\ud83d', '&#55357;'),
    1:                  (u'\udc9d', '&#56477;'),
                       ]
    1:         if u'\ud83d\udc9d' != u'\U0001f49d':
>>>>>>             tests += [(u'\ud83d\udc9d', '&#55357;&#56477;')]
    4:         for s, exp in tests:
    3:             self.assertEqual(
    3:                     unicode_encodedecimal(u"123" + s, "xmlcharrefreplace"),
    3:                     '123' + exp)
       
    1: def test_main():
    1:     test_support.run_unittest(__name__)
       
    1: if __name__ == "__main__":
>>>>>>     test_main()
