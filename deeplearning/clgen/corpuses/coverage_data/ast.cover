       # -*- coding: utf-8 -*-
       """
           ast
           ~~~
       
           The `ast` module helps Python applications to process trees of the Python
           abstract syntax grammar.  The abstract syntax itself might change with
           each Python release; this module helps to find out programmatically what
           the current grammar looks like and allows modifications of it.
       
           An abstract syntax tree can be generated by passing `ast.PyCF_ONLY_AST` as
           a flag to the `compile()` builtin function or by using the `parse()`
           function from this module.  The result will be a tree of objects whose
           classes all inherit from `ast.AST`.
       
           A modified abstract syntax tree can be compiled into a Python code object
           using the built-in `compile()` function.
       
           Additionally various helper functions are provided that make working with
           the trees simpler.  The main intention of the helper functions and this
           module in general is to provide an easy to use interface for libraries
           that work tightly with the python syntax (template engines for example).
       
       
           :copyright: Copyright 2008 by Armin Ronacher.
           :license: Python License.
    1: """
    1: from _ast import *
    1: from _ast import __version__
       
       
    1: def parse(source, filename='<unknown>', mode='exec'):
           """
           Parse the source into an AST node.
           Equivalent to compile(source, filename, mode, PyCF_ONLY_AST).
           """
  151:     return compile(source, filename, mode, PyCF_ONLY_AST)
       
       
    1: def literal_eval(node_or_string):
           """
           Safely evaluate an expression node or a string containing a Python
           expression.  The string or node provided may only consist of the following
           Python literal structures: strings, numbers, tuples, lists, dicts, booleans,
           and None.
           """
  139:     _safe_names = {'None': None, 'True': True, 'False': False}
  139:     if isinstance(node_or_string, basestring):
  139:         node_or_string = parse(node_or_string, mode='eval')
  139:     if isinstance(node_or_string, Expression):
  139:         node_or_string = node_or_string.body
  139:     def _convert(node):
  668:         if isinstance(node, Str):
  131:             return node.s
  537:         elif isinstance(node, Num):
  265:             return node.n
  272:         elif isinstance(node, Tuple):
  262:             return tuple(map(_convert, node.elts))
   10:         elif isinstance(node, List):
    1:             return list(map(_convert, node.elts))
    9:         elif isinstance(node, Dict):
    3:             return dict((_convert(k), _convert(v)) for k, v
    1:                         in zip(node.keys, node.values))
    8:         elif isinstance(node, Name):
    3:             if node.id in _safe_names:
    3:                 return _safe_names[node.id]
    5:         elif isinstance(node, BinOp) and \
    3:              isinstance(node.op, (Add, Sub)) and \
    3:              isinstance(node.right, Num) and \
    2:              isinstance(node.right.n, complex) and \
    2:              isinstance(node.left, Num) and \
    2:              isinstance(node.left.n, (int, long, float)):
    2:             left = node.left.n
    2:             right = node.right.n
    2:             if isinstance(node.op, Add):
    1:                 return left + right
                   else:
    1:                 return left - right
    3:         raise ValueError('malformed string')
  139:     return _convert(node_or_string)
       
       
    1: def dump(node, annotate_fields=True, include_attributes=False):
           """
           Return a formatted dump of the tree in *node*.  This is mainly useful for
           debugging purposes.  The returned string will show the names and the values
           for fields.  This makes the code impossible to evaluate, so if evaluation is
           wanted *annotate_fields* must be set to False.  Attributes such as line
           numbers and column offsets are not dumped by default.  If this is wanted,
           *include_attributes* can be set to True.
           """
   10:     def _format(node):
  175:         if isinstance(node, AST):
  174:             fields = [(a, _format(b)) for a, b in iter_fields(node)]
   70:             rv = '%s(%s' % (node.__class__.__name__, ', '.join(
  154:                 ('%s=%s' % field for field in fields)
   70:                 if annotate_fields else
   28:                 (b for a, b in fields)
                   ))
   70:             if include_attributes and node._attributes:
   22:                 rv += fields and ', ' or ' '
   88:                 rv += ', '.join('%s=%s' % (a, _format(getattr(node, a)))
   66:                                 for a in node._attributes)
   70:             return rv + ')'
  105:         elif isinstance(node, list):
   57:             return '[%s]' % ', '.join(_format(x) for x in node)
   85:         return repr(node)
   10:     if not isinstance(node, AST):
>>>>>>         raise TypeError('expected AST, got %r' % node.__class__.__name__)
   10:     return _format(node)
       
       
    1: def copy_location(new_node, old_node):
           """
           Copy source location (`lineno` and `col_offset` attributes) from
           *old_node* to *new_node* if possible, and return *new_node*.
           """
    3:     for attr in 'lineno', 'col_offset':
    2:         if attr in old_node._attributes and attr in new_node._attributes \
    2:            and hasattr(old_node, attr):
    2:             setattr(new_node, attr, getattr(old_node, attr))
    1:     return new_node
       
       
    1: def fix_missing_locations(node):
           """
           When you compile a node tree with compile(), the compiler expects lineno and
           col_offset attributes for every node that supports them.  This is rather
           tedious to fill in for generated nodes, so this helper adds these attributes
           recursively where not already set, by setting them to the values of the
           parent node.  It works recursively starting at *node*.
           """
    3:     def _fix(node, lineno, col_offset):
   18:         if 'lineno' in node._attributes:
   12:             if not hasattr(node, 'lineno'):
    8:                 node.lineno = lineno
                   else:
    4:                 lineno = node.lineno
   18:         if 'col_offset' in node._attributes:
   12:             if not hasattr(node, 'col_offset'):
    8:                 node.col_offset = col_offset
                   else:
    4:                 col_offset = node.col_offset
   33:         for child in iter_child_nodes(node):
   15:             _fix(child, lineno, col_offset)
    3:     _fix(node, 1, 0)
    3:     return node
       
       
    1: def increment_lineno(node, n=1):
           """
           Increment the line number of each node in the tree starting at *node* by *n*.
           This is useful to "move code" to a different location in a file.
           """
   11:     for child in walk(node):
    9:         if 'lineno' in child._attributes:
    6:             child.lineno = getattr(child, 'lineno', 0) + n
    2:     return node
       
       
    1: def iter_fields(node):
           """
           Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields``
           that is present on *node*.
           """
  253:     for field in node._fields:
  154:         try:
  154:             yield field, getattr(node, field)
    1:         except AttributeError:
>>>>>>             pass
       
       
    1: def iter_child_nodes(node):
           """
           Yield all direct child nodes of *node*, that is, all fields that are nodes
           and all items of fields that are lists of nodes.
           """
   73:     for name, field in iter_fields(node):
   45:         if isinstance(field, AST):
   18:             yield field
   27:         elif isinstance(field, list):
   22:             for item in field:
   12:                 if isinstance(item, AST):
   12:                     yield item
       
       
    1: def get_docstring(node, clean=True):
           """
           Return the docstring for the given node or None if no docstring can
           be found.  If the node provided does not have docstrings a TypeError
           will be raised.
           """
    1:     if not isinstance(node, (FunctionDef, ClassDef, Module)):
>>>>>>         raise TypeError("%r can't have docstrings" % node.__class__.__name__)
    1:     if node.body and isinstance(node.body[0], Expr) and \
    1:        isinstance(node.body[0].value, Str):
    1:         if clean:
    1:             import inspect
    1:             return inspect.cleandoc(node.body[0].value.s)
>>>>>>         return node.body[0].value.s
       
       
    1: def walk(node):
           """
           Recursively yield all descendant nodes in the tree starting at *node*
           (including *node* itself), in no specified order.  This is useful if you
           only want to modify nodes in place and don't care about the context.
           """
    2:     from collections import deque
    2:     todo = deque([node])
   11:     while todo:
    9:         node = todo.popleft()
    9:         todo.extend(iter_child_nodes(node))
    9:         yield node
       
       
    2: class NodeVisitor(object):
           """
           A node visitor base class that walks the abstract syntax tree and calls a
           visitor function for every node found.  This function may return a value
           which is forwarded by the `visit` method.
       
           This class is meant to be subclassed, with the subclass adding visitor
           methods.
       
           Per default the visitor functions for the nodes are ``'visit_'`` +
           class name of the node.  So a `TryFinally` node visit function would
           be `visit_TryFinally`.  This behavior can be changed by overriding
           the `visit` method.  If no visitor function exists for a node
           (return value `None`) the `generic_visit` visitor is used instead.
       
           Don't use the `NodeVisitor` if you want to apply changes to nodes during
           traversing.  For this a special visitor exists (`NodeTransformer`) that
           allows modifications.
    1:     """
       
    1:     def visit(self, node):
               """Visit a node."""
>>>>>>         method = 'visit_' + node.__class__.__name__
>>>>>>         visitor = getattr(self, method, self.generic_visit)
>>>>>>         return visitor(node)
       
    1:     def generic_visit(self, node):
               """Called if no explicit visitor function exists for a node."""
>>>>>>         for field, value in iter_fields(node):
>>>>>>             if isinstance(value, list):
>>>>>>                 for item in value:
>>>>>>                     if isinstance(item, AST):
>>>>>>                         self.visit(item)
>>>>>>             elif isinstance(value, AST):
>>>>>>                 self.visit(value)
       
       
    2: class NodeTransformer(NodeVisitor):
           """
           A :class:`NodeVisitor` subclass that walks the abstract syntax tree and
           allows modification of nodes.
       
           The `NodeTransformer` will walk the AST and use the return value of the
           visitor methods to replace or remove the old node.  If the return value of
           the visitor method is ``None``, the node will be removed from its location,
           otherwise it is replaced with the return value.  The return value may be the
           original node in which case no replacement takes place.
       
           Here is an example transformer that rewrites all occurrences of name lookups
           (``foo``) to ``data['foo']``::
       
              class RewriteName(NodeTransformer):
       
                  def visit_Name(self, node):
                      return copy_location(Subscript(
                          value=Name(id='data', ctx=Load()),
                          slice=Index(value=Str(s=node.id)),
                          ctx=node.ctx
                      ), node)
       
           Keep in mind that if the node you're operating on has child nodes you must
           either transform the child nodes yourself or call the :meth:`generic_visit`
           method for the node first.
       
           For nodes that were part of a collection of statements (that applies to all
           statement nodes), the visitor may also return a list of nodes rather than
           just a single node.
       
           Usually you use the transformer like this::
       
              node = YourTransformer().visit(node)
    1:     """
       
    1:     def generic_visit(self, node):
>>>>>>         for field, old_value in iter_fields(node):
>>>>>>             old_value = getattr(node, field, None)
>>>>>>             if isinstance(old_value, list):
>>>>>>                 new_values = []
>>>>>>                 for value in old_value:
>>>>>>                     if isinstance(value, AST):
>>>>>>                         value = self.visit(value)
>>>>>>                         if value is None:
>>>>>>                             continue
>>>>>>                         elif not isinstance(value, AST):
>>>>>>                             new_values.extend(value)
>>>>>>                             continue
>>>>>>                     new_values.append(value)
>>>>>>                 old_value[:] = new_values
>>>>>>             elif isinstance(old_value, AST):
>>>>>>                 new_node = self.visit(old_value)
>>>>>>                 if new_node is None:
>>>>>>                     delattr(node, field)
                       else:
>>>>>>                     setattr(node, field, new_node)
>>>>>>         return node
