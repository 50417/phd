    1: """Class for printing reports on profiled python code."""
       
       # Written by James Roskind
       # Based on prior profile module by Sjoerd Mullender...
       #   which was hacked somewhat by: Guido van Rossum
       
       # Copyright Disney Enterprises, Inc.  All Rights Reserved.
       # Licensed to PSF under a Contributor Agreement
       #
       # Licensed under the Apache License, Version 2.0 (the "License");
       # you may not use this file except in compliance with the License.
       # You may obtain a copy of the License at
       #
       # http://www.apache.org/licenses/LICENSE-2.0
       #
       # Unless required by applicable law or agreed to in writing, software
       # distributed under the License is distributed on an "AS IS" BASIS,
       # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
       # either express or implied.  See the License for the specific language
       # governing permissions and limitations under the License.
       
       
    1: import sys
    1: import os
    1: import time
    1: import marshal
    1: import re
    1: from functools import cmp_to_key
       
    1: __all__ = ["Stats"]
       
    2: class Stats:
           """This class is used for creating reports from data generated by the
           Profile class.  It is a "friend" of that class, and imports data either
           by direct access to members of Profile class, or by reading in a dictionary
           that was emitted (via marshal) from the Profile class.
       
           The big change from the previous Profiler (in terms of raw functionality)
           is that an "add()" method has been provided to combine Stats from
           several distinct profile runs.  Both the constructor and the add()
           method now take arbitrarily many file names as arguments.
       
           All the print methods now take an argument that indicates how many lines
           to print.  If the arg is a floating point number between 0 and 1.0, then
           it is taken as a decimal percentage of the available lines to be printed
           (e.g., .1 means print 10% of all available lines).  If it is an integer,
           it is taken to mean the number of lines of data that you wish to have
           printed.
       
           The sort_stats() method now processes some additional options (i.e., in
           addition to the old -1, 0, 1, or 2).  It takes an arbitrary number of
           quoted strings to select the sort order.  For example sort_stats('time',
           'name') sorts on the major key of 'internal function time', and on the
           minor key of 'the name of the function'.  Look at the two tables in
           sort_stats() and get_sort_arg_defs(self) for more examples.
       
           All methods return self, so you can string together commands like:
               Stats('foo', 'goo').strip_dirs().sort_stats('calls').\
                                   print_stats(5).print_callers(5)
    1:     """
       
    1:     def __init__(self, *args, **kwds):
               # I can't figure out how to explicitly specify a stream keyword arg
               # with *args:
               #   def __init__(self, *args, stream=sys.stdout): ...
               # so I use **kwds and sqauwk if something unexpected is passed in.
   14:         self.stream = sys.stdout
   14:         if "stream" in kwds:
   14:             self.stream = kwds["stream"]
   14:             del kwds["stream"]
   14:         if kwds:
>>>>>>             keys = kwds.keys()
>>>>>>             keys.sort()
>>>>>>             extras = ", ".join(["%s=%s" % (k, kwds[k]) for k in keys])
>>>>>>             raise ValueError, "unrecognized keyword args: %s" % extras
   14:         if not len(args):
>>>>>>             arg = None
               else:
   14:             arg = args[0]
   14:             args = args[1:]
   14:         self.init(arg)
   14:         self.add(*args)
       
    1:     def init(self, arg):
   14:         self.all_callees = None  # calc only if needed
   14:         self.files = []
   14:         self.fcn_list = None
   14:         self.total_tt = 0
   14:         self.total_calls = 0
   14:         self.prim_calls = 0
   14:         self.max_name_len = 0
   14:         self.top_level = {}
   14:         self.stats = {}
   14:         self.sort_arg_dict = {}
   14:         self.load_stats(arg)
   14:         trouble = 1
   14:         try:
   14:             self.get_top_level_stats()
   14:             trouble = 0
               finally:
   14:             if trouble:
>>>>>>                 print >> self.stream, "Invalid timing data",
>>>>>>                 if self.files: print >> self.stream, self.files[-1],
>>>>>>                 print >> self.stream
       
    1:     def load_stats(self, arg):
   14:         if not arg:  self.stats = {}
   14:         elif isinstance(arg, basestring):
>>>>>>             f = open(arg, 'rb')
>>>>>>             self.stats = marshal.load(f)
>>>>>>             f.close()
>>>>>>             try:
>>>>>>                 file_stats = os.stat(arg)
>>>>>>                 arg = time.ctime(file_stats.st_mtime) + "    " + arg
>>>>>>             except:  # in case this is not unix
>>>>>>                 pass
>>>>>>             self.files = [ arg ]
   14:         elif hasattr(arg, 'create_stats'):
   14:             arg.create_stats()
   14:             self.stats = arg.stats
   14:             arg.stats = {}
   14:         if not self.stats:
>>>>>>             raise TypeError("Cannot create or construct a %r object from %r"
>>>>>>                             % (self.__class__, arg))
   14:         return
       
    1:     def get_top_level_stats(self):
  142:         for func, (cc, nc, tt, ct, callers) in self.stats.items():
  128:             self.total_calls += nc
  128:             self.prim_calls  += cc
  128:             self.total_tt    += tt
  128:             if ("jprofile", 0, "profiler") in callers:
>>>>>>                 self.top_level[func] = None
  128:             if len(func_std_string(func)) > self.max_name_len:
   34:                 self.max_name_len = len(func_std_string(func))
       
    1:     def add(self, *arg_list):
   14:         if not arg_list: return self
>>>>>>         if len(arg_list) > 1: self.add(*arg_list[1:])
>>>>>>         other = arg_list[0]
>>>>>>         if type(self) != type(other) or self.__class__ != other.__class__:
>>>>>>             other = Stats(other)
>>>>>>         self.files += other.files
>>>>>>         self.total_calls += other.total_calls
>>>>>>         self.prim_calls += other.prim_calls
>>>>>>         self.total_tt += other.total_tt
>>>>>>         for func in other.top_level:
>>>>>>             self.top_level[func] = None
       
>>>>>>         if self.max_name_len < other.max_name_len:
>>>>>>             self.max_name_len = other.max_name_len
       
>>>>>>         self.fcn_list = None
       
>>>>>>         for func, stat in other.stats.iteritems():
>>>>>>             if func in self.stats:
>>>>>>                 old_func_stat = self.stats[func]
                   else:
>>>>>>                 old_func_stat = (0, 0, 0, 0, {},)
>>>>>>             self.stats[func] = add_func_stats(old_func_stat, stat)
>>>>>>         return self
       
    1:     def dump_stats(self, filename):
               """Write the profile data to a file we know how to load back."""
>>>>>>         f = file(filename, 'wb')
>>>>>>         try:
>>>>>>             marshal.dump(self.stats, f)
               finally:
>>>>>>             f.close()
       
           # list the tuple indices and directions for sorting,
           # along with some printable description
    1:     sort_arg_dict_default = {
    1:               "calls"     : (((1,-1),              ), "call count"),
    1:               "ncalls"    : (((1,-1),              ), "call count"),
    1:               "cumtime"   : (((3,-1),              ), "cumulative time"),
    1:               "cumulative": (((3,-1),              ), "cumulative time"),
    1:               "file"      : (((4, 1),              ), "file name"),
    1:               "filename"  : (((4, 1),              ), "file name"),
    1:               "line"      : (((5, 1),              ), "line number"),
    1:               "module"    : (((4, 1),              ), "file name"),
    1:               "name"      : (((6, 1),              ), "function name"),
    1:               "nfl"       : (((6, 1),(4, 1),(5, 1),), "name/file/line"),
    1:               "pcalls"    : (((0,-1),              ), "primitive call count"),
    1:               "stdname"   : (((7, 1),              ), "standard name"),
    1:               "time"      : (((2,-1),              ), "internal time"),
    1:               "tottime"   : (((2,-1),              ), "internal time"),
                     }
       
    1:     def get_sort_arg_defs(self):
               """Expand all abbreviations that are unique."""
    6:         if not self.sort_arg_dict:
    6:             self.sort_arg_dict = dict = {}
    6:             bad_list = {}
   90:             for word, tup in self.sort_arg_dict_default.iteritems():
   84:                 fragment = word
  504:                 while fragment:
  456:                     if not fragment:
>>>>>>                         break
  456:                     if fragment in dict:
   36:                         bad_list[fragment] = 0
   36:                         break
  420:                     dict[fragment] = tup
  420:                     fragment = fragment[:-1]
   36:             for word in bad_list:
   30:                 del dict[word]
    6:         return self.sort_arg_dict
       
    1:     def sort_stats(self, *field):
    6:         if not field:
>>>>>>             self.fcn_list = 0
>>>>>>             return self
    6:         if len(field) == 1 and isinstance(field[0], (int, long)):
                   # Be compatible with old profiler
>>>>>>             field = [ {-1: "stdname",
>>>>>>                        0:  "calls",
>>>>>>                        1:  "time",
>>>>>>                        2:  "cumulative"}[field[0]] ]
       
    6:         sort_arg_defs = self.get_sort_arg_defs()
    6:         sort_tuple = ()
    6:         self.sort_type = ""
    6:         connector = ""
   12:         for word in field:
    6:             sort_tuple = sort_tuple + sort_arg_defs[word][0]
    6:             self.sort_type += connector + sort_arg_defs[word][1]
    6:             connector = ", "
       
    6:         stats_list = []
  102:         for func, (cc, nc, tt, ct, callers) in self.stats.iteritems():
   96:             stats_list.append((cc, nc, tt, ct) + func +
   96:                               (func_std_string(func), func))
       
    6:         stats_list.sort(key=cmp_to_key(TupleComp(sort_tuple).compare))
       
    6:         self.fcn_list = fcn_list = []
  102:         for tuple in stats_list:
   96:             fcn_list.append(tuple[-1])
    6:         return self
       
    1:     def reverse_order(self):
>>>>>>         if self.fcn_list:
>>>>>>             self.fcn_list.reverse()
>>>>>>         return self
       
    1:     def strip_dirs(self):
    6:         oldstats = self.stats
    6:         self.stats = newstats = {}
    6:         max_name_len = 0
  102:         for func, (cc, nc, tt, ct, callers) in oldstats.iteritems():
   96:             newfunc = func_strip_path(func)
   96:             if len(func_std_string(newfunc)) > max_name_len:
   18:                 max_name_len = len(func_std_string(newfunc))
   96:             newcallers = {}
  213:             for func2, caller in callers.iteritems():
  117:                 newcallers[func_strip_path(func2)] = caller
       
   96:             if newfunc in newstats:
>>>>>>                 newstats[newfunc] = add_func_stats(
>>>>>>                                         newstats[newfunc],
>>>>>>                                         (cc, nc, tt, ct, newcallers))
                   else:
   96:                 newstats[newfunc] = (cc, nc, tt, ct, newcallers)
    6:         old_top = self.top_level
    6:         self.top_level = new_top = {}
    6:         for func in old_top:
>>>>>>             new_top[func_strip_path(func)] = None
       
    6:         self.max_name_len = max_name_len
       
    6:         self.fcn_list = None
    6:         self.all_callees = None
    6:         return self
       
    1:     def calc_callees(self):
    2:         if self.all_callees: return
    2:         self.all_callees = all_callees = {}
   34:         for func, (cc, nc, tt, ct, callers) in self.stats.iteritems():
   32:             if not func in all_callees:
   19:                 all_callees[func] = {}
   71:             for func2, caller in callers.iteritems():
   39:                 if not func2 in all_callees:
   13:                     all_callees[func2] = {}
   39:                 all_callees[func2][func]  = caller
    2:         return
       
           #******************************************************************
           # The following functions support actual printing of reports
           #******************************************************************
       
           # Optional "amount" is either a line count, or a percentage of lines.
       
    1:     def eval_print_amount(self, sel, list, msg):
>>>>>>         new_list = list
>>>>>>         if isinstance(sel, basestring):
>>>>>>             try:
>>>>>>                 rex = re.compile(sel)
>>>>>>             except re.error:
>>>>>>                 msg += "   <Invalid regular expression %r>\n" % sel
>>>>>>                 return new_list, msg
>>>>>>             new_list = []
>>>>>>             for func in list:
>>>>>>                 if rex.search(func_std_string(func)):
>>>>>>                     new_list.append(func)
               else:
>>>>>>             count = len(list)
>>>>>>             if isinstance(sel, float) and 0.0 <= sel < 1.0:
>>>>>>                 count = int(count * sel + .5)
>>>>>>                 new_list = list[:count]
>>>>>>             elif isinstance(sel, (int, long)) and 0 <= sel < count:
>>>>>>                 count = sel
>>>>>>                 new_list = list[:count]
>>>>>>         if len(list) != len(new_list):
>>>>>>             msg += "   List reduced from %r to %r due to restriction <%r>\n" % (
>>>>>>                 len(list), len(new_list), sel)
       
>>>>>>         return new_list, msg
       
    1:     def get_print_list(self, sel_list):
   14:         width = self.max_name_len
   14:         if self.fcn_list:
    6:             stat_list = self.fcn_list[:]
    6:             msg = "   Ordered by: " + self.sort_type + '\n'
               else:
    8:             stat_list = self.stats.keys()
    8:             msg = "   Random listing order was used\n"
       
   14:         for selection in sel_list:
>>>>>>             stat_list, msg = self.eval_print_amount(selection, stat_list, msg)
       
   14:         count = len(stat_list)
       
   14:         if not stat_list:
>>>>>>             return 0, stat_list
   14:         print >> self.stream, msg
   14:         if count < len(self.stats):
>>>>>>             width = 0
>>>>>>             for func in stat_list:
>>>>>>                 if  len(func_std_string(func)) > width:
>>>>>>                     width = len(func_std_string(func))
   14:         return width+2, stat_list
       
    1:     def print_stats(self, *amount):
   10:         for filename in self.files:
>>>>>>             print >> self.stream, filename
   10:         if self.files: print >> self.stream
   10:         indent = ' ' * 8
   10:         for func in self.top_level:
>>>>>>             print >> self.stream, indent, func_get_function_name(func)
       
   10:         print >> self.stream, indent, self.total_calls, "function calls",
   10:         if self.total_calls != self.prim_calls:
    2:             print >> self.stream, "(%d primitive calls)" % self.prim_calls,
   10:         print >> self.stream, "in %.3f seconds" % self.total_tt
   10:         print >> self.stream
   10:         width, list = self.get_print_list(amount)
   10:         if list:
   10:             self.print_title()
   74:             for func in list:
   64:                 self.print_line(func)
   10:             print >> self.stream
   10:             print >> self.stream
   10:         return self
       
    1:     def print_callees(self, *amount):
    2:         width, list = self.get_print_list(amount)
    2:         if list:
    2:             self.calc_callees()
       
    2:             self.print_call_heading(width, "called...")
   34:             for func in list:
   32:                 if func in self.all_callees:
   32:                     self.print_call_line(width, func, self.all_callees[func])
                       else:
>>>>>>                     self.print_call_line(width, func, {})
    2:             print >> self.stream
    2:             print >> self.stream
    2:         return self
       
    1:     def print_callers(self, *amount):
    2:         width, list = self.get_print_list(amount)
    2:         if list:
    2:             self.print_call_heading(width, "was called by...")
   34:             for func in list:
   32:                 cc, nc, tt, ct, callers = self.stats[func]
   32:                 self.print_call_line(width, func, callers, "<-")
    2:             print >> self.stream
    2:             print >> self.stream
    2:         return self
       
    1:     def print_call_heading(self, name_size, column_title):
    4:         print >> self.stream, "Function ".ljust(name_size) + column_title
               # print sub-header only if we have new-style callers
    4:         subheader = False
    4:         for cc, nc, tt, ct, callers in self.stats.itervalues():
    4:             if callers:
    4:                 value = callers.itervalues().next()
    4:                 subheader = isinstance(value, tuple)
    4:                 break
    4:         if subheader:
    2:             print >> self.stream, " "*name_size + "    ncalls  tottime  cumtime"
       
    1:     def print_call_line(self, name_size, source, call_dict, arrow="->"):
   64:         print >> self.stream, func_std_string(source).ljust(name_size) + arrow,
   64:         if not call_dict:
   15:             print >> self.stream
   15:             return
   49:         clist = call_dict.keys()
   49:         clist.sort()
   49:         indent = ""
  127:         for func in clist:
   78:             name = func_std_string(func)
   78:             value = call_dict[func]
   78:             if isinstance(value, tuple):
   36:                 nc, cc, tt, ct = value
   36:                 if nc != cc:
    2:                     substats = '%d/%d' % (nc, cc)
                       else:
   34:                     substats = '%d' % (nc,)
   36:                 substats = '%s %s %s  %s' % (substats.rjust(7+2*len(indent)),
   36:                                              f8(tt), f8(ct), name)
   36:                 left_width = name_size + 1
                   else:
   42:                 substats = '%s(%r) %s' % (name, value, f8(self.stats[func][3]))
   42:                 left_width = name_size + 3
   78:             print >> self.stream, indent*left_width + substats
   78:             indent = " "
       
    1:     def print_title(self):
   10:         print >> self.stream, '   ncalls  tottime  percall  cumtime  percall',
   10:         print >> self.stream, 'filename:lineno(function)'
       
    1:     def print_line(self, func):  # hack : should print percentages
   64:         cc, nc, tt, ct, callers = self.stats[func]
   64:         c = str(nc)
   64:         if nc != cc:
    2:             c = c + '/' + str(cc)
   64:         print >> self.stream, c.rjust(9),
   64:         print >> self.stream, f8(tt),
   64:         if nc == 0:
    5:             print >> self.stream, ' '*8,
               else:
   59:             print >> self.stream, f8(float(tt)/nc),
   64:         print >> self.stream, f8(ct),
   64:         if cc == 0:
    5:             print >> self.stream, ' '*8,
               else:
   59:             print >> self.stream, f8(float(ct)/cc),
   64:         print >> self.stream, func_std_string(func)
       
    2: class TupleComp:
           """This class provides a generic function for comparing any two tuples.
           Each instance records a list of tuple-indices (from most significant
           to least significant), and sort direction (ascending or decending) for
           each tuple-index.  The compare functions can then be used as the function
           argument to the system sort() function when a list of tuples need to be
    1:     sorted in the instances order."""
       
    1:     def __init__(self, comp_select_list):
    6:         self.comp_select_list = comp_select_list
       
    1:     def compare (self, left, right):
  270:         for index, direction in self.comp_select_list:
  270:             l = left[index]
  270:             r = right[index]
  270:             if l < r:
  138:                 return -direction
  132:             if l > r:
  132:                 return direction
>>>>>>         return 0
       
       #**************************************************************************
       # func_name is a triple (file:string, line:int, name:string)
       
    1: def func_strip_path(func_name):
  213:     filename, line, name = func_name
  213:     return os.path.basename(filename), line, name
       
    1: def func_get_function_name(func):
>>>>>>     return func[2]
       
    1: def func_std_string(func_name): # match what old profile produced
  578:     if func_name[:2] == ('~', 0):
               # special case for built-in functions
   92:         name = func_name[2]
   92:         if name.startswith('<') and name.endswith('>'):
   92:             return '{%s}' % name[1:-1]
               else:
>>>>>>             return name
           else:
  486:         return "%s:%d(%s)" % func_name
       
       #**************************************************************************
       # The following functions combine statists for pairs functions.
       # The bulk of the processing involves correctly handling "call" lists,
       # such as callers and callees.
       #**************************************************************************
       
    1: def add_func_stats(target, source):
           """Add together all the stats for two profile entries."""
>>>>>>     cc, nc, tt, ct, callers = source
>>>>>>     t_cc, t_nc, t_tt, t_ct, t_callers = target
>>>>>>     return (cc+t_cc, nc+t_nc, tt+t_tt, ct+t_ct,
>>>>>>               add_callers(t_callers, callers))
       
    1: def add_callers(target, source):
           """Combine two caller lists in a single list."""
    2:     new_callers = {}
    4:     for func, caller in target.iteritems():
    2:         new_callers[func] = caller
    6:     for func, caller in source.iteritems():
    4:         if func in new_callers:
    2:             if isinstance(caller, tuple):
                       # format used by cProfile
    1:                 new_callers[func] = tuple([i[0] + i[1] for i in
    5:                                            zip(caller, new_callers[func])])
                   else:
                       # format used by profile
    1:                 new_callers[func] += caller
               else:
    2:             new_callers[func] = caller
    2:     return new_callers
       
    1: def count_calls(callers):
           """Sum the caller statistics to get total number of calls received."""
>>>>>>     nc = 0
>>>>>>     for calls in callers.itervalues():
>>>>>>         nc += calls
>>>>>>     return nc
       
       #**************************************************************************
       # The following functions support printing of reports
       #**************************************************************************
       
    1: def f8(x):
  360:     return "%8.3f" % x
       
       #**************************************************************************
       # Statistics browser added by ESR, April 2001
       #**************************************************************************
       
    1: if __name__ == '__main__':
>>>>>>     import cmd
>>>>>>     try:
>>>>>>         import readline
>>>>>>     except ImportError:
>>>>>>         pass
       
>>>>>>     class ProfileBrowser(cmd.Cmd):
>>>>>>         def __init__(self, profile=None):
>>>>>>             cmd.Cmd.__init__(self)
>>>>>>             self.prompt = "% "
>>>>>>             self.stats = None
>>>>>>             self.stream = sys.stdout
>>>>>>             if profile is not None:
>>>>>>                 self.do_read(profile)
       
>>>>>>         def generic(self, fn, line):
>>>>>>             args = line.split()
>>>>>>             processed = []
>>>>>>             for term in args:
>>>>>>                 try:
>>>>>>                     processed.append(int(term))
>>>>>>                     continue
>>>>>>                 except ValueError:
>>>>>>                     pass
>>>>>>                 try:
>>>>>>                     frac = float(term)
>>>>>>                     if frac > 1 or frac < 0:
>>>>>>                         print >> self.stream, "Fraction argument must be in [0, 1]"
>>>>>>                         continue
>>>>>>                     processed.append(frac)
>>>>>>                     continue
>>>>>>                 except ValueError:
>>>>>>                     pass
>>>>>>                 processed.append(term)
>>>>>>             if self.stats:
>>>>>>                 getattr(self.stats, fn)(*processed)
                   else:
>>>>>>                 print >> self.stream, "No statistics object is loaded."
>>>>>>             return 0
>>>>>>         def generic_help(self):
>>>>>>             print >> self.stream, "Arguments may be:"
>>>>>>             print >> self.stream, "* An integer maximum number of entries to print."
>>>>>>             print >> self.stream, "* A decimal fractional number between 0 and 1, controlling"
>>>>>>             print >> self.stream, "  what fraction of selected entries to print."
>>>>>>             print >> self.stream, "* A regular expression; only entries with function names"
>>>>>>             print >> self.stream, "  that match it are printed."
       
>>>>>>         def do_add(self, line):
>>>>>>             if self.stats:
>>>>>>                 self.stats.add(line)
                   else:
>>>>>>                 print >> self.stream, "No statistics object is loaded."
>>>>>>             return 0
>>>>>>         def help_add(self):
>>>>>>             print >> self.stream, "Add profile info from given file to current statistics object."
       
>>>>>>         def do_callees(self, line):
>>>>>>             return self.generic('print_callees', line)
>>>>>>         def help_callees(self):
>>>>>>             print >> self.stream, "Print callees statistics from the current stat object."
>>>>>>             self.generic_help()
       
>>>>>>         def do_callers(self, line):
>>>>>>             return self.generic('print_callers', line)
>>>>>>         def help_callers(self):
>>>>>>             print >> self.stream, "Print callers statistics from the current stat object."
>>>>>>             self.generic_help()
       
>>>>>>         def do_EOF(self, line):
>>>>>>             print >> self.stream, ""
>>>>>>             return 1
>>>>>>         def help_EOF(self):
>>>>>>             print >> self.stream, "Leave the profile brower."
       
>>>>>>         def do_quit(self, line):
>>>>>>             return 1
>>>>>>         def help_quit(self):
>>>>>>             print >> self.stream, "Leave the profile brower."
       
>>>>>>         def do_read(self, line):
>>>>>>             if line:
>>>>>>                 try:
>>>>>>                     self.stats = Stats(line)
>>>>>>                 except IOError, args:
>>>>>>                     print >> self.stream, args[1]
>>>>>>                     return
>>>>>>                 except Exception as err:
>>>>>>                     print >> self.stream, err.__class__.__name__ + ':', err
>>>>>>                     return
>>>>>>                 self.prompt = line + "% "
>>>>>>             elif len(self.prompt) > 2:
>>>>>>                 line = self.prompt[:-2]
>>>>>>                 self.do_read(line)
                   else:
>>>>>>                 print >> self.stream, "No statistics object is current -- cannot reload."
>>>>>>             return 0
>>>>>>         def help_read(self):
>>>>>>             print >> self.stream, "Read in profile data from a specified file."
>>>>>>             print >> self.stream, "Without argument, reload the current file."
       
>>>>>>         def do_reverse(self, line):
>>>>>>             if self.stats:
>>>>>>                 self.stats.reverse_order()
                   else:
>>>>>>                 print >> self.stream, "No statistics object is loaded."
>>>>>>             return 0
>>>>>>         def help_reverse(self):
>>>>>>             print >> self.stream, "Reverse the sort order of the profiling report."
       
>>>>>>         def do_sort(self, line):
>>>>>>             if not self.stats:
>>>>>>                 print >> self.stream, "No statistics object is loaded."
>>>>>>                 return
>>>>>>             abbrevs = self.stats.get_sort_arg_defs()
>>>>>>             if line and all((x in abbrevs) for x in line.split()):
>>>>>>                 self.stats.sort_stats(*line.split())
                   else:
>>>>>>                 print >> self.stream, "Valid sort keys (unique prefixes are accepted):"
>>>>>>                 for (key, value) in Stats.sort_arg_dict_default.iteritems():
>>>>>>                     print >> self.stream, "%s -- %s" % (key, value[1])
>>>>>>             return 0
>>>>>>         def help_sort(self):
>>>>>>             print >> self.stream, "Sort profile data according to specified keys."
>>>>>>             print >> self.stream, "(Typing `sort' without arguments lists valid keys.)"
>>>>>>         def complete_sort(self, text, *args):
>>>>>>             return [a for a in Stats.sort_arg_dict_default if a.startswith(text)]
       
>>>>>>         def do_stats(self, line):
>>>>>>             return self.generic('print_stats', line)
>>>>>>         def help_stats(self):
>>>>>>             print >> self.stream, "Print statistics from the current stat object."
>>>>>>             self.generic_help()
       
>>>>>>         def do_strip(self, line):
>>>>>>             if self.stats:
>>>>>>                 self.stats.strip_dirs()
                   else:
>>>>>>                 print >> self.stream, "No statistics object is loaded."
>>>>>>         def help_strip(self):
>>>>>>             print >> self.stream, "Strip leading path information from filenames in the report."
       
>>>>>>         def help_help(self):
>>>>>>             print >> self.stream, "Show help for a given command."
       
>>>>>>         def postcmd(self, stop, line):
>>>>>>             if stop:
>>>>>>                 return stop
>>>>>>             return None
       
>>>>>>     import sys
>>>>>>     if len(sys.argv) > 1:
>>>>>>         initprofile = sys.argv[1]
           else:
>>>>>>         initprofile = None
>>>>>>     try:
>>>>>>         browser = ProfileBrowser(initprofile)
>>>>>>         print >> browser.stream, "Welcome to the profile statistics browser."
>>>>>>         browser.cmdloop()
>>>>>>         print >> browser.stream, "Goodbye."
>>>>>>     except KeyboardInterrupt:
>>>>>>         pass
       
       # That's all, folks.
