    2: from test import test_support
    2: import unittest
    2: import codecs
    2: import locale
    2: import sys, StringIO
       
    2: def coding_checker(self, coder):
    5:     def check(input, expect):
 1189:         self.assertEqual(coder(input), (expect, len(input)))
    5:     return check
       
    4: class Queue(object):
           """
           queue: write bytes at one end, read bytes from the other end
    2:     """
    2:     def __init__(self):
  214:         self._buffer = ""
       
    2:     def write(self, chars):
 1402:         self._buffer += chars
       
    2:     def read(self, size=-1):
 2189:         if size<0:
 1955:             s = self._buffer
 1955:             self._buffer = ""
 1955:             return s
               else:
  234:             s = self._buffer[:size]
  234:             self._buffer = self._buffer[size:]
  234:             return s
       
    4: class ReadTest(unittest.TestCase):
    2:     def check_partial(self, input, partialresults):
               # get a StreamReader for the encoding and feed the bytestring version
               # of input to the reader byte by byte. Read everything available from
               # the StreamReader and check that the results equal the appropriate
               # entries from partialresults.
    9:         q = Queue()
    9:         r = codecs.getreader(self.encoding)(q)
    9:         result = u""
  152:         for (c, partialresult) in zip(input.encode(self.encoding), partialresults):
  143:             q.write(c)
  143:             result += r.read()
  143:             self.assertEqual(result, partialresult)
               # check that there's nothing left in the buffers
    9:         self.assertEqual(r.read(), u"")
    9:         self.assertEqual(r.bytebuffer, "")
    9:         self.assertEqual(r.charbuffer, u"")
       
               # do the check again, this time using an incremental decoder
    9:         d = codecs.getincrementaldecoder(self.encoding)()
    9:         result = u""
  152:         for (c, partialresult) in zip(input.encode(self.encoding), partialresults):
  143:             result += d.decode(c)
  143:             self.assertEqual(result, partialresult)
               # check that there's nothing left in the buffers
    9:         self.assertEqual(d.decode("", True), u"")
    9:         self.assertEqual(d.buffer, "")
       
               # Check whether the reset method works properly
    9:         d.reset()
    9:         result = u""
  152:         for (c, partialresult) in zip(input.encode(self.encoding), partialresults):
  143:             result += d.decode(c)
  143:             self.assertEqual(result, partialresult)
               # check that there's nothing left in the buffers
    9:         self.assertEqual(d.decode("", True), u"")
    9:         self.assertEqual(d.buffer, "")
       
               # check iterdecode()
    9:         encoded = input.encode(self.encoding)
    9:         self.assertEqual(
    9:             input,
    9:             u"".join(codecs.iterdecode(encoded, self.encoding))
               )
       
    2:     def test_readline(self):
    9:         def getreader(input):
 5814:             stream = StringIO.StringIO(input.encode(self.encoding))
 5814:             return codecs.getreader(self.encoding)(stream)
       
    9:         def readalllines(input, keepends=True, size=None):
   54:             reader = getreader(input)
   54:             lines = []
  306:             while True:
  306:                 line = reader.readline(size=size, keepends=keepends)
  306:                 if not line:
   54:                     break
  252:                 lines.append(line)
   54:             return "|".join(lines)
       
    9:         s = u"foo\nbar\r\nbaz\rspam\u2028eggs"
    9:         sexpected = u"foo\n|bar\r\n|baz\r|spam\u2028|eggs"
    9:         sexpectednoends = u"foo|bar|baz|spam|eggs"
    9:         self.assertEqual(readalllines(s, True), sexpected)
    9:         self.assertEqual(readalllines(s, False), sexpectednoends)
    9:         self.assertEqual(readalllines(s, True, 10), sexpected)
    9:         self.assertEqual(readalllines(s, False, 10), sexpectednoends)
       
    9:         lineends = ("\n", "\r\n", "\r", u"\u2028")
               # Test long lines (multiple calls to read() in readline())
    9:         vw = []
    9:         vwo = []
   45:         for (i, lineend) in enumerate(lineends):
   36:             vw.append((i*200+200)*u"\u3042" + lineend)
   36:             vwo.append((i*200+200)*u"\u3042")
    9:         self.assertEqual(readalllines("".join(vw), True), "|".join(vw))
    9:         self.assertEqual(readalllines("".join(vw), False), "|".join(vwo))
       
               # Test lines where the first read might end with \r, so the
               # reader has to look ahead whether this is a lone \r or a \r\n
  729:         for size in xrange(80):
 3600:             for lineend in lineends:
 2880:                 s = 10*(size*u"a" + lineend + u"xxx\n")
 2880:                 reader = getreader(s)
31680:                 for i in xrange(10):
28800:                     self.assertEqual(
28800:                         reader.readline(keepends=True),
28800:                         size*u"a" + lineend,
                           )
28800:                     self.assertEqual(
28800:                         reader.readline(keepends=True),
28800:                         "xxx\n",
                           )
 2880:                 reader = getreader(s)
31680:                 for i in xrange(10):
28800:                     self.assertEqual(
28800:                         reader.readline(keepends=False),
28800:                         size*u"a",
                           )
28800:                     self.assertEqual(
28800:                         reader.readline(keepends=False),
28800:                         "xxx",
                           )
       
    2:     def test_mixed_readline_and_read(self):
    9:         lines = ["Humpty Dumpty sat on a wall,\n",
    9:                  "Humpty Dumpty had a great fall.\r\n",
    9:                  "All the king's horses and all the king's men\r",
    9:                  "Couldn't put Humpty together again."]
    9:         data = ''.join(lines)
    9:         def getreader():
   36:             stream = StringIO.StringIO(data.encode(self.encoding))
   36:             return codecs.getreader(self.encoding)(stream)
       
               # Issue #8260: Test readline() followed by read()
    9:         f = getreader()
    9:         self.assertEqual(f.readline(), lines[0])
    9:         self.assertEqual(f.read(), ''.join(lines[1:]))
    9:         self.assertEqual(f.read(), '')
       
               # Issue #16636: Test readline() followed by readlines()
    9:         f = getreader()
    9:         self.assertEqual(f.readline(), lines[0])
    9:         self.assertEqual(f.readlines(), lines[1:])
    9:         self.assertEqual(f.read(), '')
       
               # Test read() followed by read()
    9:         f = getreader()
    9:         self.assertEqual(f.read(size=40, chars=5), data[:5])
    9:         self.assertEqual(f.read(), data[5:])
    9:         self.assertEqual(f.read(), '')
       
               # Issue #12446: Test read() followed by readlines()
    9:         f = getreader()
    9:         self.assertEqual(f.read(size=40, chars=5), data[:5])
    9:         self.assertEqual(f.readlines(), [lines[0][5:]] + lines[1:])
    9:         self.assertEqual(f.read(), '')
       
    2:     def test_bug1175396(self):
               s = [
    9:             '<%!--===================================================\r\n',
    9:             '    BLOG index page: show recent articles,\r\n',
    9:             '    today\'s articles, or articles of a specific date.\r\n',
    9:             '========================================================--%>\r\n',
    9:             '<%@inputencoding="ISO-8859-1"%>\r\n',
    9:             '<%@pagetemplate=TEMPLATE.y%>\r\n',
    9:             '<%@import=import frog.util, frog%>\r\n',
    9:             '<%@import=import frog.objects%>\r\n',
    9:             '<%@import=from frog.storageerrors import StorageError%>\r\n',
    9:             '<%\r\n',
    9:             '\r\n',
    9:             'import logging\r\n',
    9:             'log=logging.getLogger("Snakelets.logger")\r\n',
    9:             '\r\n',
    9:             '\r\n',
    9:             'user=self.SessionCtx.user\r\n',
    9:             'storageEngine=self.SessionCtx.storageEngine\r\n',
    9:             '\r\n',
    9:             '\r\n',
    9:             'def readArticlesFromDate(date, count=None):\r\n',
    9:             '    entryids=storageEngine.listBlogEntries(date)\r\n',
    9:             '    entryids.reverse() # descending\r\n',
    9:             '    if count:\r\n',
    9:             '        entryids=entryids[:count]\r\n',
    9:             '    try:\r\n',
    9:             '        return [ frog.objects.BlogEntry.load(storageEngine, date, Id) for Id in entryids ]\r\n',
    9:             '    except StorageError,x:\r\n',
    9:             '        log.error("Error loading articles: "+str(x))\r\n',
    9:             '        self.abort("cannot load articles")\r\n',
    9:             '\r\n',
    9:             'showdate=None\r\n',
    9:             '\r\n',
    9:             'arg=self.Request.getArg()\r\n',
    9:             'if arg=="today":\r\n',
    9:             '    #-------------------- TODAY\'S ARTICLES\r\n',
    9:             '    self.write("<h2>Today\'s articles</h2>")\r\n',
    9:             '    showdate = frog.util.isodatestr() \r\n',
    9:             '    entries = readArticlesFromDate(showdate)\r\n',
    9:             'elif arg=="active":\r\n',
    9:             '    #-------------------- ACTIVE ARTICLES redirect\r\n',
    9:             '    self.Yredirect("active.y")\r\n',
    9:             'elif arg=="login":\r\n',
    9:             '    #-------------------- LOGIN PAGE redirect\r\n',
    9:             '    self.Yredirect("login.y")\r\n',
    9:             'elif arg=="date":\r\n',
    9:             '    #-------------------- ARTICLES OF A SPECIFIC DATE\r\n',
    9:             '    showdate = self.Request.getParameter("date")\r\n',
    9:             '    self.write("<h2>Articles written on %s</h2>"% frog.util.mediumdatestr(showdate))\r\n',
    9:             '    entries = readArticlesFromDate(showdate)\r\n',
    9:             'else:\r\n',
    9:             '    #-------------------- RECENT ARTICLES\r\n',
    9:             '    self.write("<h2>Recent articles</h2>")\r\n',
    9:             '    dates=storageEngine.listBlogEntryDates()\r\n',
    9:             '    if dates:\r\n',
    9:             '        entries=[]\r\n',
    9:             '        SHOWAMOUNT=10\r\n',
    9:             '        for showdate in dates:\r\n',
    9:             '            entries.extend( readArticlesFromDate(showdate, SHOWAMOUNT-len(entries)) )\r\n',
    9:             '            if len(entries)>=SHOWAMOUNT:\r\n',
    9:             '                break\r\n',
    9:             '                \r\n',
               ]
    9:         stream = StringIO.StringIO("".join(s).encode(self.encoding))
    9:         reader = codecs.getreader(self.encoding)(stream)
  558:         for (i, line) in enumerate(reader):
  549:             self.assertEqual(line, s[i])
       
    2:     def test_readlinequeue(self):
    9:         q = Queue()
    9:         writer = codecs.getwriter(self.encoding)(q)
    9:         reader = codecs.getreader(self.encoding)(q)
       
               # No lineends
    9:         writer.write(u"foo\r")
    9:         self.assertEqual(reader.readline(keepends=False), u"foo")
    9:         writer.write(u"\nbar\r")
    9:         self.assertEqual(reader.readline(keepends=False), u"")
    9:         self.assertEqual(reader.readline(keepends=False), u"bar")
    9:         writer.write(u"baz")
    9:         self.assertEqual(reader.readline(keepends=False), u"baz")
    9:         self.assertEqual(reader.readline(keepends=False), u"")
       
               # Lineends
    9:         writer.write(u"foo\r")
    9:         self.assertEqual(reader.readline(keepends=True), u"foo\r")
    9:         writer.write(u"\nbar\r")
    9:         self.assertEqual(reader.readline(keepends=True), u"\n")
    9:         self.assertEqual(reader.readline(keepends=True), u"bar\r")
    9:         writer.write(u"baz")
    9:         self.assertEqual(reader.readline(keepends=True), u"baz")
    9:         self.assertEqual(reader.readline(keepends=True), u"")
    9:         writer.write(u"foo\r\n")
    9:         self.assertEqual(reader.readline(keepends=True), u"foo\r\n")
       
    2:     def test_bug1098990_a(self):
    9:         s1 = u"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\r\n"
    9:         s2 = u"offending line: ladfj askldfj klasdj fskla dfzaskdj fasklfj laskd fjasklfzzzzaa%whereisthis!!!\r\n"
    9:         s3 = u"next line.\r\n"
       
    9:         s = (s1+s2+s3).encode(self.encoding)
    9:         stream = StringIO.StringIO(s)
    9:         reader = codecs.getreader(self.encoding)(stream)
    9:         self.assertEqual(reader.readline(), s1)
    9:         self.assertEqual(reader.readline(), s2)
    9:         self.assertEqual(reader.readline(), s3)
    9:         self.assertEqual(reader.readline(), u"")
       
    2:     def test_bug1098990_b(self):
    9:         s1 = u"aaaaaaaaaaaaaaaaaaaaaaaa\r\n"
    9:         s2 = u"bbbbbbbbbbbbbbbbbbbbbbbb\r\n"
    9:         s3 = u"stillokay:bbbbxx\r\n"
    9:         s4 = u"broken!!!!badbad\r\n"
    9:         s5 = u"againokay.\r\n"
       
    9:         s = (s1+s2+s3+s4+s5).encode(self.encoding)
    9:         stream = StringIO.StringIO(s)
    9:         reader = codecs.getreader(self.encoding)(stream)
    9:         self.assertEqual(reader.readline(), s1)
    9:         self.assertEqual(reader.readline(), s2)
    9:         self.assertEqual(reader.readline(), s3)
    9:         self.assertEqual(reader.readline(), s4)
    9:         self.assertEqual(reader.readline(), s5)
    9:         self.assertEqual(reader.readline(), u"")
       
    4: class UTF32Test(ReadTest):
    2:     encoding = "utf-32"
       
    2:     spamle = ('\xff\xfe\x00\x00'
                     's\x00\x00\x00p\x00\x00\x00a\x00\x00\x00m\x00\x00\x00'
                     's\x00\x00\x00p\x00\x00\x00a\x00\x00\x00m\x00\x00\x00')
    2:     spambe = ('\x00\x00\xfe\xff'
                     '\x00\x00\x00s\x00\x00\x00p\x00\x00\x00a\x00\x00\x00m'
                     '\x00\x00\x00s\x00\x00\x00p\x00\x00\x00a\x00\x00\x00m')
       
    2:     def test_only_one_bom(self):
    1:         _,_,reader,writer = codecs.lookup(self.encoding)
               # encode some stream
    1:         s = StringIO.StringIO()
    1:         f = writer(s)
    1:         f.write(u"spam")
    1:         f.write(u"spam")
    1:         d = s.getvalue()
               # check whether there is exactly one BOM in it
    1:         self.assertTrue(d == self.spamle or d == self.spambe)
               # try to read it back
    1:         s = StringIO.StringIO(d)
    1:         f = reader(s)
    1:         self.assertEqual(f.read(), u"spamspam")
       
    2:     def test_badbom(self):
    1:         s = StringIO.StringIO(4*"\xff")
    1:         f = codecs.getreader(self.encoding)(s)
    1:         self.assertRaises(UnicodeError, f.read)
       
    1:         s = StringIO.StringIO(8*"\xff")
    1:         f = codecs.getreader(self.encoding)(s)
    1:         self.assertRaises(UnicodeError, f.read)
       
    2:     def test_partial(self):
    1:         self.check_partial(
    1:             u"\x00\xff\u0100\uffff\U00010000",
                   [
    1:                 u"", # first byte of BOM read
    1:                 u"", # second byte of BOM read
    1:                 u"", # third byte of BOM read
    1:                 u"", # fourth byte of BOM read => byteorder known
    1:                 u"",
    1:                 u"",
    1:                 u"",
    1:                 u"\x00",
    1:                 u"\x00",
    1:                 u"\x00",
    1:                 u"\x00",
    1:                 u"\x00\xff",
    1:                 u"\x00\xff",
    1:                 u"\x00\xff",
    1:                 u"\x00\xff",
    1:                 u"\x00\xff\u0100",
    1:                 u"\x00\xff\u0100",
    1:                 u"\x00\xff\u0100",
    1:                 u"\x00\xff\u0100",
    1:                 u"\x00\xff\u0100\uffff",
    1:                 u"\x00\xff\u0100\uffff",
    1:                 u"\x00\xff\u0100\uffff",
    1:                 u"\x00\xff\u0100\uffff",
    1:                 u"\x00\xff\u0100\uffff\U00010000",
                   ]
               )
       
    2:     def test_handlers(self):
    1:         self.assertEqual((u'\ufffd', 1),
    1:                          codecs.utf_32_decode('\x01', 'replace', True))
    1:         self.assertEqual((u'', 1),
    1:                          codecs.utf_32_decode('\x01', 'ignore', True))
       
    2:     def test_errors(self):
    1:         self.assertRaises(UnicodeDecodeError, codecs.utf_32_decode,
    1:                           "\xff", "strict", True)
       
    2:     def test_issue8941(self):
               # Issue #8941: insufficient result allocation when decoding into
               # surrogate pairs on UCS-2 builds.
    1:         encoded_le = '\xff\xfe\x00\x00' + '\x00\x00\x01\x00' * 1024
    1:         self.assertEqual(u'\U00010000' * 1024,
    1:                          codecs.utf_32_decode(encoded_le)[0])
    1:         encoded_be = '\x00\x00\xfe\xff' + '\x00\x01\x00\x00' * 1024
    1:         self.assertEqual(u'\U00010000' * 1024,
    1:                          codecs.utf_32_decode(encoded_be)[0])
       
    4: class UTF32LETest(ReadTest):
    2:     encoding = "utf-32-le"
       
    2:     def test_partial(self):
    1:         self.check_partial(
    1:             u"\x00\xff\u0100\uffff\U00010000",
                   [
    1:                 u"",
    1:                 u"",
    1:                 u"",
    1:                 u"\x00",
    1:                 u"\x00",
    1:                 u"\x00",
    1:                 u"\x00",
    1:                 u"\x00\xff",
    1:                 u"\x00\xff",
    1:                 u"\x00\xff",
    1:                 u"\x00\xff",
    1:                 u"\x00\xff\u0100",
    1:                 u"\x00\xff\u0100",
    1:                 u"\x00\xff\u0100",
    1:                 u"\x00\xff\u0100",
    1:                 u"\x00\xff\u0100\uffff",
    1:                 u"\x00\xff\u0100\uffff",
    1:                 u"\x00\xff\u0100\uffff",
    1:                 u"\x00\xff\u0100\uffff",
    1:                 u"\x00\xff\u0100\uffff\U00010000",
                   ]
               )
       
    2:     def test_simple(self):
    1:         self.assertEqual(u"\U00010203".encode(self.encoding), "\x03\x02\x01\x00")
       
    2:     def test_errors(self):
    1:         self.assertRaises(UnicodeDecodeError, codecs.utf_32_le_decode,
    1:                           "\xff", "strict", True)
       
    2:     def test_issue8941(self):
               # Issue #8941: insufficient result allocation when decoding into
               # surrogate pairs on UCS-2 builds.
    1:         encoded = '\x00\x00\x01\x00' * 1024
    1:         self.assertEqual(u'\U00010000' * 1024,
    1:                          codecs.utf_32_le_decode(encoded)[0])
       
    4: class UTF32BETest(ReadTest):
    2:     encoding = "utf-32-be"
       
    2:     def test_partial(self):
    1:         self.check_partial(
    1:             u"\x00\xff\u0100\uffff\U00010000",
                   [
    1:                 u"",
    1:                 u"",
    1:                 u"",
    1:                 u"\x00",
    1:                 u"\x00",
    1:                 u"\x00",
    1:                 u"\x00",
    1:                 u"\x00\xff",
    1:                 u"\x00\xff",
    1:                 u"\x00\xff",
    1:                 u"\x00\xff",
    1:                 u"\x00\xff\u0100",
    1:                 u"\x00\xff\u0100",
    1:                 u"\x00\xff\u0100",
    1:                 u"\x00\xff\u0100",
    1:                 u"\x00\xff\u0100\uffff",
    1:                 u"\x00\xff\u0100\uffff",
    1:                 u"\x00\xff\u0100\uffff",
    1:                 u"\x00\xff\u0100\uffff",
    1:                 u"\x00\xff\u0100\uffff\U00010000",
                   ]
               )
       
    2:     def test_simple(self):
    1:         self.assertEqual(u"\U00010203".encode(self.encoding), "\x00\x01\x02\x03")
       
    2:     def test_errors(self):
    1:         self.assertRaises(UnicodeDecodeError, codecs.utf_32_be_decode,
    1:                           "\xff", "strict", True)
       
    2:     def test_issue8941(self):
               # Issue #8941: insufficient result allocation when decoding into
               # surrogate pairs on UCS-2 builds.
    1:         encoded = '\x00\x01\x00\x00' * 1024
    1:         self.assertEqual(u'\U00010000' * 1024,
    1:                          codecs.utf_32_be_decode(encoded)[0])
       
       
    4: class UTF16Test(ReadTest):
    2:     encoding = "utf-16"
       
    2:     spamle = '\xff\xfes\x00p\x00a\x00m\x00s\x00p\x00a\x00m\x00'
    2:     spambe = '\xfe\xff\x00s\x00p\x00a\x00m\x00s\x00p\x00a\x00m'
       
    2:     def test_only_one_bom(self):
    1:         _,_,reader,writer = codecs.lookup(self.encoding)
               # encode some stream
    1:         s = StringIO.StringIO()
    1:         f = writer(s)
    1:         f.write(u"spam")
    1:         f.write(u"spam")
    1:         d = s.getvalue()
               # check whether there is exactly one BOM in it
    1:         self.assertTrue(d == self.spamle or d == self.spambe)
               # try to read it back
    1:         s = StringIO.StringIO(d)
    1:         f = reader(s)
    1:         self.assertEqual(f.read(), u"spamspam")
       
    2:     def test_badbom(self):
    1:         s = StringIO.StringIO("\xff\xff")
    1:         f = codecs.getreader(self.encoding)(s)
    1:         self.assertRaises(UnicodeError, f.read)
       
    1:         s = StringIO.StringIO("\xff\xff\xff\xff")
    1:         f = codecs.getreader(self.encoding)(s)
    1:         self.assertRaises(UnicodeError, f.read)
       
    2:     def test_partial(self):
    1:         self.check_partial(
    1:             u"\x00\xff\u0100\uffff\U00010000",
                   [
    1:                 u"", # first byte of BOM read
    1:                 u"", # second byte of BOM read => byteorder known
    1:                 u"",
    1:                 u"\x00",
    1:                 u"\x00",
    1:                 u"\x00\xff",
    1:                 u"\x00\xff",
    1:                 u"\x00\xff\u0100",
    1:                 u"\x00\xff\u0100",
    1:                 u"\x00\xff\u0100\uffff",
    1:                 u"\x00\xff\u0100\uffff",
    1:                 u"\x00\xff\u0100\uffff",
    1:                 u"\x00\xff\u0100\uffff",
    1:                 u"\x00\xff\u0100\uffff\U00010000",
                   ]
               )
       
    2:     def test_handlers(self):
    1:         self.assertEqual((u'\ufffd', 1),
    1:                          codecs.utf_16_decode('\x01', 'replace', True))
    1:         self.assertEqual((u'', 1),
    1:                          codecs.utf_16_decode('\x01', 'ignore', True))
       
    2:     def test_errors(self):
    1:         self.assertRaises(UnicodeDecodeError, codecs.utf_16_decode, "\xff", "strict", True)
       
    2:     def test_bug691291(self):
               # Files are always opened in binary mode, even if no binary mode was
               # specified.  This means that no automatic conversion of '\n' is done
               # on reading and writing.
    1:         s1 = u'Hello\r\nworld\r\n'
       
    1:         s = s1.encode(self.encoding)
    1:         self.addCleanup(test_support.unlink, test_support.TESTFN)
    1:         with open(test_support.TESTFN, 'wb') as fp:
    1:             fp.write(s)
    1:         with codecs.open(test_support.TESTFN, 'U', encoding=self.encoding) as reader:
    1:             self.assertEqual(reader.read(), s1)
       
    4: class UTF16LETest(ReadTest):
    2:     encoding = "utf-16-le"
       
    2:     def test_partial(self):
    1:         self.check_partial(
    1:             u"\x00\xff\u0100\uffff\U00010000",
                   [
    1:                 u"",
    1:                 u"\x00",
    1:                 u"\x00",
    1:                 u"\x00\xff",
    1:                 u"\x00\xff",
    1:                 u"\x00\xff\u0100",
    1:                 u"\x00\xff\u0100",
    1:                 u"\x00\xff\u0100\uffff",
    1:                 u"\x00\xff\u0100\uffff",
    1:                 u"\x00\xff\u0100\uffff",
    1:                 u"\x00\xff\u0100\uffff",
    1:                 u"\x00\xff\u0100\uffff\U00010000",
                   ]
               )
       
    2:     def test_errors(self):
               tests = [
    1:             (b'\xff', u'\ufffd'),
    1:             (b'A\x00Z', u'A\ufffd'),
    1:             (b'A\x00B\x00C\x00D\x00Z', u'ABCD\ufffd'),
    1:             (b'\x00\xd8', u'\ufffd'),
    1:             (b'\x00\xd8A', u'\ufffd'),
    1:             (b'\x00\xd8A\x00', u'\ufffdA'),
    1:             (b'\x00\xdcA\x00', u'\ufffdA'),
               ]
    8:         for raw, expected in tests:
    7:             try:
    7:                 with self.assertRaises(UnicodeDecodeError):
    7:                     codecs.utf_16_le_decode(raw, 'strict', True)
    7:                 self.assertEqual(raw.decode('utf-16le', 'replace'), expected)
>>>>>>             except:
>>>>>>                 print 'raw=%r' % raw
>>>>>>                 raise
       
    4: class UTF16BETest(ReadTest):
    2:     encoding = "utf-16-be"
       
    2:     def test_partial(self):
    1:         self.check_partial(
    1:             u"\x00\xff\u0100\uffff\U00010000",
                   [
    1:                 u"",
    1:                 u"\x00",
    1:                 u"\x00",
    1:                 u"\x00\xff",
    1:                 u"\x00\xff",
    1:                 u"\x00\xff\u0100",
    1:                 u"\x00\xff\u0100",
    1:                 u"\x00\xff\u0100\uffff",
    1:                 u"\x00\xff\u0100\uffff",
    1:                 u"\x00\xff\u0100\uffff",
    1:                 u"\x00\xff\u0100\uffff",
    1:                 u"\x00\xff\u0100\uffff\U00010000",
                   ]
               )
       
    2:     def test_errors(self):
               tests = [
    1:             (b'\xff', u'\ufffd'),
    1:             (b'\x00A\xff', u'A\ufffd'),
    1:             (b'\x00A\x00B\x00C\x00DZ', u'ABCD\ufffd'),
    1:             (b'\xd8\x00', u'\ufffd'),
    1:             (b'\xd8\x00\xdc', u'\ufffd'),
    1:             (b'\xd8\x00\x00A', u'\ufffdA'),
    1:             (b'\xdc\x00\x00A', u'\ufffdA'),
               ]
    8:         for raw, expected in tests:
    7:             try:
    7:                 with self.assertRaises(UnicodeDecodeError):
    7:                     codecs.utf_16_be_decode(raw, 'strict', True)
    7:                 self.assertEqual(raw.decode('utf-16be', 'replace'), expected)
>>>>>>             except:
>>>>>>                 print 'raw=%r' % raw
>>>>>>                 raise
       
    4: class UTF8Test(ReadTest):
    2:     encoding = "utf-8"
       
    2:     def test_partial(self):
    1:         self.check_partial(
    1:             u"\x00\xff\u07ff\u0800\uffff\U00010000",
                   [
    1:                 u"\x00",
    1:                 u"\x00",
    1:                 u"\x00\xff",
    1:                 u"\x00\xff",
    1:                 u"\x00\xff\u07ff",
    1:                 u"\x00\xff\u07ff",
    1:                 u"\x00\xff\u07ff",
    1:                 u"\x00\xff\u07ff\u0800",
    1:                 u"\x00\xff\u07ff\u0800",
    1:                 u"\x00\xff\u07ff\u0800",
    1:                 u"\x00\xff\u07ff\u0800\uffff",
    1:                 u"\x00\xff\u07ff\u0800\uffff",
    1:                 u"\x00\xff\u07ff\u0800\uffff",
    1:                 u"\x00\xff\u07ff\u0800\uffff",
    1:                 u"\x00\xff\u07ff\u0800\uffff\U00010000",
                   ]
               )
       
    4: class UTF7Test(ReadTest):
    2:     encoding = "utf-7"
       
    2:     def test_ascii(self):
               # Set D (directly encoded characters)
    1:         set_d = ('ABCDEFGHIJKLMNOPQRSTUVWXYZ'
                        'abcdefghijklmnopqrstuvwxyz'
                        '0123456789'
                        '\'(),-./:?')
    1:         self.assertEqual(set_d.encode(self.encoding), set_d)
    1:         self.assertEqual(set_d.decode(self.encoding), set_d)
               # Set O (optional direct characters)
    1:         set_o = ' !"#$%&*;<=>@[]^_`{|}'
    1:         self.assertEqual(set_o.encode(self.encoding), set_o)
    1:         self.assertEqual(set_o.decode(self.encoding), set_o)
               # +
    1:         self.assertEqual(u'a+b'.encode(self.encoding), 'a+-b')
    1:         self.assertEqual('a+-b'.decode(self.encoding), u'a+b')
               # White spaces
    1:         ws = ' \t\n\r'
    1:         self.assertEqual(ws.encode(self.encoding), ws)
    1:         self.assertEqual(ws.decode(self.encoding), ws)
               # Other ASCII characters
  130:         other_ascii = ''.join(sorted(set(chr(i) for i in range(0x80)) -
    1:                                      set(set_d + set_o + '+' + ws)))
    1:         self.assertEqual(other_ascii.encode(self.encoding),
    1:                          '+AAAAAQACAAMABAAFAAYABwAIAAsADAAOAA8AEAARABIAEwAU'
                                'ABUAFgAXABgAGQAaABsAHAAdAB4AHwBcAH4Afw-')
       
    2:     def test_partial(self):
    1:         self.check_partial(
    1:             u"a+-b",
                   [
    1:                 u"a",
    1:                 u"a",
    1:                 u"a+",
    1:                 u"a+-",
    1:                 u"a+-b",
                   ]
               )
       
    2:     def test_errors(self):
               tests = [
    1:             ('\xe1b', u'\ufffdb'),
    1:             ('a\xe1b', u'a\ufffdb'),
    1:             ('a\xe1\xe1b', u'a\ufffd\ufffdb'),
    1:             ('a+IK', u'a\ufffd'),
    1:             ('a+IK-b', u'a\ufffdb'),
    1:             ('a+IK,b', u'a\ufffdb'),
    1:             ('a+IKx', u'a\u20ac\ufffd'),
    1:             ('a+IKx-b', u'a\u20ac\ufffdb'),
    1:             ('a+IKwgr', u'a\u20ac\ufffd'),
    1:             ('a+IKwgr-b', u'a\u20ac\ufffdb'),
    1:             ('a+IKwgr,', u'a\u20ac\ufffd'),
    1:             ('a+IKwgr,-b', u'a\u20ac\ufffd-b'),
    1:             ('a+IKwgrB', u'a\u20ac\u20ac\ufffd'),
    1:             ('a+IKwgrB-b', u'a\u20ac\u20ac\ufffdb'),
    1:             ('a+/,+IKw-b', u'a\ufffd\u20acb'),
    1:             ('a+//,+IKw-b', u'a\ufffd\u20acb'),
    1:             ('a+///,+IKw-b', u'a\uffff\ufffd\u20acb'),
    1:             ('a+////,+IKw-b', u'a\uffff\ufffd\u20acb'),
    1:             ('a+IKw-b\xe1', u'a\u20acb\ufffd'),
    1:             ('a+IKw\xe1b', u'a\u20ac\ufffdb'),
               ]
   21:         for raw, expected in tests:
   20:             try:
   20:                 with self.assertRaises(UnicodeDecodeError):
   20:                     codecs.utf_7_decode(raw, 'strict', True)
   20:                 self.assertEqual(raw.decode('utf-7', 'replace'), expected)
>>>>>>             except:
>>>>>>                 print 'raw=%r' % raw
>>>>>>                 raise
       
    2:     def test_nonbmp(self):
    1:         self.assertEqual(u'\U000104A0'.encode(self.encoding), '+2AHcoA-')
    1:         self.assertEqual(u'\ud801\udca0'.encode(self.encoding), '+2AHcoA-')
    1:         self.assertEqual('+2AHcoA-'.decode(self.encoding), u'\U000104A0')
    1:         self.assertEqual('+2AHcoA'.decode(self.encoding), u'\U000104A0')
    1:         self.assertEqual(u'\u20ac\U000104A0'.encode(self.encoding), '+IKzYAdyg-')
    1:         self.assertEqual('+IKzYAdyg-'.decode(self.encoding), u'\u20ac\U000104A0')
    1:         self.assertEqual('+IKzYAdyg'.decode(self.encoding), u'\u20ac\U000104A0')
    1:         self.assertEqual(u'\u20ac\u20ac\U000104A0'.encode(self.encoding),
    1:                          '+IKwgrNgB3KA-')
    1:         self.assertEqual('+IKwgrNgB3KA-'.decode(self.encoding),
    1:                          u'\u20ac\u20ac\U000104A0')
    1:         self.assertEqual('+IKwgrNgB3KA'.decode(self.encoding),
    1:                          u'\u20ac\u20ac\U000104A0')
       
    2:     def test_lone_surrogates(self):
               tests = [
    1:             ('a+2AE-b', u'a\ud801b'),
    1:             ('a+2AE\xe1b', u'a\ufffdb'),
    1:             ('a+2AE', u'a\ufffd'),
    1:             ('a+2AEA-b', u'a\ufffdb'),
    1:             ('a+2AH-b', u'a\ufffdb'),
    1:             ('a+IKzYAQ-b', u'a\u20ac\ud801b'),
    1:             ('a+IKzYAQ\xe1b', u'a\u20ac\ufffdb'),
    1:             ('a+IKzYAQA-b', u'a\u20ac\ufffdb'),
    1:             ('a+IKzYAd-b', u'a\u20ac\ufffdb'),
    1:             ('a+IKwgrNgB-b', u'a\u20ac\u20ac\ud801b'),
    1:             ('a+IKwgrNgB\xe1b', u'a\u20ac\u20ac\ufffdb'),
    1:             ('a+IKwgrNgB', u'a\u20ac\u20ac\ufffd'),
    1:             ('a+IKwgrNgBA-b', u'a\u20ac\u20ac\ufffdb'),
               ]
   14:         for raw, expected in tests:
   13:             try:
   13:                 self.assertEqual(raw.decode('utf-7', 'replace'), expected)
>>>>>>             except:
>>>>>>                 print 'raw=%r' % raw
>>>>>>                 raise
       
    4: class UTF16ExTest(unittest.TestCase):
       
    2:     def test_errors(self):
    1:         self.assertRaises(UnicodeDecodeError, codecs.utf_16_ex_decode, "\xff", "strict", 0, True)
       
    2:     def test_bad_args(self):
    1:         self.assertRaises(TypeError, codecs.utf_16_ex_decode)
       
    4: class ReadBufferTest(unittest.TestCase):
       
    2:     def test_array(self):
    1:         import array
    1:         self.assertEqual(
    1:             codecs.readbuffer_encode(array.array("c", "spam")),
    1:             ("spam", 4)
               )
       
    2:     def test_empty(self):
    1:         self.assertEqual(codecs.readbuffer_encode(""), ("", 0))
       
    2:     def test_bad_args(self):
    1:         self.assertRaises(TypeError, codecs.readbuffer_encode)
    1:         self.assertRaises(TypeError, codecs.readbuffer_encode, 42)
       
    4: class CharBufferTest(unittest.TestCase):
       
    2:     def test_string(self):
    1:         self.assertEqual(codecs.charbuffer_encode("spam"), ("spam", 4))
       
    2:     def test_empty(self):
    1:         self.assertEqual(codecs.charbuffer_encode(""), ("", 0))
       
    2:     def test_bad_args(self):
    1:         self.assertRaises(TypeError, codecs.charbuffer_encode)
    1:         self.assertRaises(TypeError, codecs.charbuffer_encode, 42)
       
    4: class UTF8SigTest(ReadTest):
    2:     encoding = "utf-8-sig"
       
    2:     def test_partial(self):
    1:         self.check_partial(
    1:             u"\ufeff\x00\xff\u07ff\u0800\uffff\U00010000",
                   [
    1:                 u"",
    1:                 u"",
    1:                 u"", # First BOM has been read and skipped
    1:                 u"",
    1:                 u"",
    1:                 u"\ufeff", # Second BOM has been read and emitted
    1:                 u"\ufeff\x00", # "\x00" read and emitted
    1:                 u"\ufeff\x00", # First byte of encoded u"\xff" read
    1:                 u"\ufeff\x00\xff", # Second byte of encoded u"\xff" read
    1:                 u"\ufeff\x00\xff", # First byte of encoded u"\u07ff" read
    1:                 u"\ufeff\x00\xff\u07ff", # Second byte of encoded u"\u07ff" read
    1:                 u"\ufeff\x00\xff\u07ff",
    1:                 u"\ufeff\x00\xff\u07ff",
    1:                 u"\ufeff\x00\xff\u07ff\u0800",
    1:                 u"\ufeff\x00\xff\u07ff\u0800",
    1:                 u"\ufeff\x00\xff\u07ff\u0800",
    1:                 u"\ufeff\x00\xff\u07ff\u0800\uffff",
    1:                 u"\ufeff\x00\xff\u07ff\u0800\uffff",
    1:                 u"\ufeff\x00\xff\u07ff\u0800\uffff",
    1:                 u"\ufeff\x00\xff\u07ff\u0800\uffff",
    1:                 u"\ufeff\x00\xff\u07ff\u0800\uffff\U00010000",
                   ]
               )
       
    2:     def test_bug1601501(self):
               # SF bug #1601501: check that the codec works with a buffer
    1:         unicode("\xef\xbb\xbf", "utf-8-sig")
       
    2:     def test_bom(self):
    1:         d = codecs.getincrementaldecoder("utf-8-sig")()
    1:         s = u"spam"
    1:         self.assertEqual(d.decode(s.encode("utf-8-sig")), s)
       
    2:     def test_stream_bom(self):
    1:         unistring = u"ABC\u00A1\u2200XYZ"
    1:         bytestring = codecs.BOM_UTF8 + "ABC\xC2\xA1\xE2\x88\x80XYZ"
       
    1:         reader = codecs.getreader("utf-8-sig")
    1:         for sizehint in [None] + range(1, 11) + \
   17:                         [64, 128, 256, 512, 1024]:
   16:             istream = reader(StringIO.StringIO(bytestring))
   16:             ostream = StringIO.StringIO()
   16:             while 1:
   45:                 if sizehint is not None:
   43:                     data = istream.read(sizehint)
                       else:
    2:                     data = istream.read()
       
   45:                 if not data:
   16:                     break
   29:                 ostream.write(data)
       
   16:             got = ostream.getvalue()
   16:             self.assertEqual(got, unistring)
       
    2:     def test_stream_bare(self):
    1:         unistring = u"ABC\u00A1\u2200XYZ"
    1:         bytestring = "ABC\xC2\xA1\xE2\x88\x80XYZ"
       
    1:         reader = codecs.getreader("utf-8-sig")
    1:         for sizehint in [None] + range(1, 11) + \
   17:                         [64, 128, 256, 512, 1024]:
   16:             istream = reader(StringIO.StringIO(bytestring))
   16:             ostream = StringIO.StringIO()
   16:             while 1:
   46:                 if sizehint is not None:
   44:                     data = istream.read(sizehint)
                       else:
    2:                     data = istream.read()
       
   46:                 if not data:
   16:                     break
   30:                 ostream.write(data)
       
   16:             got = ostream.getvalue()
   16:             self.assertEqual(got, unistring)
       
    4: class EscapeDecodeTest(unittest.TestCase):
    2:     def test_empty(self):
    1:         self.assertEqual(codecs.escape_decode(""), ("", 0))
       
    2:     def test_raw(self):
    1:         decode = codecs.escape_decode
  257:         for b in range(256):
  256:             b = chr(b)
  256:             if b != '\\':
  255:                 self.assertEqual(decode(b + '0'), (b + '0', 2))
       
    2:     def test_escape(self):
    1:         decode = codecs.escape_decode
    1:         check = coding_checker(self, decode)
    1:         check(b"[\\\n]", b"[]")
    1:         check(br'[\"]', b'["]')
    1:         check(br"[\']", b"[']")
    1:         check(br"[\\]", br"[\]")
    1:         check(br"[\a]", b"[\x07]")
    1:         check(br"[\b]", b"[\x08]")
    1:         check(br"[\t]", b"[\x09]")
    1:         check(br"[\n]", b"[\x0a]")
    1:         check(br"[\v]", b"[\x0b]")
    1:         check(br"[\f]", b"[\x0c]")
    1:         check(br"[\r]", b"[\x0d]")
    1:         check(br"[\7]", b"[\x07]")
    1:         check(br"[\8]", br"[\8]")
    1:         check(br"[\78]", b"[\x078]")
    1:         check(br"[\41]", b"[!]")
    1:         check(br"[\418]", b"[!8]")
    1:         check(br"[\101]", b"[A]")
    1:         check(br"[\1010]", b"[A0]")
    1:         check(br"[\501]", b"[A]")
    1:         check(br"[\x41]", b"[A]")
    1:         check(br"[\X41]", br"[\X41]")
    1:         check(br"[\x410]", b"[A0]")
  257:         for b in range(256):
  256:             b = chr(b)
  256:             if b not in '\n"\'\\abtnvfr01234567x':
  236:                 check('\\' + b, '\\' + b)
       
    2:     def test_errors(self):
    1:         decode = codecs.escape_decode
    1:         self.assertRaises(ValueError, decode, br"\x")
    1:         self.assertRaises(ValueError, decode, br"[\x]")
    1:         self.assertEqual(decode(br"[\x]\x", "ignore"), (b"[]", 6))
    1:         self.assertEqual(decode(br"[\x]\x", "replace"), (b"[?]?", 6))
    1:         self.assertRaises(ValueError, decode, br"\x0")
    1:         self.assertRaises(ValueError, decode, br"[\x0]")
    1:         self.assertEqual(decode(br"[\x0]\x0", "ignore"), (b"[]", 8))
    1:         self.assertEqual(decode(br"[\x0]\x0", "replace"), (b"[?]?", 8))
       
    4: class RecodingTest(unittest.TestCase):
    2:     def test_recoding(self):
    1:         f = StringIO.StringIO()
    1:         f2 = codecs.EncodedFile(f, "unicode_internal", "utf-8")
    1:         f2.write(u"a")
    1:         f2.close()
               # Python used to crash on this at exit because of a refcount
               # bug in _codecsmodule.c
       
       # From RFC 3492
       punycode_testcases = [
           # A Arabic (Egyptian):
    2:     (u"\u0644\u064A\u0647\u0645\u0627\u0628\u062A\u0643\u0644"
            u"\u0645\u0648\u0634\u0639\u0631\u0628\u064A\u061F",
    2:      "egbpdaj6bu4bxfgehfvwxn"),
           # B Chinese (simplified):
    2:     (u"\u4ED6\u4EEC\u4E3A\u4EC0\u4E48\u4E0D\u8BF4\u4E2D\u6587",
    2:      "ihqwcrb4cv8a8dqg056pqjye"),
           # C Chinese (traditional):
    2:     (u"\u4ED6\u5011\u7232\u4EC0\u9EBD\u4E0D\u8AAA\u4E2D\u6587",
    2:      "ihqwctvzc91f659drss3x8bo0yb"),
           # D Czech: Pro<ccaron>prost<ecaron>nemluv<iacute><ccaron>esky
    2:     (u"\u0050\u0072\u006F\u010D\u0070\u0072\u006F\u0073\u0074"
            u"\u011B\u006E\u0065\u006D\u006C\u0075\u0076\u00ED\u010D"
            u"\u0065\u0073\u006B\u0079",
    2:      "Proprostnemluvesky-uyb24dma41a"),
           # E Hebrew:
    2:     (u"\u05DC\u05DE\u05D4\u05D4\u05DD\u05E4\u05E9\u05D5\u05D8"
            u"\u05DC\u05D0\u05DE\u05D3\u05D1\u05E8\u05D9\u05DD\u05E2"
            u"\u05D1\u05E8\u05D9\u05EA",
    2:      "4dbcagdahymbxekheh6e0a7fei0b"),
           # F Hindi (Devanagari):
    2:     (u"\u092F\u0939\u0932\u094B\u0917\u0939\u093F\u0928\u094D"
           u"\u0926\u0940\u0915\u094D\u092F\u094B\u0902\u0928\u0939"
           u"\u0940\u0902\u092C\u094B\u0932\u0938\u0915\u0924\u0947"
           u"\u0939\u0948\u0902",
    2:     "i1baa7eci9glrd9b2ae1bj0hfcgg6iyaf8o0a1dig0cd"),
       
           #(G) Japanese (kanji and hiragana):
    2:     (u"\u306A\u305C\u307F\u3093\u306A\u65E5\u672C\u8A9E\u3092"
           u"\u8A71\u3057\u3066\u304F\u308C\u306A\u3044\u306E\u304B",
    2:      "n8jok5ay5dzabd5bym9f0cm5685rrjetr6pdxa"),
       
           # (H) Korean (Hangul syllables):
    2:     (u"\uC138\uACC4\uC758\uBAA8\uB4E0\uC0AC\uB78C\uB4E4\uC774"
            u"\uD55C\uAD6D\uC5B4\uB97C\uC774\uD574\uD55C\uB2E4\uBA74"
            u"\uC5BC\uB9C8\uB098\uC88B\uC744\uAE4C",
    2:      "989aomsvi5e83db1d2a355cv1e0vak1dwrv93d5xbh15a0dt30a5j"
            "psd879ccm6fea98c"),
       
           # (I) Russian (Cyrillic):
    2:     (u"\u043F\u043E\u0447\u0435\u043C\u0443\u0436\u0435\u043E"
            u"\u043D\u0438\u043D\u0435\u0433\u043E\u0432\u043E\u0440"
            u"\u044F\u0442\u043F\u043E\u0440\u0443\u0441\u0441\u043A"
            u"\u0438",
    2:      "b1abfaaepdrnnbgefbaDotcwatmq2g4l"),
       
           # (J) Spanish: Porqu<eacute>nopuedensimplementehablarenEspa<ntilde>ol
    2:     (u"\u0050\u006F\u0072\u0071\u0075\u00E9\u006E\u006F\u0070"
            u"\u0075\u0065\u0064\u0065\u006E\u0073\u0069\u006D\u0070"
            u"\u006C\u0065\u006D\u0065\u006E\u0074\u0065\u0068\u0061"
            u"\u0062\u006C\u0061\u0072\u0065\u006E\u0045\u0073\u0070"
            u"\u0061\u00F1\u006F\u006C",
    2:      "PorqunopuedensimplementehablarenEspaol-fmd56a"),
       
           # (K) Vietnamese:
           #  T<adotbelow>isaoh<odotbelow>kh<ocirc>ngth<ecirchookabove>ch\
           #   <ihookabove>n<oacute>iti<ecircacute>ngVi<ecircdotbelow>t
    2:     (u"\u0054\u1EA1\u0069\u0073\u0061\u006F\u0068\u1ECD\u006B"
            u"\u0068\u00F4\u006E\u0067\u0074\u0068\u1EC3\u0063\u0068"
            u"\u1EC9\u006E\u00F3\u0069\u0074\u0069\u1EBF\u006E\u0067"
            u"\u0056\u0069\u1EC7\u0074",
    2:      "TisaohkhngthchnitingVit-kjcr8268qyxafd2f1b9g"),
       
           #(L) 3<nen>B<gumi><kinpachi><sensei>
    2:     (u"\u0033\u5E74\u0042\u7D44\u91D1\u516B\u5148\u751F",
    2:      "3B-ww4c5e180e575a65lsy2b"),
       
           # (M) <amuro><namie>-with-SUPER-MONKEYS
    2:     (u"\u5B89\u5BA4\u5948\u7F8E\u6075\u002D\u0077\u0069\u0074"
            u"\u0068\u002D\u0053\u0055\u0050\u0045\u0052\u002D\u004D"
            u"\u004F\u004E\u004B\u0045\u0059\u0053",
    2:      "-with-SUPER-MONKEYS-pc58ag80a8qai00g7n9n"),
       
           # (N) Hello-Another-Way-<sorezore><no><basho>
    2:     (u"\u0048\u0065\u006C\u006C\u006F\u002D\u0041\u006E\u006F"
            u"\u0074\u0068\u0065\u0072\u002D\u0057\u0061\u0079\u002D"
            u"\u305D\u308C\u305E\u308C\u306E\u5834\u6240",
    2:      "Hello-Another-Way--fc4qua05auwb3674vfr0b"),
       
           # (O) <hitotsu><yane><no><shita>2
    2:     (u"\u3072\u3068\u3064\u5C4B\u6839\u306E\u4E0B\u0032",
    2:      "2-u9tlzr9756bt3uc0v"),
       
           # (P) Maji<de>Koi<suru>5<byou><mae>
    2:     (u"\u004D\u0061\u006A\u0069\u3067\u004B\u006F\u0069\u3059"
            u"\u308B\u0035\u79D2\u524D",
    2:      "MajiKoi5-783gue6qz075azm5e"),
       
            # (Q) <pafii>de<runba>
    2:     (u"\u30D1\u30D5\u30A3\u30FC\u0064\u0065\u30EB\u30F3\u30D0",
    2:      "de-jg4avhby1noc0d"),
       
           # (R) <sono><supiido><de>
    2:     (u"\u305D\u306E\u30B9\u30D4\u30FC\u30C9\u3067",
    2:      "d9juau41awczczp"),
       
           # (S) -> $1.00 <-
    2:     (u"\u002D\u003E\u0020\u0024\u0031\u002E\u0030\u0030\u0020"
            u"\u003C\u002D",
    2:      "-> $1.00 <--")
           ]
       
   40: for i in punycode_testcases:
   38:     if len(i)!=2:
>>>>>>         print repr(i)
       
    4: class PunycodeTest(unittest.TestCase):
    2:     def test_encode(self):
   20:         for uni, puny in punycode_testcases:
                   # Need to convert both strings to lower case, since
                   # some of the extended encodings use upper case, but our
                   # code produces only lower case. Converting just puny to
                   # lower is also insufficient, since some of the input characters
                   # are upper case.
   19:             self.assertEqual(uni.encode("punycode").lower(), puny.lower())
       
    2:     def test_decode(self):
   20:         for uni, puny in punycode_testcases:
   19:             self.assertEqual(uni, puny.decode("punycode"))
       
    4: class UnicodeInternalTest(unittest.TestCase):
    2:     def test_bug1251300(self):
               # Decoding with unicode_internal used to not correctly handle "code
               # points" above 0x10ffff on UCS-4 builds.
    1:         if sys.maxunicode > 0xffff:
                   ok = [
>>>>>>                 ("\x00\x10\xff\xff", u"\U0010ffff"),
>>>>>>                 ("\x00\x00\x01\x01", u"\U00000101"),
>>>>>>                 ("", u""),
                   ]
                   not_ok = [
>>>>>>                 "\x7f\xff\xff\xff",
>>>>>>                 "\x80\x00\x00\x00",
>>>>>>                 "\x81\x00\x00\x00",
>>>>>>                 "\x00",
>>>>>>                 "\x00\x00\x00\x00\x00",
                   ]
>>>>>>             for internal, uni in ok:
>>>>>>                 if sys.byteorder == "little":
>>>>>>                     internal = "".join(reversed(internal))
>>>>>>                 self.assertEqual(uni, internal.decode("unicode_internal"))
>>>>>>             for internal in not_ok:
>>>>>>                 if sys.byteorder == "little":
>>>>>>                     internal = "".join(reversed(internal))
>>>>>>                 self.assertRaises(UnicodeDecodeError, internal.decode,
>>>>>>                     "unicode_internal")
       
    2:     def test_decode_error_attributes(self):
    1:         if sys.maxunicode > 0xffff:
>>>>>>             try:
                       "\x00\x00\x00\x00\x00\x11\x11\x00".decode("unicode_internal")
>>>>>>             except UnicodeDecodeError, ex:
>>>>>>                 self.assertEqual("unicode_internal", ex.encoding)
>>>>>>                 self.assertEqual("\x00\x00\x00\x00\x00\x11\x11\x00", ex.object)
>>>>>>                 self.assertEqual(4, ex.start)
>>>>>>                 self.assertEqual(8, ex.end)
                   else:
>>>>>>                 self.fail()
       
    2:     def test_decode_callback(self):
    1:         if sys.maxunicode > 0xffff:
>>>>>>             codecs.register_error("UnicodeInternalTest", codecs.ignore_errors)
>>>>>>             decoder = codecs.getdecoder("unicode_internal")
>>>>>>             ab = u"ab".encode("unicode_internal")
>>>>>>             ignored = decoder("%s\x22\x22\x22\x22%s" % (ab[:4], ab[4:]),
>>>>>>                 "UnicodeInternalTest")
>>>>>>             self.assertEqual((u"ab", 12), ignored)
       
    2:     def test_encode_length(self):
               # Issue 3739
    1:         encoder = codecs.getencoder("unicode_internal")
    1:         self.assertEqual(encoder(u"a")[1], 1)
    1:         self.assertEqual(encoder(u"\xe9\u0142")[1], 2)
       
    1:         encoder = codecs.getencoder("string-escape")
    1:         self.assertEqual(encoder(r'\x00')[1], 4)
       
       # From http://www.gnu.org/software/libidn/draft-josefsson-idn-test-vectors.html
       nameprep_tests = [
           # 3.1 Map to nothing.
    2:     ('foo\xc2\xad\xcd\x8f\xe1\xa0\x86\xe1\xa0\x8bbar'
            '\xe2\x80\x8b\xe2\x81\xa0baz\xef\xb8\x80\xef\xb8\x88\xef'
            '\xb8\x8f\xef\xbb\xbf',
    2:      'foobarbaz'),
           # 3.2 Case folding ASCII U+0043 U+0041 U+0046 U+0045.
    2:     ('CAFE',
    2:      'cafe'),
           # 3.3 Case folding 8bit U+00DF (german sharp s).
           # The original test case is bogus; it says \xc3\xdf
    2:     ('\xc3\x9f',
    2:      'ss'),
           # 3.4 Case folding U+0130 (turkish capital I with dot).
    2:     ('\xc4\xb0',
    2:      'i\xcc\x87'),
           # 3.5 Case folding multibyte U+0143 U+037A.
    2:     ('\xc5\x83\xcd\xba',
    2:      '\xc5\x84 \xce\xb9'),
           # 3.6 Case folding U+2121 U+33C6 U+1D7BB.
           # XXX: skip this as it fails in UCS-2 mode
           #('\xe2\x84\xa1\xe3\x8f\x86\xf0\x9d\x9e\xbb',
           # 'telc\xe2\x88\x95kg\xcf\x83'),
    2:     (None, None),
           # 3.7 Normalization of U+006a U+030c U+00A0 U+00AA.
    2:     ('j\xcc\x8c\xc2\xa0\xc2\xaa',
    2:      '\xc7\xb0 a'),
           # 3.8 Case folding U+1FB7 and normalization.
    2:     ('\xe1\xbe\xb7',
    2:      '\xe1\xbe\xb6\xce\xb9'),
           # 3.9 Self-reverting case folding U+01F0 and normalization.
           # The original test case is bogus, it says `\xc7\xf0'
    2:     ('\xc7\xb0',
    2:      '\xc7\xb0'),
           # 3.10 Self-reverting case folding U+0390 and normalization.
    2:     ('\xce\x90',
    2:      '\xce\x90'),
           # 3.11 Self-reverting case folding U+03B0 and normalization.
    2:     ('\xce\xb0',
    2:      '\xce\xb0'),
           # 3.12 Self-reverting case folding U+1E96 and normalization.
    2:     ('\xe1\xba\x96',
    2:      '\xe1\xba\x96'),
           # 3.13 Self-reverting case folding U+1F56 and normalization.
    2:     ('\xe1\xbd\x96',
    2:      '\xe1\xbd\x96'),
           # 3.14 ASCII space character U+0020.
    2:     (' ',
    2:      ' '),
           # 3.15 Non-ASCII 8bit space character U+00A0.
    2:     ('\xc2\xa0',
    2:      ' '),
           # 3.16 Non-ASCII multibyte space character U+1680.
    2:     ('\xe1\x9a\x80',
    2:      None),
           # 3.17 Non-ASCII multibyte space character U+2000.
    2:     ('\xe2\x80\x80',
    2:      ' '),
           # 3.18 Zero Width Space U+200b.
    2:     ('\xe2\x80\x8b',
    2:      ''),
           # 3.19 Non-ASCII multibyte space character U+3000.
    2:     ('\xe3\x80\x80',
    2:      ' '),
           # 3.20 ASCII control characters U+0010 U+007F.
    2:     ('\x10\x7f',
    2:      '\x10\x7f'),
           # 3.21 Non-ASCII 8bit control character U+0085.
    2:     ('\xc2\x85',
    2:      None),
           # 3.22 Non-ASCII multibyte control character U+180E.
    2:     ('\xe1\xa0\x8e',
    2:      None),
           # 3.23 Zero Width No-Break Space U+FEFF.
    2:     ('\xef\xbb\xbf',
    2:      ''),
           # 3.24 Non-ASCII control character U+1D175.
    2:     ('\xf0\x9d\x85\xb5',
    2:      None),
           # 3.25 Plane 0 private use character U+F123.
    2:     ('\xef\x84\xa3',
    2:      None),
           # 3.26 Plane 15 private use character U+F1234.
    2:     ('\xf3\xb1\x88\xb4',
    2:      None),
           # 3.27 Plane 16 private use character U+10F234.
    2:     ('\xf4\x8f\x88\xb4',
    2:      None),
           # 3.28 Non-character code point U+8FFFE.
    2:     ('\xf2\x8f\xbf\xbe',
    2:      None),
           # 3.29 Non-character code point U+10FFFF.
    2:     ('\xf4\x8f\xbf\xbf',
    2:      None),
           # 3.30 Surrogate code U+DF42.
    2:     ('\xed\xbd\x82',
    2:      None),
           # 3.31 Non-plain text character U+FFFD.
    2:     ('\xef\xbf\xbd',
    2:      None),
           # 3.32 Ideographic description character U+2FF5.
    2:     ('\xe2\xbf\xb5',
    2:      None),
           # 3.33 Display property character U+0341.
    2:     ('\xcd\x81',
    2:      '\xcc\x81'),
           # 3.34 Left-to-right mark U+200E.
    2:     ('\xe2\x80\x8e',
    2:      None),
           # 3.35 Deprecated U+202A.
    2:     ('\xe2\x80\xaa',
    2:      None),
           # 3.36 Language tagging character U+E0001.
    2:     ('\xf3\xa0\x80\x81',
    2:      None),
           # 3.37 Language tagging character U+E0042.
    2:     ('\xf3\xa0\x81\x82',
    2:      None),
           # 3.38 Bidi: RandALCat character U+05BE and LCat characters.
    2:     ('foo\xd6\xbebar',
    2:      None),
           # 3.39 Bidi: RandALCat character U+FD50 and LCat characters.
    2:     ('foo\xef\xb5\x90bar',
    2:      None),
           # 3.40 Bidi: RandALCat character U+FB38 and LCat characters.
    2:     ('foo\xef\xb9\xb6bar',
    2:      'foo \xd9\x8ebar'),
           # 3.41 Bidi: RandALCat without trailing RandALCat U+0627 U+0031.
    2:     ('\xd8\xa71',
    2:      None),
           # 3.42 Bidi: RandALCat character U+0627 U+0031 U+0628.
    2:     ('\xd8\xa71\xd8\xa8',
    2:      '\xd8\xa71\xd8\xa8'),
           # 3.43 Unassigned code point U+E0002.
           # Skip this test as we allow unassigned
           #('\xf3\xa0\x80\x82',
           # None),
    2:     (None, None),
           # 3.44 Larger test (shrinking).
           # Original test case reads \xc3\xdf
    2:     ('X\xc2\xad\xc3\x9f\xc4\xb0\xe2\x84\xa1j\xcc\x8c\xc2\xa0\xc2'
            '\xaa\xce\xb0\xe2\x80\x80',
    2:      'xssi\xcc\x87tel\xc7\xb0 a\xce\xb0 '),
           # 3.45 Larger test (expanding).
           # Original test case reads \xc3\x9f
    2:     ('X\xc3\x9f\xe3\x8c\x96\xc4\xb0\xe2\x84\xa1\xe2\x92\x9f\xe3\x8c'
            '\x80',
    2:      'xss\xe3\x82\xad\xe3\x83\xad\xe3\x83\xa1\xe3\x83\xbc\xe3'
            '\x83\x88\xe3\x83\xabi\xcc\x87tel\x28d\x29\xe3\x82'
            '\xa2\xe3\x83\x91\xe3\x83\xbc\xe3\x83\x88')
           ]
       
       
    4: class NameprepTest(unittest.TestCase):
    2:     def test_nameprep(self):
    1:         from encodings.idna import nameprep
   46:         for pos, (orig, prepped) in enumerate(nameprep_tests):
   45:             if orig is None:
                       # Skipped
    2:                 continue
                   # The Unicode strings are given in UTF-8
   43:             orig = unicode(orig, "utf-8")
   43:             if prepped is None:
                       # Input contains prohibited characters
   19:                 self.assertRaises(UnicodeError, nameprep, orig)
                   else:
   24:                 prepped = unicode(prepped, "utf-8")
   24:                 try:
   24:                     self.assertEqual(nameprep(orig), prepped)
>>>>>>                 except Exception,e:
>>>>>>                     raise test_support.TestFailed("Test 3.%d: %s" % (pos+1, str(e)))
       
    4: class IDNACodecTest(unittest.TestCase):
    2:     def test_builtin_decode(self):
    1:         self.assertEqual(unicode("python.org", "idna"), u"python.org")
    1:         self.assertEqual(unicode("python.org.", "idna"), u"python.org.")
    1:         self.assertEqual(unicode("xn--pythn-mua.org", "idna"), u"pyth\xf6n.org")
    1:         self.assertEqual(unicode("xn--pythn-mua.org.", "idna"), u"pyth\xf6n.org.")
       
    2:     def test_builtin_encode(self):
    1:         self.assertEqual(u"python.org".encode("idna"), "python.org")
    1:         self.assertEqual("python.org.".encode("idna"), "python.org.")
    1:         self.assertEqual(u"pyth\xf6n.org".encode("idna"), "xn--pythn-mua.org")
    1:         self.assertEqual(u"pyth\xf6n.org.".encode("idna"), "xn--pythn-mua.org.")
       
    2:     def test_stream(self):
    1:         import StringIO
    1:         r = codecs.getreader("idna")(StringIO.StringIO("abc"))
    1:         r.read(3)
    1:         self.assertEqual(r.read(), u"")
       
    2:     def test_incremental_decode(self):
    1:         self.assertEqual(
    1:             "".join(codecs.iterdecode("python.org", "idna")),
    1:             u"python.org"
               )
    1:         self.assertEqual(
    1:             "".join(codecs.iterdecode("python.org.", "idna")),
    1:             u"python.org."
               )
    1:         self.assertEqual(
    1:             "".join(codecs.iterdecode("xn--pythn-mua.org.", "idna")),
    1:             u"pyth\xf6n.org."
               )
    1:         self.assertEqual(
    1:             "".join(codecs.iterdecode("xn--pythn-mua.org.", "idna")),
    1:             u"pyth\xf6n.org."
               )
       
    1:         decoder = codecs.getincrementaldecoder("idna")()
    1:         self.assertEqual(decoder.decode("xn--xam", ), u"")
    1:         self.assertEqual(decoder.decode("ple-9ta.o", ), u"\xe4xample.")
    1:         self.assertEqual(decoder.decode(u"rg"), u"")
    1:         self.assertEqual(decoder.decode(u"", True), u"org")
       
    1:         decoder.reset()
    1:         self.assertEqual(decoder.decode("xn--xam", ), u"")
    1:         self.assertEqual(decoder.decode("ple-9ta.o", ), u"\xe4xample.")
    1:         self.assertEqual(decoder.decode("rg."), u"org.")
    1:         self.assertEqual(decoder.decode("", True), u"")
       
    2:     def test_incremental_encode(self):
    1:         self.assertEqual(
    1:             "".join(codecs.iterencode(u"python.org", "idna")),
    1:             "python.org"
               )
    1:         self.assertEqual(
    1:             "".join(codecs.iterencode(u"python.org.", "idna")),
    1:             "python.org."
               )
    1:         self.assertEqual(
    1:             "".join(codecs.iterencode(u"pyth\xf6n.org.", "idna")),
    1:             "xn--pythn-mua.org."
               )
    1:         self.assertEqual(
    1:             "".join(codecs.iterencode(u"pyth\xf6n.org.", "idna")),
    1:             "xn--pythn-mua.org."
               )
       
    1:         encoder = codecs.getincrementalencoder("idna")()
    1:         self.assertEqual(encoder.encode(u"\xe4x"), "")
    1:         self.assertEqual(encoder.encode(u"ample.org"), "xn--xample-9ta.")
    1:         self.assertEqual(encoder.encode(u"", True), "org")
       
    1:         encoder.reset()
    1:         self.assertEqual(encoder.encode(u"\xe4x"), "")
    1:         self.assertEqual(encoder.encode(u"ample.org."), "xn--xample-9ta.org.")
    1:         self.assertEqual(encoder.encode(u"", True), "")
       
    4: class CodecsModuleTest(unittest.TestCase):
       
    2:     def test_decode(self):
    1:         self.assertEqual(codecs.decode('\xe4\xf6\xfc', 'latin-1'),
    1:                           u'\xe4\xf6\xfc')
    1:         self.assertRaises(TypeError, codecs.decode)
    1:         self.assertEqual(codecs.decode('abc'), u'abc')
    1:         self.assertRaises(UnicodeDecodeError, codecs.decode, '\xff', 'ascii')
       
    2:     def test_encode(self):
    1:         self.assertEqual(codecs.encode(u'\xe4\xf6\xfc', 'latin-1'),
    1:                           '\xe4\xf6\xfc')
    1:         self.assertRaises(TypeError, codecs.encode)
    1:         self.assertRaises(LookupError, codecs.encode, "foo", "__spam__")
    1:         self.assertEqual(codecs.encode(u'abc'), 'abc')
    1:         self.assertRaises(UnicodeEncodeError, codecs.encode, u'\xffff', 'ascii')
       
    2:     def test_register(self):
    1:         self.assertRaises(TypeError, codecs.register)
    1:         self.assertRaises(TypeError, codecs.register, 42)
       
    2:     def test_lookup(self):
    1:         self.assertRaises(TypeError, codecs.lookup)
    1:         self.assertRaises(LookupError, codecs.lookup, "__spam__")
    1:         self.assertRaises(LookupError, codecs.lookup, " ")
       
    2:     def test_getencoder(self):
    1:         self.assertRaises(TypeError, codecs.getencoder)
    1:         self.assertRaises(LookupError, codecs.getencoder, "__spam__")
       
    2:     def test_getdecoder(self):
    1:         self.assertRaises(TypeError, codecs.getdecoder)
    1:         self.assertRaises(LookupError, codecs.getdecoder, "__spam__")
       
    2:     def test_getreader(self):
    1:         self.assertRaises(TypeError, codecs.getreader)
    1:         self.assertRaises(LookupError, codecs.getreader, "__spam__")
       
    2:     def test_getwriter(self):
    1:         self.assertRaises(TypeError, codecs.getwriter)
    1:         self.assertRaises(LookupError, codecs.getwriter, "__spam__")
       
    2:     def test_lookup_issue1813(self):
               # Issue #1813: under Turkish locales, lookup of some codecs failed
               # because 'I' is lowercased as a dotless "i"
    1:         oldlocale = locale.getlocale(locale.LC_CTYPE)
    1:         self.addCleanup(locale.setlocale, locale.LC_CTYPE, oldlocale)
    1:         try:
    1:             locale.setlocale(locale.LC_CTYPE, 'tr_TR')
>>>>>>         except locale.Error:
                   # Unsupported locale on this system
>>>>>>             self.skipTest('test needs Turkish locale')
    1:         c = codecs.lookup('ASCII')
    1:         self.assertEqual(c.name, 'ascii')
       
    2:     def test_all(self):
               api = (
                   "encode", "decode",
                   "register", "CodecInfo", "Codec", "IncrementalEncoder",
                   "IncrementalDecoder", "StreamReader", "StreamWriter", "lookup",
                   "getencoder", "getdecoder", "getincrementalencoder",
                   "getincrementaldecoder", "getreader", "getwriter",
                   "register_error", "lookup_error",
                   "strict_errors", "replace_errors", "ignore_errors",
                   "xmlcharrefreplace_errors", "backslashreplace_errors",
                   "open", "EncodedFile",
                   "iterencode", "iterdecode",
                   "BOM", "BOM_BE", "BOM_LE",
                   "BOM_UTF8", "BOM_UTF16", "BOM_UTF16_BE", "BOM_UTF16_LE",
                   "BOM_UTF32", "BOM_UTF32_BE", "BOM_UTF32_LE",
                   "BOM32_BE", "BOM32_LE", "BOM64_BE", "BOM64_LE",  # Undocumented
    1:             "StreamReaderWriter", "StreamRecoder",
               )
    1:         self.assertEqual(sorted(api), sorted(codecs.__all__))
   44:         for api in codecs.__all__:
   43:             getattr(codecs, api)
       
    4: class StreamReaderTest(unittest.TestCase):
       
    2:     def setUp(self):
    1:         self.reader = codecs.getreader('utf-8')
    1:         self.stream = StringIO.StringIO('\xed\x95\x9c\n\xea\xb8\x80')
       
    2:     def test_readlines(self):
    1:         f = self.reader(self.stream)
    1:         self.assertEqual(f.readlines(), [u'\ud55c\n', u'\uae00'])
       
    4: class EncodedFileTest(unittest.TestCase):
       
    2:     def test_basic(self):
    1:         f = StringIO.StringIO('\xed\x95\x9c\n\xea\xb8\x80')
    1:         ef = codecs.EncodedFile(f, 'utf-16-le', 'utf-8')
    1:         self.assertEqual(ef.read(), '\\\xd5\n\x00\x00\xae')
       
    1:         f = StringIO.StringIO()
    1:         ef = codecs.EncodedFile(f, 'utf-8', 'latin1')
    1:         ef.write('\xc3\xbc')
    1:         self.assertEqual(f.getvalue(), '\xfc')
       
    4: class Str2StrTest(unittest.TestCase):
       
    2:     def test_read(self):
    1:         sin = codecs.encode("\x80", "base64_codec")
    1:         reader = codecs.getreader("base64_codec")(StringIO.StringIO(sin))
    1:         sout = reader.read()
    1:         self.assertEqual(sout, "\x80")
    1:         self.assertIsInstance(sout, str)
       
    2:     def test_readline(self):
    1:         sin = codecs.encode("\x80", "base64_codec")
    1:         reader = codecs.getreader("base64_codec")(StringIO.StringIO(sin))
    1:         sout = reader.readline()
    1:         self.assertEqual(sout, "\x80")
    1:         self.assertIsInstance(sout, str)
       
       all_unicode_encodings = [
    2:     "ascii",
    2:     "base64_codec",
    2:     "big5",
    2:     "big5hkscs",
    2:     "charmap",
    2:     "cp037",
    2:     "cp1006",
    2:     "cp1026",
    2:     "cp1140",
    2:     "cp1250",
    2:     "cp1251",
    2:     "cp1252",
    2:     "cp1253",
    2:     "cp1254",
    2:     "cp1255",
    2:     "cp1256",
    2:     "cp1257",
    2:     "cp1258",
    2:     "cp424",
    2:     "cp437",
    2:     "cp500",
    2:     "cp720",
    2:     "cp737",
    2:     "cp775",
    2:     "cp850",
    2:     "cp852",
    2:     "cp855",
    2:     "cp856",
    2:     "cp857",
    2:     "cp858",
    2:     "cp860",
    2:     "cp861",
    2:     "cp862",
    2:     "cp863",
    2:     "cp864",
    2:     "cp865",
    2:     "cp866",
    2:     "cp869",
    2:     "cp874",
    2:     "cp875",
    2:     "cp932",
    2:     "cp949",
    2:     "cp950",
    2:     "euc_jis_2004",
    2:     "euc_jisx0213",
    2:     "euc_jp",
    2:     "euc_kr",
    2:     "gb18030",
    2:     "gb2312",
    2:     "gbk",
    2:     "hex_codec",
    2:     "hp_roman8",
    2:     "hz",
    2:     "idna",
    2:     "iso2022_jp",
    2:     "iso2022_jp_1",
    2:     "iso2022_jp_2",
    2:     "iso2022_jp_2004",
    2:     "iso2022_jp_3",
    2:     "iso2022_jp_ext",
    2:     "iso2022_kr",
    2:     "iso8859_1",
    2:     "iso8859_10",
    2:     "iso8859_11",
    2:     "iso8859_13",
    2:     "iso8859_14",
    2:     "iso8859_15",
    2:     "iso8859_16",
    2:     "iso8859_2",
    2:     "iso8859_3",
    2:     "iso8859_4",
    2:     "iso8859_5",
    2:     "iso8859_6",
    2:     "iso8859_7",
    2:     "iso8859_8",
    2:     "iso8859_9",
    2:     "johab",
    2:     "koi8_r",
    2:     "koi8_u",
    2:     "latin_1",
    2:     "mac_cyrillic",
    2:     "mac_greek",
    2:     "mac_iceland",
    2:     "mac_latin2",
    2:     "mac_roman",
    2:     "mac_turkish",
    2:     "palmos",
    2:     "ptcp154",
    2:     "punycode",
    2:     "raw_unicode_escape",
    2:     "rot_13",
    2:     "shift_jis",
    2:     "shift_jis_2004",
    2:     "shift_jisx0213",
    2:     "tis_620",
    2:     "unicode_escape",
    2:     "unicode_internal",
    2:     "utf_16",
    2:     "utf_16_be",
    2:     "utf_16_le",
    2:     "utf_7",
    2:     "utf_8",
       ]
       
    2: if hasattr(codecs, "mbcs_encode"):
>>>>>>     all_unicode_encodings.append("mbcs")
       
       # The following encodings work only with str, not unicode
       all_string_encodings = [
    2:     "quopri_codec",
    2:     "string_escape",
    2:     "uu_codec",
       ]
       
       # The following encoding is not tested, because it's not supposed
       # to work:
       #    "undefined"
       
       # The following encodings don't work in stateful mode
       broken_unicode_with_streams = [
    2:     "base64_codec",
    2:     "hex_codec",
    2:     "punycode",
    2:     "unicode_internal"
       ]
    2: broken_incremental_coders = broken_unicode_with_streams[:]
       
    2: if sys.flags.py3k_warning:
>>>>>>     broken_unicode_with_streams.append("rot_13")
       
       # The following encodings only support "strict" mode
       only_strict_mode = [
    2:     "idna",
    2:     "zlib_codec",
    2:     "bz2_codec",
       ]
       
    2: try:
    2:     import bz2
>>>>>> except ImportError:
>>>>>>     pass
       else:
    2:     all_unicode_encodings.append("bz2_codec")
    2:     broken_unicode_with_streams.append("bz2_codec")
       
    2: try:
    2:     import zlib
>>>>>> except ImportError:
>>>>>>     pass
       else:
    2:     all_unicode_encodings.append("zlib_codec")
    2:     broken_unicode_with_streams.append("zlib_codec")
       
    4: class BasicUnicodeTest(unittest.TestCase):
    2:     def test_basics(self):
    1:         s = u"abc123"  # all codecs should be able to encode these
  105:         for encoding in all_unicode_encodings:
  104:             name = codecs.lookup(encoding).name
  104:             if encoding.endswith("_codec"):
    4:                 name += "_codec"
  100:             elif encoding == "latin_1":
    1:                 name = "latin_1"
  104:             self.assertEqual(encoding.replace("_", "-"), name.replace("_", "-"))
  104:             (bytes, size) = codecs.getencoder(encoding)(s)
  104:             self.assertEqual(size, len(s), "encoding=%r" % encoding)
  104:             (chars, size) = codecs.getdecoder(encoding)(bytes)
  104:             self.assertEqual(chars, s, "encoding=%r" % encoding)
       
  104:             if encoding not in broken_unicode_with_streams:
                       # check stream reader/writer
   98:                 q = Queue()
   98:                 writer = codecs.getwriter(encoding)(q)
   98:                 encodedresult = ""
  686:                 for c in s:
  588:                     writer.write(c)
  588:                     encodedresult += q.read()
   98:                 q = Queue()
   98:                 reader = codecs.getreader(encoding)(q)
   98:                 decodedresult = u""
  706:                 for c in encodedresult:
  608:                     q.write(c)
  608:                     decodedresult += reader.read()
   98:                 self.assertEqual(decodedresult, s, "encoding=%r" % encoding)
       
  104:             if encoding not in broken_incremental_coders:
                       # check incremental decoder/encoder and iterencode()/iterdecode()
  100:                 try:
  100:                     encoder = codecs.getincrementalencoder(encoding)()
>>>>>>                 except LookupError:  # no IncrementalEncoder
>>>>>>                     pass
                       else:
                           # check incremental decoder/encoder
  100:                     encodedresult = ""
  700:                     for c in s:
  600:                         encodedresult += encoder.encode(c)
  100:                     encodedresult += encoder.encode(u"", True)
  100:                     decoder = codecs.getincrementaldecoder(encoding)()
  100:                     decodedresult = u""
  764:                     for c in encodedresult:
  664:                         decodedresult += decoder.decode(c)
  100:                     decodedresult += decoder.decode("", True)
  100:                     self.assertEqual(decodedresult, s,
  100:                                      "encoding=%r" % encoding)
       
                           # check iterencode()/iterdecode()
  100:                     result = u"".join(codecs.iterdecode(
  100:                             codecs.iterencode(s, encoding), encoding))
  100:                     self.assertEqual(result, s, "encoding=%r" % encoding)
       
                           # check iterencode()/iterdecode() with empty string
  100:                     result = u"".join(codecs.iterdecode(
  100:                             codecs.iterencode(u"", encoding), encoding))
  100:                     self.assertEqual(result, u"")
       
  100:                 if encoding not in only_strict_mode:
                           # check incremental decoder/encoder with errors argument
   97:                     try:
   97:                         encoder = codecs.getincrementalencoder(encoding)("ignore")
>>>>>>                     except LookupError:  # no IncrementalEncoder
>>>>>>                         pass
                           else:
  776:                         encodedresult = "".join(encoder.encode(c) for c in s)
   97:                         decoder = codecs.getincrementaldecoder(encoding)("ignore")
  796:                         decodedresult = u"".join(decoder.decode(c)
  699:                                                  for c in encodedresult)
   97:                         self.assertEqual(decodedresult, s,
   97:                                          "encoding=%r" % encoding)
       
    2:     @test_support.cpython_only
           def test_basics_capi(self):
    1:         from _testcapi import codec_incrementalencoder, codec_incrementaldecoder
    1:         s = u"abc123"  # all codecs should be able to encode these
  105:         for encoding in all_unicode_encodings:
  104:             if encoding not in broken_incremental_coders:
                       # check incremental decoder/encoder and iterencode()/iterdecode()
  100:                 try:
  100:                     cencoder = codec_incrementalencoder(encoding)
>>>>>>                 except LookupError:  # no IncrementalEncoder
>>>>>>                     pass
                       else:
                           # check C API
  100:                     encodedresult = ""
  700:                     for c in s:
  600:                         encodedresult += cencoder.encode(c)
  100:                     encodedresult += cencoder.encode(u"", True)
  100:                     cdecoder = codec_incrementaldecoder(encoding)
  100:                     decodedresult = u""
  764:                     for c in encodedresult:
  664:                         decodedresult += cdecoder.decode(c)
  100:                     decodedresult += cdecoder.decode("", True)
  100:                     self.assertEqual(decodedresult, s,
  100:                                      "encoding=%r" % encoding)
       
  100:                 if encoding not in only_strict_mode:
                           # check incremental decoder/encoder with errors argument
   97:                     try:
   97:                         cencoder = codec_incrementalencoder(encoding, "ignore")
>>>>>>                     except LookupError:  # no IncrementalEncoder
>>>>>>                         pass
                           else:
  776:                         encodedresult = "".join(cencoder.encode(c) for c in s)
   97:                         cdecoder = codec_incrementaldecoder(encoding, "ignore")
  796:                         decodedresult = u"".join(cdecoder.decode(c)
  699:                                                  for c in encodedresult)
   97:                         self.assertEqual(decodedresult, s,
   97:                                          "encoding=%r" % encoding)
       
    2:     def test_seek(self):
               # all codecs should be able to encode these
    1:         s = u"%s\n%s\n" % (100*u"abc123", 100*u"def456")
  105:         for encoding in all_unicode_encodings:
  104:             if encoding == "idna": # FIXME: See SF bug #1163178
    1:                 continue
  103:             if encoding in broken_unicode_with_streams:
    6:                 continue
   97:             reader = codecs.getreader(encoding)(StringIO.StringIO(s.encode(encoding)))
  582:             for t in xrange(5):
                       # Test that calling seek resets the internal codec state and buffers
  485:                 reader.seek(0, 0)
  485:                 line = reader.readline()
  485:                 self.assertEqual(s[:len(line)], line)
       
    2:     def test_bad_decode_args(self):
  105:         for encoding in all_unicode_encodings:
  104:             decoder = codecs.getdecoder(encoding)
  104:             self.assertRaises(TypeError, decoder)
  104:             if encoding not in ("idna", "punycode"):
  102:                 self.assertRaises(TypeError, decoder, 42)
       
    2:     def test_bad_encode_args(self):
  105:         for encoding in all_unicode_encodings:
  104:             encoder = codecs.getencoder(encoding)
  104:             self.assertRaises(TypeError, encoder)
       
    2:     def test_encoding_map_type_initialized(self):
    1:         from encodings import cp1140
               # This used to crash, we are only verifying there's no crash.
    1:         table_type = type(cp1140.encoding_table)
    1:         self.assertEqual(table_type, table_type)
       
    4: class BasicStrTest(unittest.TestCase):
    2:     def test_basics(self):
    1:         s = "abc123"
    4:         for encoding in all_string_encodings:
    3:             (bytes, size) = codecs.getencoder(encoding)(s)
    3:             self.assertEqual(size, len(s))
    3:             (chars, size) = codecs.getdecoder(encoding)(bytes)
    3:             self.assertEqual(chars, s, "%r != %r (encoding=%r)" % (chars, s, encoding))
       
    4: class CharmapTest(unittest.TestCase):
    2:     def test_decode_with_string_map(self):
    1:         self.assertEqual(
    1:             codecs.charmap_decode("\x00\x01\x02", "strict", u"abc"),
    1:             (u"abc", 3)
               )
       
    1:         self.assertRaises(UnicodeDecodeError,
    1:             codecs.charmap_decode, b"\x00\x01\x02", "strict", u"ab"
               )
       
    1:         self.assertRaises(UnicodeDecodeError,
    1:             codecs.charmap_decode, "\x00\x01\x02", "strict", u"ab\ufffe"
               )
       
    1:         self.assertEqual(
    1:             codecs.charmap_decode("\x00\x01\x02", "replace", u"ab"),
    1:             (u"ab\ufffd", 3)
               )
       
    1:         self.assertEqual(
    1:             codecs.charmap_decode("\x00\x01\x02", "replace", u"ab\ufffe"),
    1:             (u"ab\ufffd", 3)
               )
       
    1:         self.assertEqual(
    1:             codecs.charmap_decode("\x00\x01\x02", "ignore", u"ab"),
    1:             (u"ab", 3)
               )
       
    1:         self.assertEqual(
    1:             codecs.charmap_decode("\x00\x01\x02", "ignore", u"ab\ufffe"),
    1:             (u"ab", 3)
               )
       
  258:         allbytes = "".join(chr(i) for i in xrange(256))
    1:         self.assertEqual(
    1:             codecs.charmap_decode(allbytes, "ignore", u""),
    1:             (u"", len(allbytes))
               )
       
    2:     def test_decode_with_int2str_map(self):
    1:         self.assertEqual(
    1:             codecs.charmap_decode("\x00\x01\x02", "strict",
    1:                                   {0: u'a', 1: u'b', 2: u'c'}),
    1:             (u"abc", 3)
               )
       
    1:         self.assertEqual(
    1:             codecs.charmap_decode("\x00\x01\x02", "strict",
    1:                                   {0: u'Aa', 1: u'Bb', 2: u'Cc'}),
    1:             (u"AaBbCc", 3)
               )
       
    1:         self.assertEqual(
    1:             codecs.charmap_decode("\x00\x01\x02", "strict",
    1:                                   {0: u'\U0010FFFF', 1: u'b', 2: u'c'}),
    1:             (u"\U0010FFFFbc", 3)
               )
       
    1:         self.assertEqual(
    1:             codecs.charmap_decode("\x00\x01\x02", "strict",
    1:                                   {0: u'a', 1: u'b', 2: u''}),
    1:             (u"ab", 3)
               )
       
    1:         self.assertRaises(UnicodeDecodeError,
    1:             codecs.charmap_decode, "\x00\x01\x02", "strict",
    1:                                    {0: u'a', 1: u'b'}
               )
       
    1:         self.assertRaises(UnicodeDecodeError,
    1:             codecs.charmap_decode, "\x00\x01\x02", "strict",
    1:                                    {0: u'a', 1: u'b', 2: None}
               )
       
               # Issue #14850
    1:         self.assertRaises(UnicodeDecodeError,
    1:             codecs.charmap_decode, "\x00\x01\x02", "strict",
    1:                                    {0: u'a', 1: u'b', 2: u'\ufffe'}
               )
       
    1:         self.assertEqual(
    1:             codecs.charmap_decode("\x00\x01\x02", "replace",
    1:                                   {0: u'a', 1: u'b'}),
    1:             (u"ab\ufffd", 3)
               )
       
    1:         self.assertEqual(
    1:             codecs.charmap_decode("\x00\x01\x02", "replace",
    1:                                   {0: u'a', 1: u'b', 2: None}),
    1:             (u"ab\ufffd", 3)
               )
       
               # Issue #14850
    1:         self.assertEqual(
    1:             codecs.charmap_decode("\x00\x01\x02", "replace",
    1:                                   {0: u'a', 1: u'b', 2: u'\ufffe'}),
    1:             (u"ab\ufffd", 3)
               )
       
    1:         self.assertEqual(
    1:             codecs.charmap_decode("\x00\x01\x02", "ignore",
    1:                                   {0: u'a', 1: u'b'}),
    1:             (u"ab", 3)
               )
       
    1:         self.assertEqual(
    1:             codecs.charmap_decode("\x00\x01\x02", "ignore",
    1:                                   {0: u'a', 1: u'b', 2: None}),
    1:             (u"ab", 3)
               )
       
               # Issue #14850
    1:         self.assertEqual(
    1:             codecs.charmap_decode("\x00\x01\x02", "ignore",
    1:                                   {0: u'a', 1: u'b', 2: u'\ufffe'}),
    1:             (u"ab", 3)
               )
       
  258:         allbytes = "".join(chr(i) for i in xrange(256))
    1:         self.assertEqual(
    1:             codecs.charmap_decode(allbytes, "ignore", {}),
    1:             (u"", len(allbytes))
               )
       
    2:     def test_decode_with_int2int_map(self):
    1:         a = ord(u'a')
    1:         b = ord(u'b')
    1:         c = ord(u'c')
       
    1:         self.assertEqual(
    1:             codecs.charmap_decode("\x00\x01\x02", "strict",
    1:                                   {0: a, 1: b, 2: c}),
    1:             (u"abc", 3)
               )
       
               # Issue #15379
    1:         self.assertEqual(
    1:             codecs.charmap_decode("\x00\x01\x02", "strict",
    1:                                   {0: 0x10FFFF, 1: b, 2: c}),
    1:             (u"\U0010FFFFbc", 3)
               )
       
    1:         self.assertRaises(TypeError,
    1:             codecs.charmap_decode, "\x00\x01\x02", "strict",
    1:                                    {0: 0x110000, 1: b, 2: c}
               )
       
    1:         self.assertRaises(UnicodeDecodeError,
    1:             codecs.charmap_decode, "\x00\x01\x02", "strict",
    1:                                    {0: a, 1: b},
               )
       
    1:         self.assertRaises(UnicodeDecodeError,
    1:             codecs.charmap_decode, "\x00\x01\x02", "strict",
    1:                                    {0: a, 1: b, 2: 0xFFFE},
               )
       
    1:         self.assertEqual(
    1:             codecs.charmap_decode("\x00\x01\x02", "replace",
    1:                                   {0: a, 1: b}),
    1:             (u"ab\ufffd", 3)
               )
       
    1:         self.assertEqual(
    1:             codecs.charmap_decode("\x00\x01\x02", "replace",
    1:                                   {0: a, 1: b, 2: 0xFFFE}),
    1:             (u"ab\ufffd", 3)
               )
       
    1:         self.assertEqual(
    1:             codecs.charmap_decode("\x00\x01\x02", "ignore",
    1:                                   {0: a, 1: b}),
    1:             (u"ab", 3)
               )
       
    1:         self.assertEqual(
    1:             codecs.charmap_decode("\x00\x01\x02", "ignore",
    1:                                   {0: a, 1: b, 2: 0xFFFE}),
    1:             (u"ab", 3)
               )
       
       
    4: class WithStmtTest(unittest.TestCase):
    2:     def test_encodedfile(self):
    1:         f = StringIO.StringIO("\xc3\xbc")
    1:         with codecs.EncodedFile(f, "latin-1", "utf-8") as ef:
    1:             self.assertEqual(ef.read(), "\xfc")
       
    2:     def test_streamreaderwriter(self):
    1:         f = StringIO.StringIO("\xc3\xbc")
    1:         info = codecs.lookup("utf-8")
    1:         with codecs.StreamReaderWriter(f, info.streamreader,
    1:                                        info.streamwriter, 'strict') as srw:
    1:             self.assertEqual(srw.read(), u"\xfc")
       
       
    4: class UnicodeEscapeTest(unittest.TestCase):
    2:     def test_empty(self):
    1:         self.assertEqual(codecs.unicode_escape_encode(u""), ("", 0))
    1:         self.assertEqual(codecs.unicode_escape_decode(""), (u"", 0))
       
    2:     def test_raw_encode(self):
    1:         encode = codecs.unicode_escape_encode
   96:         for b in range(32, 127):
   95:             if b != ord('\\'):
   94:                 self.assertEqual(encode(unichr(b)), (chr(b), 1))
       
    2:     def test_raw_decode(self):
    1:         decode = codecs.unicode_escape_decode
  257:         for b in range(256):
  256:             if b != ord('\\'):
  255:                 self.assertEqual(decode(chr(b) + '0'), (unichr(b) + u'0', 2))
       
    2:     def test_escape_encode(self):
    1:         encode = codecs.unicode_escape_encode
    1:         check = coding_checker(self, encode)
    1:         check(u'\t', r'\t')
    1:         check(u'\n', r'\n')
    1:         check(u'\r', r'\r')
    1:         check(u'\\', r'\\')
   33:         for b in range(32):
   32:             if chr(b) not in '\t\n\r':
   29:                 check(unichr(b), '\\x%02x' % b)
  130:         for b in range(127, 256):
  129:             check(unichr(b), '\\x%02x' % b)
    1:         check(u'\u20ac', r'\u20ac')
    1:         check(u'\U0001d120', r'\U0001d120')
       
    2:     def test_escape_decode(self):
    1:         decode = codecs.unicode_escape_decode
    1:         check = coding_checker(self, decode)
    1:         check("[\\\n]", u"[]")
    1:         check(r'[\"]', u'["]')
    1:         check(r"[\']", u"[']")
    1:         check(r"[\\]", ur"[\]")
    1:         check(r"[\a]", u"[\x07]")
    1:         check(r"[\b]", u"[\x08]")
    1:         check(r"[\t]", u"[\x09]")
    1:         check(r"[\n]", u"[\x0a]")
    1:         check(r"[\v]", u"[\x0b]")
    1:         check(r"[\f]", u"[\x0c]")
    1:         check(r"[\r]", u"[\x0d]")
    1:         check(r"[\7]", u"[\x07]")
    1:         check(r"[\8]", ur"[\8]")
    1:         check(r"[\78]", u"[\x078]")
    1:         check(r"[\41]", u"[!]")
    1:         check(r"[\418]", u"[!8]")
    1:         check(r"[\101]", u"[A]")
    1:         check(r"[\1010]", u"[A0]")
    1:         check(r"[\x41]", u"[A]")
    1:         check(r"[\x410]", u"[A0]")
    1:         check(r"\u20ac", u"\u20ac")
    1:         check(r"\U0001d120", u"\U0001d120")
  257:         for b in range(256):
  256:             if chr(b) not in '\n"\'\\abtnvfr01234567xuUN':
  233:                 check('\\' + chr(b), u'\\' + unichr(b))
       
    2:     def test_decode_errors(self):
    1:         decode = codecs.unicode_escape_decode
    4:         for c, d in ('x', 2), ('u', 4), ('U', 4):
   13:             for i in range(d):
   10:                 self.assertRaises(UnicodeDecodeError, decode,
   10:                                   "\\" + c + "0"*i)
   10:                 self.assertRaises(UnicodeDecodeError, decode,
   10:                                   "[\\" + c + "0"*i + "]")
   10:                 data = "[\\" + c + "0"*i + "]\\" + c + "0"*i
   10:                 self.assertEqual(decode(data, "ignore"), (u"[]", len(data)))
   10:                 self.assertEqual(decode(data, "replace"),
   10:                                  (u"[\ufffd]\ufffd", len(data)))
    1:         self.assertRaises(UnicodeDecodeError, decode, r"\U00110000")
    1:         self.assertEqual(decode(r"\U00110000", "ignore"), (u"", 10))
    1:         self.assertEqual(decode(r"\U00110000", "replace"), (u"\ufffd", 10))
       
       
    4: class RawUnicodeEscapeTest(unittest.TestCase):
    2:     def test_empty(self):
    1:         self.assertEqual(codecs.raw_unicode_escape_encode(u""), ("", 0))
    1:         self.assertEqual(codecs.raw_unicode_escape_decode(""), (u"", 0))
       
    2:     def test_raw_encode(self):
    1:         encode = codecs.raw_unicode_escape_encode
  257:         for b in range(256):
  256:             self.assertEqual(encode(unichr(b)), (chr(b), 1))
       
    2:     def test_raw_decode(self):
    1:         decode = codecs.raw_unicode_escape_decode
  257:         for b in range(256):
  256:             self.assertEqual(decode(chr(b) + '0'), (unichr(b) + u'0', 2))
       
    2:     def test_escape_encode(self):
    1:         encode = codecs.raw_unicode_escape_encode
    1:         check = coding_checker(self, encode)
  257:         for b in range(256):
  256:             if chr(b) not in 'uU':
  254:                 check(u'\\' + unichr(b), '\\' + chr(b))
    1:         check(u'\u20ac', r'\u20ac')
    1:         check(u'\U0001d120', r'\U0001d120')
       
    2:     def test_escape_decode(self):
    1:         decode = codecs.raw_unicode_escape_decode
    1:         check = coding_checker(self, decode)
  257:         for b in range(256):
  256:             if chr(b) not in 'uU':
  254:                 check('\\' + chr(b), u'\\' + unichr(b))
    1:         check(r"\u20ac", u"\u20ac")
    1:         check(r"\U0001d120", u"\U0001d120")
       
    2:     def test_decode_errors(self):
    1:         decode = codecs.raw_unicode_escape_decode
    3:         for c, d in ('u', 4), ('U', 4):
   10:             for i in range(d):
    8:                 self.assertRaises(UnicodeDecodeError, decode,
    8:                                   "\\" + c + "0"*i)
    8:                 self.assertRaises(UnicodeDecodeError, decode,
    8:                                   "[\\" + c + "0"*i + "]")
    8:                 data = "[\\" + c + "0"*i + "]\\" + c + "0"*i
    8:                 self.assertEqual(decode(data, "ignore"), (u"[]", len(data)))
    8:                 self.assertEqual(decode(data, "replace"),
    8:                                  (u"[\ufffd]\ufffd", len(data)))
    1:         self.assertRaises(UnicodeDecodeError, decode, r"\U00110000")
    1:         self.assertEqual(decode(r"\U00110000", "ignore"), (u"", 10))
    1:         self.assertEqual(decode(r"\U00110000", "replace"), (u"\ufffd", 10))
       
       
    4: class BomTest(unittest.TestCase):
    2:     def test_seek0(self):
    1:         data = u"1234567890"
               tests = ("utf-16",
                        "utf-16-le",
                        "utf-16-be",
                        "utf-32",
                        "utf-32-le",
    1:                  "utf-32-be")
    1:         self.addCleanup(test_support.unlink, test_support.TESTFN)
    7:         for encoding in tests:
                   # Check if the BOM is written only once
    6:             with codecs.open(test_support.TESTFN, 'w+', encoding=encoding) as f:
    6:                 f.write(data)
    6:                 f.write(data)
    6:                 f.seek(0)
    6:                 self.assertEqual(f.read(), data * 2)
    6:                 f.seek(0)
    6:                 self.assertEqual(f.read(), data * 2)
       
                   # Check that the BOM is written after a seek(0)
    6:             with codecs.open(test_support.TESTFN, 'w+', encoding=encoding) as f:
    6:                 f.write(data[0])
    6:                 self.assertNotEqual(f.tell(), 0)
    6:                 f.seek(0)
    6:                 f.write(data)
    6:                 f.seek(0)
    6:                 self.assertEqual(f.read(), data)
       
                   # (StreamWriter) Check that the BOM is written after a seek(0)
    6:             with codecs.open(test_support.TESTFN, 'w+', encoding=encoding) as f:
    6:                 f.writer.write(data[0])
    6:                 self.assertNotEqual(f.writer.tell(), 0)
    6:                 f.writer.seek(0)
    6:                 f.writer.write(data)
    6:                 f.seek(0)
    6:                 self.assertEqual(f.read(), data)
       
                   # Check that the BOM is not written after a seek() at a position
                   # different than the start
    6:             with codecs.open(test_support.TESTFN, 'w+', encoding=encoding) as f:
    6:                 f.write(data)
    6:                 f.seek(f.tell())
    6:                 f.write(data)
    6:                 f.seek(0)
    6:                 self.assertEqual(f.read(), data * 2)
       
                   # (StreamWriter) Check that the BOM is not written after a seek()
                   # at a position different than the start
    6:             with codecs.open(test_support.TESTFN, 'w+', encoding=encoding) as f:
    6:                 f.writer.write(data)
    6:                 f.writer.seek(f.writer.tell())
    6:                 f.writer.write(data)
    6:                 f.seek(0)
    6:                 self.assertEqual(f.read(), data * 2)
       
       
    4: class TransformCodecTest(unittest.TestCase):
       
    2:     def test_quopri_stateless(self):
               # Should encode with quotetabs=True
    1:         encoded = codecs.encode(b"space tab\teol \n", "quopri-codec")
    1:         self.assertEqual(encoded, b"space=20tab=09eol=20\n")
               # But should still support unescaped tabs and spaces
    1:         unescaped = b"space tab eol\n"
    1:         self.assertEqual(codecs.decode(unescaped, "quopri-codec"), unescaped)
       
    2:     def test_uu_invalid(self):
               # Missing "begin" line
    1:         self.assertRaises(ValueError, codecs.decode, "", "uu-codec")
       
       
    2: def test_main():
    1:     test_support.run_unittest(
    1:         UTF32Test,
    1:         UTF32LETest,
    1:         UTF32BETest,
    1:         UTF16Test,
    1:         UTF16LETest,
    1:         UTF16BETest,
    1:         UTF8Test,
    1:         UTF8SigTest,
    1:         UTF7Test,
    1:         UTF16ExTest,
    1:         ReadBufferTest,
    1:         CharBufferTest,
    1:         EscapeDecodeTest,
    1:         RecodingTest,
    1:         PunycodeTest,
    1:         UnicodeInternalTest,
    1:         NameprepTest,
    1:         IDNACodecTest,
    1:         CodecsModuleTest,
    1:         StreamReaderTest,
    1:         EncodedFileTest,
    1:         Str2StrTest,
    1:         BasicUnicodeTest,
    1:         BasicStrTest,
    1:         CharmapTest,
    1:         WithStmtTest,
    1:         UnicodeEscapeTest,
    1:         RawUnicodeEscapeTest,
    1:         BomTest,
    1:         TransformCodecTest,
           )
       
       
    2: if __name__ == "__main__":
>>>>>>     test_main()
