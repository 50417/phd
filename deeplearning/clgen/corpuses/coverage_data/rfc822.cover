       """RFC 2822 message manipulation.
       
       Note: This is only a very rough sketch of a full RFC-822 parser; in particular
       the tokenizing of addresses does not adhere to all the quoting rules.
       
       Note: RFC 2822 is a long awaited update to RFC 822.  This module should
       conform to RFC 2822, and is thus mis-named (it's not worth renaming it).  Some
       effort at RFC 2822 updates have been made, but a thorough audit has not been
       performed.  Consider any RFC 2822 non-conformance to be a bug.
       
           RFC 2822: http://www.faqs.org/rfcs/rfc2822.html
           RFC 822 : http://www.faqs.org/rfcs/rfc822.html (obsolete)
       
       Directions for use:
       
       To create a Message object: first open a file, e.g.:
       
         fp = open(file, 'r')
       
       You can use any other legal way of getting an open file object, e.g. use
       sys.stdin or call os.popen().  Then pass the open file object to the Message()
       constructor:
       
         m = Message(fp)
       
       This class can work with any input object that supports a readline method.  If
       the input object has seek and tell capability, the rewindbody method will
       work; also illegal lines will be pushed back onto the input stream.  If the
       input object lacks seek but has an `unread' method that can push back a line
       of input, Message will use that to push back illegal lines.  Thus this class
       can be used to parse messages coming from a buffered stream.
       
       The optional `seekable' argument is provided as a workaround for certain stdio
       libraries in which tell() discards buffered data before discovering that the
       lseek() system call doesn't work.  For maximum portability, you should set the
       seekable argument to zero to prevent that initial \code{tell} when passing in
       an unseekable object such as a file object created from a socket object.  If
       it is 1 on entry -- which it is by default -- the tell() method of the open
       file object is called once; if this raises an exception, seekable is reset to
       0.  For other nonzero values of seekable, this test is not made.
       
       To get the text of a particular header there are several methods:
       
         str = m.getheader(name)
         str = m.getrawheader(name)
       
       where name is the name of the header, e.g. 'Subject'.  The difference is that
       getheader() strips the leading and trailing whitespace, while getrawheader()
       doesn't.  Both functions retain embedded whitespace (including newlines)
       exactly as they are specified in the header, and leave the case of the text
       unchanged.
       
       For addresses and address lists there are functions
       
         realname, mailaddress = m.getaddr(name)
         list = m.getaddrlist(name)
       
       where the latter returns a list of (realname, mailaddr) tuples.
       
       There is also a method
       
         time = m.getdate(name)
       
       which parses a Date-like field and returns a time-compatible tuple,
       i.e. a tuple such as returned by time.localtime() or accepted by
       time.mktime().
       
       See the class definition for lower level access methods.
       
       There are also some utility functions here.
    1: """
       # Cleanup and extensions by Eric S. Raymond <esr@thyrsus.com>
       
    1: import time
       
    1: from warnings import warnpy3k
    1: warnpy3k("in 3.x, rfc822 has been removed in favor of the email package",
    1:          stacklevel=2)
       
    1: __all__ = ["Message","AddressList","parsedate","parsedate_tz","mktime_tz"]
       
    1: _blanklines = ('\r\n', '\n')            # Optimization for islast()
       
       
    2: class Message:
    1:     """Represents a single RFC 2822-compliant message."""
       
    1:     def __init__(self, fp, seekable = 1):
               """Initialize the class instance and read the headers."""
  585:         if seekable == 1:
                   # Exercise tell() to make sure it works
                   # (and then assume seek() works, too)
  280:             try:
  280:                 fp.tell()
>>>>>>             except (AttributeError, IOError):
>>>>>>                 seekable = 0
  585:         self.fp = fp
  585:         self.seekable = seekable
  585:         self.startofheaders = None
  585:         self.startofbody = None
               #
  585:         if self.seekable:
  280:             try:
  280:                 self.startofheaders = self.fp.tell()
>>>>>>             except IOError:
>>>>>>                 self.seekable = 0
               #
  585:         self.readheaders()
               #
  583:         if self.seekable:
  280:             try:
  280:                 self.startofbody = self.fp.tell()
>>>>>>             except IOError:
>>>>>>                 self.seekable = 0
       
    1:     def rewindbody(self):
               """Rewind the file to the start of the body (if seekable)."""
>>>>>>         if not self.seekable:
>>>>>>             raise IOError, "unseekable file"
>>>>>>         self.fp.seek(self.startofbody)
       
    1:     def readheaders(self):
               """Read header lines.
       
               Read header lines up to the entirely blank line that terminates them.
               The (normally blank) line that ends the headers is skipped, but not
               included in the returned list.  If a non-header line ends the headers,
               (which is an error), an attempt is made to backspace over it; it is
               never included in the returned list.
       
               The variable self.status is set to the empty string if all went well,
               otherwise it is an error message.  The variable self.headers is a
               completely uninterpreted list of lines contained in the header (so
               printing them will reproduce the header exactly as it appears in the
               file).
               """
  408:         self.dict = {}
  408:         self.unixfrom = ''
  408:         self.headers = lst = []
  408:         self.status = ''
  408:         headerseen = ""
  408:         firstline = 1
  408:         startofline = unread = tell = None
  408:         if hasattr(self.fp, 'unread'):
>>>>>>             unread = self.fp.unread
  408:         elif self.seekable:
  275:             tell = self.fp.tell
  408:         while 1:
 1214:             if tell:
  645:                 try:
  645:                     startofline = tell()
>>>>>>                 except IOError:
>>>>>>                     startofline = tell = None
>>>>>>                     self.seekable = 0
 1214:             line = self.fp.readline()
 1214:             if not line:
  200:                 self.status = 'EOF in headers'
  200:                 break
                   # Skip unix From name time lines
 1014:             if firstline and line.startswith('From '):
    4:                 self.unixfrom = self.unixfrom + line
    4:                 continue
 1010:             firstline = 0
 1010:             if headerseen and line[0] in ' \t':
                       # It's a continuation line.
    6:                 lst.append(line)
    6:                 x = (self.dict[headerseen] + "\n " + line.strip())
    6:                 self.dict[headerseen] = x.strip()
    6:                 continue
 1004:             elif self.iscomment(line):
                       # It's a comment.  Ignore it.
>>>>>>                 continue
 1004:             elif self.islast(line):
                       # Note! No pushback here!  The delimiter line gets eaten.
  208:                 break
  796:             headerseen = self.isheader(line)
  796:             if headerseen:
                       # It's a legal header line, save it.
  795:                 lst.append(line)
  795:                 self.dict[headerseen] = line[len(headerseen)+1:].strip()
  795:                 continue
    1:             elif headerseen is not None:
                       # An empty header name. These aren't allowed in HTTP, but it's
                       # probably a benign mistake. Don't add the header, just keep
                       # going.
    1:                 continue
                   else:
                       # It's not a header line; throw it back and stop here.
>>>>>>                 if not self.dict:
>>>>>>                     self.status = 'No headers'
                       else:
>>>>>>                     self.status = 'Non-header line where header expected'
                       # Try to undo the read.
>>>>>>                 if unread:
>>>>>>                     unread(line)
>>>>>>                 elif tell:
>>>>>>                     self.fp.seek(startofline)
                       else:
>>>>>>                     self.status = self.status + '; bad seek'
>>>>>>                 break
       
    1:     def isheader(self, line):
               """Determine whether a given line is a legal header.
       
               This method should return the header name, suitably canonicalized.
               You may override this method in order to use Message parsing on tagged
               data in RFC 2822-like formats with special header formats.
               """
 1454:         i = line.find(':')
 1454:         if i > -1:
 1449:             return line[:i].lower()
    5:         return None
       
    1:     def islast(self, line):
               """Determine whether a line is a legal end of RFC 2822 headers.
       
               You may override this method if your application wants to bend the
               rules, e.g. to strip trailing whitespace, or to recognize MH template
               separators ('--------').  For convenience (e.g. for code reading from
               sockets) a line consisting of \\r\\n also matches.
               """
 1817:         return line in _blanklines
       
    1:     def iscomment(self, line):
               """Determine whether a line should be skipped entirely.
       
               You may override this method in order to use Message parsing on tagged
               data in RFC 2822-like formats that support embedded comments or
               free-text data.
               """
 1817:         return False
       
    1:     def getallmatchingheaders(self, name):
               """Find all header lines matching a given header name.
       
               Look through the list of headers and find all lines matching a given
               header name (and their continuation lines).  A list of the lines is
               returned, without interpretation.  If the header does not occur, an
               empty list is returned.  If the header occurs multiple times, all
               occurrences are returned.  Case is not important in the header name.
               """
  390:         name = name.lower() + ':'
  390:         n = len(name)
  390:         lst = []
  390:         hit = 0
  810:         for line in self.headers:
  420:             if line[:n].lower() == name:
  175:                 hit = 1
  245:             elif not line[:1].isspace():
  239:                 hit = 0
  420:             if hit:
  178:                 lst.append(line)
  390:         return lst
       
    1:     def getfirstmatchingheader(self, name):
               """Get the first header line matching name.
       
               This is similar to getallmatchingheaders, but it returns only the
               first matching header (and its continuation lines).
               """
>>>>>>         name = name.lower() + ':'
>>>>>>         n = len(name)
>>>>>>         lst = []
>>>>>>         hit = 0
>>>>>>         for line in self.headers:
>>>>>>             if hit:
>>>>>>                 if not line[:1].isspace():
>>>>>>                     break
>>>>>>             elif line[:n].lower() == name:
>>>>>>                 hit = 1
>>>>>>             if hit:
>>>>>>                 lst.append(line)
>>>>>>         return lst
       
    1:     def getrawheader(self, name):
               """A higher-level interface to getfirstmatchingheader().
       
               Return a string containing the literal text of the header but with the
               keyword stripped.  All leading, trailing and embedded whitespace is
               kept in the string, however.  Return None if the header does not
               occur.
               """
       
>>>>>>         lst = self.getfirstmatchingheader(name)
>>>>>>         if not lst:
>>>>>>             return None
>>>>>>         lst[0] = lst[0][len(name) + 1:]
>>>>>>         return ''.join(lst)
       
    1:     def getheader(self, name, default=None):
               """Get the header value for a name.
       
               This is the normal interface: it returns a stripped version of the
               header value for a given header name, or None if it doesn't exist.
               This uses the dictionary version which finds the *last* such header.
               """
 2196:         return self.dict.get(name.lower(), default)
    1:     get = getheader
       
    1:     def getheaders(self, name):
               """Get all values for a header.
       
               This returns a list of values for headers given more than once; each
               value in the result list is stripped in the same way as the result of
               getheader().  If the header is not given, return an empty list.
               """
  351:         result = []
  351:         current = ''
  351:         have_header = 0
  501:         for s in self.getallmatchingheaders(name):
  150:             if s[0].isspace():
>>>>>>                 if current:
>>>>>>                     current = "%s\n %s" % (current, s.strip())
                       else:
>>>>>>                     current = s.strip()
                   else:
  150:                 if have_header:
    9:                     result.append(current)
  150:                 current = s[s.find(":") + 1:].strip()
  150:                 have_header = 1
  351:         if have_header:
  141:             result.append(current)
  351:         return result
       
    1:     def getaddr(self, name):
               """Get a single address from a header, as a tuple.
       
               An example return value:
               ('Guido van Rossum', 'guido@cwi.nl')
               """
               # New, by Ben Escoto
>>>>>>         alist = self.getaddrlist(name)
>>>>>>         if alist:
>>>>>>             return alist[0]
               else:
>>>>>>             return (None, None)
       
    1:     def getaddrlist(self, name):
               """Get a list of addresses from a header.
       
               Retrieves a list of addresses from a header, where each address is a
               tuple as returned by getaddr().  Scans all named headers, so it works
               properly with multiple To: or Cc: headers for example.
               """
   30:         raw = []
   58:         for h in self.getallmatchingheaders(name):
   28:             if h[0] in ' \t':
    3:                 raw.append(h)
                   else:
   25:                 if raw:
    6:                     raw.append(', ')
   25:                 i = h.find(':')
   25:                 if i > 0:
   25:                     addr = h[i+1:]
   25:                 raw.append(addr)
   30:         alladdrs = ''.join(raw)
   30:         a = AddressList(alladdrs)
   30:         return a.addresslist
       
    1:     def getdate(self, name):
               """Retrieve a date field from a header.
       
               Retrieves a date field from the named header, returning a tuple
               compatible with time.mktime().
               """
   14:         try:
   14:             data = self[name]
    6:         except KeyError:
    6:             return None
    8:         return parsedate(data)
       
    1:     def getdate_tz(self, name):
               """Retrieve a date field from a header as a 10-tuple.
       
               The first 9 elements make up a tuple compatible with time.mktime(),
               and the 10th is the offset of the poster's time zone from GMT/UTC.
               """
>>>>>>         try:
>>>>>>             data = self[name]
>>>>>>         except KeyError:
>>>>>>             return None
>>>>>>         return parsedate_tz(data)
       
       
           # Access as a dictionary (only finds *last* header of each type):
       
    1:     def __len__(self):
               """Get the number of headers in a message."""
    1:         return len(self.dict)
       
    1:     def __getitem__(self, name):
               """Get a specific header, as from a dictionary."""
  125:         return self.dict[name.lower()]
       
    1:     def __setitem__(self, name, value):
               """Set the value of a header.
       
               Note: This is not a perfect inversion of __getitem__, because any
               changed headers get stuck at the end of the raw-headers list rather
               than where the altered header was.
               """
>>>>>>         del self[name] # Won't fail if it doesn't exist
>>>>>>         self.dict[name.lower()] = value
>>>>>>         text = name + ": " + value
>>>>>>         for line in text.split("\n"):
>>>>>>             self.headers.append(line + "\n")
       
    1:     def __delitem__(self, name):
               """Delete all occurrences of a specific header, if it is present."""
>>>>>>         name = name.lower()
>>>>>>         if not name in self.dict:
>>>>>>             return
>>>>>>         del self.dict[name]
>>>>>>         name = name + ':'
>>>>>>         n = len(name)
>>>>>>         lst = []
>>>>>>         hit = 0
>>>>>>         for i in range(len(self.headers)):
>>>>>>             line = self.headers[i]
>>>>>>             if line[:n].lower() == name:
>>>>>>                 hit = 1
>>>>>>             elif not line[:1].isspace():
>>>>>>                 hit = 0
>>>>>>             if hit:
>>>>>>                 lst.append(i)
>>>>>>         for i in reversed(lst):
>>>>>>             del self.headers[i]
       
    1:     def setdefault(self, name, default=""):
    3:         lowername = name.lower()
    3:         if lowername in self.dict:
    1:             return self.dict[lowername]
               else:
    2:             text = name + ": " + default
    4:             for line in text.split("\n"):
    2:                 self.headers.append(line + "\n")
    2:             self.dict[lowername] = default
    2:             return default
       
    1:     def has_key(self, name):
               """Determine whether a message contains the named header."""
    1:         return name.lower() in self.dict
       
    1:     def __contains__(self, name):
               """Determine whether a message contains the named header."""
   76:         return name.lower() in self.dict
       
    1:     def __iter__(self):
    1:         return iter(self.dict)
       
    1:     def keys(self):
               """Get all of a message's header field names."""
>>>>>>         return self.dict.keys()
       
    1:     def values(self):
               """Get all of a message's header field values."""
>>>>>>         return self.dict.values()
       
    1:     def items(self):
               """Get all of a message's headers.
       
               Returns a list of name, value tuples.
               """
>>>>>>         return self.dict.items()
       
    1:     def __str__(self):
    1:         return ''.join(self.headers)
       
       
       # Utility functions
       # -----------------
       
       # XXX Should fix unquote() and quote() to be really conformant.
       # XXX The inverses of the parse functions may also be useful.
       
       
    1: def unquote(s):
           """Remove quotes from a string."""
    5:     if len(s) > 1:
    5:         if s.startswith('"') and s.endswith('"'):
    3:             return s[1:-1].replace('\\\\', '\\').replace('\\"', '"')
    2:         if s.startswith('<') and s.endswith('>'):
>>>>>>             return s[1:-1]
    2:     return s
       
       
    1: def quote(s):
           """Add quotes around a string."""
    1:     return s.replace('\\', '\\\\').replace('"', '\\"')
       
       
    1: def parseaddr(address):
           """Parse an address into a (realname, mailaddr) tuple."""
    4:     a = AddressList(address)
    4:     lst = a.addresslist
    4:     if not lst:
>>>>>>         return (None, None)
    4:     return lst[0]
       
       
    2: class AddrlistClass:
           """Address parser class by Ben Escoto.
       
           To understand what this class does, it helps to have a copy of
           RFC 2822 in front of you.
       
           http://www.faqs.org/rfcs/rfc2822.html
       
           Note: this class interface is deprecated and may be removed in the future.
           Use rfc822.AddressList instead.
    1:     """
       
    1:     def __init__(self, field):
               """Initialize a new instance.
       
               `field' is an unparsed address header field, containing one or more
               addresses.
               """
   34:         self.specials = '()<>@,:;.\"[]'
   34:         self.pos = 0
   34:         self.LWS = ' \t'
   34:         self.CR = '\r\n'
   34:         self.atomends = self.specials + self.LWS + self.CR
               # Note that RFC 2822 now specifies `.' as obs-phrase, meaning that it
               # is obsolete syntax.  RFC 2822 requires that we recognize obsolete
               # syntax, so allow dots in phrases.
   34:         self.phraseends = self.atomends.replace('.', '')
   34:         self.field = field
   34:         self.commentlist = []
       
    1:     def gotonext(self):
               """Parse up to the start of the next address."""
  366:         while self.pos < len(self.field):
  272:             if self.field[self.pos] in self.LWS + '\n\r':
   73:                 self.pos = self.pos + 1
  199:             elif self.field[self.pos] == '(':
    1:                 self.commentlist.append(self.getcomment())
  198:             else: break
       
    1:     def getaddrlist(self):
               """Parse all addresses.
       
               Returns a list containing all of the addresses.
               """
   23:         result = []
   23:         ad = self.getaddress()
   55:         while ad:
   32:             result += ad
   32:             ad = self.getaddress()
   23:         return result
       
    1:     def getaddress(self):
               """Parse the next address."""
   60:         self.commentlist = []
   60:         self.gotonext()
       
   60:         oldpos = self.pos
   60:         oldcl = self.commentlist
   60:         plist = self.getphraselist()
       
   60:         self.gotonext()
   60:         returnlist = []
       
   60:         if self.pos >= len(self.field):
                   # Bad email address technically, no domain.
   23:             if plist:
>>>>>>                 returnlist = [(' '.join(self.commentlist), plist[0])]
       
   37:         elif self.field[self.pos] in '.@':
                   # email address is just an addrspec
                   # this isn't very efficient since we start over
   20:             self.pos = oldpos
   20:             self.commentlist = oldcl
   20:             addrspec = self.getaddrspec()
   20:             returnlist = [(' '.join(self.commentlist), addrspec)]
       
   17:         elif self.field[self.pos] == ':':
                   # address is a group
    2:             returnlist = []
       
    2:             fieldlen = len(self.field)
    2:             self.pos += 1
    7:             while self.pos < len(self.field):
    5:                 self.gotonext()
    5:                 if self.pos < fieldlen and self.field[self.pos] == ';':
>>>>>>                     self.pos += 1
>>>>>>                     break
    5:                 returnlist = returnlist + self.getaddress()
       
   15:         elif self.field[self.pos] == '<':
                   # Address is a phrase then a route addr
   13:             routeaddr = self.getrouteaddr()
       
   13:             if self.commentlist:
                       returnlist = [(' '.join(plist) + ' (' + \
>>>>>>                          ' '.join(self.commentlist) + ')', routeaddr)]
   13:             else: returnlist = [(' '.join(plist), routeaddr)]
       
               else:
    2:             if plist:
>>>>>>                 returnlist = [(' '.join(self.commentlist), plist[0])]
    2:             elif self.field[self.pos] in self.specials:
    2:                 self.pos += 1
       
   60:         self.gotonext()
   60:         if self.pos < len(self.field) and self.field[self.pos] == ',':
    9:             self.pos += 1
   60:         return returnlist
       
    1:     def getrouteaddr(self):
               """Parse a route address (Return-path value).
       
               This method just skips all the route stuff and returns the addrspec.
               """
   13:         if self.field[self.pos] != '<':
>>>>>>             return
       
   13:         expectroute = 0
   13:         self.pos += 1
   13:         self.gotonext()
   13:         adlist = ""
   13:         while self.pos < len(self.field):
   13:             if expectroute:
>>>>>>                 self.getdomain()
>>>>>>                 expectroute = 0
   13:             elif self.field[self.pos] == '>':
    1:                 self.pos += 1
    1:                 break
   12:             elif self.field[self.pos] == '@':
>>>>>>                 self.pos += 1
>>>>>>                 expectroute = 1
   12:             elif self.field[self.pos] == ':':
>>>>>>                 self.pos += 1
                   else:
   12:                 adlist = self.getaddrspec()
   12:                 self.pos += 1
   12:                 break
>>>>>>             self.gotonext()
       
   13:         return adlist
       
    1:     def getaddrspec(self):
               """Parse an RFC 2822 addr-spec."""
   32:         aslist = []
       
   32:         self.gotonext()
   63:         while self.pos < len(self.field):
   63:             if self.field[self.pos] == '.':
>>>>>>                 aslist.append('.')
>>>>>>                 self.pos += 1
   63:             elif self.field[self.pos] == '"':
    1:                 aslist.append('"%s"' % self.getquote())
   62:             elif self.field[self.pos] in self.atomends:
   32:                 break
   30:             else: aslist.append(self.getatom())
   31:             self.gotonext()
       
   32:         if self.pos >= len(self.field) or self.field[self.pos] != '@':
    1:             return ''.join(aslist)
       
   31:         aslist.append('@')
   31:         self.pos += 1
   31:         self.gotonext()
   31:         return ''.join(aslist) + self.getdomain()
       
    1:     def getdomain(self):
               """Get the complete domain name from an address."""
   31:         sdlist = []
  138:         while self.pos < len(self.field):
  136:             if self.field[self.pos] in self.LWS:
    5:                 self.pos += 1
  131:             elif self.field[self.pos] == '(':
    5:                 self.commentlist.append(self.getcomment())
  126:             elif self.field[self.pos] == '[':
    1:                 sdlist.append(self.getdomainliteral())
  125:             elif self.field[self.pos] == '.':
   33:                 self.pos += 1
   33:                 sdlist.append('.')
   92:             elif self.field[self.pos] in self.atomends:
   29:                 break
   63:             else: sdlist.append(self.getatom())
   31:         return ''.join(sdlist)
       
    1:     def getdelimited(self, beginchar, endchars, allowcomments = 1):
               """Parse a header fragment delimited by special characters.
       
               `beginchar' is the start character for the fragment.  If self is not
               looking at an instance of `beginchar' then getdelimited returns the
               empty string.
       
               `endchars' is a sequence of allowable end-delimiting characters.
               Parsing stops when one of these is encountered.
       
               If `allowcomments' is non-zero, embedded RFC 2822 comments are allowed
               within the parsed fragment.
               """
   16:         if self.field[self.pos] != beginchar:
>>>>>>             return ''
       
   16:         slist = ['']
   16:         quote = 0
   16:         self.pos += 1
  276:         while self.pos < len(self.field):
  276:             if quote == 1:
>>>>>>                 slist.append(self.field[self.pos])
>>>>>>                 quote = 0
  276:             elif self.field[self.pos] in endchars:
   16:                 self.pos += 1
   16:                 break
  260:             elif allowcomments and self.field[self.pos] == '(':
    1:                 slist.append(self.getcomment())
    1:                 continue        # have already advanced pos from getcomment
  259:             elif self.field[self.pos] == '\\':
>>>>>>                 quote = 1
                   else:
  259:                 slist.append(self.field[self.pos])
  259:             self.pos += 1
       
   16:         return ''.join(slist)
       
    1:     def getquote(self):
               """Get a quote-delimited fragment from self's field."""
    8:         return self.getdelimited('"', '"\r', 0)
       
    1:     def getcomment(self):
               """Get a parenthesis-delimited fragment from self's field."""
    7:         return self.getdelimited('(', ')\r', 1)
       
    1:     def getdomainliteral(self):
               """Parse an RFC 2822 domain-literal."""
    1:         return '[%s]' % self.getdelimited('[', ']\r', 0)
       
    1:     def getatom(self, atomends=None):
               """Parse an RFC 2822 atom.
       
               Optional atomends specifies a different set of end token delimiters
               (the default is to use self.atomends).  This is used e.g. in
               getphraselist() since phrase endings must not include the `.' (which
               is legal in phrases)."""
  124:         atomlist = ['']
  124:         if atomends is None:
   93:             atomends = self.atomends
       
  713:         while self.pos < len(self.field):
  712:             if self.field[self.pos] in atomends:
  123:                 break
  589:             else: atomlist.append(self.field[self.pos])
  589:             self.pos += 1
       
  124:         return ''.join(atomlist)
       
    1:     def getphraselist(self):
               """Parse a sequence of RFC 2822 phrases.
       
               A phrase is a sequence of words, which are in turn either RFC 2822
               atoms or quoted-strings.  Phrases are canonicalized by squeezing all
               runs of continuous whitespace into one space.
               """
   60:         plist = []
       
  115:         while self.pos < len(self.field):
   92:             if self.field[self.pos] in self.LWS:
   17:                 self.pos += 1
   75:             elif self.field[self.pos] == '"':
    7:                 plist.append(self.getquote())
   68:             elif self.field[self.pos] == '(':
>>>>>>                 self.commentlist.append(self.getcomment())
   68:             elif self.field[self.pos] in self.phraseends:
   37:                 break
                   else:
   31:                 plist.append(self.getatom(self.phraseends))
       
   60:         return plist
       
    2: class AddressList(AddrlistClass):
    1:     """An AddressList encapsulates a list of parsed RFC 2822 addresses."""
    1:     def __init__(self, field):
   34:         AddrlistClass.__init__(self, field)
   34:         if field:
   23:             self.addresslist = self.getaddrlist()
               else:
   11:             self.addresslist = []
       
    1:     def __len__(self):
>>>>>>         return len(self.addresslist)
       
    1:     def __str__(self):
>>>>>>         return ", ".join(map(dump_address_pair, self.addresslist))
       
    1:     def __add__(self, other):
               # Set union
>>>>>>         newaddr = AddressList(None)
>>>>>>         newaddr.addresslist = self.addresslist[:]
>>>>>>         for x in other.addresslist:
>>>>>>             if not x in self.addresslist:
>>>>>>                 newaddr.addresslist.append(x)
>>>>>>         return newaddr
       
    1:     def __iadd__(self, other):
               # Set union, in-place
>>>>>>         for x in other.addresslist:
>>>>>>             if not x in self.addresslist:
>>>>>>                 self.addresslist.append(x)
>>>>>>         return self
       
    1:     def __sub__(self, other):
               # Set difference
>>>>>>         newaddr = AddressList(None)
>>>>>>         for x in self.addresslist:
>>>>>>             if not x in other.addresslist:
>>>>>>                 newaddr.addresslist.append(x)
>>>>>>         return newaddr
       
    1:     def __isub__(self, other):
               # Set difference, in-place
>>>>>>         for x in other.addresslist:
>>>>>>             if x in self.addresslist:
>>>>>>                 self.addresslist.remove(x)
>>>>>>         return self
       
    1:     def __getitem__(self, index):
               # Make indexing, slices, and 'in' work
>>>>>>         return self.addresslist[index]
       
    1: def dump_address_pair(pair):
           """Dump a (name, address) pair in a canonicalized form."""
>>>>>>     if pair[0]:
>>>>>>         return '"' + pair[0] + '" <' + pair[1] + '>'
           else:
>>>>>>         return pair[1]
       
       # Parse a date field
       
    1: _monthnames = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul',
    1:                'aug', 'sep', 'oct', 'nov', 'dec',
    1:                'january', 'february', 'march', 'april', 'may', 'june', 'july',
    1:                'august', 'september', 'october', 'november', 'december']
    1: _daynames = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun']
       
       # The timezone table does not include the military time zones defined
       # in RFC822, other than Z.  According to RFC1123, the description in
       # RFC822 gets the signs wrong, so we can't rely on any such time
       # zones.  RFC1123 recommends that numeric timezone indicators be used
       # instead of timezone names.
       
    1: _timezones = {'UT':0, 'UTC':0, 'GMT':0, 'Z':0,
    1:               'AST': -400, 'ADT': -300,  # Atlantic (used in Canada)
    1:               'EST': -500, 'EDT': -400,  # Eastern
    1:               'CST': -600, 'CDT': -500,  # Central
    1:               'MST': -700, 'MDT': -600,  # Mountain
    1:               'PST': -800, 'PDT': -700   # Pacific
                     }
       
       
    1: def parsedate_tz(data):
           """Convert a date string to a time tuple.
       
           Accounts for military timezones.
           """
    8:     if not data:
    1:         return None
    7:     data = data.split()
    7:     if data[0][-1] in (',', '.') or data[0].lower() in _daynames:
               # There's a dayname here. Skip it
    6:         del data[0]
           else:
               # no space after the "weekday,"?
    1:         i = data[0].rfind(',')
    1:         if i >= 0:
>>>>>>             data[0] = data[0][i+1:]
    7:     if len(data) == 3: # RFC 850 date, deprecated
    1:         stuff = data[0].split('-')
    1:         if len(stuff) == 3:
    1:             data = stuff + data[1:]
    7:     if len(data) == 4:
>>>>>>         s = data[3]
>>>>>>         i = s.find('+')
>>>>>>         if i > 0:
>>>>>>             data[3:] = [s[:i], s[i+1:]]
               else:
>>>>>>             data.append('') # Dummy tz
    7:     if len(data) < 5:
>>>>>>         return None
    7:     data = data[:5]
    7:     [dd, mm, yy, tm, tz] = data
    7:     mm = mm.lower()
    7:     if not mm in _monthnames:
    1:         dd, mm = mm, dd.lower()
    1:         if not mm in _monthnames:
>>>>>>             return None
    7:     mm = _monthnames.index(mm)+1
    7:     if mm > 12: mm = mm - 12
    7:     if dd[-1] == ',':
>>>>>>         dd = dd[:-1]
    7:     i = yy.find(':')
    7:     if i > 0:
>>>>>>         yy, tm = tm, yy
    7:     if yy[-1] == ',':
>>>>>>         yy = yy[:-1]
    7:     if not yy[0].isdigit():
>>>>>>         yy, tz = tz, yy
    7:     if tm[-1] == ',':
>>>>>>         tm = tm[:-1]
    7:     tm = tm.split(':')
    7:     if len(tm) == 2:
>>>>>>         [thh, tmm] = tm
>>>>>>         tss = '0'
    7:     elif len(tm) == 3:
    7:         [thh, tmm, tss] = tm
           else:
>>>>>>         return None
    7:     try:
    7:         yy = int(yy)
    7:         dd = int(dd)
    7:         thh = int(thh)
    7:         tmm = int(tmm)
    7:         tss = int(tss)
>>>>>>     except ValueError:
>>>>>>         return None
    7:     tzoffset = None
    7:     tz = tz.upper()
    7:     if tz in _timezones:
    1:         tzoffset = _timezones[tz]
           else:
    6:         try:
    6:             tzoffset = int(tz)
>>>>>>         except ValueError:
>>>>>>             pass
           # Convert a timezone offset into seconds ; -0500 -> -18000
    7:     if tzoffset:
    7:         if tzoffset < 0:
    7:             tzsign = -1
    7:             tzoffset = -tzoffset
               else:
>>>>>>             tzsign = 1
    7:         tzoffset = tzsign * ( (tzoffset//100)*3600 + (tzoffset % 100)*60)
    7:     return (yy, mm, dd, thh, tmm, tss, 0, 1, 0, tzoffset)
       
       
    1: def parsedate(data):
           """Convert a time string to a time tuple."""
    8:     t = parsedate_tz(data)
    8:     if t is None:
    1:         return t
    7:     return t[:9]
       
       
    1: def mktime_tz(data):
           """Turn a 10-tuple as returned by parsedate_tz() into a UTC timestamp."""
>>>>>>     if data[9] is None:
               # No zone info, so localtime is better assumption than GMT
>>>>>>         return time.mktime(data[:8] + (-1,))
           else:
>>>>>>         t = time.mktime(data[:8] + (0,))
>>>>>>         return t - data[9] - time.timezone
       
    1: def formatdate(timeval=None):
           """Returns time format preferred for Internet standards.
       
           Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123
       
           According to RFC 1123, day and month names must always be in
           English.  If not for that, this code could use strftime().  It
           can't because strftime() honors the locale and could generate
           non-English names.
           """
    4:     if timeval is None:
>>>>>>         timeval = time.time()
    4:     timeval = time.gmtime(timeval)
    4:     return "%s, %02d %s %04d %02d:%02d:%02d GMT" % (
    4:             ("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun")[timeval[6]],
    4:             timeval[2],
                   ("Jan", "Feb", "Mar", "Apr", "May", "Jun",
    4:              "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")[timeval[1]-1],
    4:                                 timeval[0], timeval[3], timeval[4], timeval[5])
       
       
       # When used as script, run a small test program.
       # The first command line argument must be a filename containing one
       # message in RFC-822 format.
       
    1: if __name__ == '__main__':
>>>>>>     import sys, os
>>>>>>     file = os.path.join(os.environ['HOME'], 'Mail/inbox/1')
>>>>>>     if sys.argv[1:]: file = sys.argv[1]
>>>>>>     f = open(file, 'r')
>>>>>>     m = Message(f)
>>>>>>     print 'From:', m.getaddr('from')
>>>>>>     print 'To:', m.getaddrlist('to')
>>>>>>     print 'Subject:', m.getheader('subject')
>>>>>>     print 'Date:', m.getheader('date')
>>>>>>     date = m.getdate_tz('date')
>>>>>>     tz = date[-1]
>>>>>>     date = time.localtime(mktime_tz(date))
>>>>>>     if date:
>>>>>>         print 'ParsedDate:', time.asctime(date),
>>>>>>         hhmmss = tz
>>>>>>         hhmm, ss = divmod(hhmmss, 60)
>>>>>>         hh, mm = divmod(hhmm, 60)
>>>>>>         print "%+03d%02d" % (hh, mm),
>>>>>>         if ss: print ".%02d" % ss,
>>>>>>         print
           else:
>>>>>>         print 'ParsedDate:', None
>>>>>>     m.rewindbody()
>>>>>>     n = 0
>>>>>>     while f.readline():
>>>>>>         n += 1
>>>>>>     print 'Lines:', n
>>>>>>     print '-'*70
>>>>>>     print 'len =', len(m)
>>>>>>     if 'Date' in m: print 'Date =', m['Date']
>>>>>>     if 'X-Nonsense' in m: pass
>>>>>>     print 'keys =', m.keys()
>>>>>>     print 'values =', m.values()
>>>>>>     print 'items =', m.items()
