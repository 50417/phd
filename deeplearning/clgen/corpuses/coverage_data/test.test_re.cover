       # -*- coding: utf-8 -*-
    1: from test.test_support import (
           verbose, run_unittest, import_module,
           precisionbigmemtest, _2G, cpython_only,
           captured_stdout, have_unicode, requires_unicode, u,
           check_warnings, check_py3k_warnings)
    1: import locale
    1: import re
    1: from re import Scanner
    1: import sre_constants
    1: import sys
    1: import string
    1: import traceback
    1: from weakref import proxy
       
       
       # Misc tests from Tim Peters' re.doc
       
       # WARNING: Don't change details in these tests if you don't know
       # what you're doing. Some of these tests were carefully modeled to
       # cover most of the code.
       
    1: import unittest
       
    2: class ReTests(unittest.TestCase):
       
    1:     def test_weakref(self):
    1:         s = 'QabbbcR'
    1:         x = re.compile('ab+c')
    1:         y = proxy(x)
    1:         self.assertEqual(x.findall('QabbbcR'), y.findall('QabbbcR'))
       
    1:     def test_search_star_plus(self):
    1:         self.assertEqual(re.search('x*', 'axx').span(0), (0, 0))
    1:         self.assertEqual(re.search('x*', 'axx').span(), (0, 0))
    1:         self.assertEqual(re.search('x+', 'axx').span(0), (1, 3))
    1:         self.assertEqual(re.search('x+', 'axx').span(), (1, 3))
    1:         self.assertIsNone(re.search('x', 'aaa'))
    1:         self.assertEqual(re.match('a*', 'xxx').span(0), (0, 0))
    1:         self.assertEqual(re.match('a*', 'xxx').span(), (0, 0))
    1:         self.assertEqual(re.match('x*', 'xxxa').span(0), (0, 3))
    1:         self.assertEqual(re.match('x*', 'xxxa').span(), (0, 3))
    1:         self.assertIsNone(re.match('a+', 'xxx'))
       
    1:     def bump_num(self, matchobj):
    8:         int_value = int(matchobj.group(0))
    8:         return str(int_value + 1)
       
    1:     def test_basic_re_sub(self):
    1:         self.assertEqual(re.sub("(?i)b+", "x", "bbbb BBBB"), 'x x')
    1:         self.assertEqual(re.sub(r'\d+', self.bump_num, '08.2 -2 23x99y'),
    1:                          '9.3 -3 24x100y')
    1:         self.assertEqual(re.sub(r'\d+', self.bump_num, '08.2 -2 23x99y', 3),
    1:                          '9.3 -3 23x99y')
       
    2:         self.assertEqual(re.sub('.', lambda m: r"\n", 'x'), '\\n')
    1:         self.assertEqual(re.sub('.', r"\n", 'x'), '\n')
       
    1:         s = r"\1\1"
    1:         self.assertEqual(re.sub('(.)', s, 'x'), 'xx')
    1:         self.assertEqual(re.sub('(.)', re.escape(s), 'x'), s)
    2:         self.assertEqual(re.sub('(.)', lambda m: s, 'x'), s)
       
    1:         self.assertEqual(re.sub('(?P<a>x)', '\g<a>\g<a>', 'xx'), 'xxxx')
    1:         self.assertEqual(re.sub('(?P<a>x)', '\g<a>\g<1>', 'xx'), 'xxxx')
    1:         self.assertEqual(re.sub('(?P<unk>x)', '\g<unk>\g<unk>', 'xx'), 'xxxx')
    1:         self.assertEqual(re.sub('(?P<unk>x)', '\g<1>\g<1>', 'xx'), 'xxxx')
       
    1:         self.assertEqual(re.sub('a', r'\t\n\v\r\f\a\b', 'a'), '\t\n\v\r\f\a\b')
    1:         self.assertEqual(re.sub('a', '\t\n\v\r\f\a\b', 'a'), '\t\n\v\r\f\a\b')
    1:         self.assertEqual(re.sub('a', '\t\n\v\r\f\a\b', 'a'),
    1:                          (chr(9)+chr(10)+chr(11)+chr(13)+chr(12)+chr(7)+chr(8)))
   45:         for c in 'cdehijklmopqsuwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ':
   44:             with check_py3k_warnings():
   44:                 self.assertEqual(re.sub('a', '\\' + c, 'a'), '\\' + c)
       
    1:         self.assertEqual(re.sub('^\s*', 'X', 'test'), 'Xtest')
       
    1:     def test_bug_449964(self):
               # fails for group followed by other escape
    1:         self.assertEqual(re.sub(r'(?P<unk>x)', '\g<1>\g<1>\\b', 'xx'),
    1:                          'xx\bxx\b')
       
    1:     def test_bug_449000(self):
               # Test for sub() on escaped characters
    1:         self.assertEqual(re.sub(r'\r\n', r'\n', 'abc\r\ndef\r\n'),
    1:                          'abc\ndef\n')
    1:         self.assertEqual(re.sub('\r\n', r'\n', 'abc\r\ndef\r\n'),
    1:                          'abc\ndef\n')
    1:         self.assertEqual(re.sub(r'\r\n', '\n', 'abc\r\ndef\r\n'),
    1:                          'abc\ndef\n')
    1:         self.assertEqual(re.sub('\r\n', '\n', 'abc\r\ndef\r\n'),
    1:                          'abc\ndef\n')
       
    1:     @requires_unicode
           def test_bug_1140(self):
               # re.sub(x, y, u'') should return u'', not '', and
               # re.sub(x, y, '') should return '', not u''.
               # Also:
               # re.sub(x, y, unicode(x)) should return unicode(y), and
               # re.sub(x, y, str(x)) should return
               #     str(y) if isinstance(y, str) else unicode(y).
    3:         for x in 'x', u'x':
    6:             for y in 'y', u'y':
    4:                 z = re.sub(x, y, u'')
    4:                 self.assertEqual(z, u'')
    4:                 self.assertEqual(type(z), unicode)
                       #
    4:                 z = re.sub(x, y, '')
    4:                 self.assertEqual(z, '')
    4:                 self.assertEqual(type(z), str)
                       #
    4:                 z = re.sub(x, y, unicode(x))
    4:                 self.assertEqual(z, y)
    4:                 self.assertEqual(type(z), unicode)
                       #
    4:                 z = re.sub(x, y, str(x))
    4:                 self.assertEqual(z, y)
    4:                 self.assertEqual(type(z), type(y))
       
    1:     def test_bug_1661(self):
               # Verify that flags do not get silently ignored with compiled patterns
    1:         pattern = re.compile('.')
    1:         self.assertRaises(ValueError, re.match, pattern, 'A', re.I)
    1:         self.assertRaises(ValueError, re.search, pattern, 'A', re.I)
    1:         self.assertRaises(ValueError, re.findall, pattern, 'A', re.I)
    1:         self.assertRaises(ValueError, re.compile, pattern, re.I)
       
    1:     def test_bug_3629(self):
               # A regex that triggered a bug in the sre-code validator
    1:         re.compile("(?P<quote>)(?(quote))")
       
    1:     def test_sub_template_numeric_escape(self):
               # bug 776311 and friends
    1:         self.assertEqual(re.sub('x', r'\0', 'x'), '\0')
    1:         self.assertEqual(re.sub('x', r'\000', 'x'), '\000')
    1:         self.assertEqual(re.sub('x', r'\001', 'x'), '\001')
    1:         self.assertEqual(re.sub('x', r'\008', 'x'), '\0' + '8')
    1:         self.assertEqual(re.sub('x', r'\009', 'x'), '\0' + '9')
    1:         self.assertEqual(re.sub('x', r'\111', 'x'), '\111')
    1:         self.assertEqual(re.sub('x', r'\117', 'x'), '\117')
       
    1:         self.assertEqual(re.sub('x', r'\1111', 'x'), '\1111')
    1:         self.assertEqual(re.sub('x', r'\1111', 'x'), '\111' + '1')
       
    1:         self.assertEqual(re.sub('x', r'\00', 'x'), '\x00')
    1:         self.assertEqual(re.sub('x', r'\07', 'x'), '\x07')
    1:         self.assertEqual(re.sub('x', r'\08', 'x'), '\0' + '8')
    1:         self.assertEqual(re.sub('x', r'\09', 'x'), '\0' + '9')
    1:         self.assertEqual(re.sub('x', r'\0a', 'x'), '\0' + 'a')
       
    1:         self.assertEqual(re.sub('x', r'\400', 'x'), '\0')
    1:         self.assertEqual(re.sub('x', r'\777', 'x'), '\377')
       
    1:         self.assertRaises(re.error, re.sub, 'x', r'\1', 'x')
    1:         self.assertRaises(re.error, re.sub, 'x', r'\8', 'x')
    1:         self.assertRaises(re.error, re.sub, 'x', r'\9', 'x')
    1:         self.assertRaises(re.error, re.sub, 'x', r'\11', 'x')
    1:         self.assertRaises(re.error, re.sub, 'x', r'\18', 'x')
    1:         self.assertRaises(re.error, re.sub, 'x', r'\1a', 'x')
    1:         self.assertRaises(re.error, re.sub, 'x', r'\90', 'x')
    1:         self.assertRaises(re.error, re.sub, 'x', r'\99', 'x')
    1:         self.assertRaises(re.error, re.sub, 'x', r'\118', 'x') # r'\11' + '8'
    1:         self.assertRaises(re.error, re.sub, 'x', r'\11a', 'x')
    1:         self.assertRaises(re.error, re.sub, 'x', r'\181', 'x') # r'\18' + '1'
    1:         self.assertRaises(re.error, re.sub, 'x', r'\800', 'x') # r'\80' + '0'
       
               # in python2.3 (etc), these loop endlessly in sre_parser.py
    1:         self.assertEqual(re.sub('(((((((((((x)))))))))))', r'\11', 'x'), 'x')
    1:         self.assertEqual(re.sub('((((((((((y))))))))))(.)', r'\118', 'xyz'),
    1:                          'xz8')
    1:         self.assertEqual(re.sub('((((((((((y))))))))))(.)', r'\11a', 'xyz'),
    1:                          'xza')
       
    1:     def test_qualified_re_sub(self):
    1:         self.assertEqual(re.sub('a', 'b', 'aaaaa'), 'bbbbb')
    1:         self.assertEqual(re.sub('a', 'b', 'aaaaa', 1), 'baaaa')
       
    1:     def test_bug_114660(self):
    1:         self.assertEqual(re.sub(r'(\S)\s+(\S)', r'\1 \2', 'hello  there'),
    1:                          'hello there')
       
    1:     def test_bug_462270(self):
               # Test for empty sub() behaviour, see SF bug #462270
    1:         self.assertEqual(re.sub('x*', '-', 'abxd'), '-a-b-d-')
    1:         self.assertEqual(re.sub('x+', '-', 'abxd'), 'ab-d')
       
    1:     def test_symbolic_groups(self):
    1:         re.compile('(?P<a>x)(?P=a)(?(a)y)')
    1:         re.compile('(?P<a1>x)(?P=a1)(?(a1)y)')
    1:         self.assertRaises(re.error, re.compile, '(?P<a>)(?P<a>)')
    1:         self.assertRaises(re.error, re.compile, '(?Px)')
    1:         self.assertRaises(re.error, re.compile, '(?P=)')
    1:         self.assertRaises(re.error, re.compile, '(?P=1)')
    1:         self.assertRaises(re.error, re.compile, '(?P=a)')
    1:         self.assertRaises(re.error, re.compile, '(?P=a1)')
    1:         self.assertRaises(re.error, re.compile, '(?P=a.)')
    1:         self.assertRaises(re.error, re.compile, '(?P<)')
    1:         self.assertRaises(re.error, re.compile, '(?P<>)')
    1:         self.assertRaises(re.error, re.compile, '(?P<1>)')
    1:         self.assertRaises(re.error, re.compile, '(?P<a.>)')
    1:         self.assertRaises(re.error, re.compile, '(?())')
    1:         self.assertRaises(re.error, re.compile, '(?(a))')
    1:         self.assertRaises(re.error, re.compile, '(?(1a))')
    1:         self.assertRaises(re.error, re.compile, '(?(a.))')
       
    1:     def test_symbolic_refs(self):
    1:         self.assertRaises(re.error, re.sub, '(?P<a>x)', '\g<a', 'xx')
    1:         self.assertRaises(re.error, re.sub, '(?P<a>x)', '\g<', 'xx')
    1:         self.assertRaises(re.error, re.sub, '(?P<a>x)', '\g', 'xx')
    1:         self.assertRaises(re.error, re.sub, '(?P<a>x)', '\g<a a>', 'xx')
    1:         self.assertRaises(re.error, re.sub, '(?P<a>x)', '\g<>', 'xx')
    1:         self.assertRaises(re.error, re.sub, '(?P<a>x)', '\g<1a1>', 'xx')
    1:         self.assertRaises(IndexError, re.sub, '(?P<a>x)', '\g<ab>', 'xx')
    1:         self.assertRaises(re.error, re.sub, '(?P<a>x)|(?P<b>y)', '\g<b>', 'xx')
    1:         self.assertRaises(re.error, re.sub, '(?P<a>x)|(?P<b>y)', '\\2', 'xx')
    1:         self.assertRaises(re.error, re.sub, '(?P<a>x)', '\g<-1>', 'xx')
       
    1:     def test_re_subn(self):
    1:         self.assertEqual(re.subn("(?i)b+", "x", "bbbb BBBB"), ('x x', 2))
    1:         self.assertEqual(re.subn("b+", "x", "bbbb BBBB"), ('x BBBB', 1))
    1:         self.assertEqual(re.subn("b+", "x", "xyz"), ('xyz', 0))
    1:         self.assertEqual(re.subn("b*", "x", "xyz"), ('xxxyxzx', 4))
    1:         self.assertEqual(re.subn("b*", "x", "xyz", 2), ('xxxyz', 2))
       
    1:     def test_re_split(self):
    1:         self.assertEqual(re.split(":", ":a:b::c"), ['', 'a', 'b', '', 'c'])
    1:         self.assertEqual(re.split(":+", ":a:b::c"), ['', 'a', 'b', 'c'])
    1:         self.assertEqual(re.split("(:+)", ":a:b::c"),
    1:                          ['', ':', 'a', ':', 'b', '::', 'c'])
    1:         self.assertEqual(re.split("(?::+)", ":a:b::c"), ['', 'a', 'b', 'c'])
    1:         self.assertEqual(re.split("(:)+", ":a:b::c"),
    1:                          ['', ':', 'a', ':', 'b', ':', 'c'])
    1:         self.assertEqual(re.split("([b:]+)", ":a:b::c"),
    1:                          ['', ':', 'a', ':b::', 'c'])
    1:         self.assertEqual(re.split("(b)|(:+)", ":a:b::c"),
    1:                          ['', None, ':', 'a', None, ':', '', 'b', None, '',
    1:                           None, '::', 'c'])
    1:         self.assertEqual(re.split("(?:b)|(?::+)", ":a:b::c"),
    1:                          ['', 'a', '', '', 'c'])
       
    1:         for sep, expected in [
    1:             (':*', ['', 'a', 'b', 'c']),
    1:             ('(?::*)', ['', 'a', 'b', 'c']),
    1:             ('(:*)', ['', ':', 'a', ':', 'b', '::', 'c']),
    5:             ('(:)*', ['', ':', 'a', ':', 'b', ':', 'c']),
               ]:
    4:             with check_py3k_warnings(('', FutureWarning)):
    4:                 self.assertEqual(re.split(sep, ':a:b::c'), expected)
       
    1:         for sep, expected in [
    1:             ('', [':a:b::c']),
    1:             (r'\b', [':a:b::c']),
    1:             (r'(?=:)', [':a:b::c']),
    5:             (r'(?<=:)', [':a:b::c']),
               ]:
    4:             with check_py3k_warnings():
    4:                 self.assertEqual(re.split(sep, ':a:b::c'), expected)
       
    1:     def test_qualified_re_split(self):
    1:         self.assertEqual(re.split(":", ":a:b::c", 2), ['', 'a', 'b::c'])
    1:         self.assertEqual(re.split(':', 'a:b:c:d', 2), ['a', 'b', 'c:d'])
    1:         self.assertEqual(re.split("(:)", ":a:b::c", 2),
    1:                          ['', ':', 'a', ':', 'b::c'])
    1:         self.assertEqual(re.split("(:+)", ":a:b::c", 2),
    1:                          ['', ':', 'a', ':', 'b::c'])
    1:         with check_py3k_warnings(('', FutureWarning)):
    1:             self.assertEqual(re.split("(:*)", ":a:b::c", maxsplit=2),
    1:                              ['', ':', 'a', ':', 'b::c'])
       
    1:     def test_re_findall(self):
    1:         self.assertEqual(re.findall(":+", "abc"), [])
    1:         self.assertEqual(re.findall(":+", "a:b::c:::d"), [":", "::", ":::"])
    1:         self.assertEqual(re.findall("(:+)", "a:b::c:::d"), [":", "::", ":::"])
    1:         self.assertEqual(re.findall("(:)(:*)", "a:b::c:::d"), [(":", ""),
    1:                                                                (":", ":"),
    1:                                                                (":", "::")])
       
    1:     def test_bug_117612(self):
    1:         self.assertEqual(re.findall(r"(a|(b))", "aba"),
    1:                          [("a", ""),("b", "b"),("a", "")])
       
    1:     def test_re_match(self):
    1:         self.assertEqual(re.match('a', 'a').groups(), ())
    1:         self.assertEqual(re.match('(a)', 'a').groups(), ('a',))
    1:         self.assertEqual(re.match(r'(a)', 'a').group(0), 'a')
    1:         self.assertEqual(re.match(r'(a)', 'a').group(1), 'a')
    1:         self.assertEqual(re.match(r'(a)', 'a').group(1, 1), ('a', 'a'))
       
    1:         pat = re.compile('((a)|(b))(c)?')
    1:         self.assertEqual(pat.match('a').groups(), ('a', 'a', None, None))
    1:         self.assertEqual(pat.match('b').groups(), ('b', None, 'b', None))
    1:         self.assertEqual(pat.match('ac').groups(), ('a', 'a', None, 'c'))
    1:         self.assertEqual(pat.match('bc').groups(), ('b', None, 'b', 'c'))
    1:         self.assertEqual(pat.match('bc').groups(""), ('b', "", 'b', 'c'))
       
               # A single group
    1:         m = re.match('(a)', 'a')
    1:         self.assertEqual(m.group(0), 'a')
    1:         self.assertEqual(m.group(0), 'a')
    1:         self.assertEqual(m.group(1), 'a')
    1:         self.assertEqual(m.group(1, 1), ('a', 'a'))
       
    1:         pat = re.compile('(?:(?P<a1>a)|(?P<b2>b))(?P<c3>c)?')
    1:         self.assertEqual(pat.match('a').group(1, 2, 3), ('a', None, None))
    1:         self.assertEqual(pat.match('b').group('a1', 'b2', 'c3'),
    1:                          (None, 'b', None))
    1:         self.assertEqual(pat.match('ac').group(1, 'b2', 3), ('a', None, 'c'))
       
    1:     def test_re_groupref_exists(self):
    1:         self.assertEqual(re.match('^(\()?([^()]+)(?(1)\))$', '(a)').groups(),
    1:                          ('(', 'a'))
    1:         self.assertEqual(re.match('^(\()?([^()]+)(?(1)\))$', 'a').groups(),
    1:                          (None, 'a'))
    1:         self.assertIsNone(re.match('^(\()?([^()]+)(?(1)\))$', 'a)'))
    1:         self.assertIsNone(re.match('^(\()?([^()]+)(?(1)\))$', '(a'))
    1:         self.assertEqual(re.match('^(?:(a)|c)((?(1)b|d))$', 'ab').groups(),
    1:                          ('a', 'b'))
    1:         self.assertEqual(re.match('^(?:(a)|c)((?(1)b|d))$', 'cd').groups(),
    1:                          (None, 'd'))
    1:         self.assertEqual(re.match('^(?:(a)|c)((?(1)|d))$', 'cd').groups(),
    1:                          (None, 'd'))
    1:         self.assertEqual(re.match('^(?:(a)|c)((?(1)|d))$', 'a').groups(),
    1:                          ('a', ''))
       
               # Tests for bug #1177831: exercise groups other than the first group
    1:         p = re.compile('(?P<g1>a)(?P<g2>b)?((?(g2)c|d))')
    1:         self.assertEqual(p.match('abc').groups(),
    1:                          ('a', 'b', 'c'))
    1:         self.assertEqual(p.match('ad').groups(),
    1:                          ('a', None, 'd'))
    1:         self.assertIsNone(p.match('abd'))
    1:         self.assertIsNone(p.match('ac'))
       
       
    1:     def test_re_groupref(self):
    1:         self.assertEqual(re.match(r'^(\|)?([^()]+)\1$', '|a|').groups(),
    1:                          ('|', 'a'))
    1:         self.assertEqual(re.match(r'^(\|)?([^()]+)\1?$', 'a').groups(),
    1:                          (None, 'a'))
    1:         self.assertIsNone(re.match(r'^(\|)?([^()]+)\1$', 'a|'))
    1:         self.assertIsNone(re.match(r'^(\|)?([^()]+)\1$', '|a'))
    1:         self.assertEqual(re.match(r'^(?:(a)|c)(\1)$', 'aa').groups(),
    1:                          ('a', 'a'))
    1:         self.assertEqual(re.match(r'^(?:(a)|c)(\1)?$', 'c').groups(),
    1:                          (None, None))
       
    1:     def test_groupdict(self):
    1:         self.assertEqual(re.match('(?P<first>first) (?P<second>second)',
    1:                                   'first second').groupdict(),
    1:                          {'first':'first', 'second':'second'})
       
    1:     def test_expand(self):
    1:         self.assertEqual(re.match("(?P<first>first) (?P<second>second)",
    1:                                   "first second")
    1:                                   .expand(r"\2 \1 \g<second> \g<first>"),
    1:                          "second first second first")
       
    1:     def test_repeat_minmax(self):
    1:         self.assertIsNone(re.match("^(\w){1}$", "abc"))
    1:         self.assertIsNone(re.match("^(\w){1}?$", "abc"))
    1:         self.assertIsNone(re.match("^(\w){1,2}$", "abc"))
    1:         self.assertIsNone(re.match("^(\w){1,2}?$", "abc"))
       
    1:         self.assertEqual(re.match("^(\w){3}$", "abc").group(1), "c")
    1:         self.assertEqual(re.match("^(\w){1,3}$", "abc").group(1), "c")
    1:         self.assertEqual(re.match("^(\w){1,4}$", "abc").group(1), "c")
    1:         self.assertEqual(re.match("^(\w){3,4}?$", "abc").group(1), "c")
    1:         self.assertEqual(re.match("^(\w){3}?$", "abc").group(1), "c")
    1:         self.assertEqual(re.match("^(\w){1,3}?$", "abc").group(1), "c")
    1:         self.assertEqual(re.match("^(\w){1,4}?$", "abc").group(1), "c")
    1:         self.assertEqual(re.match("^(\w){3,4}?$", "abc").group(1), "c")
       
    1:         self.assertIsNone(re.match("^x{1}$", "xxx"))
    1:         self.assertIsNone(re.match("^x{1}?$", "xxx"))
    1:         self.assertIsNone(re.match("^x{1,2}$", "xxx"))
    1:         self.assertIsNone(re.match("^x{1,2}?$", "xxx"))
       
    1:         self.assertTrue(re.match("^x{3}$", "xxx"))
    1:         self.assertTrue(re.match("^x{1,3}$", "xxx"))
    1:         self.assertTrue(re.match("^x{1,4}$", "xxx"))
    1:         self.assertTrue(re.match("^x{3,4}?$", "xxx"))
    1:         self.assertTrue(re.match("^x{3}?$", "xxx"))
    1:         self.assertTrue(re.match("^x{1,3}?$", "xxx"))
    1:         self.assertTrue(re.match("^x{1,4}?$", "xxx"))
    1:         self.assertTrue(re.match("^x{3,4}?$", "xxx"))
       
    1:         self.assertIsNone(re.match("^x{}$", "xxx"))
    1:         self.assertTrue(re.match("^x{}$", "x{}"))
       
    1:     def test_getattr(self):
    1:         self.assertEqual(re.match("(a)", "a").pos, 0)
    1:         self.assertEqual(re.match("(a)", "a").endpos, 1)
    1:         self.assertEqual(re.match("(a)", "a").string, "a")
    1:         self.assertEqual(re.match("(a)", "a").regs, ((0, 1), (0, 1)))
    1:         self.assertTrue(re.match("(a)", "a").re)
       
    1:     def test_special_escapes(self):
    1:         self.assertEqual(re.search(r"\b(b.)\b",
    1:                                    "abcd abc bcd bx").group(1), "bx")
    1:         self.assertEqual(re.search(r"\B(b.)\B",
    1:                                    "abc bcd bc abxd").group(1), "bx")
    1:         self.assertEqual(re.search(r"\b(b.)\b",
    1:                                    "abcd abc bcd bx", re.LOCALE).group(1), "bx")
    1:         self.assertEqual(re.search(r"\B(b.)\B",
    1:                                    "abc bcd bc abxd", re.LOCALE).group(1), "bx")
    1:         if have_unicode:
    1:             self.assertEqual(re.search(r"\b(b.)\b",
    1:                                        "abcd abc bcd bx", re.UNICODE).group(1), "bx")
    1:             self.assertEqual(re.search(r"\B(b.)\B",
    1:                                        "abc bcd bc abxd", re.UNICODE).group(1), "bx")
    1:         self.assertEqual(re.search(r"^abc$", "\nabc\n", re.M).group(0), "abc")
    1:         self.assertEqual(re.search(r"^\Aabc\Z$", "abc", re.M).group(0), "abc")
    1:         self.assertIsNone(re.search(r"^\Aabc\Z$", "\nabc\n", re.M))
    1:         self.assertEqual(re.search(r"\b(b.)\b",
    1:                                    u"abcd abc bcd bx").group(1), "bx")
    1:         self.assertEqual(re.search(r"\B(b.)\B",
    1:                                    u"abc bcd bc abxd").group(1), "bx")
    1:         self.assertEqual(re.search(r"^abc$", u"\nabc\n", re.M).group(0), "abc")
    1:         self.assertEqual(re.search(r"^\Aabc\Z$", u"abc", re.M).group(0), "abc")
    1:         self.assertIsNone(re.search(r"^\Aabc\Z$", u"\nabc\n", re.M))
    1:         self.assertEqual(re.search(r"\d\D\w\W\s\S",
    1:                                    "1aa! a").group(0), "1aa! a")
    1:         self.assertEqual(re.search(r"\d\D\w\W\s\S",
    1:                                    "1aa! a", re.LOCALE).group(0), "1aa! a")
    1:         if have_unicode:
    1:             self.assertEqual(re.search(r"\d\D\w\W\s\S",
    1:                                        "1aa! a", re.UNICODE).group(0), "1aa! a")
       
    1:     def test_other_escapes(self):
    1:         self.assertRaises(re.error, re.compile, "\\")
    1:         self.assertEqual(re.match(r"\(", '(').group(), '(')
    1:         self.assertIsNone(re.match(r"\(", ')'))
    1:         self.assertEqual(re.match(r"\\", '\\').group(), '\\')
    1:         self.assertEqual(re.match(r"[\]]", ']').group(), ']')
    1:         self.assertIsNone(re.match(r"[\]]", '['))
    1:         self.assertEqual(re.match(r"[a\-c]", '-').group(), '-')
    1:         self.assertIsNone(re.match(r"[a\-c]", 'b'))
    1:         self.assertEqual(re.match(r"[\^a]+", 'a^').group(), 'a^')
    1:         self.assertIsNone(re.match(r"[\^a]+", 'b'))
    1:         re.purge()  # for warnings
   36:         for c in 'ceghijklmopquyzCEFGHIJKLMNOPQRTUVXY':
   35:             warn = FutureWarning if c in 'Uu' else DeprecationWarning
   35:             with check_py3k_warnings(('', warn)):
   35:                 self.assertEqual(re.match('\\%c$' % c, c).group(), c)
   35:                 self.assertIsNone(re.match('\\%c' % c, 'a'))
   39:         for c in 'ceghijklmopquyzABCEFGHIJKLMNOPQRTUVXYZ':
   38:             warn = FutureWarning if c in 'Uu' else DeprecationWarning
   38:             with check_py3k_warnings(('', warn)):
   38:                 self.assertEqual(re.match('[\\%c]$' % c, c).group(), c)
   38:                 self.assertIsNone(re.match('[\\%c]' % c, 'a'))
       
    1:     def test_string_boundaries(self):
               # See http://bugs.python.org/issue10713
    1:         self.assertEqual(re.search(r"\b(abc)\b", "abc").group(1),
    1:                          "abc")
               # There's a word boundary at the start of a string.
    1:         self.assertTrue(re.match(r"\b", "abc"))
               # A non-empty string includes a non-boundary zero-length match.
    1:         self.assertTrue(re.search(r"\B", "abc"))
               # There is no non-boundary match at the start of a string.
    1:         self.assertFalse(re.match(r"\B", "abc"))
               # However, an empty string contains no word boundaries, and also no
               # non-boundaries.
    1:         self.assertIsNone(re.search(r"\B", ""))
               # This one is questionable and different from the perlre behaviour,
               # but describes current behavior.
    1:         self.assertIsNone(re.search(r"\b", ""))
               # A single word-character string has two boundaries, but no
               # non-boundary gaps.
    1:         self.assertEqual(len(re.findall(r"\b", "a")), 2)
    1:         self.assertEqual(len(re.findall(r"\B", "a")), 0)
               # If there are no words, there are no boundaries
    1:         self.assertEqual(len(re.findall(r"\b", " ")), 0)
    1:         self.assertEqual(len(re.findall(r"\b", "   ")), 0)
               # Can match around the whitespace.
    1:         self.assertEqual(len(re.findall(r"\B", " ")), 2)
       
    1:     @requires_unicode
           def test_bigcharset(self):
    1:         self.assertEqual(re.match(u(r"([\u2222\u2223])"),
    1:                                   unichr(0x2222)).group(1), unichr(0x2222))
    1:         self.assertEqual(re.match(u(r"([\u2222\u2223])"),
    1:                                   unichr(0x2222), re.UNICODE).group(1), unichr(0x2222))
    1:         r = u'[%s]' % u''.join(map(unichr, range(256, 2**16, 255)))
    1:         self.assertEqual(re.match(r, unichr(0xff01), re.UNICODE).group(), unichr(0xff01))
       
    1:     def test_big_codesize(self):
               # Issue #1160
10002:         r = re.compile('|'.join(('%d'%x for x in range(10000))))
    1:         self.assertTrue(r.match('1000'))
    1:         self.assertTrue(r.match('9999'))
       
    1:     def test_anyall(self):
    1:         self.assertEqual(re.match("a.b", "a\nb", re.DOTALL).group(0),
    1:                          "a\nb")
    1:         self.assertEqual(re.match("a.*b", "a\n\nb", re.DOTALL).group(0),
    1:                          "a\n\nb")
       
    1:     def test_lookahead(self):
    1:         self.assertEqual(re.match("(a(?=\s[^a]))", "a b").group(1), "a")
    1:         self.assertEqual(re.match("(a(?=\s[^a]*))", "a b").group(1), "a")
    1:         self.assertEqual(re.match("(a(?=\s[abc]))", "a b").group(1), "a")
    1:         self.assertEqual(re.match("(a(?=\s[abc]*))", "a bc").group(1), "a")
    1:         self.assertEqual(re.match(r"(a)(?=\s\1)", "a a").group(1), "a")
    1:         self.assertEqual(re.match(r"(a)(?=\s\1*)", "a aa").group(1), "a")
    1:         self.assertEqual(re.match(r"(a)(?=\s(abc|a))", "a a").group(1), "a")
       
    1:         self.assertEqual(re.match(r"(a(?!\s[^a]))", "a a").group(1), "a")
    1:         self.assertEqual(re.match(r"(a(?!\s[abc]))", "a d").group(1), "a")
    1:         self.assertEqual(re.match(r"(a)(?!\s\1)", "a b").group(1), "a")
    1:         self.assertEqual(re.match(r"(a)(?!\s(abc|a))", "a b").group(1), "a")
       
               # Group reference.
    1:         self.assertTrue(re.match(r'(a)b(?=\1)a', 'aba'))
    1:         self.assertIsNone(re.match(r'(a)b(?=\1)c', 'abac'))
               # Named group reference.
    1:         self.assertTrue(re.match(r'(?P<g>a)b(?=(?P=g))a', 'aba'))
    1:         self.assertIsNone(re.match(r'(?P<g>a)b(?=(?P=g))c', 'abac'))
               # Conditional group reference.
    1:         self.assertTrue(re.match(r'(?:(a)|(x))b(?=(?(2)x|c))c', 'abc'))
    1:         self.assertIsNone(re.match(r'(?:(a)|(x))b(?=(?(2)c|x))c', 'abc'))
    1:         self.assertTrue(re.match(r'(?:(a)|(x))b(?=(?(2)x|c))c', 'abc'))
    1:         self.assertIsNone(re.match(r'(?:(a)|(x))b(?=(?(1)b|x))c', 'abc'))
    1:         self.assertTrue(re.match(r'(?:(a)|(x))b(?=(?(1)c|x))c', 'abc'))
               # Group used before defined.
    1:         self.assertTrue(re.match(r'(a)b(?=(?(2)x|c))(c)', 'abc'))
    1:         self.assertIsNone(re.match(r'(a)b(?=(?(2)b|x))(c)', 'abc'))
    1:         self.assertTrue(re.match(r'(a)b(?=(?(1)c|x))(c)', 'abc'))
       
    1:     def test_lookbehind(self):
    1:         self.assertTrue(re.match(r'ab(?<=b)c', 'abc'))
    1:         self.assertIsNone(re.match(r'ab(?<=c)c', 'abc'))
    1:         self.assertIsNone(re.match(r'ab(?<!b)c', 'abc'))
    1:         self.assertTrue(re.match(r'ab(?<!c)c', 'abc'))
               # Group reference.
    1:         with check_warnings(('', RuntimeWarning)):
    1:             re.compile(r'(a)a(?<=\1)c')
               # Named group reference.
    1:         with check_warnings(('', RuntimeWarning)):
    1:             re.compile(r'(?P<g>a)a(?<=(?P=g))c')
               # Conditional group reference.
    1:         with check_warnings(('', RuntimeWarning)):
    1:             re.compile(r'(a)b(?<=(?(1)b|x))c')
               # Group used before defined.
    1:         with check_warnings(('', RuntimeWarning)):
    1:             re.compile(r'(a)b(?<=(?(2)b|x))(c)')
       
    1:     def test_ignore_case(self):
    1:         self.assertEqual(re.match("abc", "ABC", re.I).group(0), "ABC")
    1:         self.assertEqual(re.match("abc", u"ABC", re.I).group(0), "ABC")
    1:         self.assertEqual(re.match(r"(a\s[^a])", "a b", re.I).group(1), "a b")
    1:         self.assertEqual(re.match(r"(a\s[^a]*)", "a bb", re.I).group(1), "a bb")
    1:         self.assertEqual(re.match(r"(a\s[abc])", "a b", re.I).group(1), "a b")
    1:         self.assertEqual(re.match(r"(a\s[abc]*)", "a bb", re.I).group(1), "a bb")
    1:         self.assertEqual(re.match(r"((a)\s\2)", "a a", re.I).group(1), "a a")
    1:         self.assertEqual(re.match(r"((a)\s\2*)", "a aa", re.I).group(1), "a aa")
    1:         self.assertEqual(re.match(r"((a)\s(abc|a))", "a a", re.I).group(1), "a a")
    1:         self.assertEqual(re.match(r"((a)\s(abc|a)*)", "a aa", re.I).group(1), "a aa")
       
    1:         if have_unicode:
    1:             assert u(r'\u212a').lower() == u'k' # 'K'
    1:             self.assertTrue(re.match(ur'K', u(r'\u212a'), re.U | re.I))
    1:             self.assertTrue(re.match(ur'k', u(r'\u212a'), re.U | re.I))
    1:             self.assertTrue(re.match(u(r'\u212a'), u'K', re.U | re.I))
    1:             self.assertTrue(re.match(u(r'\u212a'), u'k', re.U | re.I))
    1:             assert u(r'\u017f').upper() == u'S' # 'ſ'
    1:             self.assertTrue(re.match(ur'S', u(r'\u017f'), re.U | re.I))
    1:             self.assertTrue(re.match(ur's', u(r'\u017f'), re.U | re.I))
    1:             self.assertTrue(re.match(u(r'\u017f'), u'S', re.U | re.I))
    1:             self.assertTrue(re.match(u(r'\u017f'), u's', re.U | re.I))
       
    1:     def test_ignore_case_set(self):
    1:         self.assertTrue(re.match(r'[19A]', 'A', re.I))
    1:         self.assertTrue(re.match(r'[19a]', 'a', re.I))
    1:         self.assertTrue(re.match(r'[19a]', 'A', re.I))
    1:         self.assertTrue(re.match(r'[19A]', 'a', re.I))
    1:         if have_unicode:
    1:             self.assertTrue(re.match(ur'[19A]', u'A', re.U | re.I))
    1:             self.assertTrue(re.match(ur'[19a]', u'a', re.U | re.I))
    1:             self.assertTrue(re.match(ur'[19a]', u'A', re.U | re.I))
    1:             self.assertTrue(re.match(ur'[19A]', u'a', re.U | re.I))
    1:             assert u(r'\u212a').lower() == u'k' # 'K'
    1:             self.assertTrue(re.match(u(r'[19K]'), u(r'\u212a'), re.U | re.I))
    1:             self.assertTrue(re.match(u(r'[19k]'), u(r'\u212a'), re.U | re.I))
    1:             self.assertTrue(re.match(u(r'[19\u212a]'), u'K', re.U | re.I))
    1:             self.assertTrue(re.match(u(r'[19\u212a]'), u'k', re.U | re.I))
    1:             assert u(r'\u017f').upper() == u'S' # 'ſ'
    1:             self.assertTrue(re.match(ur'[19S]', u(r'\u017f'), re.U | re.I))
    1:             self.assertTrue(re.match(ur'[19s]', u(r'\u017f'), re.U | re.I))
    1:             self.assertTrue(re.match(u(r'[19\u017f]'), u'S', re.U | re.I))
    1:             self.assertTrue(re.match(u(r'[19\u017f]'), u's', re.U | re.I))
       
    1:     def test_ignore_case_range(self):
               # Issues #3511, #17381.
    1:         self.assertTrue(re.match(r'[9-a]', '_', re.I))
    1:         self.assertIsNone(re.match(r'[9-A]', '_', re.I))
    1:         self.assertTrue(re.match(r'[\xc0-\xde]', '\xd7', re.I))
    1:         self.assertIsNone(re.match(r'[\xc0-\xde]', '\xf7', re.I))
    1:         self.assertTrue(re.match(r'[\xe0-\xfe]', '\xf7',re.I))
    1:         self.assertIsNone(re.match(r'[\xe0-\xfe]', '\xd7', re.I))
    1:         if have_unicode:
    1:             self.assertTrue(re.match(u(r'[9-a]'), u(r'_'), re.U | re.I))
    1:             self.assertIsNone(re.match(u(r'[9-A]'), u(r'_'), re.U | re.I))
    1:             self.assertTrue(re.match(u(r'[\xc0-\xde]'),
    1:                                      u(r'\xd7'), re.U | re.I))
    1:             self.assertIsNone(re.match(u(r'[\xc0-\xde]'),
    1:                                        u(r'\xf7'), re.U | re.I))
    1:             self.assertTrue(re.match(u(r'[\xe0-\xfe]'),
    1:                                      u(r'\xf7'), re.U | re.I))
    1:             self.assertIsNone(re.match(u(r'[\xe0-\xfe]'),
    1:                                        u(r'\xd7'), re.U | re.I))
    1:             self.assertTrue(re.match(u(r'[\u0430-\u045f]'),
    1:                                      u(r'\u0450'), re.U | re.I))
    1:             self.assertTrue(re.match(u(r'[\u0430-\u045f]'),
    1:                                      u(r'\u0400'), re.U | re.I))
    1:             self.assertTrue(re.match(u(r'[\u0400-\u042f]'),
    1:                                      u(r'\u0450'), re.U | re.I))
    1:             self.assertTrue(re.match(u(r'[\u0400-\u042f]'),
    1:                                      u(r'\u0400'), re.U | re.I))
    1:             if sys.maxunicode > 0xffff:
>>>>>>                 self.assertTrue(re.match(u(r'[\U00010428-\U0001044f]'),
>>>>>>                                          u(r'\U00010428'), re.U | re.I))
>>>>>>                 self.assertTrue(re.match(u(r'[\U00010428-\U0001044f]'),
>>>>>>                                          u(r'\U00010400'), re.U | re.I))
>>>>>>                 self.assertTrue(re.match(u(r'[\U00010400-\U00010427]'),
>>>>>>                                          u(r'\U00010428'), re.U | re.I))
>>>>>>                 self.assertTrue(re.match(u(r'[\U00010400-\U00010427]'),
>>>>>>                                          u(r'\U00010400'), re.U | re.I))
       
    1:             assert u(r'\u212a').lower() == u'k' # 'K'
    1:             self.assertTrue(re.match(ur'[J-M]', u(r'\u212a'), re.U | re.I))
    1:             self.assertTrue(re.match(ur'[j-m]', u(r'\u212a'), re.U | re.I))
    1:             self.assertTrue(re.match(u(r'[\u2129-\u212b]'), u'K', re.U | re.I))
    1:             self.assertTrue(re.match(u(r'[\u2129-\u212b]'), u'k', re.U | re.I))
    1:             assert u(r'\u017f').upper() == u'S' # 'ſ'
    1:             self.assertTrue(re.match(ur'[R-T]', u(r'\u017f'), re.U | re.I))
    1:             self.assertTrue(re.match(ur'[r-t]', u(r'\u017f'), re.U | re.I))
    1:             self.assertTrue(re.match(u(r'[\u017e-\u0180]'), u'S', re.U | re.I))
    1:             self.assertTrue(re.match(u(r'[\u017e-\u0180]'), u's', re.U | re.I))
       
    1:     def test_category(self):
    1:         self.assertEqual(re.match(r"(\s)", " ").group(1), " ")
       
    1:     def test_getlower(self):
    1:         import _sre
    1:         self.assertEqual(_sre.getlower(ord('A'), 0), ord('a'))
    1:         self.assertEqual(_sre.getlower(ord('A'), re.LOCALE), ord('a'))
    1:         if have_unicode:
    1:             self.assertEqual(_sre.getlower(ord('A'), re.UNICODE), ord('a'))
       
    1:         self.assertEqual(re.match("abc", "ABC", re.I).group(0), "ABC")
    1:         self.assertEqual(re.match("abc", u"ABC", re.I).group(0), "ABC")
       
    1:     def test_not_literal(self):
    1:         self.assertEqual(re.search("\s([^a])", " b").group(1), "b")
    1:         self.assertEqual(re.search("\s([^a]*)", " bb").group(1), "bb")
       
    1:     def test_search_coverage(self):
    1:         self.assertEqual(re.search("\s(b)", " b").group(1), "b")
    1:         self.assertEqual(re.search("a\s", "a ").group(0), "a ")
       
    1:     def assertMatch(self, pattern, text, match=None, span=None,
    1:                     matcher=re.match):
  517:         if match is None and span is None:
                   # the pattern matches the whole text
  516:             match = text
  516:             span = (0, len(text))
    1:         elif match is None or span is None:
>>>>>>             raise ValueError('If match is not None, span should be specified '
                                    '(and vice versa).')
  517:         m = matcher(pattern, text)
  517:         self.assertTrue(m)
  517:         self.assertEqual(m.group(), match)
  517:         self.assertEqual(m.span(), span)
       
    1:     @requires_unicode
           def test_re_escape(self):
    1:         alnum_chars = unicode(string.ascii_letters + string.digits)
  258:         p = u''.join(unichr(i) for i in range(256))
  257:         for c in p:
  256:             if c in alnum_chars:
   62:                 self.assertEqual(re.escape(c), c)
  194:             elif c == u'\x00':
    1:                 self.assertEqual(re.escape(c), u'\\000')
                   else:
  193:                 self.assertEqual(re.escape(c), u'\\' + c)
  256:             self.assertMatch(re.escape(c), c)
    1:         self.assertMatch(re.escape(p), p)
       
    1:     def test_re_escape_byte(self):
    1:         alnum_chars = string.ascii_letters + string.digits
  258:         p = ''.join(chr(i) for i in range(256))
  257:         for b in p:
  256:             if b in alnum_chars:
   62:                 self.assertEqual(re.escape(b), b)
  194:             elif b == b'\x00':
    1:                 self.assertEqual(re.escape(b), b'\\000')
                   else:
  193:                 self.assertEqual(re.escape(b), b'\\' + b)
  256:             self.assertMatch(re.escape(b), b)
    1:         self.assertMatch(re.escape(p), p)
       
    1:     @requires_unicode
           def test_re_escape_non_ascii(self):
    1:         s = u(r'xxx\u2620\u2620\u2620xxx')
    1:         s_escaped = re.escape(s)
    1:         self.assertEqual(s_escaped, u(r'xxx\\\u2620\\\u2620\\\u2620xxx'))
    1:         self.assertMatch(s_escaped, s)
    1:         self.assertMatch(u'.%s+.' % re.escape(unichr(0x2620)), s,
    1:                          u(r'x\u2620\u2620\u2620x'), (2, 7), re.search)
       
    1:     def test_re_escape_non_ascii_bytes(self):
    1:         b = b'y\xe2\x98\xa0y\xe2\x98\xa0y'
    1:         b_escaped = re.escape(b)
    1:         self.assertEqual(b_escaped, b'y\\\xe2\\\x98\\\xa0y\\\xe2\\\x98\\\xa0y')
    1:         self.assertMatch(b_escaped, b)
    1:         res = re.findall(re.escape(b'\xe2\x98\xa0'), b)
    1:         self.assertEqual(len(res), 2)
       
    1:     def test_pickling(self):
    1:         import pickle
    1:         self.pickle_test(pickle)
    1:         import cPickle
    1:         self.pickle_test(cPickle)
               # old pickles expect the _compile() reconstructor in sre module
    1:         import_module("sre", deprecated=True)
    1:         from sre import _compile
               # current pickle expects the _compile() reconstructor in re module
    1:         from re import _compile
       
    1:     def pickle_test(self, pickle):
    2:         oldpat = re.compile('a(?:b|(c|e){1,2}?|d)+?(.)')
    8:         for proto in range(pickle.HIGHEST_PROTOCOL + 1):
    6:             pickled = pickle.dumps(oldpat, proto)
    6:             newpat = pickle.loads(pickled)
    6:             self.assertEqual(newpat, oldpat)
       
    1:     def test_constants(self):
    1:         self.assertEqual(re.I, re.IGNORECASE)
    1:         self.assertEqual(re.L, re.LOCALE)
    1:         self.assertEqual(re.M, re.MULTILINE)
    1:         self.assertEqual(re.S, re.DOTALL)
    1:         self.assertEqual(re.X, re.VERBOSE)
       
    1:     def test_flags(self):
    6:         for flag in [re.I, re.M, re.X, re.S, re.L]:
    5:             self.assertTrue(re.compile('^pattern$', flag))
       
    1:     def test_sre_character_literals(self):
    9:         for i in [0, 8, 16, 32, 64, 127, 128, 255]:
    8:             self.assertTrue(re.match(r"\%03o" % i, chr(i)))
    8:             self.assertTrue(re.match(r"\%03o0" % i, chr(i)+"0"))
    8:             self.assertTrue(re.match(r"\%03o8" % i, chr(i)+"8"))
    8:             self.assertTrue(re.match(r"\x%02x" % i, chr(i)))
    8:             self.assertTrue(re.match(r"\x%02x0" % i, chr(i)+"0"))
    8:             self.assertTrue(re.match(r"\x%02xz" % i, chr(i)+"z"))
    1:         self.assertRaises(re.error, re.match, "\911", "")
       
    1:     def test_sre_character_class_literals(self):
    9:         for i in [0, 8, 16, 32, 64, 127, 128, 255]:
    8:             self.assertTrue(re.match(r"[\%03o]" % i, chr(i)))
    8:             self.assertTrue(re.match(r"[\%03o0]" % i, chr(i)))
    8:             self.assertTrue(re.match(r"[\%03o8]" % i, chr(i)))
    8:             self.assertTrue(re.match(r"[\x%02x]" % i, chr(i)))
    8:             self.assertTrue(re.match(r"[\x%02x0]" % i, chr(i)))
    8:             self.assertTrue(re.match(r"[\x%02xz]" % i, chr(i)))
    1:         self.assertRaises(re.error, re.match, "[\911]", "")
       
    1:     def test_bug_113254(self):
    1:         self.assertEqual(re.match(r'(a)|(b)', 'b').start(1), -1)
    1:         self.assertEqual(re.match(r'(a)|(b)', 'b').end(1), -1)
    1:         self.assertEqual(re.match(r'(a)|(b)', 'b').span(1), (-1, -1))
       
    1:     def test_bug_527371(self):
               # bug described in patches 527371/672491
    1:         self.assertIsNone(re.match(r'(a)?a','a').lastindex)
    1:         self.assertEqual(re.match(r'(a)(b)?b','ab').lastindex, 1)
    1:         self.assertEqual(re.match(r'(?P<a>a)(?P<b>b)?b','ab').lastgroup, 'a')
    1:         self.assertEqual(re.match("(?P<a>a(b))", "ab").lastgroup, 'a')
    1:         self.assertEqual(re.match("((a))", "a").lastindex, 1)
       
    1:     def test_bug_545855(self):
               # bug 545855 -- This pattern failed to cause a compile error as it
               # should, instead provoking a TypeError.
    1:         self.assertRaises(re.error, re.compile, 'foo[a-')
       
    1:     def test_bug_418626(self):
               # bugs 418626 at al. -- Testing Greg Chapman's addition of op code
               # SRE_OP_MIN_REPEAT_ONE for eliminating recursion on simple uses of
               # pattern '*?' on a long string.
    1:         self.assertEqual(re.match('.*?c', 10000*'ab'+'cd').end(0), 20001)
    1:         self.assertEqual(re.match('.*?cd', 5000*'ab'+'c'+5000*'ab'+'cde').end(0),
    1:                          20003)
    1:         self.assertEqual(re.match('.*?cd', 20000*'abc'+'de').end(0), 60001)
               # non-simple '*?' still used to hit the recursion limit, before the
               # non-recursive scheme was implemented.
    1:         self.assertEqual(re.search('(a|b)*?c', 10000*'ab'+'cd').end(0), 20001)
       
    1:     @requires_unicode
           def test_bug_612074(self):
    1:         pat=u"["+re.escape(unichr(0x2039))+u"]"
    1:         self.assertEqual(re.compile(pat) and 1, 1)
       
    1:     def test_stack_overflow(self):
               # nasty cases that used to overflow the straightforward recursive
               # implementation of repeated groups.
    1:         self.assertEqual(re.match('(x)*', 50000*'x').group(1), 'x')
    1:         self.assertEqual(re.match('(x)*y', 50000*'x'+'y').group(1), 'x')
    1:         self.assertEqual(re.match('(x)*?y', 50000*'x'+'y').group(1), 'x')
       
    1:     def test_unlimited_zero_width_repeat(self):
               # Issue #9669
    1:         self.assertIsNone(re.match(r'(?:a?)*y', 'z'))
    1:         self.assertIsNone(re.match(r'(?:a?)+y', 'z'))
    1:         self.assertIsNone(re.match(r'(?:a?){2,}y', 'z'))
    1:         self.assertIsNone(re.match(r'(?:a?)*?y', 'z'))
    1:         self.assertIsNone(re.match(r'(?:a?)+?y', 'z'))
    1:         self.assertIsNone(re.match(r'(?:a?){2,}?y', 'z'))
       
    1:     def test_scanner(self):
    4:         def s_ident(scanner, token): return token
    5:         def s_operator(scanner, token): return "op%s" % token
    2:         def s_float(scanner, token): return float(token)
    2:         def s_int(scanner, token): return int(token)
       
    1:         scanner = Scanner([
    1:             (r"[a-zA-Z_]\w*", s_ident),
    1:             (r"\d+\.\d*", s_float),
    1:             (r"\d+", s_int),
    1:             (r"=|\+|-|\*|/", s_operator),
    1:             (r"\s+", None),
                   ])
       
    1:         self.assertTrue(scanner.scanner.scanner("").pattern)
       
    1:         self.assertEqual(scanner.scan("sum = 3*foo + 312.50 + bar"),
    1:                          (['sum', 'op=', 3, 'op*', 'foo', 'op+', 312.5,
    1:                            'op+', 'bar'], ''))
       
    1:     def test_bug_448951(self):
               # bug 448951 (similar to 429357, but with single char match)
               # (Also test greedy matches.)
    4:         for op in '','?','*':
    3:             self.assertEqual(re.match(r'((.%s):)?z'%op, 'z').groups(),
    3:                              (None, None))
    3:             self.assertEqual(re.match(r'((.%s):)?z'%op, 'a:z').groups(),
    3:                              ('a:', 'a'))
       
    1:     def test_bug_725106(self):
               # capturing groups in alternatives in repeats
    1:         self.assertEqual(re.match('^((a)|b)*', 'abc').groups(),
    1:                          ('b', 'a'))
    1:         self.assertEqual(re.match('^(([ab])|c)*', 'abc').groups(),
    1:                          ('c', 'b'))
    1:         self.assertEqual(re.match('^((d)|[ab])*', 'abc').groups(),
    1:                          ('b', None))
    1:         self.assertEqual(re.match('^((a)c|[ab])*', 'abc').groups(),
    1:                          ('b', None))
    1:         self.assertEqual(re.match('^((a)|b)*?c', 'abc').groups(),
    1:                          ('b', 'a'))
    1:         self.assertEqual(re.match('^(([ab])|c)*?d', 'abcd').groups(),
    1:                          ('c', 'b'))
    1:         self.assertEqual(re.match('^((d)|[ab])*?c', 'abc').groups(),
    1:                          ('b', None))
    1:         self.assertEqual(re.match('^((a)c|[ab])*?c', 'abc').groups(),
    1:                          ('b', None))
       
    1:     def test_bug_725149(self):
               # mark_stack_base restoring before restoring marks
    1:         self.assertEqual(re.match('(a)(?:(?=(b)*)c)*', 'abb').groups(),
    1:                          ('a', None))
    1:         self.assertEqual(re.match('(a)((?!(b)*))*', 'abb').groups(),
    1:                          ('a', None, None))
       
    1:     @requires_unicode
           def test_bug_764548(self):
               # bug 764548, re.compile() barfs on str/unicode subclasses
    2:         class my_unicode(unicode): pass
    1:         pat = re.compile(my_unicode("abc"))
    1:         self.assertIsNone(pat.match("xyz"))
       
    1:     def test_finditer(self):
    1:         iter = re.finditer(r":+", "a:b::c:::d")
    4:         self.assertEqual([item.group(0) for item in iter],
    1:                          [":", "::", ":::"])
       
    1:     @requires_unicode
           def test_bug_926075(self):
    1:         self.assertIsNot(re.compile('bug_926075'),
    1:                          re.compile(u'bug_926075'))
       
    1:     @requires_unicode
           def test_bug_931848(self):
    1:         pattern = u(r"[\u002E\u3002\uFF0E\uFF61]")
    1:         self.assertEqual(re.compile(pattern).split("a.b.c"),
    1:                          ['a','b','c'])
       
    1:     def test_bug_581080(self):
    1:         iter = re.finditer(r"\s", "a b")
    1:         self.assertEqual(iter.next().span(), (1,2))
    1:         self.assertRaises(StopIteration, iter.next)
       
    1:         scanner = re.compile(r"\s").scanner("a b")
    1:         self.assertEqual(scanner.search().span(), (1, 2))
    1:         self.assertIsNone(scanner.search())
       
    1:     def test_bug_817234(self):
    1:         iter = re.finditer(r".*", "asdf")
    1:         self.assertEqual(iter.next().span(), (0, 4))
    1:         self.assertEqual(iter.next().span(), (4, 4))
    1:         self.assertRaises(StopIteration, iter.next)
       
    1:     @requires_unicode
           def test_bug_6561(self):
               # '\d' should match characters in Unicode category 'Nd'
               # (Number, Decimal Digit), but not those in 'Nl' (Number,
               # Letter) or 'No' (Number, Other).
               decimal_digits = [
    1:             unichr(0x0037), # '\N{DIGIT SEVEN}', category 'Nd'
    1:             unichr(0x0e58), # '\N{THAI DIGIT SIX}', category 'Nd'
    1:             unichr(0xff10), # '\N{FULLWIDTH DIGIT ZERO}', category 'Nd'
                   ]
    4:         for x in decimal_digits:
    3:             self.assertEqual(re.match('^\d$', x, re.UNICODE).group(0), x)
       
               not_decimal_digits = [
    1:             unichr(0x2165), # '\N{ROMAN NUMERAL SIX}', category 'Nl'
    1:             unichr(0x3039), # '\N{HANGZHOU NUMERAL TWENTY}', category 'Nl'
    1:             unichr(0x2082), # '\N{SUBSCRIPT TWO}', category 'No'
    1:             unichr(0x32b4), # '\N{CIRCLED NUMBER THIRTY NINE}', category 'No'
                   ]
    5:         for x in not_decimal_digits:
    4:             self.assertIsNone(re.match('^\d$', x, re.UNICODE))
       
    1:     def test_empty_array(self):
               # SF buf 1647541
    1:         import array
    1:         typecodes = 'cbBhHiIlLfd'
    1:         if have_unicode:
    1:             typecodes += 'u'
   13:         for typecode in typecodes:
   12:             a = array.array(typecode)
   12:             self.assertIsNone(re.compile("bla").match(a))
   12:             self.assertEqual(re.compile("").match(a).groups(), ())
       
    1:     @requires_unicode
           def test_inline_flags(self):
               # Bug #1700
    1:         upper_char = unichr(0x1ea0) # Latin Capital Letter A with Dot Bellow
    1:         lower_char = unichr(0x1ea1) # Latin Small Letter A with Dot Bellow
       
    1:         p = re.compile(upper_char, re.I | re.U)
    1:         q = p.match(lower_char)
    1:         self.assertTrue(q)
       
    1:         p = re.compile(lower_char, re.I | re.U)
    1:         q = p.match(upper_char)
    1:         self.assertTrue(q)
       
    1:         p = re.compile('(?i)' + upper_char, re.U)
    1:         q = p.match(lower_char)
    1:         self.assertTrue(q)
       
    1:         p = re.compile('(?i)' + lower_char, re.U)
    1:         q = p.match(upper_char)
    1:         self.assertTrue(q)
       
    1:         p = re.compile('(?iu)' + upper_char)
    1:         q = p.match(lower_char)
    1:         self.assertTrue(q)
       
    1:         p = re.compile('(?iu)' + lower_char)
    1:         q = p.match(upper_char)
    1:         self.assertTrue(q)
       
    1:         self.assertTrue(re.match('(?ixu) ' + upper_char, lower_char))
    1:         self.assertTrue(re.match('(?ixu) ' + lower_char, upper_char))
       
               # Incompatibilities
    1:         re.purge()
    1:         with check_py3k_warnings():
    1:             re.compile('', re.LOCALE|re.UNICODE)
    1:         with check_py3k_warnings():
    1:             re.compile('(?L)', re.UNICODE)
    1:         with check_py3k_warnings():
    1:             re.compile('(?u)', re.LOCALE)
    1:         with check_py3k_warnings():
    1:             re.compile('(?Lu)')
    1:         with check_py3k_warnings():
    1:             re.compile('(?uL)')
       
    1:     def test_dollar_matches_twice(self):
               "$ matches the end of string, and just before the terminating \n"
    1:         pattern = re.compile('$')
    1:         self.assertEqual(pattern.sub('#', 'a\nb\n'), 'a\nb#\n#')
    1:         self.assertEqual(pattern.sub('#', 'a\nb\nc'), 'a\nb\nc#')
    1:         self.assertEqual(pattern.sub('#', '\n'), '#\n#')
       
    1:         pattern = re.compile('$', re.MULTILINE)
    1:         self.assertEqual(pattern.sub('#', 'a\nb\n' ), 'a#\nb#\n#' )
    1:         self.assertEqual(pattern.sub('#', 'a\nb\nc'), 'a#\nb#\nc#')
    1:         self.assertEqual(pattern.sub('#', '\n'), '#\n#')
       
    1:     def test_dealloc(self):
               # issue 3299: check for segfault in debug build
    1:         import _sre
               # the overflow limit is different on wide and narrow builds and it
               # depends on the definition of SRE_CODE (see sre.h).
               # 2**128 should be big enough to overflow on both. For smaller values
               # a RuntimeError is raised instead of OverflowError.
    1:         long_overflow = 2**128
    1:         self.assertRaises(TypeError, re.finditer, "a", {})
    1:         self.assertRaises(OverflowError, _sre.compile, "abc", 0, [long_overflow])
       
    1:     def test_compile(self):
               # Test return value when given string and pattern as parameter
    1:         pattern = re.compile('random pattern')
    1:         self.assertIsInstance(pattern, re._pattern_type)
    1:         same_pattern = re.compile(pattern)
    1:         self.assertIsInstance(same_pattern, re._pattern_type)
    1:         self.assertIs(same_pattern, pattern)
               # Test behaviour when not given a string or pattern as parameter
    1:         self.assertRaises(TypeError, re.compile, 0)
       
    1:     def test_bug_13899(self):
               # Issue #13899: re pattern r"[\A]" should work like "A" but matches
               # nothing. Ditto B and Z.
    1:         with check_py3k_warnings():
    1:             self.assertEqual(re.findall(r'[\A\B\b\C\Z]', 'AB\bCZ'),
    1:                              ['A', 'B', '\b', 'C', 'Z'])
       
    1:     @precisionbigmemtest(size=_2G, memuse=1)
           def test_large_search(self, size):
               # Issue #10182: indices were 32-bit-truncated.
    1:         s = 'a' * size
    1:         m = re.search('$', s)
    1:         self.assertIsNotNone(m)
    1:         self.assertEqual(m.start(), size)
    1:         self.assertEqual(m.end(), size)
       
           # The huge memuse is because of re.sub() using a list and a join()
           # to create the replacement result.
    1:     @precisionbigmemtest(size=_2G, memuse=16 + 2)
           def test_large_subn(self, size):
               # Issue #10182: indices were 32-bit-truncated.
    1:         s = 'a' * size
    1:         r, n = re.subn('', '', s)
    1:         self.assertEqual(r, s)
    1:         self.assertEqual(n, size + 1)
       
       
    1:     def test_repeat_minmax_overflow(self):
               # Issue #13169
    1:         string = "x" * 100000
    1:         self.assertEqual(re.match(r".{65535}", string).span(), (0, 65535))
    1:         self.assertEqual(re.match(r".{,65535}", string).span(), (0, 65535))
    1:         self.assertEqual(re.match(r".{65535,}?", string).span(), (0, 65535))
    1:         self.assertEqual(re.match(r".{65536}", string).span(), (0, 65536))
    1:         self.assertEqual(re.match(r".{,65536}", string).span(), (0, 65536))
    1:         self.assertEqual(re.match(r".{65536,}?", string).span(), (0, 65536))
               # 2**128 should be big enough to overflow both SRE_CODE and Py_ssize_t.
    1:         self.assertRaises(OverflowError, re.compile, r".{%d}" % 2**128)
    1:         self.assertRaises(OverflowError, re.compile, r".{,%d}" % 2**128)
    1:         self.assertRaises(OverflowError, re.compile, r".{%d,}?" % 2**128)
    1:         self.assertRaises(OverflowError, re.compile, r".{%d,%d}" % (2**129, 2**128))
       
    1:     @cpython_only
           def test_repeat_minmax_overflow_maxrepeat(self):
    1:         try:
    1:             from _sre import MAXREPEAT
>>>>>>         except ImportError:
>>>>>>             self.skipTest('requires _sre.MAXREPEAT constant')
    1:         string = "x" * 100000
    1:         self.assertIsNone(re.match(r".{%d}" % (MAXREPEAT - 1), string))
    1:         self.assertEqual(re.match(r".{,%d}" % (MAXREPEAT - 1), string).span(),
    1:                          (0, 100000))
    1:         self.assertIsNone(re.match(r".{%d,}?" % (MAXREPEAT - 1), string))
    1:         self.assertRaises(OverflowError, re.compile, r".{%d}" % MAXREPEAT)
    1:         self.assertRaises(OverflowError, re.compile, r".{,%d}" % MAXREPEAT)
    1:         self.assertRaises(OverflowError, re.compile, r".{%d,}?" % MAXREPEAT)
       
    1:     def test_backref_group_name_in_exception(self):
               # Issue 17341: Poor error message when compiling invalid regex
    1:         with self.assertRaisesRegexp(sre_constants.error, '<foo>'):
    1:             re.compile('(?P=<foo>)')
       
    1:     def test_group_name_in_exception(self):
               # Issue 17341: Poor error message when compiling invalid regex
    1:         with self.assertRaisesRegexp(sre_constants.error, '\?foo'):
    1:             re.compile('(?P<?foo>)')
       
    1:     def test_issue17998(self):
    5:         for reps in '*', '+', '?', '{1}':
   12:             for mod in '', '?':
    8:                 pattern = '.' + reps + mod + 'yz'
    8:                 self.assertEqual(re.compile(pattern, re.S).findall('xyz'),
    8:                                  ['xyz'], msg=pattern)
    8:                 if have_unicode:
    8:                     pattern = unicode(pattern)
    8:                     self.assertEqual(re.compile(pattern, re.S).findall(u'xyz'),
    8:                                      [u'xyz'], msg=pattern)
       
       
    1:     def test_bug_2537(self):
               # issue 2537: empty submatches
    5:         for outer_op in ('{0,}', '*', '+', '{1,187}'):
   16:             for inner_op in ('{0,}', '*', '?'):
   12:                 r = re.compile("^((x|y)%s)%s" % (inner_op, outer_op))
   12:                 m = r.match("xyyzy")
   12:                 self.assertEqual(m.group(0), "xyy")
   12:                 self.assertEqual(m.group(1), "")
   12:                 self.assertEqual(m.group(2), "y")
       
    1:     def test_debug_flag(self):
    1:         pat = r'(\.)(?:[ch]|py)(?(1)$|: )'
    1:         with captured_stdout() as out:
    1:             re.compile(pat, re.DEBUG)
               dump = '''\
       subpattern 1
         literal 46
       subpattern None
         branch
           in
             literal 99
             literal 104
         or
           literal 112
           literal 121
       subpattern None
         groupref_exists 1
           at at_end
         else
           literal 58
           literal 32
    1: '''
    1:         self.assertEqual(out.getvalue(), dump)
               # Debug output is output again even a second time (bypassing
               # the cache -- issue #20426).
    1:         with captured_stdout() as out:
    1:             re.compile(pat, re.DEBUG)
    1:         self.assertEqual(out.getvalue(), dump)
       
    1:     def test_keyword_parameters(self):
               # Issue #20283: Accepting the string keyword parameter.
    1:         pat = re.compile(r'(ab)')
    1:         self.assertEqual(
    1:             pat.match(string='abracadabra', pos=7, endpos=10).span(), (7, 9))
    1:         self.assertEqual(
    1:             pat.search(string='abracadabra', pos=3, endpos=10).span(), (7, 9))
    1:         self.assertEqual(
    1:             pat.findall(string='abracadabra', pos=3, endpos=10), ['ab'])
    1:         self.assertEqual(
    1:             pat.split(string='abracadabra', maxsplit=1),
    1:             ['', 'ab', 'racadabra'])
       
    1:     def test_match_group_takes_long(self):
    1:         self.assertEqual(re.match("(foo)", "foo").group(1L), "foo")
    1:         self.assertRaises(IndexError, re.match("", "").group, sys.maxint + 1)
       
    1:     def test_locale_caching(self):
               # Issue #22410
    1:         oldlocale = locale.setlocale(locale.LC_CTYPE)
    1:         self.addCleanup(locale.setlocale, locale.LC_CTYPE, oldlocale)
    1:         for loc in 'en_US.iso88591', 'en_US.utf8':
    1:             try:
    1:                 locale.setlocale(locale.LC_CTYPE, loc)
    1:             except locale.Error:
                       # Unsupported locale on this system
    1:                 self.skipTest('test needs %s locale' % loc)
       
>>>>>>         re.purge()
>>>>>>         self.check_en_US_iso88591()
>>>>>>         self.check_en_US_utf8()
>>>>>>         re.purge()
>>>>>>         self.check_en_US_utf8()
>>>>>>         self.check_en_US_iso88591()
       
    1:     def check_en_US_iso88591(self):
>>>>>>         locale.setlocale(locale.LC_CTYPE, 'en_US.iso88591')
>>>>>>         self.assertTrue(re.match(b'\xc5\xe5', b'\xc5\xe5', re.L|re.I))
>>>>>>         self.assertTrue(re.match(b'\xc5', b'\xe5', re.L|re.I))
>>>>>>         self.assertTrue(re.match(b'\xe5', b'\xc5', re.L|re.I))
>>>>>>         self.assertTrue(re.match(b'(?Li)\xc5\xe5', b'\xc5\xe5'))
>>>>>>         self.assertTrue(re.match(b'(?Li)\xc5', b'\xe5'))
>>>>>>         self.assertTrue(re.match(b'(?Li)\xe5', b'\xc5'))
       
    1:     def check_en_US_utf8(self):
>>>>>>         locale.setlocale(locale.LC_CTYPE, 'en_US.utf8')
>>>>>>         self.assertTrue(re.match(b'\xc5\xe5', b'\xc5\xe5', re.L|re.I))
>>>>>>         self.assertIsNone(re.match(b'\xc5', b'\xe5', re.L|re.I))
>>>>>>         self.assertIsNone(re.match(b'\xe5', b'\xc5', re.L|re.I))
>>>>>>         self.assertTrue(re.match(b'(?Li)\xc5\xe5', b'\xc5\xe5'))
>>>>>>         self.assertIsNone(re.match(b'(?Li)\xc5', b'\xe5'))
>>>>>>         self.assertIsNone(re.match(b'(?Li)\xe5', b'\xc5'))
       
       
    1: def run_re_tests():
    1:     from test.re_tests import tests, SUCCEED, FAIL, SYNTAX_ERROR
    1:     if verbose:
>>>>>>         print 'Running re_tests test suite'
           else:
               # To save time, only run the first and last 10 tests
               #tests = tests[:10] + tests[-10:]
               pass
       
  509:     for t in tests:
  508:         sys.stdout.flush()
  508:         pattern = s = outcome = repl = expected = None
  508:         if len(t) == 5:
  374:             pattern, s, outcome, repl, expected = t
  134:         elif len(t) == 3:
  134:             pattern, s, outcome = t
               else:
>>>>>>             raise ValueError, ('Test tuples should have 3 or 5 fields', t)
       
  508:         try:
  508:             obj = re.compile(pattern)
   45:         except re.error:
   45:             if outcome == SYNTAX_ERROR: pass  # Expected a syntax error
                   else:
>>>>>>                 print '=== Syntax error:', t
>>>>>>         except KeyboardInterrupt: raise KeyboardInterrupt
>>>>>>         except:
>>>>>>             print '*** Unexpected error ***', t
>>>>>>             if verbose:
>>>>>>                 traceback.print_exc(file=sys.stdout)
               else:
  463:             try:
  463:                 result = obj.search(s)
>>>>>>             except re.error, msg:
>>>>>>                 print '=== Unexpected exception', t, repr(msg)
  463:             if outcome == SYNTAX_ERROR:
                       # This should have been a syntax error; forget it.
>>>>>>                 pass
  463:             elif outcome == FAIL:
   96:                 if result is None: pass   # No match, as expected
>>>>>>                 else: print '=== Succeeded incorrectly', t
  367:             elif outcome == SUCCEED:
  367:                 if result is not None:
                           # Matched, as expected, so now we compute the
                           # result string and compare it to our expected result.
  367:                     start, end = result.span(0)
  367:                     vardict={'found': result.group(0),
  367:                              'groups': result.group(),
  367:                              'flags': result.re.flags}
36700:                     for i in range(1, 100):
36333:                         try:
36333:                             gi = result.group(i)
                                   # Special hack because else the string concat fails:
  281:                             if gi is None:
   20:                                 gi = "None"
36052:                         except IndexError:
36052:                             gi = "Error"
36333:                         vardict['g%d' % i] = gi
  371:                     for i in result.re.groupindex.keys():
    4:                         try:
    4:                             gi = result.group(i)
    4:                             if gi is None:
>>>>>>                                 gi = "None"
>>>>>>                         except IndexError:
>>>>>>                             gi = "Error"
    4:                         vardict[i] = gi
  367:                     repl = eval(repl, vardict)
  367:                     if repl != expected:
>>>>>>                         print '=== grouping error', t,
>>>>>>                         print repr(repl) + ' should be ' + repr(expected)
                       else:
>>>>>>                     print '=== Failed incorrectly', t
       
                       # Try the match on a unicode string, and check that it
                       # still succeeds.
  367:                 try:
  367:                     result = obj.search(unicode(s, "latin-1"))
  365:                     if result is None:
>>>>>>                         print '=== Fails on unicode match', t
    2:                 except NameError:
>>>>>>                     continue # 1.5.2
    2:                 except TypeError:
    2:                     continue # unicode test case
       
                       # Try the match on a unicode pattern, and check that it
                       # still succeeds.
  365:                 obj=re.compile(unicode(pattern, "latin-1"))
  365:                 result = obj.search(s)
  365:                 if result is None:
>>>>>>                     print '=== Fails on unicode pattern match', t
       
                       # Try the match with the search area limited to the extent
                       # of the match and see if it still succeeds.  \B will
                       # break (because it won't match at the end or start of a
                       # string), so we'll ignore patterns that feature it.
       
  365:                 if pattern[:2] != '\\B' and pattern[-2:] != '\\B' \
  360:                                and result is not None:
  360:                     obj = re.compile(pattern)
  360:                     result = obj.search(s, result.start(0), result.end(0) + 1)
  360:                     if result is None:
>>>>>>                         print '=== Failed on range-limited match', t
       
                       # Try the match with IGNORECASE enabled, and check that it
                       # still succeeds.
  365:                 obj = re.compile(pattern, re.IGNORECASE)
  365:                 result = obj.search(s)
  365:                 if result is None:
>>>>>>                     print '=== Fails on case-insensitive match', t
       
                       # Try the match with LOCALE enabled, and check that it
                       # still succeeds.
  365:                 obj = re.compile(pattern, re.LOCALE)
  365:                 result = obj.search(s)
  365:                 if result is None:
>>>>>>                     print '=== Fails on locale-sensitive match', t
       
                       # Try the match with UNICODE locale enabled, and check
                       # that it still succeeds.
  365:                 obj = re.compile(pattern, re.UNICODE)
  365:                 result = obj.search(s)
  365:                 if result is None:
>>>>>>                     print '=== Fails on unicode-sensitive match', t
       
    1: def test_main():
    1:     run_unittest(ReTests)
           deprecations = [
    1:         ('bad escape', DeprecationWarning),
           ]
    1:     with check_py3k_warnings(*deprecations):
    1:         run_re_tests()
       
    1: if __name__ == "__main__":
>>>>>>     test_main()
