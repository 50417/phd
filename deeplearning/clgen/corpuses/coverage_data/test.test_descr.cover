    1: import __builtin__
    1: import copy
    1: import gc
    1: import pickle
    1: import sys
    1: import types
    1: import unittest
    1: import warnings
    1: import weakref
       
    1: from copy import deepcopy
    1: from test import test_support
       
       
    1: def func(*args):
>>>>>>     return args
       
       
    2: class OperatorsTest(unittest.TestCase):
       
    1:     def __init__(self, *args, **kwargs):
    8:         unittest.TestCase.__init__(self, *args, **kwargs)
    8:         self.binops = {
    8:             'add': '+',
    8:             'sub': '-',
    8:             'mul': '*',
    8:             'div': '/',
    8:             'divmod': 'divmod',
    8:             'pow': '**',
    8:             'lshift': '<<',
    8:             'rshift': '>>',
    8:             'and': '&',
    8:             'xor': '^',
    8:             'or': '|',
    8:             'cmp': 'cmp',
    8:             'lt': '<',
    8:             'le': '<=',
    8:             'eq': '==',
    8:             'ne': '!=',
    8:             'gt': '>',
    8:             'ge': '>=',
               }
       
  152:         for name, expr in self.binops.items():
  144:             if expr.islower():
   16:                 expr = expr + "(a, b)"
                   else:
  128:                 expr = 'a %s b' % expr
  144:             self.binops[name] = expr
       
    8:         self.unops = {
    8:             'pos': '+',
    8:             'neg': '-',
    8:             'abs': 'abs',
    8:             'invert': '~',
    8:             'int': 'int',
    8:             'long': 'long',
    8:             'float': 'float',
    8:             'oct': 'oct',
    8:             'hex': 'hex',
               }
       
   80:         for name, expr in self.unops.items():
   72:             if expr.islower():
   48:                 expr = expr + "(a)"
                   else:
   24:                 expr = '%s a' % expr
   72:             self.unops[name] = expr
       
    1:     def unop_test(self, a, res, expr="len(a)", meth="__len__"):
   32:         d = {'a': a}
   32:         self.assertEqual(eval(expr, d), res)
   32:         t = type(a)
   32:         m = getattr(t, meth)
       
               # Find method in parent class
   35:         while meth not in t.__dict__:
    3:             t = t.__bases__[0]
               # in some implementations (e.g. PyPy), 'm' can be a regular unbound
               # method object; the getattr() below obtains its underlying function.
   32:         self.assertEqual(getattr(m, 'im_func', m), t.__dict__[meth])
   32:         self.assertEqual(m(a), res)
   32:         bm = getattr(a, meth)
   32:         self.assertEqual(bm(), res)
       
    1:     def binop_test(self, a, b, res, expr="a+b", meth="__add__"):
   64:         d = {'a': a, 'b': b}
       
               # XXX Hack so this passes before 2.3 when -Qnew is specified.
   64:         if meth == "__div__" and 1/2 == 0.5:
>>>>>>             meth = "__truediv__"
       
   64:         if meth == '__divmod__': pass
       
   64:         self.assertEqual(eval(expr, d), res)
   64:         t = type(a)
   64:         m = getattr(t, meth)
   74:         while meth not in t.__dict__:
   10:             t = t.__bases__[0]
               # in some implementations (e.g. PyPy), 'm' can be a regular unbound
               # method object; the getattr() below obtains its underlying function.
   64:         self.assertEqual(getattr(m, 'im_func', m), t.__dict__[meth])
   64:         self.assertEqual(m(a, b), res)
   64:         bm = getattr(a, meth)
   64:         self.assertEqual(bm(b), res)
       
    1:     def ternop_test(self, a, b, c, res, expr="a[b:c]", meth="__getslice__"):
    2:         d = {'a': a, 'b': b, 'c': c}
    2:         self.assertEqual(eval(expr, d), res)
    2:         t = type(a)
    2:         m = getattr(t, meth)
    3:         while meth not in t.__dict__:
    1:             t = t.__bases__[0]
               # in some implementations (e.g. PyPy), 'm' can be a regular unbound
               # method object; the getattr() below obtains its underlying function.
    2:         self.assertEqual(getattr(m, 'im_func', m), t.__dict__[meth])
    2:         self.assertEqual(m(a, b, c), res)
    2:         bm = getattr(a, meth)
    2:         self.assertEqual(bm(b, c), res)
       
    1:     def setop_test(self, a, b, res, stmt="a+=b", meth="__iadd__"):
    4:         d = {'a': deepcopy(a), 'b': b}
    4:         exec stmt in d
    4:         self.assertEqual(d['a'], res)
    4:         t = type(a)
    4:         m = getattr(t, meth)
    6:         while meth not in t.__dict__:
    2:             t = t.__bases__[0]
               # in some implementations (e.g. PyPy), 'm' can be a regular unbound
               # method object; the getattr() below obtains its underlying function.
    4:         self.assertEqual(getattr(m, 'im_func', m), t.__dict__[meth])
    4:         d['a'] = deepcopy(a)
    4:         m(d['a'], b)
    4:         self.assertEqual(d['a'], res)
    4:         d['a'] = deepcopy(a)
    4:         bm = getattr(d['a'], meth)
    4:         bm(b)
    4:         self.assertEqual(d['a'], res)
       
    1:     def set2op_test(self, a, b, c, res, stmt="a[b]=c", meth="__setitem__"):
    4:         d = {'a': deepcopy(a), 'b': b, 'c': c}
    4:         exec stmt in d
    4:         self.assertEqual(d['a'], res)
    4:         t = type(a)
    4:         m = getattr(t, meth)
    6:         while meth not in t.__dict__:
    2:             t = t.__bases__[0]
               # in some implementations (e.g. PyPy), 'm' can be a regular unbound
               # method object; the getattr() below obtains its underlying function.
    4:         self.assertEqual(getattr(m, 'im_func', m), t.__dict__[meth])
    4:         d['a'] = deepcopy(a)
    4:         m(d['a'], b, c)
    4:         self.assertEqual(d['a'], res)
    4:         d['a'] = deepcopy(a)
    4:         bm = getattr(d['a'], meth)
    4:         bm(b, c)
    4:         self.assertEqual(d['a'], res)
       
    1:     def set3op_test(self, a, b, c, d, res, stmt="a[b:c]=d", meth="__setslice__"):
    2:         dictionary = {'a': deepcopy(a), 'b': b, 'c': c, 'd': d}
    2:         exec stmt in dictionary
    2:         self.assertEqual(dictionary['a'], res)
    2:         t = type(a)
    3:         while meth not in t.__dict__:
    1:             t = t.__bases__[0]
    2:         m = getattr(t, meth)
               # in some implementations (e.g. PyPy), 'm' can be a regular unbound
               # method object; the getattr() below obtains its underlying function.
    2:         self.assertEqual(getattr(m, 'im_func', m), t.__dict__[meth])
    2:         dictionary['a'] = deepcopy(a)
    2:         m(dictionary['a'], b, c, d)
    2:         self.assertEqual(dictionary['a'], res)
    2:         dictionary['a'] = deepcopy(a)
    2:         bm = getattr(dictionary['a'], meth)
    2:         bm(b, c, d)
    2:         self.assertEqual(dictionary['a'], res)
       
    1:     def test_lists(self):
               # Testing list operations...
               # Asserts are within individual test methods
    1:         self.binop_test([1], [2], [1,2], "a+b", "__add__")
    1:         self.binop_test([1,2,3], 2, 1, "b in a", "__contains__")
    1:         self.binop_test([1,2,3], 4, 0, "b in a", "__contains__")
    1:         self.binop_test([1,2,3], 1, 2, "a[b]", "__getitem__")
    1:         self.ternop_test([1,2,3], 0, 2, [1,2], "a[b:c]", "__getslice__")
    1:         self.setop_test([1], [2], [1,2], "a+=b", "__iadd__")
    1:         self.setop_test([1,2], 3, [1,2,1,2,1,2], "a*=b", "__imul__")
    1:         self.unop_test([1,2,3], 3, "len(a)", "__len__")
    1:         self.binop_test([1,2], 3, [1,2,1,2,1,2], "a*b", "__mul__")
    1:         self.binop_test([1,2], 3, [1,2,1,2,1,2], "b*a", "__rmul__")
    1:         self.set2op_test([1,2], 1, 3, [1,3], "a[b]=c", "__setitem__")
    1:         self.set3op_test([1,2,3,4], 1, 3, [5,6], [1,5,6,4], "a[b:c]=d",
    1:                         "__setslice__")
       
    1:     def test_dicts(self):
               # Testing dict operations...
    1:         if hasattr(dict, '__cmp__'):   # PyPy has only rich comparison on dicts
    1:             self.binop_test({1:2}, {2:1}, -1, "cmp(a,b)", "__cmp__")
               else:
>>>>>>             self.binop_test({1:2}, {2:1}, True, "a < b", "__lt__")
    1:         self.binop_test({1:2,3:4}, 1, 1, "b in a", "__contains__")
    1:         self.binop_test({1:2,3:4}, 2, 0, "b in a", "__contains__")
    1:         self.binop_test({1:2,3:4}, 1, 2, "a[b]", "__getitem__")
       
    1:         d = {1:2, 3:4}
    1:         l1 = []
    3:         for i in d.keys():
    2:             l1.append(i)
    1:         l = []
    3:         for i in iter(d):
    2:             l.append(i)
    1:         self.assertEqual(l, l1)
    1:         l = []
    3:         for i in d.__iter__():
    2:             l.append(i)
    1:         self.assertEqual(l, l1)
    1:         l = []
    3:         for i in dict.__iter__(d):
    2:             l.append(i)
    1:         self.assertEqual(l, l1)
    1:         d = {1:2, 3:4}
    1:         self.unop_test(d, 2, "len(a)", "__len__")
    1:         self.assertEqual(eval(repr(d), {}), d)
    1:         self.assertEqual(eval(d.__repr__(), {}), d)
    1:         self.set2op_test({1:2,3:4}, 2, 3, {1:2,2:3,3:4}, "a[b]=c",
    1:                         "__setitem__")
       
           # Tests for unary and binary operators
    1:     def number_operators(self, a, b, skip=[]):
    4:         dict = {'a': a, 'b': b}
       
   76:         for name, expr in self.binops.items():
   72:             if name not in skip:
   68:                 name = "__%s__" % name
   68:                 if hasattr(a, name):
   44:                     res = eval(expr, dict)
   44:                     self.binop_test(a, b, res, expr, name)
       
   40:         for name, expr in self.unops.items():
   36:             if name not in skip:
   33:                 name = "__%s__" % name
   33:                 if hasattr(a, name):
   27:                     res = eval(expr, dict)
   27:                     self.unop_test(a, res, expr, name)
       
    1:     def test_ints(self):
               # Testing int operations...
    1:         self.number_operators(100, 3)
               # The following crashes in Python 2.2
    1:         self.assertEqual((1).__nonzero__(), 1)
    1:         self.assertEqual((0).__nonzero__(), 0)
               # This returns 'NotImplemented' in Python 2.2
    2:         class C(int):
    1:             def __add__(self, other):
    1:                 return NotImplemented
    1:         self.assertEqual(C(5L), 5)
    1:         try:
    1:             C() + ""
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("NotImplemented should have caused TypeError")
    1:         try:
    1:             C(sys.maxint+1)
    1:         except OverflowError:
    1:             pass
               else:
>>>>>>             self.fail("should have raised OverflowError")
       
    1:     def test_longs(self):
               # Testing long operations...
    1:         self.number_operators(100L, 3L)
       
    1:     def test_floats(self):
               # Testing float operations...
    1:         self.number_operators(100.0, 3.0)
       
    1:     def test_complexes(self):
               # Testing complex operations...
    1:         self.number_operators(100.0j, 3.0j, skip=['lt', 'le', 'gt', 'ge',
    1:                                                   'int', 'long', 'float'])
       
    2:         class Number(complex):
    1:             __slots__ = ['prec']
    1:             def __new__(cls, *args, **kwds):
    3:                 result = complex.__new__(cls, *args)
    3:                 result.prec = kwds.get('prec', 12)
    3:                 return result
    1:             def __repr__(self):
    3:                 prec = self.prec
    3:                 if self.imag == 0.0:
    3:                     return "%.*g" % (prec, self.real)
>>>>>>                 if self.real == 0.0:
>>>>>>                     return "%.*gj" % (prec, self.imag)
>>>>>>                 return "(%.*g+%.*gj)" % (prec, self.real, prec, self.imag)
    1:             __str__ = __repr__
       
    1:         a = Number(3.14, prec=6)
    1:         self.assertEqual(repr(a), "3.14")
    1:         self.assertEqual(a.prec, 6)
       
    1:         a = Number(a, prec=2)
    1:         self.assertEqual(repr(a), "3.1")
    1:         self.assertEqual(a.prec, 2)
       
    1:         a = Number(234.5)
    1:         self.assertEqual(repr(a), "234.5")
    1:         self.assertEqual(a.prec, 12)
       
    1:     @test_support.impl_detail("the module 'xxsubtype' is internal")
           def test_spam_lists(self):
               # Testing spamlist operations...
    1:         import copy, xxsubtype as spam
       
    1:         def spamlist(l, memo=None):
   35:             import xxsubtype as spam
   35:             return spam.spamlist(l)
       
               # This is an ugly hack:
    1:         copy._deepcopy_dispatch[spam.spamlist] = spamlist
       
    1:         self.binop_test(spamlist([1]), spamlist([2]), spamlist([1,2]), "a+b",
    1:                        "__add__")
    1:         self.binop_test(spamlist([1,2,3]), 2, 1, "b in a", "__contains__")
    1:         self.binop_test(spamlist([1,2,3]), 4, 0, "b in a", "__contains__")
    1:         self.binop_test(spamlist([1,2,3]), 1, 2, "a[b]", "__getitem__")
    1:         self.ternop_test(spamlist([1,2,3]), 0, 2, spamlist([1,2]), "a[b:c]",
    1:                         "__getslice__")
    1:         self.setop_test(spamlist([1]), spamlist([2]), spamlist([1,2]), "a+=b",
    1:                        "__iadd__")
    1:         self.setop_test(spamlist([1,2]), 3, spamlist([1,2,1,2,1,2]), "a*=b",
    1:                        "__imul__")
    1:         self.unop_test(spamlist([1,2,3]), 3, "len(a)", "__len__")
    1:         self.binop_test(spamlist([1,2]), 3, spamlist([1,2,1,2,1,2]), "a*b",
    1:                        "__mul__")
    1:         self.binop_test(spamlist([1,2]), 3, spamlist([1,2,1,2,1,2]), "b*a",
    1:                        "__rmul__")
    1:         self.set2op_test(spamlist([1,2]), 1, 3, spamlist([1,3]), "a[b]=c",
    1:                         "__setitem__")
    1:         self.set3op_test(spamlist([1,2,3,4]), 1, 3, spamlist([5,6]),
    1:                    spamlist([1,5,6,4]), "a[b:c]=d", "__setslice__")
               # Test subclassing
    2:         class C(spam.spamlist):
    2:             def foo(self): return 1
    1:         a = C()
    1:         self.assertEqual(a, [])
    1:         self.assertEqual(a.foo(), 1)
    1:         a.append(100)
    1:         self.assertEqual(a, [100])
    1:         self.assertEqual(a.getstate(), 0)
    1:         a.setstate(42)
    1:         self.assertEqual(a.getstate(), 42)
       
    1:     @test_support.impl_detail("the module 'xxsubtype' is internal")
           def test_spam_dicts(self):
               # Testing spamdict operations...
    1:         import copy, xxsubtype as spam
    1:         def spamdict(d, memo=None):
   13:             import xxsubtype as spam
   13:             sd = spam.spamdict()
   36:             for k, v in d.items():
   23:                 sd[k] = v
   13:             return sd
               # This is an ugly hack:
    1:         copy._deepcopy_dispatch[spam.spamdict] = spamdict
       
    1:         self.binop_test(spamdict({1:2}), spamdict({2:1}), -1, "cmp(a,b)",
    1:                        "__cmp__")
    1:         self.binop_test(spamdict({1:2,3:4}), 1, 1, "b in a", "__contains__")
    1:         self.binop_test(spamdict({1:2,3:4}), 2, 0, "b in a", "__contains__")
    1:         self.binop_test(spamdict({1:2,3:4}), 1, 2, "a[b]", "__getitem__")
    1:         d = spamdict({1:2,3:4})
    1:         l1 = []
    3:         for i in d.keys():
    2:             l1.append(i)
    1:         l = []
    3:         for i in iter(d):
    2:             l.append(i)
    1:         self.assertEqual(l, l1)
    1:         l = []
    3:         for i in d.__iter__():
    2:             l.append(i)
    1:         self.assertEqual(l, l1)
    1:         l = []
    3:         for i in type(spamdict({})).__iter__(d):
    2:             l.append(i)
    1:         self.assertEqual(l, l1)
    1:         straightd = {1:2, 3:4}
    1:         spamd = spamdict(straightd)
    1:         self.unop_test(spamd, 2, "len(a)", "__len__")
    1:         self.unop_test(spamd, repr(straightd), "repr(a)", "__repr__")
    1:         self.set2op_test(spamdict({1:2,3:4}), 2, 3, spamdict({1:2,2:3,3:4}),
    1:                    "a[b]=c", "__setitem__")
               # Test subclassing
    2:         class C(spam.spamdict):
    2:             def foo(self): return 1
    1:         a = C()
    1:         self.assertEqual(a.items(), [])
    1:         self.assertEqual(a.foo(), 1)
    1:         a['foo'] = 'bar'
    1:         self.assertEqual(a.items(), [('foo', 'bar')])
    1:         self.assertEqual(a.getstate(), 0)
    1:         a.setstate(100)
    1:         self.assertEqual(a.getstate(), 100)
       
    2: class ClassPropertiesAndMethods(unittest.TestCase):
       
    1:     def assertHasAttr(self, obj, name):
    1:         self.assertTrue(hasattr(obj, name),
    1:                         '%r has no attribute %r' % (obj, name))
       
    1:     def assertNotHasAttr(self, obj, name):
   25:         self.assertFalse(hasattr(obj, name),
   25:                          '%r has unexpected attribute %r' % (obj, name))
       
    1:     def test_python_dicts(self):
               # Testing Python subclass of dict...
    1:         self.assertTrue(issubclass(dict, dict))
    1:         self.assertIsInstance({}, dict)
    1:         d = dict()
    1:         self.assertEqual(d, {})
    1:         self.assertIs(d.__class__, dict)
    1:         self.assertIsInstance(d, dict)
    2:         class C(dict):
    1:             state = -1
    1:             def __init__(self_local, *a, **kw):
   53:                 if a:
    1:                     self.assertEqual(len(a), 1)
    1:                     self_local.state = a[0]
   53:                 if kw:
    3:                     for k, v in kw.items():
    2:                         self_local[v] = k
    1:             def __getitem__(self, key):
 7504:                 return self.get(key, 0)
    1:             def __setitem__(self_local, key, value):
 2553:                 self.assertIsInstance(key, type(0))
 2553:                 dict.__setitem__(self_local, key, value)
    1:             def setstate(self, state):
    2:                 self.state = state
    1:             def getstate(self):
    3:                 return self.state
    1:         self.assertTrue(issubclass(C, dict))
    1:         a1 = C(12)
    1:         self.assertEqual(a1.state, 12)
    1:         a2 = C(foo=1, bar=2)
    1:         self.assertEqual(a2[1] == 'foo' and a2[2], 'bar')
    1:         a = C()
    1:         self.assertEqual(a.state, -1)
    1:         self.assertEqual(a.getstate(), -1)
    1:         a.setstate(0)
    1:         self.assertEqual(a.state, 0)
    1:         self.assertEqual(a.getstate(), 0)
    1:         a.setstate(10)
    1:         self.assertEqual(a.state, 10)
    1:         self.assertEqual(a.getstate(), 10)
    1:         self.assertEqual(a[42], 0)
    1:         a[42] = 24
    1:         self.assertEqual(a[42], 24)
    1:         N = 50
   51:         for i in range(N):
   50:             a[i] = C()
 2550:             for j in range(N):
 2500:                 a[i][j] = i*j
   51:         for i in range(N):
 2550:             for j in range(N):
 2500:                 self.assertEqual(a[i][j], i*j)
       
    1:     def test_python_lists(self):
               # Testing Python subclass of list...
    2:         class C(list):
    1:             def __getitem__(self, i):
    3:                 return list.__getitem__(self, i) + 100
    1:             def __getslice__(self, i, j):
    1:                 return (i, j)
    1:         a = C()
    1:         a.extend([0,1,2])
    1:         self.assertEqual(a[0], 100)
    1:         self.assertEqual(a[1], 101)
    1:         self.assertEqual(a[2], 102)
    1:         self.assertEqual(a[100:200], (100,200))
       
    1:     def test_metaclass(self):
               # Testing __metaclass__...
    2:         class C:
    1:             __metaclass__ = type
    1:             def __init__(self):
    1:                 self.__state = 0
    1:             def getstate(self):
    2:                 return self.__state
    1:             def setstate(self, state):
    1:                 self.__state = state
    1:         a = C()
    1:         self.assertEqual(a.getstate(), 0)
    1:         a.setstate(10)
    1:         self.assertEqual(a.getstate(), 10)
    2:         class D:
    2:             class __metaclass__(type):
    2:                 def myself(cls): return cls
    1:         self.assertEqual(D.myself(), D)
    1:         d = D()
    1:         self.assertEqual(d.__class__, D)
    2:         class M1(type):
    1:             def __new__(cls, name, bases, dict):
    1:                 dict['__spam__'] = 1
    1:                 return type.__new__(cls, name, bases, dict)
    2:         class C:
    1:             __metaclass__ = M1
    1:         self.assertEqual(C.__spam__, 1)
    1:         c = C()
    1:         self.assertEqual(c.__spam__, 1)
       
    2:         class _instance(object):
    1:             pass
    2:         class M2(object):
    1:             @staticmethod
                   def __new__(cls, name, bases, dict):
    1:                 self = object.__new__(cls)
    1:                 self.name = name
    1:                 self.bases = bases
    1:                 self.dict = dict
    1:                 return self
    1:             def __call__(self):
    1:                 it = _instance()
                       # Early binding of methods
    4:                 for key in self.dict:
    3:                     if key.startswith("__"):
    2:                         continue
    1:                     setattr(it, key, self.dict[key].__get__(it, self))
    1:                 return it
    2:         class C:
    1:             __metaclass__ = M2
    1:             def spam(self):
    1:                 return 42
    1:         self.assertEqual(C.name, 'C')
    1:         self.assertEqual(C.bases, ())
    1:         self.assertIn('spam', C.dict)
    1:         c = C()
    1:         self.assertEqual(c.spam(), 42)
       
               # More metaclass examples
       
    2:         class autosuper(type):
                   # Automatically add __super to the class
                   # This trick only works for dynamic classes
    1:             def __new__(metaclass, name, bases, dict):
    9:                 cls = super(autosuper, metaclass).__new__(metaclass,
    9:                                                           name, bases, dict)
                       # Name mangling for __super removes leading underscores
    9:                 while name[:1] == "_":
>>>>>>                     name = name[1:]
    9:                 if name:
    9:                     name = "_%s__super" % name
                       else:
>>>>>>                     name = "__super"
    9:                 setattr(cls, name, super(cls))
    9:                 return cls
    2:         class A:
    1:             __metaclass__ = autosuper
    1:             def meth(self):
    2:                 return "A"
    2:         class B(A):
    1:             def meth(self):
    2:                 return "B" + self.__super.meth()
    2:         class C(A):
    1:             def meth(self):
    2:                 return "C" + self.__super.meth()
    2:         class D(C, B):
    1:             def meth(self):
    1:                 return "D" + self.__super.meth()
    1:         self.assertEqual(D().meth(), "DCBA")
    2:         class E(B, C):
    1:             def meth(self):
    1:                 return "E" + self.__super.meth()
    1:         self.assertEqual(E().meth(), "EBCA")
       
    2:         class autoproperty(type):
                   # Automatically create property attributes when methods
                   # named _get_x and/or _set_x are found
    1:             def __new__(metaclass, name, bases, dict):
    5:                 hits = {}
   18:                 for key, val in dict.iteritems():
   13:                     if key.startswith("_get_"):
    5:                         key = key[5:]
    5:                         get, set = hits.get(key, (None, None))
    5:                         get = val
    5:                         hits[key] = get, set
    8:                     elif key.startswith("_set_"):
    1:                         key = key[5:]
    1:                         get, set = hits.get(key, (None, None))
    1:                         set = val
    1:                         hits[key] = get, set
   10:                 for key, (get, set) in hits.iteritems():
    5:                     dict[key] = property(get, set)
    5:                 return super(autoproperty, metaclass).__new__(metaclass,
    5:                                                             name, bases, dict)
    2:         class A:
    1:             __metaclass__ = autoproperty
    1:             def _get_x(self):
    2:                 return -self.__x
    1:             def _set_x(self, x):
    1:                 self.__x = -x
    1:         a = A()
    1:         self.assertNotHasAttr(a, "x")
    1:         a.x = 12
    1:         self.assertEqual(a.x, 12)
    1:         self.assertEqual(a._A__x, -12)
       
    2:         class multimetaclass(autoproperty, autosuper):
                   # Merge of multiple cooperating metaclasses
    1:             pass
    2:         class A:
    1:             __metaclass__ = multimetaclass
    1:             def _get_x(self):
    1:                 return "A"
    2:         class B(A):
    1:             def _get_x(self):
    1:                 return "B" + self.__super._get_x()
    2:         class C(A):
    1:             def _get_x(self):
    1:                 return "C" + self.__super._get_x()
    2:         class D(C, B):
    1:             def _get_x(self):
    1:                 return "D" + self.__super._get_x()
    1:         self.assertEqual(D().x, "DCBA")
       
               # Make sure type(x) doesn't call x.__class__.__init__
    2:         class T(type):
    1:             counter = 0
    1:             def __init__(self, *args):
    1:                 T.counter += 1
    2:         class C:
    1:             __metaclass__ = T
    1:         self.assertEqual(T.counter, 1)
    1:         a = C()
    1:         self.assertEqual(type(a), C)
    1:         self.assertEqual(T.counter, 1)
       
    2:         class C(object): pass
    1:         c = C()
    1:         try: c()
    1:         except TypeError: pass
>>>>>>         else: self.fail("calling object w/o call method should raise "
                               "TypeError")
       
               # Testing code to find most derived baseclass
    2:         class A(type):
    1:             def __new__(*args, **kwargs):
    2:                 return type.__new__(*args, **kwargs)
       
    2:         class B(object):
    1:             pass
       
    2:         class C(object):
    1:             __metaclass__ = A
       
               # The most derived metaclass of D is A rather than type.
    2:         class D(B, C):
    1:             pass
       
    1:     def test_module_subclasses(self):
               # Testing Python subclass of module...
    1:         log = []
    1:         MT = type(sys)
    2:         class MM(MT):
    1:             def __init__(self, name):
    1:                 MT.__init__(self, name)
    1:             def __getattribute__(self, name):
    1:                 log.append(("getattr", name))
    1:                 return MT.__getattribute__(self, name)
    1:             def __setattr__(self, name, value):
    1:                 log.append(("setattr", name, value))
    1:                 MT.__setattr__(self, name, value)
    1:             def __delattr__(self, name):
    1:                 log.append(("delattr", name))
    1:                 MT.__delattr__(self, name)
    1:         a = MM("a")
    1:         a.foo = 12
    1:         x = a.foo
    1:         del a.foo
    1:         self.assertEqual(log, [("setattr", "foo", 12),
    1:                                ("getattr", "foo"),
    1:                                ("delattr", "foo")])
       
               # http://python.org/sf/1174712
    1:         try:
    2:             class Module(types.ModuleType, str):
    1:                 pass
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("inheriting from ModuleType and str at the same time "
                             "should fail")
       
    1:     def test_multiple_inheritance(self):
               # Testing multiple inheritance...
    2:         class C(object):
    1:             def __init__(self):
    2:                 self.__state = 0
    1:             def getstate(self):
    4:                 return self.__state
    1:             def setstate(self, state):
    2:                 self.__state = state
    1:         a = C()
    1:         self.assertEqual(a.getstate(), 0)
    1:         a.setstate(10)
    1:         self.assertEqual(a.getstate(), 10)
    2:         class D(dict, C):
    1:             def __init__(self):
    1:                 type({}).__init__(self)
    1:                 C.__init__(self)
    1:         d = D()
    1:         self.assertEqual(d.keys(), [])
    1:         d["hello"] = "world"
    1:         self.assertEqual(d.items(), [("hello", "world")])
    1:         self.assertEqual(d["hello"], "world")
    1:         self.assertEqual(d.getstate(), 0)
    1:         d.setstate(10)
    1:         self.assertEqual(d.getstate(), 10)
    1:         self.assertEqual(D.__mro__, (D, dict, C, object))
       
               # SF bug #442833
    2:         class Node(object):
    1:             def __int__(self):
    4:                 return int(self.foo())
    1:             def foo(self):
    2:                 return "23"
    2:         class Frag(Node, list):
    1:             def foo(self):
    2:                 return "42"
    1:         self.assertEqual(Node().__int__(), 23)
    1:         self.assertEqual(int(Node()), 23)
    1:         self.assertEqual(Frag().__int__(), 42)
    1:         self.assertEqual(int(Frag()), 42)
       
               # MI mixing classic and new-style classes.
       
    2:         class A:
    1:             x = 1
       
    2:         class B(A):
    1:             pass
       
    2:         class C(A):
    1:             x = 2
       
    2:         class D(B, C):
    1:             pass
    1:         self.assertEqual(D.x, 1)
       
               # Classic MRO is preserved for a classic base class.
    2:         class E(D, object):
    1:             pass
    1:         self.assertEqual(E.__mro__, (E, D, B, A, C, object))
    1:         self.assertEqual(E.x, 1)
       
               # But with a mix of classic bases, their MROs are combined using
               # new-style MRO.
    2:         class F(B, C, object):
    1:             pass
    1:         self.assertEqual(F.__mro__, (F, B, C, A, object))
    1:         self.assertEqual(F.x, 2)
       
               # Try something else.
    2:         class C:
    1:             def cmethod(self):
    3:                 return "C a"
    1:             def all_method(self):
>>>>>>                 return "C b"
       
    2:         class M1(C, object):
    1:             def m1method(self):
    2:                 return "M1 a"
    1:             def all_method(self):
    1:                 return "M1 b"
       
    1:         self.assertEqual(M1.__mro__, (M1, C, object))
    1:         m = M1()
    1:         self.assertEqual(m.cmethod(), "C a")
    1:         self.assertEqual(m.m1method(), "M1 a")
    1:         self.assertEqual(m.all_method(), "M1 b")
       
    2:         class D(C):
    1:             def dmethod(self):
    2:                 return "D a"
    1:             def all_method(self):
>>>>>>                 return "D b"
       
    2:         class M2(D, object):
    1:             def m2method(self):
    2:                 return "M2 a"
    1:             def all_method(self):
    1:                 return "M2 b"
       
    1:         self.assertEqual(M2.__mro__, (M2, D, C, object))
    1:         m = M2()
    1:         self.assertEqual(m.cmethod(), "C a")
    1:         self.assertEqual(m.dmethod(), "D a")
    1:         self.assertEqual(m.m2method(), "M2 a")
    1:         self.assertEqual(m.all_method(), "M2 b")
       
    2:         class M3(M1, M2, object):
    1:             def m3method(self):
    1:                 return "M3 a"
    1:             def all_method(self):
    1:                 return "M3 b"
    1:         self.assertEqual(M3.__mro__, (M3, M1, M2, D, C, object))
    1:         m = M3()
    1:         self.assertEqual(m.cmethod(), "C a")
    1:         self.assertEqual(m.dmethod(), "D a")
    1:         self.assertEqual(m.m1method(), "M1 a")
    1:         self.assertEqual(m.m2method(), "M2 a")
    1:         self.assertEqual(m.m3method(), "M3 a")
    1:         self.assertEqual(m.all_method(), "M3 b")
       
    2:         class Classic:
    1:             pass
    1:         try:
    2:             class New(Classic):
    1:                 __metaclass__ = type
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("new class with only classic bases - shouldn't be")
       
    1:     def test_diamond_inheritance(self):
               # Testing multiple inheritance special cases...
    2:         class A(object):
    3:             def spam(self): return "A"
    1:         self.assertEqual(A().spam(), "A")
    2:         class B(A):
    3:             def boo(self): return "B"
    4:             def spam(self): return "B"
    1:         self.assertEqual(B().spam(), "B")
    1:         self.assertEqual(B().boo(), "B")
    2:         class C(A):
    3:             def boo(self): return "C"
    1:         self.assertEqual(C().spam(), "A")
    1:         self.assertEqual(C().boo(), "C")
    2:         class D(B, C): pass
    1:         self.assertEqual(D().spam(), "B")
    1:         self.assertEqual(D().boo(), "B")
    1:         self.assertEqual(D.__mro__, (D, B, C, A, object))
    2:         class E(C, B): pass
    1:         self.assertEqual(E().spam(), "B")
    1:         self.assertEqual(E().boo(), "C")
    1:         self.assertEqual(E.__mro__, (E, C, B, A, object))
               # MRO order disagreement
    1:         try:
    2:             class F(D, E): pass
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("expected MRO order disagreement (F)")
    1:         try:
    2:             class G(E, D): pass
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("expected MRO order disagreement (G)")
       
           # see thread python-dev/2002-October/029035.html
    1:     def test_ex5_from_c3_switch(self):
               # Testing ex5 from C3 switch discussion...
    2:         class A(object): pass
    2:         class B(object): pass
    2:         class C(object): pass
    2:         class X(A): pass
    2:         class Y(A): pass
    2:         class Z(X,B,Y,C): pass
    1:         self.assertEqual(Z.__mro__, (Z, X, B, Y, A, C, object))
       
           # see "A Monotonic Superclass Linearization for Dylan",
           # by Kim Barrett et al. (OOPSLA 1996)
    1:     def test_monotonicity(self):
               # Testing MRO monotonicity...
    2:         class Boat(object): pass
    2:         class DayBoat(Boat): pass
    2:         class WheelBoat(Boat): pass
    2:         class EngineLess(DayBoat): pass
    2:         class SmallMultihull(DayBoat): pass
    2:         class PedalWheelBoat(EngineLess,WheelBoat): pass
    2:         class SmallCatamaran(SmallMultihull): pass
    2:         class Pedalo(PedalWheelBoat,SmallCatamaran): pass
       
    1:         self.assertEqual(PedalWheelBoat.__mro__,
    1:               (PedalWheelBoat, EngineLess, DayBoat, WheelBoat, Boat, object))
    1:         self.assertEqual(SmallCatamaran.__mro__,
    1:               (SmallCatamaran, SmallMultihull, DayBoat, Boat, object))
    1:         self.assertEqual(Pedalo.__mro__,
    1:               (Pedalo, PedalWheelBoat, EngineLess, SmallCatamaran,
    1:                SmallMultihull, DayBoat, WheelBoat, Boat, object))
       
           # see "A Monotonic Superclass Linearization for Dylan",
           # by Kim Barrett et al. (OOPSLA 1996)
    1:     def test_consistency_with_epg(self):
               # Testing consistency with EPG...
    2:         class Pane(object): pass
    2:         class ScrollingMixin(object): pass
    2:         class EditingMixin(object): pass
    2:         class ScrollablePane(Pane,ScrollingMixin): pass
    2:         class EditablePane(Pane,EditingMixin): pass
    2:         class EditableScrollablePane(ScrollablePane,EditablePane): pass
       
    1:         self.assertEqual(EditableScrollablePane.__mro__,
    1:               (EditableScrollablePane, ScrollablePane, EditablePane, Pane,
    1:                 ScrollingMixin, EditingMixin, object))
       
    1:     def test_mro_disagreement(self):
               # Testing error messages for MRO disagreement...
               mro_err_msg = """Cannot create a consistent method resolution
    1: order (MRO) for bases """
       
    1:         def raises(exc, expected, callable, *args):
    4:             try:
    4:                 callable(*args)
    4:             except exc, msg:
                       # the exact msg is generally considered an impl detail
    4:                 if test_support.check_impl_detail():
    4:                     if not str(msg).startswith(expected):
>>>>>>                         self.fail("Message %r, expected %r" %
>>>>>>                                   (str(msg), expected))
                   else:
>>>>>>                 self.fail("Expected %s" % exc)
       
    2:         class A(object): pass
    2:         class B(A): pass
    2:         class C(object): pass
       
               # Test some very simple errors
    1:         raises(TypeError, "duplicate base class A",
    1:                type, "X", (A, A), {})
    1:         raises(TypeError, mro_err_msg,
    1:                type, "X", (A, B), {})
    1:         raises(TypeError, mro_err_msg,
    1:                type, "X", (A, C, B), {})
               # Test a slightly more complex error
    2:         class GridLayout(object): pass
    2:         class HorizontalGrid(GridLayout): pass
    2:         class VerticalGrid(GridLayout): pass
    2:         class HVGrid(HorizontalGrid, VerticalGrid): pass
    2:         class VHGrid(VerticalGrid, HorizontalGrid): pass
    1:         raises(TypeError, mro_err_msg,
    1:                type, "ConfusedGrid", (HVGrid, VHGrid), {})
       
    1:     def test_object_class(self):
               # Testing object class...
    1:         a = object()
    1:         self.assertEqual(a.__class__, object)
    1:         self.assertEqual(type(a), object)
    1:         b = object()
    1:         self.assertNotEqual(a, b)
    1:         self.assertNotHasAttr(a, "foo")
    1:         try:
    1:             a.foo = 12
    1:         except (AttributeError, TypeError):
    1:             pass
               else:
>>>>>>             self.fail("object() should not allow setting a foo attribute")
    1:         self.assertNotHasAttr(object(), "__dict__")
       
    2:         class Cdict(object):
    1:             pass
    1:         x = Cdict()
    1:         self.assertEqual(x.__dict__, {})
    1:         x.foo = 1
    1:         self.assertEqual(x.foo, 1)
    1:         self.assertEqual(x.__dict__, {'foo': 1})
       
    1:     def test_slots(self):
               # Testing __slots__...
>>>>>>         class C0(object):
>>>>>>             __slots__ = []
>>>>>>         x = C0()
>>>>>>         self.assertNotHasAttr(x, "__dict__")
>>>>>>         self.assertNotHasAttr(x, "foo")
       
>>>>>>         class C1(object):
>>>>>>             __slots__ = ['a']
>>>>>>         x = C1()
>>>>>>         self.assertNotHasAttr(x, "__dict__")
>>>>>>         self.assertNotHasAttr(x, "a")
>>>>>>         x.a = 1
>>>>>>         self.assertEqual(x.a, 1)
>>>>>>         x.a = None
>>>>>>         self.assertEqual(x.a, None)
>>>>>>         del x.a
>>>>>>         self.assertNotHasAttr(x, "a")
       
>>>>>>         class C3(object):
>>>>>>             __slots__ = ['a', 'b', 'c']
>>>>>>         x = C3()
>>>>>>         self.assertNotHasAttr(x, "__dict__")
>>>>>>         self.assertNotHasAttr(x, 'a')
>>>>>>         self.assertNotHasAttr(x, 'b')
>>>>>>         self.assertNotHasAttr(x, 'c')
>>>>>>         x.a = 1
>>>>>>         x.b = 2
>>>>>>         x.c = 3
>>>>>>         self.assertEqual(x.a, 1)
>>>>>>         self.assertEqual(x.b, 2)
>>>>>>         self.assertEqual(x.c, 3)
       
>>>>>>         class C4(object):
                   """Validate name mangling"""
>>>>>>             __slots__ = ['__a']
>>>>>>             def __init__(self, value):
>>>>>>                 self.__a = value
>>>>>>             def get(self):
>>>>>>                 return self.__a
>>>>>>         x = C4(5)
>>>>>>         self.assertNotHasAttr(x, '__dict__')
>>>>>>         self.assertNotHasAttr(x, '__a')
>>>>>>         self.assertEqual(x.get(), 5)
>>>>>>         try:
>>>>>>             x.__a = 6
>>>>>>         except AttributeError:
>>>>>>             pass
               else:
>>>>>>             self.fail("Double underscored names not mangled")
       
               # Make sure slot names are proper identifiers
>>>>>>         try:
>>>>>>             class C(object):
>>>>>>                 __slots__ = [None]
>>>>>>         except TypeError:
>>>>>>             pass
               else:
>>>>>>             self.fail("[None] slots not caught")
>>>>>>         try:
>>>>>>             class C(object):
>>>>>>                 __slots__ = ["foo bar"]
>>>>>>         except TypeError:
>>>>>>             pass
               else:
>>>>>>             self.fail("['foo bar'] slots not caught")
>>>>>>         try:
>>>>>>             class C(object):
>>>>>>                 __slots__ = ["foo\0bar"]
>>>>>>         except TypeError:
>>>>>>             pass
               else:
>>>>>>             self.fail("['foo\\0bar'] slots not caught")
>>>>>>         try:
>>>>>>             class C(object):
>>>>>>                 __slots__ = ["1"]
>>>>>>         except TypeError:
>>>>>>             pass
               else:
>>>>>>             self.fail("['1'] slots not caught")
>>>>>>         try:
>>>>>>             class C(object):
>>>>>>                 __slots__ = [""]
>>>>>>         except TypeError:
>>>>>>             pass
               else:
>>>>>>             self.fail("[''] slots not caught")
>>>>>>         class C(object):
>>>>>>             __slots__ = ["a", "a_b", "_a", "A0123456789Z"]
               # XXX(nnorwitz): was there supposed to be something tested
               # from the class above?
       
               # Test a single string is not expanded as a sequence.
>>>>>>         class C(object):
>>>>>>             __slots__ = "abc"
>>>>>>         c = C()
>>>>>>         c.abc = 5
>>>>>>         self.assertEqual(c.abc, 5)
       
    1:     def test_unicode_slots(self):
               # Test unicode slot names
>>>>>>         try:
>>>>>>             unicode
>>>>>>         except NameError:
>>>>>>             self.skipTest('no unicode support')
               else:
                   # Test a single unicode string is not expanded as a sequence.
>>>>>>             class C(object):
>>>>>>                 __slots__ = unicode("abc")
>>>>>>             c = C()
>>>>>>             c.abc = 5
>>>>>>             self.assertEqual(c.abc, 5)
       
                   # _unicode_to_string used to modify slots in certain circumstances
>>>>>>             slots = (unicode("foo"), unicode("bar"))
>>>>>>             class C(object):
>>>>>>                 __slots__ = slots
>>>>>>             x = C()
>>>>>>             x.foo = 5
>>>>>>             self.assertEqual(x.foo, 5)
>>>>>>             self.assertEqual(type(slots[0]), unicode)
                   # this used to leak references
>>>>>>             try:
>>>>>>                 class C(object):
>>>>>>                     __slots__ = [unichr(128)]
>>>>>>             except (TypeError, UnicodeEncodeError):
>>>>>>                 pass
                   else:
>>>>>>                 self.fail("[unichr(128)] slots not caught")
       
               # Test leaks
>>>>>>         class Counted(object):
>>>>>>             counter = 0    # counts the number of instances alive
>>>>>>             def __init__(self):
>>>>>>                 Counted.counter += 1
>>>>>>             def __del__(self):
>>>>>>                 Counted.counter -= 1
>>>>>>         class C(object):
>>>>>>             __slots__ = ['a', 'b', 'c']
>>>>>>         x = C()
>>>>>>         x.a = Counted()
>>>>>>         x.b = Counted()
>>>>>>         x.c = Counted()
>>>>>>         self.assertEqual(Counted.counter, 3)
>>>>>>         del x
>>>>>>         test_support.gc_collect()
>>>>>>         self.assertEqual(Counted.counter, 0)
>>>>>>         class D(C):
>>>>>>             pass
>>>>>>         x = D()
>>>>>>         x.a = Counted()
>>>>>>         x.z = Counted()
>>>>>>         self.assertEqual(Counted.counter, 2)
>>>>>>         del x
>>>>>>         test_support.gc_collect()
>>>>>>         self.assertEqual(Counted.counter, 0)
>>>>>>         class E(D):
>>>>>>             __slots__ = ['e']
>>>>>>         x = E()
>>>>>>         x.a = Counted()
>>>>>>         x.z = Counted()
>>>>>>         x.e = Counted()
>>>>>>         self.assertEqual(Counted.counter, 3)
>>>>>>         del x
>>>>>>         test_support.gc_collect()
>>>>>>         self.assertEqual(Counted.counter, 0)
       
               # Test cyclical leaks [SF bug 519621]
>>>>>>         class F(object):
>>>>>>             __slots__ = ['a', 'b']
>>>>>>         s = F()
>>>>>>         s.a = [Counted(), s]
>>>>>>         self.assertEqual(Counted.counter, 1)
>>>>>>         s = None
>>>>>>         test_support.gc_collect()
>>>>>>         self.assertEqual(Counted.counter, 0)
       
               # Test lookup leaks [SF bug 572567]
>>>>>>         if hasattr(gc, 'get_objects'):
>>>>>>             class G(object):
>>>>>>                 def __cmp__(self, other):
>>>>>>                     return 0
>>>>>>                 __hash__ = None # Silence Py3k warning
>>>>>>             g = G()
>>>>>>             orig_objects = len(gc.get_objects())
>>>>>>             for i in xrange(10):
>>>>>>                 g==g
>>>>>>             new_objects = len(gc.get_objects())
>>>>>>             self.assertEqual(orig_objects, new_objects)
       
>>>>>>         class H(object):
>>>>>>             __slots__ = ['a', 'b']
>>>>>>             def __init__(self):
>>>>>>                 self.a = 1
>>>>>>                 self.b = 2
>>>>>>             def __del__(self_):
>>>>>>                 self.assertEqual(self_.a, 1)
>>>>>>                 self.assertEqual(self_.b, 2)
>>>>>>         with test_support.captured_output('stderr') as s:
>>>>>>             h = H()
>>>>>>             del h
>>>>>>         self.assertEqual(s.getvalue(), '')
       
>>>>>>         class X(object):
>>>>>>             __slots__ = "a"
>>>>>>         with self.assertRaises(AttributeError):
>>>>>>             del X().a
       
    1:     def test_slots_special(self):
               # Testing __dict__ and __weakref__ in __slots__...
>>>>>>         class D(object):
>>>>>>             __slots__ = ["__dict__"]
>>>>>>         a = D()
>>>>>>         self.assertHasAttr(a, "__dict__")
>>>>>>         self.assertNotHasAttr(a, "__weakref__")
>>>>>>         a.foo = 42
>>>>>>         self.assertEqual(a.__dict__, {"foo": 42})
       
>>>>>>         class W(object):
>>>>>>             __slots__ = ["__weakref__"]
>>>>>>         a = W()
>>>>>>         self.assertHasAttr(a, "__weakref__")
>>>>>>         self.assertNotHasAttr(a, "__dict__")
>>>>>>         try:
>>>>>>             a.foo = 42
>>>>>>         except AttributeError:
>>>>>>             pass
               else:
>>>>>>             self.fail("shouldn't be allowed to set a.foo")
       
>>>>>>         class C1(W, D):
>>>>>>             __slots__ = []
>>>>>>         a = C1()
>>>>>>         self.assertHasAttr(a, "__dict__")
>>>>>>         self.assertHasAttr(a, "__weakref__")
>>>>>>         a.foo = 42
>>>>>>         self.assertEqual(a.__dict__, {"foo": 42})
       
>>>>>>         class C2(D, W):
>>>>>>             __slots__ = []
>>>>>>         a = C2()
>>>>>>         self.assertHasAttr(a, "__dict__")
>>>>>>         self.assertHasAttr(a, "__weakref__")
>>>>>>         a.foo = 42
>>>>>>         self.assertEqual(a.__dict__, {"foo": 42})
       
    1:     def test_slots_descriptor(self):
               # Issue2115: slot descriptors did not correctly check
               # the type of the given object
>>>>>>         import abc
>>>>>>         class MyABC:
>>>>>>             __metaclass__ = abc.ABCMeta
>>>>>>             __slots__ = "a"
       
>>>>>>         class Unrelated(object):
>>>>>>             pass
>>>>>>         MyABC.register(Unrelated)
       
>>>>>>         u = Unrelated()
>>>>>>         self.assertIsInstance(u, MyABC)
       
               # This used to crash
>>>>>>         self.assertRaises(TypeError, MyABC.a.__set__, u, 3)
       
    1:     def test_metaclass_cmp(self):
               # See bug 7491.
    2:         class M(type):
    1:             def __cmp__(self, other):
    1:                 return -1
    2:         class X(object):
    1:             __metaclass__ = M
    1:         self.assertTrue(X < M)
       
    1:     def test_dynamics(self):
               # Testing class attribute propagation...
    2:         class D(object):
    1:             pass
    2:         class E(D):
    1:             pass
    2:         class F(D):
    1:             pass
    1:         D.foo = 1
    1:         self.assertEqual(D.foo, 1)
               # Test that dynamic attributes are inherited
    1:         self.assertEqual(E.foo, 1)
    1:         self.assertEqual(F.foo, 1)
               # Test dynamic instances
    2:         class C(object):
    1:             pass
    1:         a = C()
    1:         self.assertNotHasAttr(a, "foobar")
    1:         C.foobar = 2
    1:         self.assertEqual(a.foobar, 2)
    2:         C.method = lambda self: 42
    1:         self.assertEqual(a.method(), 42)
    3:         C.__repr__ = lambda self: "C()"
    1:         self.assertEqual(repr(a), "C()")
    2:         C.__int__ = lambda self: 100
    1:         self.assertEqual(int(a), 100)
    1:         self.assertEqual(a.foobar, 2)
    1:         self.assertNotHasAttr(a, "spam")
    1:         def mygetattr(self, name):
    2:             if name == "spam":
    2:                 return "spam"
>>>>>>             raise AttributeError
    1:         C.__getattr__ = mygetattr
    1:         self.assertEqual(a.spam, "spam")
    1:         a.new = 12
    1:         self.assertEqual(a.new, 12)
    1:         def mysetattr(self, name, value):
    2:             if name == "spam":
    1:                 raise AttributeError
    1:             return object.__setattr__(self, name, value)
    1:         C.__setattr__ = mysetattr
    1:         try:
    1:             a.spam = "not spam"
    1:         except AttributeError:
    1:             pass
               else:
>>>>>>             self.fail("expected AttributeError")
    1:         self.assertEqual(a.spam, "spam")
    2:         class D(C):
    1:             pass
    1:         d = D()
    1:         d.foo = 1
    1:         self.assertEqual(d.foo, 1)
       
               # Test handling of int*seq and seq*int
    2:         class I(int):
    1:             pass
    1:         self.assertEqual("a"*I(2), "aa")
    1:         self.assertEqual(I(2)*"a", "aa")
    1:         self.assertEqual(2*I(3), 6)
    1:         self.assertEqual(I(3)*2, 6)
    1:         self.assertEqual(I(3)*I(2), 6)
       
               # Test handling of long*seq and seq*long
    2:         class L(long):
    1:             pass
    1:         self.assertEqual("a"*L(2L), "aa")
    1:         self.assertEqual(L(2L)*"a", "aa")
    1:         self.assertEqual(2*L(3), 6)
    1:         self.assertEqual(L(3)*2, 6)
    1:         self.assertEqual(L(3)*L(2), 6)
       
               # Test comparison of classes with dynamic metaclasses
    2:         class dynamicmetaclass(type):
    1:             pass
    2:         class someclass:
    1:             __metaclass__ = dynamicmetaclass
    1:         self.assertNotEqual(someclass, object)
       
    1:     def test_errors(self):
               # Testing errors...
    1:         try:
    2:             class C(list, dict):
    1:                 pass
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("inheritance from both list and dict should be illegal")
       
    1:         try:
    2:             class C(object, None):
    1:                 pass
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("inheritance from non-type should be illegal")
    2:         class Classic:
    1:             pass
       
    1:         try:
    2:             class C(type(len)):
    1:                 pass
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("inheritance from CFunction should be illegal")
       
    1:         try:
    2:             class C(object):
    1:                 __slots__ = 1
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("__slots__ = 1 should be illegal")
       
    1:         try:
    2:             class C(object):
    1:                 __slots__ = [1]
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("__slots__ = [1] should be illegal")
       
    2:         class M1(type):
    1:             pass
    2:         class M2(type):
    1:             pass
    2:         class A1(object):
    1:             __metaclass__ = M1
    2:         class A2(object):
    1:             __metaclass__ = M2
    1:         try:
    2:             class B(A1, A2):
    1:                 pass
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("finding the most derived metaclass should have failed")
       
    1:     def test_classmethods(self):
               # Testing class methods...
    2:         class C(object):
   10:             def foo(*a): return a
    1:             goo = classmethod(foo)
    1:         c = C()
    1:         self.assertEqual(C.goo(1), (C, 1))
    1:         self.assertEqual(c.goo(1), (C, 1))
    1:         self.assertEqual(c.foo(1), (c, 1))
    2:         class D(C):
    1:             pass
    1:         d = D()
    1:         self.assertEqual(D.goo(1), (D, 1))
    1:         self.assertEqual(d.goo(1), (D, 1))
    1:         self.assertEqual(d.foo(1), (d, 1))
    1:         self.assertEqual(D.foo(d, 1), (d, 1))
               # Test for a specific crash (SF bug 528132)
    3:         def f(cls, arg): return (cls, arg)
    1:         ff = classmethod(f)
    1:         self.assertEqual(ff.__get__(0, int)(42), (int, 42))
    1:         self.assertEqual(ff.__get__(0)(42), (int, 42))
       
               # Test super() with classmethods (SF bug 535444)
    1:         self.assertEqual(C.goo.im_self, C)
    1:         self.assertEqual(D.goo.im_self, D)
    1:         self.assertEqual(super(D,D).goo.im_self, D)
    1:         self.assertEqual(super(D,d).goo.im_self, D)
    1:         self.assertEqual(super(D,D).goo(), (D,))
    1:         self.assertEqual(super(D,d).goo(), (D,))
       
               # Verify that a non-callable will raise
    1:         meth = classmethod(1).__get__(1)
    1:         self.assertRaises(TypeError, meth)
       
               # Verify that classmethod() doesn't allow keyword args
    1:         try:
    1:             classmethod(f, kw=1)
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("classmethod shouldn't accept keyword args")
       
    1:     @test_support.cpython_only
           def test_classmethod_copy_pickle(self):
    1:         cm = classmethod(func)
    1:         with test_support.check_py3k_warnings(
    1:                 (".*classmethod", DeprecationWarning)):
    1:             copy.copy(cm)
    1:         with test_support.check_py3k_warnings(
    1:                 (".*classmethod", DeprecationWarning)):
    1:             copy.deepcopy(cm)
    3:         for proto in range(2):
    2:             self.assertRaises(TypeError, pickle.dumps, cm, proto)
    1:         with test_support.check_py3k_warnings(
    1:                 (".*classmethod", DeprecationWarning)):
    1:             pickle.dumps(cm, 2)
       
    1:     @test_support.impl_detail("the module 'xxsubtype' is internal")
           def test_classmethods_in_c(self):
               # Testing C-based class methods...
    1:         import xxsubtype as spam
    1:         a = (1, 2, 3)
    1:         d = {'abc': 123}
    1:         x, a1, d1 = spam.spamlist.classmeth(*a, **d)
    1:         self.assertEqual(x, spam.spamlist)
    1:         self.assertEqual(a, a1)
    1:         self.assertEqual(d, d1)
    1:         x, a1, d1 = spam.spamlist().classmeth(*a, **d)
    1:         self.assertEqual(x, spam.spamlist)
    1:         self.assertEqual(a, a1)
    1:         self.assertEqual(d, d1)
    1:         spam_cm = spam.spamlist.__dict__['classmeth']
    1:         x2, a2, d2 = spam_cm(spam.spamlist, *a, **d)
    1:         self.assertEqual(x2, spam.spamlist)
    1:         self.assertEqual(a2, a1)
    1:         self.assertEqual(d2, d1)
    2:         class SubSpam(spam.spamlist): pass
    1:         x2, a2, d2 = spam_cm(SubSpam, *a, **d)
    1:         self.assertEqual(x2, SubSpam)
    1:         self.assertEqual(a2, a1)
    1:         self.assertEqual(d2, d1)
    1:         with self.assertRaises(TypeError):
    1:             spam_cm()
    1:         with self.assertRaises(TypeError):
    1:             spam_cm(spam.spamlist())
    1:         with self.assertRaises(TypeError):
    1:             spam_cm(list)
       
    1:     def test_staticmethods(self):
               # Testing static methods...
>>>>>>         class C(object):
>>>>>>             def foo(*a): return a
>>>>>>             goo = staticmethod(foo)
>>>>>>         c = C()
>>>>>>         self.assertEqual(C.goo(1), (1,))
>>>>>>         self.assertEqual(c.goo(1), (1,))
>>>>>>         self.assertEqual(c.foo(1), (c, 1,))
>>>>>>         class D(C):
>>>>>>             pass
>>>>>>         d = D()
>>>>>>         self.assertEqual(D.goo(1), (1,))
>>>>>>         self.assertEqual(d.goo(1), (1,))
>>>>>>         self.assertEqual(d.foo(1), (d, 1))
>>>>>>         self.assertEqual(D.foo(d, 1), (d, 1))
       
    1:     @test_support.cpython_only
           def test_staticmethod_copy_pickle(self):
>>>>>>         sm = staticmethod(func)
>>>>>>         with test_support.check_py3k_warnings(
>>>>>>                 (".*staticmethod", DeprecationWarning)):
>>>>>>             copy.copy(sm)
>>>>>>         with test_support.check_py3k_warnings(
>>>>>>                 (".*staticmethod", DeprecationWarning)):
>>>>>>             copy.deepcopy(sm)
>>>>>>         for proto in range(2):
>>>>>>             self.assertRaises(TypeError, pickle.dumps, sm, proto)
>>>>>>         with test_support.check_py3k_warnings(
>>>>>>                 (".*staticmethod", DeprecationWarning)):
>>>>>>             pickle.dumps(sm, 2)
       
    1:     @test_support.impl_detail("the module 'xxsubtype' is internal")
           def test_staticmethods_in_c(self):
               # Testing C-based static methods...
>>>>>>         import xxsubtype as spam
>>>>>>         a = (1, 2, 3)
>>>>>>         d = {"abc": 123}
>>>>>>         x, a1, d1 = spam.spamlist.staticmeth(*a, **d)
>>>>>>         self.assertEqual(x, None)
>>>>>>         self.assertEqual(a, a1)
>>>>>>         self.assertEqual(d, d1)
>>>>>>         x, a1, d2 = spam.spamlist().staticmeth(*a, **d)
>>>>>>         self.assertEqual(x, None)
>>>>>>         self.assertEqual(a, a1)
>>>>>>         self.assertEqual(d, d1)
       
    1:     def test_classic(self):
               # Testing classic classes...
    2:         class C:
    8:             def foo(*a): return a
    1:             goo = classmethod(foo)
    1:         c = C()
    1:         self.assertEqual(C.goo(1), (C, 1))
    1:         self.assertEqual(c.goo(1), (C, 1))
    1:         self.assertEqual(c.foo(1), (c, 1))
    2:         class D(C):
    1:             pass
    1:         d = D()
    1:         self.assertEqual(D.goo(1), (D, 1))
    1:         self.assertEqual(d.goo(1), (D, 1))
    1:         self.assertEqual(d.foo(1), (d, 1))
    1:         self.assertEqual(D.foo(d, 1), (d, 1))
    2:         class E: # *not* subclassing from C
    1:             foo = C.foo
    1:         self.assertEqual(E().foo, C.foo) # i.e., unbound
    1:         self.assertTrue(repr(C.foo.__get__(C())).startswith("<bound method "))
       
    1:     def test_compattr(self):
               # Testing computed attributes...
    2:         class C(object):
    2:             class computed_attribute(object):
    1:                 def __init__(self, get, set=None, delete=None):
    1:                     self.__get = get
    1:                     self.__set = set
    1:                     self.__delete = delete
    1:                 def __get__(self, obj, type=None):
    5:                     return self.__get(obj)
    1:                 def __set__(self, obj, value):
    1:                     return self.__set(obj, value)
    1:                 def __delete__(self, obj):
    1:                     return self.__delete(obj)
    1:             def __init__(self):
    1:                 self.__x = 0
    1:             def __get_x(self):
    5:                 x = self.__x
    4:                 self.__x = x+1
    4:                 return x
    1:             def __set_x(self, x):
    1:                 self.__x = x
    1:             def __delete_x(self):
    1:                 del self.__x
    1:             x = computed_attribute(__get_x, __set_x, __delete_x)
    1:         a = C()
    1:         self.assertEqual(a.x, 0)
    1:         self.assertEqual(a.x, 1)
    1:         a.x = 10
    1:         self.assertEqual(a.x, 10)
    1:         self.assertEqual(a.x, 11)
    1:         del a.x
    1:         self.assertNotHasAttr(a, 'x')
       
    1:     def test_newslots(self):
               # Testing __new__ slot override...
    2:         class C(list):
    1:             def __new__(cls):
    2:                 self = list.__new__(cls)
    2:                 self.foo = 1
    2:                 return self
    1:             def __init__(self):
    2:                 self.foo = self.foo + 2
    1:         a = C()
    1:         self.assertEqual(a.foo, 3)
    1:         self.assertEqual(a.__class__, C)
    2:         class D(C):
    1:             pass
    1:         b = D()
    1:         self.assertEqual(b.foo, 3)
    1:         self.assertEqual(b.__class__, D)
       
    1:     @unittest.expectedFailure
           def test_bad_new(self):
    1:         self.assertRaises(TypeError, object.__new__)
    1:         self.assertRaises(TypeError, object.__new__, '')
    1:         self.assertRaises(TypeError, list.__new__, object)
    1:         self.assertRaises(TypeError, object.__new__, list)
    2:         class C(object):
    1:             __new__ = list.__new__
    1:         self.assertRaises(TypeError, C)
>>>>>>         class C(list):
>>>>>>             __new__ = object.__new__
>>>>>>         self.assertRaises(TypeError, C)
       
    1:     def test_object_new(self):
    2:         class A(object):
    1:             pass
    1:         object.__new__(A)
    1:         self.assertRaises(TypeError, object.__new__, A, 5)
    1:         object.__init__(A())
    1:         self.assertRaises(TypeError, object.__init__, A(), 5)
       
    2:         class A(object):
    1:             def __init__(self, foo):
    2:                 self.foo = foo
    1:         object.__new__(A)
    1:         object.__new__(A, 5)
    1:         object.__init__(A(3))
    1:         self.assertRaises(TypeError, object.__init__, A(3), 5)
       
    2:         class A(object):
    1:             def __new__(cls, foo):
    2:                 return object.__new__(cls)
    1:         object.__new__(A)
    1:         self.assertRaises(TypeError, object.__new__, A, 5)
    1:         object.__init__(A(3))
    1:         object.__init__(A(3), 5)
       
    2:         class A(object):
    1:             def __new__(cls, foo):
    2:                 return object.__new__(cls)
    1:             def __init__(self, foo):
    2:                 self.foo = foo
    1:         object.__new__(A)
    1:         with warnings.catch_warnings(record=True) as w:
    1:             warnings.simplefilter('always', DeprecationWarning)
    1:             a = object.__new__(A, 5)
    1:         self.assertEqual(type(a), A)
    1:         self.assertEqual(len(w), 1)
    1:         object.__init__(A(3))
    1:         a = A(3)
    1:         with warnings.catch_warnings(record=True) as w:
    1:             warnings.simplefilter('always', DeprecationWarning)
    1:             object.__init__(a, 5)
    1:         self.assertEqual(a.foo, 3)
    1:         self.assertEqual(len(w), 1)
       
    1:     @unittest.expectedFailure
           def test_restored_object_new(self):
>>>>>>         class A(object):
>>>>>>             def __new__(cls, *args, **kwargs):
>>>>>>                 raise AssertionError
>>>>>>         self.assertRaises(AssertionError, A)
>>>>>>         class B(A):
>>>>>>             __new__ = object.__new__
>>>>>>             def __init__(self, foo):
>>>>>>                 self.foo = foo
>>>>>>         with warnings.catch_warnings():
>>>>>>             warnings.simplefilter('error', DeprecationWarning)
>>>>>>             b = B(3)
>>>>>>         self.assertEqual(b.foo, 3)
>>>>>>         self.assertEqual(b.__class__, B)
>>>>>>         del B.__new__
>>>>>>         self.assertRaises(AssertionError, B)
>>>>>>         del A.__new__
>>>>>>         with warnings.catch_warnings():
>>>>>>             warnings.simplefilter('error', DeprecationWarning)
>>>>>>             b = B(3)
>>>>>>         self.assertEqual(b.foo, 3)
>>>>>>         self.assertEqual(b.__class__, B)
       
    1:     def test_altmro(self):
               # Testing mro() and overriding it...
    2:         class A(object):
    2:             def f(self): return "A"
    2:         class B(A):
    1:             pass
    2:         class C(A):
    2:             def f(self): return "C"
    2:         class D(B, C):
    1:             pass
    1:         self.assertEqual(D.mro(), [D, B, C, A, object])
    1:         self.assertEqual(D.__mro__, (D, B, C, A, object))
    1:         self.assertEqual(D().f(), "C")
       
    2:         class PerverseMetaType(type):
    1:             def mro(cls):
    1:                 L = type.mro(cls)
    1:                 L.reverse()
    1:                 return L
    2:         class X(D,B,C,A):
    1:             __metaclass__ = PerverseMetaType
    1:         self.assertEqual(X.__mro__, (object, A, C, B, D, X))
    1:         self.assertEqual(X().f(), "A")
       
    1:         try:
    2:             class X(object):
    2:                 class __metaclass__(type):
    1:                     def mro(self):
    1:                         return [self, dict, object]
                   # In CPython, the class creation above already raises
                   # TypeError, as a protection against the fact that
                   # instances of X would segfault it.  In other Python
                   # implementations it would be ok to let the class X
                   # be created, but instead get a clean TypeError on the
                   # __setitem__ below.
>>>>>>             x = object.__new__(X)
>>>>>>             x[5] = 6
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("devious mro() return not caught")
       
    1:         try:
    2:             class X(object):
    2:                 class __metaclass__(type):
    1:                     def mro(self):
    1:                         return [1]
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("non-class mro() return not caught")
       
    1:         try:
    2:             class X(object):
    2:                 class __metaclass__(type):
    1:                     def mro(self):
    1:                         return 1
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("non-sequence mro() return not caught")
       
    1:     def test_overloading(self):
               # Testing operator overloading...
       
    2:         class B(object):
    1:             "Intermediate class because object doesn't have a __setattr__"
       
    2:         class C(B):
    1:             def __getattr__(self, name):
    1:                 if name == "foo":
    1:                     return ("getattr", name)
                       else:
>>>>>>                     raise AttributeError
    1:             def __setattr__(self, name, value):
    7:                 if name == "foo":
    1:                     self.setattr = (name, value)
                       else:
    6:                     return B.__setattr__(self, name, value)
    1:             def __delattr__(self, name):
    1:                 if name == "foo":
    1:                     self.delattr = name
                       else:
>>>>>>                     return B.__delattr__(self, name)
       
    1:             def __getitem__(self, key):
    1:                 return ("getitem", key)
    1:             def __setitem__(self, key, value):
    1:                 self.setitem = (key, value)
    1:             def __delitem__(self, key):
    1:                 self.delitem = key
       
    1:             def __getslice__(self, i, j):
    1:                 return ("getslice", i, j)
    1:             def __setslice__(self, i, j, value):
    1:                 self.setslice = (i, j, value)
    1:             def __delslice__(self, i, j):
    1:                 self.delslice = (i, j)
       
    1:         a = C()
    1:         self.assertEqual(a.foo, ("getattr", "foo"))
    1:         a.foo = 12
    1:         self.assertEqual(a.setattr, ("foo", 12))
    1:         del a.foo
    1:         self.assertEqual(a.delattr, "foo")
       
    1:         self.assertEqual(a[12], ("getitem", 12))
    1:         a[12] = 21
    1:         self.assertEqual(a.setitem, (12, 21))
    1:         del a[12]
    1:         self.assertEqual(a.delitem, 12)
       
    1:         self.assertEqual(a[0:10], ("getslice", 0, 10))
    1:         a[0:10] = "foo"
    1:         self.assertEqual(a.setslice, (0, 10, "foo"))
    1:         del a[0:10]
    1:         self.assertEqual(a.delslice, (0, 10))
       
    1:     def test_methods(self):
               # Testing methods...
    2:         class C(object):
    1:             def __init__(self, x):
    3:                 self.x = x
    1:             def foo(self):
    4:                 return self.x
    1:         c1 = C(1)
    1:         self.assertEqual(c1.foo(), 1)
    2:         class D(C):
    1:             boo = C.foo
    1:             goo = c1.foo
    1:         d2 = D(2)
    1:         self.assertEqual(d2.foo(), 2)
    1:         self.assertEqual(d2.boo(), 2)
    1:         self.assertEqual(d2.goo(), 1)
    2:         class E(object):
    1:             foo = C.foo
    1:         self.assertEqual(E().foo, C.foo) # i.e., unbound
    1:         self.assertTrue(repr(C.foo.__get__(C(1))).startswith("<bound method "))
       
    1:     def test_special_method_lookup(self):
               # The lookup of special methods bypasses __getattr__ and
               # __getattribute__, but they still can be descriptors.
       
>>>>>>         def run_context(manager):
>>>>>>             with manager:
>>>>>>                 pass
>>>>>>         def iden(self):
>>>>>>             return self
>>>>>>         def hello(self):
>>>>>>             return "hello"
>>>>>>         def empty_seq(self):
>>>>>>             return []
>>>>>>         def zero(self):
>>>>>>             return 0
>>>>>>         def complex_num(self):
>>>>>>             return 1j
>>>>>>         def stop(self):
>>>>>>             raise StopIteration
>>>>>>         def return_true(self, thing=None):
>>>>>>             return True
>>>>>>         def do_isinstance(obj):
>>>>>>             return isinstance(int, obj)
>>>>>>         def do_issubclass(obj):
>>>>>>             return issubclass(int, obj)
>>>>>>         def swallow(*args):
>>>>>>             pass
>>>>>>         def do_dict_missing(checker):
>>>>>>             class DictSub(checker.__class__, dict):
>>>>>>                 pass
>>>>>>             self.assertEqual(DictSub()["hi"], 4)
>>>>>>         def some_number(self_, key):
>>>>>>             self.assertEqual(key, "hi")
>>>>>>             return 4
>>>>>>         def format_impl(self, spec):
>>>>>>             return "hello"
       
               # It would be nice to have every special method tested here, but I'm
               # only listing the ones I can remember outside of typeobject.c, since it
               # does it right.
               specials = [
>>>>>>             ("__unicode__", unicode, hello, set(), {}),
>>>>>>             ("__reversed__", reversed, empty_seq, set(), {}),
>>>>>>             ("__length_hint__", list, zero, set(),
>>>>>>              {"__iter__" : iden, "next" : stop}),
>>>>>>             ("__sizeof__", sys.getsizeof, zero, set(), {}),
>>>>>>             ("__instancecheck__", do_isinstance, return_true, set(), {}),
>>>>>>             ("__missing__", do_dict_missing, some_number,
>>>>>>              set(("__class__",)), {}),
>>>>>>             ("__subclasscheck__", do_issubclass, return_true,
>>>>>>              set(("__bases__",)), {}),
>>>>>>             ("__enter__", run_context, iden, set(), {"__exit__" : swallow}),
>>>>>>             ("__exit__", run_context, swallow, set(), {"__enter__" : iden}),
>>>>>>             ("__complex__", complex, complex_num, set(), {}),
>>>>>>             ("__format__", format, format_impl, set(), {}),
>>>>>>             ("__dir__", dir, empty_seq, set(), {}),
                   ]
       
>>>>>>         class Checker(object):
>>>>>>             def __getattr__(self, attr, test=self):
>>>>>>                 test.fail("__getattr__ called with {0}".format(attr))
>>>>>>             def __getattribute__(self, attr, test=self):
>>>>>>                 if attr not in ok:
>>>>>>                     test.fail("__getattribute__ called with {0}".format(attr))
>>>>>>                 return object.__getattribute__(self, attr)
>>>>>>         class SpecialDescr(object):
>>>>>>             def __init__(self, impl):
>>>>>>                 self.impl = impl
>>>>>>             def __get__(self, obj, owner):
>>>>>>                 record.append(1)
>>>>>>                 return self.impl.__get__(obj, owner)
>>>>>>         class MyException(Exception):
>>>>>>             pass
>>>>>>         class ErrDescr(object):
>>>>>>             def __get__(self, obj, owner):
>>>>>>                 raise MyException
       
>>>>>>         for name, runner, meth_impl, ok, env in specials:
>>>>>>             class X(Checker):
>>>>>>                 pass
>>>>>>             for attr, obj in env.iteritems():
>>>>>>                 setattr(X, attr, obj)
>>>>>>             setattr(X, name, meth_impl)
>>>>>>             runner(X())
       
>>>>>>             record = []
>>>>>>             class X(Checker):
>>>>>>                 pass
>>>>>>             for attr, obj in env.iteritems():
>>>>>>                 setattr(X, attr, obj)
>>>>>>             setattr(X, name, SpecialDescr(meth_impl))
>>>>>>             runner(X())
>>>>>>             self.assertEqual(record, [1], name)
       
>>>>>>             class X(Checker):
>>>>>>                 pass
>>>>>>             for attr, obj in env.iteritems():
>>>>>>                 setattr(X, attr, obj)
>>>>>>             setattr(X, name, ErrDescr())
>>>>>>             try:
>>>>>>                 runner(X())
>>>>>>             except MyException:
>>>>>>                 pass
                   else:
>>>>>>                 self.fail("{0!r} didn't raise".format(name))
       
    1:     def test_specials(self):
               # Testing special operators...
               # Test operators like __hash__ for which a built-in default exists
       
               # Test the default behavior for static classes
>>>>>>         class C(object):
>>>>>>             def __getitem__(self, i):
>>>>>>                 if 0 <= i < 10: return i
>>>>>>                 raise IndexError
>>>>>>         c1 = C()
>>>>>>         c2 = C()
>>>>>>         self.assertFalse(not c1)
>>>>>>         self.assertNotEqual(id(c1), id(c2))
>>>>>>         hash(c1)
>>>>>>         hash(c2)
>>>>>>         self.assertEqual(cmp(c1, c2), cmp(id(c1), id(c2)))
>>>>>>         self.assertEqual(c1, c1)
>>>>>>         self.assertTrue(c1 != c2)
>>>>>>         self.assertFalse(c1 != c1)
>>>>>>         self.assertFalse(c1 == c2)
               # Note that the module name appears in str/repr, and that varies
               # depending on whether this test is run standalone or from a framework.
>>>>>>         self.assertGreaterEqual(str(c1).find('C object at '), 0)
>>>>>>         self.assertEqual(str(c1), repr(c1))
>>>>>>         self.assertNotIn(-1, c1)
>>>>>>         for i in range(10):
>>>>>>             self.assertIn(i, c1)
>>>>>>         self.assertNotIn(10, c1)
               # Test the default behavior for dynamic classes
>>>>>>         class D(object):
>>>>>>             def __getitem__(self, i):
>>>>>>                 if 0 <= i < 10: return i
>>>>>>                 raise IndexError
>>>>>>         d1 = D()
>>>>>>         d2 = D()
>>>>>>         self.assertFalse(not d1)
>>>>>>         self.assertNotEqual(id(d1), id(d2))
>>>>>>         hash(d1)
>>>>>>         hash(d2)
>>>>>>         self.assertEqual(cmp(d1, d2), cmp(id(d1), id(d2)))
>>>>>>         self.assertEqual(d1, d1)
>>>>>>         self.assertNotEqual(d1, d2)
>>>>>>         self.assertFalse(d1 != d1)
>>>>>>         self.assertFalse(d1 == d2)
               # Note that the module name appears in str/repr, and that varies
               # depending on whether this test is run standalone or from a framework.
>>>>>>         self.assertGreaterEqual(str(d1).find('D object at '), 0)
>>>>>>         self.assertEqual(str(d1), repr(d1))
>>>>>>         self.assertNotIn(-1, d1)
>>>>>>         for i in range(10):
>>>>>>             self.assertIn(i, d1)
>>>>>>         self.assertNotIn(10, d1)
               # Test overridden behavior for static classes
>>>>>>         class Proxy(object):
>>>>>>             def __init__(self, x):
>>>>>>                 self.x = x
>>>>>>             def __nonzero__(self):
>>>>>>                 return not not self.x
>>>>>>             def __hash__(self):
>>>>>>                 return hash(self.x)
>>>>>>             def __eq__(self, other):
>>>>>>                 return self.x == other
>>>>>>             def __ne__(self, other):
>>>>>>                 return self.x != other
>>>>>>             def __cmp__(self, other):
>>>>>>                 return cmp(self.x, other.x)
>>>>>>             def __str__(self):
>>>>>>                 return "Proxy:%s" % self.x
>>>>>>             def __repr__(self):
>>>>>>                 return "Proxy(%r)" % self.x
>>>>>>             def __contains__(self, value):
>>>>>>                 return value in self.x
>>>>>>         p0 = Proxy(0)
>>>>>>         p1 = Proxy(1)
>>>>>>         p_1 = Proxy(-1)
>>>>>>         self.assertFalse(p0)
>>>>>>         self.assertFalse(not p1)
>>>>>>         self.assertEqual(hash(p0), hash(0))
>>>>>>         self.assertEqual(p0, p0)
>>>>>>         self.assertNotEqual(p0, p1)
>>>>>>         self.assertFalse(p0 != p0)
>>>>>>         self.assertEqual(not p0, p1)
>>>>>>         self.assertEqual(cmp(p0, p1), -1)
>>>>>>         self.assertEqual(cmp(p0, p0), 0)
>>>>>>         self.assertEqual(cmp(p0, p_1), 1)
>>>>>>         self.assertEqual(str(p0), "Proxy:0")
>>>>>>         self.assertEqual(repr(p0), "Proxy(0)")
>>>>>>         p10 = Proxy(range(10))
>>>>>>         self.assertNotIn(-1, p10)
>>>>>>         for i in range(10):
>>>>>>             self.assertIn(i, p10)
>>>>>>         self.assertNotIn(10, p10)
               # Test overridden behavior for dynamic classes
>>>>>>         class DProxy(object):
>>>>>>             def __init__(self, x):
>>>>>>                 self.x = x
>>>>>>             def __nonzero__(self):
>>>>>>                 return not not self.x
>>>>>>             def __hash__(self):
>>>>>>                 return hash(self.x)
>>>>>>             def __eq__(self, other):
>>>>>>                 return self.x == other
>>>>>>             def __ne__(self, other):
>>>>>>                 return self.x != other
>>>>>>             def __cmp__(self, other):
>>>>>>                 return cmp(self.x, other.x)
>>>>>>             def __str__(self):
>>>>>>                 return "DProxy:%s" % self.x
>>>>>>             def __repr__(self):
>>>>>>                 return "DProxy(%r)" % self.x
>>>>>>             def __contains__(self, value):
>>>>>>                 return value in self.x
>>>>>>         p0 = DProxy(0)
>>>>>>         p1 = DProxy(1)
>>>>>>         p_1 = DProxy(-1)
>>>>>>         self.assertFalse(p0)
>>>>>>         self.assertFalse(not p1)
>>>>>>         self.assertEqual(hash(p0), hash(0))
>>>>>>         self.assertEqual(p0, p0)
>>>>>>         self.assertNotEqual(p0, p1)
>>>>>>         self.assertNotEqual(not p0, p0)
>>>>>>         self.assertEqual(not p0, p1)
>>>>>>         self.assertEqual(cmp(p0, p1), -1)
>>>>>>         self.assertEqual(cmp(p0, p0), 0)
>>>>>>         self.assertEqual(cmp(p0, p_1), 1)
>>>>>>         self.assertEqual(str(p0), "DProxy:0")
>>>>>>         self.assertEqual(repr(p0), "DProxy(0)")
>>>>>>         p10 = DProxy(range(10))
>>>>>>         self.assertNotIn(-1, p10)
>>>>>>         for i in range(10):
>>>>>>             self.assertIn(i, p10)
>>>>>>         self.assertNotIn(10, p10)
       
               # Safety test for __cmp__
>>>>>>         def unsafecmp(a, b):
>>>>>>             if not hasattr(a, '__cmp__'):
>>>>>>                 return   # some types don't have a __cmp__ any more (so the
                                # test doesn't make sense any more), or maybe they
                                # never had a __cmp__ at all, e.g. in PyPy
>>>>>>             try:
>>>>>>                 a.__class__.__cmp__(a, b)
>>>>>>             except TypeError:
>>>>>>                 pass
                   else:
>>>>>>                 self.fail("shouldn't allow %s.__cmp__(%r, %r)" % (
>>>>>>                     a.__class__, a, b))
       
>>>>>>         unsafecmp(u"123", "123")
>>>>>>         unsafecmp("123", u"123")
>>>>>>         unsafecmp(1, 1.0)
>>>>>>         unsafecmp(1.0, 1)
>>>>>>         unsafecmp(1, 1L)
>>>>>>         unsafecmp(1L, 1)
       
    1:     @test_support.impl_detail("custom logic for printing to real file objects")
           def test_recursions_1(self):
               # Testing recursion checks ...
    2:         class Letter(str):
    1:             def __new__(cls, letter):
    1:                 if letter == 'EPS':
>>>>>>                     return str.__new__(cls)
    1:                 return str.__new__(cls, letter)
    1:             def __str__(self):
   11:                 if not self:
>>>>>>                     return 'EPS'
   11:                 return self
               # sys.stdout needs to be the original to trigger the recursion bug
    1:         test_stdout = sys.stdout
    1:         sys.stdout = test_support.get_original_stdout()
    1:         try:
                   # nothing should actually be printed, this should raise an exception
    1:             print Letter('w')
    1:         except RuntimeError:
    1:             pass
               else:
>>>>>>             self.fail("expected a RuntimeError for print recursion")
               finally:
    1:             sys.stdout = test_stdout
       
    1:     def test_recursions_2(self):
               # Bug #1202533.
    2:         class A(object):
    1:             pass
  320:         A.__mul__ = types.MethodType(lambda self, x: self * x, None, A)
    1:         try:
    1:             A()*2
>>>>>>         except RuntimeError:
>>>>>>             pass
               else:
>>>>>>             self.fail("expected a RuntimeError")
       
    1:     def test_weakrefs(self):
               # Testing weak references...
>>>>>>         import weakref
>>>>>>         class C(object):
>>>>>>             pass
>>>>>>         c = C()
>>>>>>         r = weakref.ref(c)
>>>>>>         self.assertEqual(r(), c)
>>>>>>         del c
>>>>>>         test_support.gc_collect()
>>>>>>         self.assertEqual(r(), None)
>>>>>>         del r
>>>>>>         class NoWeak(object):
>>>>>>             __slots__ = ['foo']
>>>>>>         no = NoWeak()
>>>>>>         try:
>>>>>>             weakref.ref(no)
>>>>>>         except TypeError, msg:
>>>>>>             self.assertIn("weak reference", str(msg))
               else:
>>>>>>             self.fail("weakref.ref(no) should be illegal")
>>>>>>         class Weak(object):
>>>>>>             __slots__ = ['foo', '__weakref__']
>>>>>>         yes = Weak()
>>>>>>         r = weakref.ref(yes)
>>>>>>         self.assertEqual(r(), yes)
>>>>>>         del yes
>>>>>>         test_support.gc_collect()
>>>>>>         self.assertEqual(r(), None)
>>>>>>         del r
       
    1:     def test_properties(self):
               # Testing property...
    2:         class C(object):
    1:             def getx(self):
    5:                 return self.__x
    1:             def setx(self, value):
    2:                 self.__x = value
    1:             def delx(self):
    2:                 del self.__x
    1:             x = property(getx, setx, delx, doc="I'm the x property.")
    1:         a = C()
    1:         self.assertNotHasAttr(a, "x")
    1:         a.x = 42
    1:         self.assertEqual(a._C__x, 42)
    1:         self.assertEqual(a.x, 42)
    1:         del a.x
    1:         self.assertNotHasAttr(a, "x")
    1:         self.assertNotHasAttr(a, "_C__x")
    1:         C.x.__set__(a, 100)
    1:         self.assertEqual(C.x.__get__(a), 100)
    1:         C.x.__delete__(a)
    1:         self.assertNotHasAttr(a, "x")
       
    1:         raw = C.__dict__['x']
    1:         self.assertIsInstance(raw, property)
       
    1:         attrs = dir(raw)
    1:         self.assertIn("__doc__", attrs)
    1:         self.assertIn("fget", attrs)
    1:         self.assertIn("fset", attrs)
    1:         self.assertIn("fdel", attrs)
       
    1:         self.assertEqual(raw.__doc__, "I'm the x property.")
    1:         self.assertIs(raw.fget, C.__dict__['getx'])
    1:         self.assertIs(raw.fset, C.__dict__['setx'])
    1:         self.assertIs(raw.fdel, C.__dict__['delx'])
       
    5:         for attr in "__doc__", "fget", "fset", "fdel":
    4:             try:
    4:                 setattr(raw, attr, 42)
    4:             except TypeError, msg:
    4:                 if str(msg).find('readonly') < 0:
>>>>>>                     self.fail("when setting readonly attr %r on a property, "
>>>>>>                                      "got unexpected TypeError msg %r" % (attr, str(msg)))
                   else:
>>>>>>                 self.fail("expected TypeError from trying to set readonly %r "
>>>>>>                                  "attr on a property" % attr)
       
    2:         class D(object):
    2:             __getitem__ = property(lambda s: 1.0/0.0)
       
    1:         d = D()
    1:         try:
    1:             for i in d:
>>>>>>                 str(i)
    1:         except ZeroDivisionError:
    1:             pass
               else:
>>>>>>             self.fail("expected ZeroDivisionError from bad property")
       
    1:     @test_support.cpython_only
           def test_property_copy_pickle(self):
    1:         p = property(func)
    1:         with test_support.check_py3k_warnings(
    1:                 (".*property", DeprecationWarning)):
    1:             copy.copy(p)
    1:         with test_support.check_py3k_warnings(
    1:                 (".*property", DeprecationWarning)):
    1:             copy.deepcopy(p)
    3:         for proto in range(2):
    2:             self.assertRaises(TypeError, pickle.dumps, p, proto)
    1:         with test_support.check_py3k_warnings(
    1:                 (".*property", DeprecationWarning)):
    1:             pickle.dumps(p, 2)
       
    1:     @unittest.skipIf(sys.flags.optimize >= 2,
    1:                      "Docstrings are omitted with -O2 and above")
           def test_properties_doc_attrib(self):
    2:         class E(object):
    1:             def getter(self):
                       "getter method"
>>>>>>                 return 0
    1:             def setter(self_, value):
                       "setter method"
>>>>>>                 pass
    1:             prop = property(getter)
    1:             self.assertEqual(prop.__doc__, "getter method")
    1:             prop2 = property(fset=setter)
    1:             self.assertEqual(prop2.__doc__, None)
       
    1:     @test_support.cpython_only
           def test_testcapi_no_segfault(self):
               # this segfaulted in 2.5b2
>>>>>>         try:
>>>>>>             import _testcapi
>>>>>>         except ImportError:
>>>>>>             pass
               else:
>>>>>>             class X(object):
>>>>>>                 p = property(_testcapi.test_with_docstring)
       
    1:     def test_properties_plus(self):
    2:         class C(object):
    1:             foo = property(doc="hello")
    1:             @foo.getter
                   def foo(self):
    4:                 return self._foo
    1:             @foo.setter
                   def foo(self, value):
    2:                 self._foo = abs(value)
    1:             @foo.deleter
                   def foo(self):
    1:                 del self._foo
    1:         c = C()
    1:         self.assertEqual(C.foo.__doc__, "hello")
    1:         self.assertNotHasAttr(c, "foo")
    1:         c.foo = -42
    1:         self.assertHasAttr(c, '_foo')
    1:         self.assertEqual(c._foo, 42)
    1:         self.assertEqual(c.foo, 42)
    1:         del c.foo
    1:         self.assertNotHasAttr(c, '_foo')
    1:         self.assertNotHasAttr(c, "foo")
       
    2:         class D(C):
    1:             @C.foo.deleter
                   def foo(self):
    2:                 try:
    2:                     del self._foo
    1:                 except AttributeError:
    1:                     pass
    1:         d = D()
    1:         d.foo = 24
    1:         self.assertEqual(d.foo, 24)
    1:         del d.foo
    1:         del d.foo
       
    2:         class E(object):
    1:             @property
                   def foo(self):
    2:                 return self._foo
    1:             @foo.setter
                   def foo(self, value):
>>>>>>                 raise RuntimeError
    1:             @foo.setter
                   def foo(self, value):
    1:                 self._foo = abs(value)
    1:             @foo.deleter
    1:             def foo(self, value=None):
    1:                 del self._foo
       
    1:         e = E()
    1:         e.foo = -42
    1:         self.assertEqual(e.foo, 42)
    1:         del e.foo
       
    2:         class F(E):
    1:             @E.foo.deleter
                   def foo(self):
    1:                 del self._foo
    1:             @foo.setter
                   def foo(self, value):
    1:                 self._foo = max(0, value)
    1:         f = F()
    1:         f.foo = -10
    1:         self.assertEqual(f.foo, 0)
    1:         del f.foo
       
    1:     def test_dict_constructors(self):
               # Testing dict constructor ...
    1:         d = dict()
    1:         self.assertEqual(d, {})
    1:         d = dict({})
    1:         self.assertEqual(d, {})
    1:         d = dict({1: 2, 'a': 'b'})
    1:         self.assertEqual(d, {1: 2, 'a': 'b'})
    1:         self.assertEqual(d, dict(d.items()))
    1:         self.assertEqual(d, dict(d.iteritems()))
    1:         d = dict({'one':1, 'two':2})
    1:         self.assertEqual(d, dict(one=1, two=2))
    1:         self.assertEqual(d, dict(**d))
    1:         self.assertEqual(d, dict({"one": 1}, two=2))
    1:         self.assertEqual(d, dict([("two", 2)], one=1))
    1:         self.assertEqual(d, dict([("one", 100), ("two", 200)], **d))
    1:         self.assertEqual(d, dict(**d))
       
    7:         for badarg in 0, 0L, 0j, "0", [0], (0,):
    6:             try:
    6:                 dict(badarg)
    6:             except TypeError:
    5:                 pass
    1:             except ValueError:
    1:                 if badarg == "0":
                           # It's a sequence, and its elements are also sequences (gotta
                           # love strings <wink>), but they aren't of length 2, so this
                           # one seemed better as a ValueError than a TypeError.
    1:                     pass
                       else:
>>>>>>                     self.fail("no TypeError from dict(%r)" % badarg)
                   else:
>>>>>>                 self.fail("no TypeError from dict(%r)" % badarg)
       
    1:         try:
    1:             dict({}, {})
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("no TypeError from dict({}, {})")
       
    2:         class Mapping:
                   # Lacks a .keys() method; will be added later.
    1:             dict = {1:2, 3:4, 'a':1j}
       
    1:         try:
    1:             dict(Mapping())
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("no TypeError from dict(incomplete mapping)")
       
    2:         Mapping.keys = lambda self: self.dict.keys()
    4:         Mapping.__getitem__ = lambda self, i: self.dict[i]
    1:         d = dict(Mapping())
    1:         self.assertEqual(d, Mapping.dict)
       
               # Init from sequence of iterable objects, each producing a 2-sequence.
    2:         class AddressBookEntry:
    1:             def __init__(self, first, last):
    4:                 self.first = first
    4:                 self.last = last
    1:             def __iter__(self):
    4:                 return iter([self.first, self.last])
       
    1:         d = dict([AddressBookEntry('Tim', 'Warsaw'),
    1:                   AddressBookEntry('Barry', 'Peters'),
    1:                   AddressBookEntry('Tim', 'Peters'),
    1:                   AddressBookEntry('Barry', 'Warsaw')])
    1:         self.assertEqual(d, {'Barry': 'Warsaw', 'Tim': 'Peters'})
       
    1:         d = dict(zip(range(4), range(1, 5)))
    5:         self.assertEqual(d, dict([(i, i+1) for i in range(4)]))
       
               # Bad sequence lengths.
    3:         for bad in [('tooshort',)], [('too', 'long', 'by 1')]:
    2:             try:
    2:                 dict(bad)
    2:             except ValueError:
    2:                 pass
                   else:
>>>>>>                 self.fail("no ValueError from dict(%r)" % bad)
       
    1:     def test_dir(self):
               # Testing dir() ...
    1:         junk = 12
    1:         self.assertEqual(dir(), ['junk', 'self'])
    1:         del junk
       
               # Just make sure these don't blow up!
   12:         for arg in 2, 2L, 2j, 2e0, [2], "2", u"2", (2,), {2:2}, type, self.test_dir:
   11:             dir(arg)
       
               # Try classic classes.
    2:         class C:
    1:             Cdata = 1
    1:             def Cmethod(self): pass
       
    1:         cstuff = ['Cdata', 'Cmethod', '__doc__', '__module__']
    1:         self.assertEqual(dir(C), cstuff)
    1:         self.assertIn('im_self', dir(C.Cmethod))
       
    1:         c = C()  # c.__doc__ is an odd thing to see here; ditto c.__module__.
    1:         self.assertEqual(dir(c), cstuff)
       
    1:         c.cdata = 2
    1:         c.cmethod = lambda self: 0
    1:         self.assertEqual(dir(c), cstuff + ['cdata', 'cmethod'])
    1:         self.assertIn('im_self', dir(c.Cmethod))
       
    2:         class A(C):
    1:             Adata = 1
    1:             def Amethod(self): pass
       
    1:         astuff = ['Adata', 'Amethod'] + cstuff
    1:         self.assertEqual(dir(A), astuff)
    1:         self.assertIn('im_self', dir(A.Amethod))
    1:         a = A()
    1:         self.assertEqual(dir(a), astuff)
    1:         self.assertIn('im_self', dir(a.Amethod))
    1:         a.adata = 42
    1:         a.amethod = lambda self: 3
    1:         self.assertEqual(dir(a), astuff + ['adata', 'amethod'])
       
               # The same, but with new-style classes.  Since these have object as a
               # base class, a lot more gets sucked in.
    1:         def interesting(strings):
  136:             return [s for s in strings if not s.startswith('_')]
       
    2:         class C(object):
    1:             Cdata = 1
    1:             def Cmethod(self): pass
       
    1:         cstuff = ['Cdata', 'Cmethod']
    1:         self.assertEqual(interesting(dir(C)), cstuff)
       
    1:         c = C()
    1:         self.assertEqual(interesting(dir(c)), cstuff)
    1:         self.assertIn('im_self', dir(C.Cmethod))
       
    1:         c.cdata = 2
    1:         c.cmethod = lambda self: 0
    1:         self.assertEqual(interesting(dir(c)), cstuff + ['cdata', 'cmethod'])
    1:         self.assertIn('im_self', dir(c.Cmethod))
       
    2:         class A(C):
    1:             Adata = 1
    1:             def Amethod(self): pass
       
    1:         astuff = ['Adata', 'Amethod'] + cstuff
    1:         self.assertEqual(interesting(dir(A)), astuff)
    1:         self.assertIn('im_self', dir(A.Amethod))
    1:         a = A()
    1:         self.assertEqual(interesting(dir(a)), astuff)
    1:         a.adata = 42
    1:         a.amethod = lambda self: 3
    1:         self.assertEqual(interesting(dir(a)), astuff + ['adata', 'amethod'])
    1:         self.assertIn('im_self', dir(a.Amethod))
       
               # Try a module subclass.
    2:         class M(type(sys)):
    1:             pass
    1:         minstance = M("m")
    1:         minstance.b = 2
    1:         minstance.a = 1
    5:         names = [x for x in dir(minstance) if x not in ["__name__", "__doc__"]]
    1:         self.assertEqual(names, ['a', 'b'])
       
    2:         class M2(M):
    1:             def getdict(self):
    2:                 return "Not a dict!"
    1:             __dict__ = property(getdict)
       
    1:         m2instance = M2("m2")
    1:         m2instance.b = 2
    1:         m2instance.a = 1
    1:         self.assertEqual(m2instance.__dict__, "Not a dict!")
    1:         try:
    1:             dir(m2instance)
    1:         except TypeError:
    1:             pass
       
               # Two essentially featureless objects, just inheriting stuff from
               # object.
    1:         self.assertEqual(dir(NotImplemented), dir(Ellipsis))
    1:         if test_support.check_impl_detail():
                   # None differs in PyPy: it has a __nonzero__
    1:             self.assertEqual(dir(None), dir(Ellipsis))
       
               # Nasty test case for proxied objects
    2:         class Wrapper(object):
    1:             def __init__(self, obj):
    4:                 self.__obj = obj
    1:             def __repr__(self):
>>>>>>                 return "Wrapper(%s)" % repr(self.__obj)
    1:             def __getitem__(self, key):
    1:                 return Wrapper(self.__obj[key])
    1:             def __len__(self):
    2:                 return len(self.__obj)
    1:             def __getattr__(self, name):
    2:                 return Wrapper(getattr(self.__obj, name))
       
    2:         class C(object):
    1:             def __getclass(self):
    1:                 return Wrapper(type(self))
    1:             __class__ = property(__getclass)
       
    1:         dir(C()) # This used to segfault
       
    1:     def test_supers(self):
               # Testing super...
       
>>>>>>         class A(object):
>>>>>>             def meth(self, a):
>>>>>>                 return "A(%r)" % a
       
>>>>>>         self.assertEqual(A().meth(1), "A(1)")
       
>>>>>>         class B(A):
>>>>>>             def __init__(self):
>>>>>>                 self.__super = super(B, self)
>>>>>>             def meth(self, a):
>>>>>>                 return "B(%r)" % a + self.__super.meth(a)
       
>>>>>>         self.assertEqual(B().meth(2), "B(2)A(2)")
       
>>>>>>         class C(A):
>>>>>>             def meth(self, a):
>>>>>>                 return "C(%r)" % a + self.__super.meth(a)
>>>>>>         C._C__super = super(C)
       
>>>>>>         self.assertEqual(C().meth(3), "C(3)A(3)")
       
>>>>>>         class D(C, B):
>>>>>>             def meth(self, a):
>>>>>>                 return "D(%r)" % a + super(D, self).meth(a)
       
>>>>>>         self.assertEqual(D().meth(4), "D(4)C(4)B(4)A(4)")
       
               # Test for subclassing super
       
>>>>>>         class mysuper(super):
>>>>>>             def __init__(self, *args):
>>>>>>                 return super(mysuper, self).__init__(*args)
       
>>>>>>         class E(D):
>>>>>>             def meth(self, a):
>>>>>>                 return "E(%r)" % a + mysuper(E, self).meth(a)
       
>>>>>>         self.assertEqual(E().meth(5), "E(5)D(5)C(5)B(5)A(5)")
       
>>>>>>         class F(E):
>>>>>>             def meth(self, a):
>>>>>>                 s = self.__super # == mysuper(F, self)
>>>>>>                 return "F(%r)[%s]" % (a, s.__class__.__name__) + s.meth(a)
>>>>>>         F._F__super = mysuper(F)
       
>>>>>>         self.assertEqual(F().meth(6), "F(6)[mysuper]E(6)D(6)C(6)B(6)A(6)")
       
               # Make sure certain errors are raised
       
>>>>>>         try:
>>>>>>             super(D, 42)
>>>>>>         except TypeError:
>>>>>>             pass
               else:
>>>>>>             self.fail("shouldn't allow super(D, 42)")
       
>>>>>>         try:
>>>>>>             super(D, C())
>>>>>>         except TypeError:
>>>>>>             pass
               else:
>>>>>>             self.fail("shouldn't allow super(D, C())")
       
>>>>>>         try:
>>>>>>             super(D).__get__(12)
>>>>>>         except TypeError:
>>>>>>             pass
               else:
>>>>>>             self.fail("shouldn't allow super(D).__get__(12)")
       
>>>>>>         try:
>>>>>>             super(D).__get__(C())
>>>>>>         except TypeError:
>>>>>>             pass
               else:
>>>>>>             self.fail("shouldn't allow super(D).__get__(C())")
       
               # Make sure data descriptors can be overridden and accessed via super
               # (new feature in Python 2.3)
       
>>>>>>         class DDbase(object):
>>>>>>             def getx(self): return 42
>>>>>>             x = property(getx)
       
>>>>>>         class DDsub(DDbase):
>>>>>>             def getx(self): return "hello"
>>>>>>             x = property(getx)
       
>>>>>>         dd = DDsub()
>>>>>>         self.assertEqual(dd.x, "hello")
>>>>>>         self.assertEqual(super(DDsub, dd).x, 42)
       
               # Ensure that super() lookup of descriptor from classmethod
               # works (SF ID# 743627)
       
>>>>>>         class Base(object):
>>>>>>             aProp = property(lambda self: "foo")
       
>>>>>>         class Sub(Base):
>>>>>>             @classmethod
                   def test(klass):
>>>>>>                 return super(Sub,klass).aProp
       
>>>>>>         self.assertEqual(Sub.test(), Base.aProp)
       
               # Verify that super() doesn't allow keyword args
>>>>>>         try:
>>>>>>             super(Base, kw=1)
>>>>>>         except TypeError:
>>>>>>             pass
               else:
>>>>>>             self.assertEqual("super shouldn't accept keyword args")
       
    1:     def test_basic_inheritance(self):
               # Testing inheritance from basic types...
       
    2:         class hexint(int):
    1:             def __repr__(self):
    2:                 return hex(self)
    1:             def __add__(self, other):
    2:                 return hexint(int.__add__(self, other))
                   # (Note that overriding __radd__ doesn't work,
                   # because the int type gets first dibs.)
    1:         self.assertEqual(repr(hexint(7) + 9), "0x10")
    1:         self.assertEqual(repr(hexint(1000) + 7), "0x3ef")
    1:         a = hexint(12345)
    1:         self.assertEqual(a, 12345)
    1:         self.assertEqual(int(a), 12345)
    1:         self.assertIs(int(a).__class__, int)
    1:         self.assertEqual(hash(a), hash(12345))
    1:         self.assertIs((+a).__class__, int)
    1:         self.assertIs((a >> 0).__class__, int)
    1:         self.assertIs((a << 0).__class__, int)
    1:         self.assertIs((hexint(0) << 12).__class__, int)
    1:         self.assertIs((hexint(0) >> 12).__class__, int)
       
    2:         class octlong(long):
    1:             __slots__ = []
    1:             def __str__(self):
    2:                 s = oct(self)
    2:                 if s[-1] == 'L':
    2:                     s = s[:-1]
    2:                 return s
    1:             def __add__(self, other):
    2:                 return self.__class__(super(octlong, self).__add__(other))
    1:             __radd__ = __add__
    1:         self.assertEqual(str(octlong(3) + 5), "010")
               # (Note that overriding __radd__ here only seems to work
               # because the example uses a short int left argument.)
    1:         self.assertEqual(str(5 + octlong(3000)), "05675")
    1:         a = octlong(12345)
    1:         self.assertEqual(a, 12345L)
    1:         self.assertEqual(long(a), 12345L)
    1:         self.assertEqual(hash(a), hash(12345L))
    1:         self.assertIs(long(a).__class__, long)
    1:         self.assertIs((+a).__class__, long)
    1:         self.assertIs((-a).__class__, long)
    1:         self.assertIs((-octlong(0)).__class__, long)
    1:         self.assertIs((a >> 0).__class__, long)
    1:         self.assertIs((a << 0).__class__, long)
    1:         self.assertIs((a - 0).__class__, long)
    1:         self.assertIs((a * 1).__class__, long)
    1:         self.assertIs((a ** 1).__class__, long)
    1:         self.assertIs((a // 1).__class__, long)
    1:         self.assertIs((1 * a).__class__, long)
    1:         self.assertIs((a | 0).__class__, long)
    1:         self.assertIs((a ^ 0).__class__, long)
    1:         self.assertIs((a & -1L).__class__, long)
    1:         self.assertIs((octlong(0) << 12).__class__, long)
    1:         self.assertIs((octlong(0) >> 12).__class__, long)
    1:         self.assertIs(abs(octlong(0)).__class__, long)
       
               # Because octlong overrides __add__, we can't check the absence of +0
               # optimizations using octlong.
    2:         class longclone(long):
    1:             pass
    1:         a = longclone(1)
    1:         self.assertIs((a + 0).__class__, long)
    1:         self.assertIs((0 + a).__class__, long)
       
               # Check that negative clones don't segfault
    1:         a = longclone(-1)
    1:         self.assertEqual(a.__dict__, {})
    1:         self.assertEqual(long(a), -1)  # self.assertTrue PyNumber_Long() copies the sign bit
       
    2:         class precfloat(float):
    1:             __slots__ = ['prec']
    1:             def __init__(self, value=0.0, prec=12):
    2:                 self.prec = int(prec)
    1:             def __repr__(self):
    1:                 return "%.*g" % (self.prec, self)
    1:         self.assertEqual(repr(precfloat(1.1)), "1.1")
    1:         a = precfloat(12345)
    1:         self.assertEqual(a, 12345.0)
    1:         self.assertEqual(float(a), 12345.0)
    1:         self.assertIs(float(a).__class__, float)
    1:         self.assertEqual(hash(a), hash(12345.0))
    1:         self.assertIs((+a).__class__, float)
       
    2:         class madcomplex(complex):
    1:             def __repr__(self):
    2:                 return "%.17gj%+.17g" % (self.imag, self.real)
    1:         a = madcomplex(-3, 4)
    1:         self.assertEqual(repr(a), "4j-3")
    1:         base = complex(-3, 4)
    1:         self.assertEqual(base.__class__, complex)
    1:         self.assertEqual(a, base)
    1:         self.assertEqual(complex(a), base)
    1:         self.assertEqual(complex(a).__class__, complex)
    1:         a = madcomplex(a)  # just trying another form of the constructor
    1:         self.assertEqual(repr(a), "4j-3")
    1:         self.assertEqual(a, base)
    1:         self.assertEqual(complex(a), base)
    1:         self.assertEqual(complex(a).__class__, complex)
    1:         self.assertEqual(hash(a), hash(base))
    1:         self.assertEqual((+a).__class__, complex)
    1:         self.assertEqual((a + 0).__class__, complex)
    1:         self.assertEqual(a + 0, base)
    1:         self.assertEqual((a - 0).__class__, complex)
    1:         self.assertEqual(a - 0, base)
    1:         self.assertEqual((a * 1).__class__, complex)
    1:         self.assertEqual(a * 1, base)
    1:         self.assertEqual((a / 1).__class__, complex)
    1:         self.assertEqual(a / 1, base)
       
    2:         class madtuple(tuple):
    1:             _rev = None
    1:             def rev(self):
 1027:                 if self._rev is not None:
    1:                     return self._rev
 1026:                 L = list(self)
 1026:                 L.reverse()
 1026:                 self._rev = self.__class__(L)
 1026:                 return self._rev
    1:         a = madtuple((1,2,3,4,5,6,7,8,9,0))
    1:         self.assertEqual(a, (1,2,3,4,5,6,7,8,9,0))
    1:         self.assertEqual(a.rev(), madtuple((0,9,8,7,6,5,4,3,2,1)))
    1:         self.assertEqual(a.rev().rev(), madtuple((1,2,3,4,5,6,7,8,9,0)))
  513:         for i in range(512):
  512:             t = madtuple(range(i))
  512:             u = t.rev()
  512:             v = u.rev()
  512:             self.assertEqual(v, t)
    1:         a = madtuple((1,2,3,4,5))
    1:         self.assertEqual(tuple(a), (1,2,3,4,5))
    1:         self.assertIs(tuple(a).__class__, tuple)
    1:         self.assertEqual(hash(a), hash((1,2,3,4,5)))
    1:         self.assertIs(a[:].__class__, tuple)
    1:         self.assertIs((a * 1).__class__, tuple)
    1:         self.assertIs((a * 0).__class__, tuple)
    1:         self.assertIs((a + ()).__class__, tuple)
    1:         a = madtuple(())
    1:         self.assertEqual(tuple(a), ())
    1:         self.assertIs(tuple(a).__class__, tuple)
    1:         self.assertIs((a + a).__class__, tuple)
    1:         self.assertIs((a * 0).__class__, tuple)
    1:         self.assertIs((a * 1).__class__, tuple)
    1:         self.assertIs((a * 2).__class__, tuple)
    1:         self.assertIs(a[:].__class__, tuple)
       
    2:         class madstring(str):
    1:             _rev = None
    1:             def rev(self):
  515:                 if self._rev is not None:
    1:                     return self._rev
  514:                 L = list(self)
  514:                 L.reverse()
  514:                 self._rev = self.__class__("".join(L))
  514:                 return self._rev
    1:         s = madstring("abcdefghijklmnopqrstuvwxyz")
    1:         self.assertEqual(s, "abcdefghijklmnopqrstuvwxyz")
    1:         self.assertEqual(s.rev(), madstring("zyxwvutsrqponmlkjihgfedcba"))
    1:         self.assertEqual(s.rev().rev(), madstring("abcdefghijklmnopqrstuvwxyz"))
  257:         for i in range(256):
  256:             s = madstring("".join(map(chr, range(i))))
  256:             t = s.rev()
  256:             u = t.rev()
  256:             self.assertEqual(u, s)
    1:         s = madstring("12345")
    1:         self.assertEqual(str(s), "12345")
    1:         self.assertIs(str(s).__class__, str)
       
    1:         base = "\x00" * 5
    1:         s = madstring(base)
    1:         self.assertEqual(s, base)
    1:         self.assertEqual(str(s), base)
    1:         self.assertIs(str(s).__class__, str)
    1:         self.assertEqual(hash(s), hash(base))
    1:         self.assertEqual({s: 1}[base], 1)
    1:         self.assertEqual({base: 1}[s], 1)
    1:         self.assertIs((s + "").__class__, str)
    1:         self.assertEqual(s + "", base)
    1:         self.assertIs(("" + s).__class__, str)
    1:         self.assertEqual("" + s, base)
    1:         self.assertIs((s * 0).__class__, str)
    1:         self.assertEqual(s * 0, "")
    1:         self.assertIs((s * 1).__class__, str)
    1:         self.assertEqual(s * 1, base)
    1:         self.assertIs((s * 2).__class__, str)
    1:         self.assertEqual(s * 2, base + base)
    1:         self.assertIs(s[:].__class__, str)
    1:         self.assertEqual(s[:], base)
    1:         self.assertIs(s[0:0].__class__, str)
    1:         self.assertEqual(s[0:0], "")
    1:         self.assertIs(s.strip().__class__, str)
    1:         self.assertEqual(s.strip(), base)
    1:         self.assertIs(s.lstrip().__class__, str)
    1:         self.assertEqual(s.lstrip(), base)
    1:         self.assertIs(s.rstrip().__class__, str)
    1:         self.assertEqual(s.rstrip(), base)
  257:         identitytab = ''.join([chr(i) for i in range(256)])
    1:         self.assertIs(s.translate(identitytab).__class__, str)
    1:         self.assertEqual(s.translate(identitytab), base)
    1:         self.assertIs(s.translate(identitytab, "x").__class__, str)
    1:         self.assertEqual(s.translate(identitytab, "x"), base)
    1:         self.assertEqual(s.translate(identitytab, "\x00"), "")
    1:         self.assertIs(s.replace("x", "x").__class__, str)
    1:         self.assertEqual(s.replace("x", "x"), base)
    1:         self.assertIs(s.ljust(len(s)).__class__, str)
    1:         self.assertEqual(s.ljust(len(s)), base)
    1:         self.assertIs(s.rjust(len(s)).__class__, str)
    1:         self.assertEqual(s.rjust(len(s)), base)
    1:         self.assertIs(s.center(len(s)).__class__, str)
    1:         self.assertEqual(s.center(len(s)), base)
    1:         self.assertIs(s.lower().__class__, str)
    1:         self.assertEqual(s.lower(), base)
       
    2:         class madunicode(unicode):
    1:             _rev = None
    1:             def rev(self):
    3:                 if self._rev is not None:
    1:                     return self._rev
    2:                 L = list(self)
    2:                 L.reverse()
    2:                 self._rev = self.__class__(u"".join(L))
    2:                 return self._rev
    1:         u = madunicode("ABCDEF")
    1:         self.assertEqual(u, u"ABCDEF")
    1:         self.assertEqual(u.rev(), madunicode(u"FEDCBA"))
    1:         self.assertEqual(u.rev().rev(), madunicode(u"ABCDEF"))
    1:         base = u"12345"
    1:         u = madunicode(base)
    1:         self.assertEqual(unicode(u), base)
    1:         self.assertIs(unicode(u).__class__, unicode)
    1:         self.assertEqual(hash(u), hash(base))
    1:         self.assertEqual({u: 1}[base], 1)
    1:         self.assertEqual({base: 1}[u], 1)
    1:         self.assertIs(u.strip().__class__, unicode)
    1:         self.assertEqual(u.strip(), base)
    1:         self.assertIs(u.lstrip().__class__, unicode)
    1:         self.assertEqual(u.lstrip(), base)
    1:         self.assertIs(u.rstrip().__class__, unicode)
    1:         self.assertEqual(u.rstrip(), base)
    1:         self.assertIs(u.replace(u"x", u"x").__class__, unicode)
    1:         self.assertEqual(u.replace(u"x", u"x"), base)
    1:         self.assertIs(u.replace(u"xy", u"xy").__class__, unicode)
    1:         self.assertEqual(u.replace(u"xy", u"xy"), base)
    1:         self.assertIs(u.center(len(u)).__class__, unicode)
    1:         self.assertEqual(u.center(len(u)), base)
    1:         self.assertIs(u.ljust(len(u)).__class__, unicode)
    1:         self.assertEqual(u.ljust(len(u)), base)
    1:         self.assertIs(u.rjust(len(u)).__class__, unicode)
    1:         self.assertEqual(u.rjust(len(u)), base)
    1:         self.assertIs(u.lower().__class__, unicode)
    1:         self.assertEqual(u.lower(), base)
    1:         self.assertIs(u.upper().__class__, unicode)
    1:         self.assertEqual(u.upper(), base)
    1:         self.assertIs(u.capitalize().__class__, unicode)
    1:         self.assertEqual(u.capitalize(), base)
    1:         self.assertIs(u.title().__class__, unicode)
    1:         self.assertEqual(u.title(), base)
    1:         self.assertIs((u + u"").__class__, unicode)
    1:         self.assertEqual(u + u"", base)
    1:         self.assertIs((u"" + u).__class__, unicode)
    1:         self.assertEqual(u"" + u, base)
    1:         self.assertIs((u * 0).__class__, unicode)
    1:         self.assertEqual(u * 0, u"")
    1:         self.assertIs((u * 1).__class__, unicode)
    1:         self.assertEqual(u * 1, base)
    1:         self.assertIs((u * 2).__class__, unicode)
    1:         self.assertEqual(u * 2, base + base)
    1:         self.assertIs(u[:].__class__, unicode)
    1:         self.assertEqual(u[:], base)
    1:         self.assertIs(u[0:0].__class__, unicode)
    1:         self.assertEqual(u[0:0], u"")
       
    2:         class sublist(list):
    1:             pass
    1:         a = sublist(range(5))
    1:         self.assertEqual(a, range(5))
    1:         a.append("hello")
    1:         self.assertEqual(a, range(5) + ["hello"])
    1:         a[5] = 5
    1:         self.assertEqual(a, range(6))
    1:         a.extend(range(6, 20))
    1:         self.assertEqual(a, range(20))
    1:         a[-5:] = []
    1:         self.assertEqual(a, range(15))
    1:         del a[10:15]
    1:         self.assertEqual(len(a), 10)
    1:         self.assertEqual(a, range(10))
    1:         self.assertEqual(list(a), range(10))
    1:         self.assertEqual(a[0], 0)
    1:         self.assertEqual(a[9], 9)
    1:         self.assertEqual(a[-10], 0)
    1:         self.assertEqual(a[-1], 9)
    1:         self.assertEqual(a[:5], range(5))
       
    2:         class CountedInput(file):
                   """Counts lines read by self.readline().
       
                   self.lineno is the 0-based ordinal of the last line read, up to
                   a maximum of one greater than the number of lines in the file.
       
                   self.ateof is true if and only if the final "" line has been read,
                   at which point self.lineno stops incrementing, and further calls
                   to readline() continue to return "".
    1:             """
       
    1:             lineno = 0
    1:             ateof = 0
    1:             def readline(self):
    5:                 if self.ateof:
    1:                     return ""
    4:                 s = file.readline(self)
                       # Next line works too.
                       # s = super(CountedInput, self).readline()
    4:                 self.lineno += 1
    4:                 if s == "":
    1:                     self.ateof = 1
    4:                 return s
       
    1:         f = file(name=test_support.TESTFN, mode='w')
    1:         lines = ['a\n', 'b\n', 'c\n']
    1:         try:
    1:             f.writelines(lines)
    1:             f.close()
    1:             f = CountedInput(test_support.TESTFN)
    6:             for (i, expected) in zip(range(1, 5) + [4], lines + 2 * [""]):
    5:                 got = f.readline()
    5:                 self.assertEqual(expected, got)
    5:                 self.assertEqual(f.lineno, i)
    5:                 self.assertEqual(f.ateof, (i > len(lines)))
    1:             f.close()
               finally:
    1:             try:
    1:                 f.close()
>>>>>>             except:
>>>>>>                 pass
    1:             test_support.unlink(test_support.TESTFN)
       
    1:     def test_keywords(self):
               # Testing keyword args to basic type constructors ...
    1:         self.assertEqual(int(x=1), 1)
    1:         self.assertEqual(float(x=2), 2.0)
    1:         self.assertEqual(long(x=3), 3L)
    1:         self.assertEqual(complex(imag=42, real=666), complex(666, 42))
    1:         self.assertEqual(str(object=500), '500')
    1:         self.assertEqual(unicode(string='abc', errors='strict'), u'abc')
    1:         self.assertEqual(tuple(sequence=range(3)), (0, 1, 2))
    1:         self.assertEqual(list(sequence=(0, 1, 2)), range(3))
               # note: as of Python 2.3, dict() no longer has an "items" keyword arg
       
    1:         for constructor in (int, float, long, complex, str, unicode,
   10:                             tuple, list, file):
    9:             try:
    9:                 constructor(bogus_keyword_arg=1)
    9:             except TypeError:
    9:                 pass
                   else:
>>>>>>                 self.fail("expected TypeError from bogus keyword argument to %r"
>>>>>>                             % constructor)
       
    1:     def test_str_subclass_as_dict_key(self):
               # Testing a str subclass used as dict key ..
       
>>>>>>         class cistr(str):
                   """Sublcass of str that computes __eq__ case-insensitively.
       
                   Also computes a hash code of the string in canonical form.
                   """
       
>>>>>>             def __init__(self, value):
>>>>>>                 self.canonical = value.lower()
>>>>>>                 self.hashcode = hash(self.canonical)
       
>>>>>>             def __eq__(self, other):
>>>>>>                 if not isinstance(other, cistr):
>>>>>>                     other = cistr(other)
>>>>>>                 return self.canonical == other.canonical
       
>>>>>>             def __hash__(self):
>>>>>>                 return self.hashcode
       
>>>>>>         self.assertEqual(cistr('ABC'), 'abc')
>>>>>>         self.assertEqual('aBc', cistr('ABC'))
>>>>>>         self.assertEqual(str(cistr('ABC')), 'ABC')
       
>>>>>>         d = {cistr('one'): 1, cistr('two'): 2, cistr('tHree'): 3}
>>>>>>         self.assertEqual(d[cistr('one')], 1)
>>>>>>         self.assertEqual(d[cistr('tWo')], 2)
>>>>>>         self.assertEqual(d[cistr('THrEE')], 3)
>>>>>>         self.assertIn(cistr('ONe'), d)
>>>>>>         self.assertEqual(d.get(cistr('thrEE')), 3)
       
    1:     def test_classic_comparisons(self):
               # Testing classic comparisons...
    2:         class classic:
    1:             pass
       
    4:         for base in (classic, int, object):
    6:             class C(base):
    3:                 def __init__(self, value):
    9:                     self.value = int(value)
    3:                 def __cmp__(self, other):
  237:                     if isinstance(other, C):
  180:                         return cmp(self.value, other.value)
   57:                     if isinstance(other, int) or isinstance(other, long):
   57:                         return cmp(self.value, other)
>>>>>>                     return NotImplemented
    3:                 __hash__ = None # Silence Py3k warning
       
    3:             c1 = C(1)
    3:             c2 = C(2)
    3:             c3 = C(3)
    3:             self.assertEqual(c1, 1)
    3:             c = {1: c1, 2: c2, 3: c3}
   12:             for x in 1, 2, 3:
   36:                 for y in 1, 2, 3:
   27:                     self.assertEqual(cmp(c[x], c[y]), cmp(x, y),
   27:                                      "x=%d, y=%d" % (x, y))
  189:                     for op in "<", "<=", "==", "!=", ">", ">=":
  162:                         self.assertEqual(eval("c[x] %s c[y]" % op),
  162:                                          eval("x %s y" % op),
  162:                                          "x=%d, y=%d" % (x, y))
   27:                     self.assertEqual(cmp(c[x], y), cmp(x, y),
   27:                                      "x=%d, y=%d" % (x, y))
   27:                     self.assertEqual(cmp(x, c[y]), cmp(x, y),
   27:                                      "x=%d, y=%d" % (x, y))
       
    1:     def test_rich_comparisons(self):
               # Testing rich comparisons...
>>>>>>         class Z(complex):
>>>>>>             pass
>>>>>>         z = Z(1)
>>>>>>         self.assertEqual(z, 1+0j)
>>>>>>         self.assertEqual(1+0j, z)
>>>>>>         class ZZ(complex):
>>>>>>             def __eq__(self, other):
>>>>>>                 try:
>>>>>>                     return abs(self - other) <= 1e-6
>>>>>>                 except:
>>>>>>                     return NotImplemented
>>>>>>             __hash__ = None # Silence Py3k warning
>>>>>>         zz = ZZ(1.0000003)
>>>>>>         self.assertEqual(zz, 1+0j)
>>>>>>         self.assertEqual(1+0j, zz)
       
>>>>>>         class classic:
>>>>>>             pass
>>>>>>         for base in (classic, int, object, list):
>>>>>>             class C(base):
>>>>>>                 def __init__(self, value):
>>>>>>                     self.value = int(value)
>>>>>>                 def __cmp__(self_, other):
>>>>>>                     self.fail("shouldn't call __cmp__")
>>>>>>                 __hash__ = None # Silence Py3k warning
>>>>>>                 def __eq__(self, other):
>>>>>>                     if isinstance(other, C):
>>>>>>                         return self.value == other.value
>>>>>>                     if isinstance(other, int) or isinstance(other, long):
>>>>>>                         return self.value == other
>>>>>>                     return NotImplemented
>>>>>>                 def __ne__(self, other):
>>>>>>                     if isinstance(other, C):
>>>>>>                         return self.value != other.value
>>>>>>                     if isinstance(other, int) or isinstance(other, long):
>>>>>>                         return self.value != other
>>>>>>                     return NotImplemented
>>>>>>                 def __lt__(self, other):
>>>>>>                     if isinstance(other, C):
>>>>>>                         return self.value < other.value
>>>>>>                     if isinstance(other, int) or isinstance(other, long):
>>>>>>                         return self.value < other
>>>>>>                     return NotImplemented
>>>>>>                 def __le__(self, other):
>>>>>>                     if isinstance(other, C):
>>>>>>                         return self.value <= other.value
>>>>>>                     if isinstance(other, int) or isinstance(other, long):
>>>>>>                         return self.value <= other
>>>>>>                     return NotImplemented
>>>>>>                 def __gt__(self, other):
>>>>>>                     if isinstance(other, C):
>>>>>>                         return self.value > other.value
>>>>>>                     if isinstance(other, int) or isinstance(other, long):
>>>>>>                         return self.value > other
>>>>>>                     return NotImplemented
>>>>>>                 def __ge__(self, other):
>>>>>>                     if isinstance(other, C):
>>>>>>                         return self.value >= other.value
>>>>>>                     if isinstance(other, int) or isinstance(other, long):
>>>>>>                         return self.value >= other
>>>>>>                     return NotImplemented
>>>>>>             c1 = C(1)
>>>>>>             c2 = C(2)
>>>>>>             c3 = C(3)
>>>>>>             self.assertEqual(c1, 1)
>>>>>>             c = {1: c1, 2: c2, 3: c3}
>>>>>>             for x in 1, 2, 3:
>>>>>>                 for y in 1, 2, 3:
>>>>>>                     for op in "<", "<=", "==", "!=", ">", ">=":
>>>>>>                         self.assertEqual(eval("c[x] %s c[y]" % op),
>>>>>>                                          eval("x %s y" % op),
>>>>>>                                          "x=%d, y=%d" % (x, y))
>>>>>>                         self.assertEqual(eval("c[x] %s y" % op),
>>>>>>                                          eval("x %s y" % op),
>>>>>>                                          "x=%d, y=%d" % (x, y))
>>>>>>                         self.assertEqual(eval("x %s c[y]" % op),
>>>>>>                                          eval("x %s y" % op),
>>>>>>                                          "x=%d, y=%d" % (x, y))
       
    1:     def test_coercions(self):
               # Testing coercions...
    2:         class I(int): pass
    1:         coerce(I(0), 0)
    1:         coerce(0, I(0))
    2:         class L(long): pass
    1:         coerce(L(0), 0)
    1:         coerce(L(0), 0L)
    1:         coerce(0, L(0))
    1:         coerce(0L, L(0))
    2:         class F(float): pass
    1:         coerce(F(0), 0)
    1:         coerce(F(0), 0L)
    1:         coerce(F(0), 0.)
    1:         coerce(0, F(0))
    1:         coerce(0L, F(0))
    1:         coerce(0., F(0))
    2:         class C(complex): pass
    1:         coerce(C(0), 0)
    1:         coerce(C(0), 0L)
    1:         coerce(C(0), 0.)
    1:         coerce(C(0), 0j)
    1:         coerce(0, C(0))
    1:         coerce(0L, C(0))
    1:         coerce(0., C(0))
    1:         coerce(0j, C(0))
       
    1:     def test_descrdoc(self):
               # Testing descriptor doc strings...
    1:         def check(descr, what):
    2:             self.assertEqual(descr.__doc__, what)
    1:         check(file.closed, "True if the file is closed") # getset descriptor
    1:         check(file.name, "file name") # member descriptor
       
    1:     def test_doc_descriptor(self):
               # Testing __doc__ descriptor...
               # SF bug 542984
    2:         class DocDescr(object):
    1:             def __get__(self, object, otype):
    4:                 if object:
    2:                     object = object.__class__.__name__ + ' instance'
    4:                 if otype:
    4:                     otype = otype.__name__
    4:                 return 'object=%s; type=%s' % (object, otype)
    2:         class OldClass:
    1:             __doc__ = DocDescr()
    2:         class NewClass(object):
    1:             __doc__ = DocDescr()
    1:         self.assertEqual(OldClass.__doc__, 'object=None; type=OldClass')
    1:         self.assertEqual(OldClass().__doc__, 'object=OldClass instance; type=OldClass')
    1:         self.assertEqual(NewClass.__doc__, 'object=None; type=NewClass')
    1:         self.assertEqual(NewClass().__doc__, 'object=NewClass instance; type=NewClass')
       
    1:     def test_set_class(self):
               # Testing __class__ assignment...
>>>>>>         class C(object): pass
>>>>>>         class D(object): pass
>>>>>>         class E(object): pass
>>>>>>         class F(D, E): pass
>>>>>>         for cls in C, D, E, F:
>>>>>>             for cls2 in C, D, E, F:
>>>>>>                 x = cls()
>>>>>>                 x.__class__ = cls2
>>>>>>                 self.assertIs(x.__class__, cls2)
>>>>>>                 x.__class__ = cls
>>>>>>                 self.assertIs(x.__class__, cls)
>>>>>>         def cant(x, C):
>>>>>>             try:
>>>>>>                 x.__class__ = C
>>>>>>             except TypeError:
>>>>>>                 pass
                   else:
>>>>>>                 self.fail("shouldn't allow %r.__class__ = %r" % (x, C))
>>>>>>             try:
>>>>>>                 delattr(x, "__class__")
>>>>>>             except (TypeError, AttributeError):
>>>>>>                 pass
                   else:
>>>>>>                 self.fail("shouldn't allow del %r.__class__" % x)
>>>>>>         cant(C(), list)
>>>>>>         cant(list(), C)
>>>>>>         cant(C(), 1)
>>>>>>         cant(C(), object)
>>>>>>         cant(object(), list)
>>>>>>         cant(list(), object)
>>>>>>         class Int(int): __slots__ = []
>>>>>>         cant(2, Int)
>>>>>>         cant(Int(), int)
>>>>>>         cant(True, int)
>>>>>>         cant(2, bool)
>>>>>>         o = object()
>>>>>>         cant(o, type(1))
>>>>>>         cant(o, type(None))
>>>>>>         del o
>>>>>>         class G(object):
>>>>>>             __slots__ = ["a", "b"]
>>>>>>         class H(object):
>>>>>>             __slots__ = ["b", "a"]
>>>>>>         try:
>>>>>>             unicode
>>>>>>         except NameError:
>>>>>>             class I(object):
>>>>>>                 __slots__ = ["a", "b"]
               else:
>>>>>>             class I(object):
>>>>>>                 __slots__ = [unicode("a"), unicode("b")]
>>>>>>         class J(object):
>>>>>>             __slots__ = ["c", "b"]
>>>>>>         class K(object):
>>>>>>             __slots__ = ["a", "b", "d"]
>>>>>>         class L(H):
>>>>>>             __slots__ = ["e"]
>>>>>>         class M(I):
>>>>>>             __slots__ = ["e"]
>>>>>>         class N(J):
>>>>>>             __slots__ = ["__weakref__"]
>>>>>>         class P(J):
>>>>>>             __slots__ = ["__dict__"]
>>>>>>         class Q(J):
>>>>>>             pass
>>>>>>         class R(J):
>>>>>>             __slots__ = ["__dict__", "__weakref__"]
       
>>>>>>         for cls, cls2 in ((G, H), (G, I), (I, H), (Q, R), (R, Q)):
>>>>>>             x = cls()
>>>>>>             x.a = 1
>>>>>>             x.__class__ = cls2
>>>>>>             self.assertIs(x.__class__, cls2,
>>>>>>                    "assigning %r as __class__ for %r silently failed" % (cls2, x))
>>>>>>             self.assertEqual(x.a, 1)
>>>>>>             x.__class__ = cls
>>>>>>             self.assertIs(x.__class__, cls,
>>>>>>                    "assigning %r as __class__ for %r silently failed" % (cls, x))
>>>>>>             self.assertEqual(x.a, 1)
>>>>>>         for cls in G, J, K, L, M, N, P, R, list, Int:
>>>>>>             for cls2 in G, J, K, L, M, N, P, R, list, Int:
>>>>>>                 if cls is cls2:
>>>>>>                     continue
>>>>>>                 cant(cls(), cls2)
       
               # Issue5283: when __class__ changes in __del__, the wrong
               # type gets DECREF'd.
>>>>>>         class O(object):
>>>>>>             pass
>>>>>>         class A(object):
>>>>>>             def __del__(self):
>>>>>>                 self.__class__ = O
>>>>>>         l = [A() for x in range(100)]
>>>>>>         del l
       
    1:     def test_set_dict(self):
               # Testing __dict__ assignment...
>>>>>>         class C(object): pass
>>>>>>         a = C()
>>>>>>         a.__dict__ = {'b': 1}
>>>>>>         self.assertEqual(a.b, 1)
>>>>>>         def cant(x, dict):
>>>>>>             try:
>>>>>>                 x.__dict__ = dict
>>>>>>             except (AttributeError, TypeError):
>>>>>>                 pass
                   else:
>>>>>>                 self.fail("shouldn't allow %r.__dict__ = %r" % (x, dict))
>>>>>>         cant(a, None)
>>>>>>         cant(a, [])
>>>>>>         cant(a, 1)
>>>>>>         del a.__dict__ # Deleting __dict__ is allowed
       
>>>>>>         class Base(object):
>>>>>>             pass
>>>>>>         def verify_dict_readonly(x):
                   """
                   x has to be an instance of a class inheriting from Base.
                   """
>>>>>>             cant(x, {})
>>>>>>             try:
>>>>>>                 del x.__dict__
>>>>>>             except (AttributeError, TypeError):
>>>>>>                 pass
                   else:
>>>>>>                 self.fail("shouldn't allow del %r.__dict__" % x)
>>>>>>             dict_descr = Base.__dict__["__dict__"]
>>>>>>             try:
>>>>>>                 dict_descr.__set__(x, {})
>>>>>>             except (AttributeError, TypeError):
>>>>>>                 pass
                   else:
>>>>>>                 self.fail("dict_descr allowed access to %r's dict" % x)
       
               # Classes don't allow __dict__ assignment and have readonly dicts
>>>>>>         class Meta1(type, Base):
>>>>>>             pass
>>>>>>         class Meta2(Base, type):
>>>>>>             pass
>>>>>>         class D(object):
>>>>>>             __metaclass__ = Meta1
>>>>>>         class E(object):
>>>>>>             __metaclass__ = Meta2
>>>>>>         for cls in C, D, E:
>>>>>>             verify_dict_readonly(cls)
>>>>>>             class_dict = cls.__dict__
>>>>>>             try:
>>>>>>                 class_dict["spam"] = "eggs"
>>>>>>             except TypeError:
>>>>>>                 pass
                   else:
>>>>>>                 self.fail("%r's __dict__ can be modified" % cls)
       
               # Modules also disallow __dict__ assignment
>>>>>>         class Module1(types.ModuleType, Base):
>>>>>>             pass
>>>>>>         class Module2(Base, types.ModuleType):
>>>>>>             pass
>>>>>>         for ModuleType in Module1, Module2:
>>>>>>             mod = ModuleType("spam")
>>>>>>             verify_dict_readonly(mod)
>>>>>>             mod.__dict__["spam"] = "eggs"
       
               # Exception's __dict__ can be replaced, but not deleted
               # (at least not any more than regular exception's __dict__ can
               # be deleted; on CPython it is not the case, whereas on PyPy they
               # can, just like any other new-style instance's __dict__.)
>>>>>>         def can_delete_dict(e):
>>>>>>             try:
>>>>>>                 del e.__dict__
>>>>>>             except (TypeError, AttributeError):
>>>>>>                 return False
                   else:
>>>>>>                 return True
>>>>>>         class Exception1(Exception, Base):
>>>>>>             pass
>>>>>>         class Exception2(Base, Exception):
>>>>>>             pass
>>>>>>         for ExceptionType in Exception, Exception1, Exception2:
>>>>>>             e = ExceptionType()
>>>>>>             e.__dict__ = {"a": 1}
>>>>>>             self.assertEqual(e.a, 1)
>>>>>>             self.assertEqual(can_delete_dict(e), can_delete_dict(ValueError()))
       
    1:     def test_pickles(self):
               # Testing pickling and copying new-style classes and objects...
    1:         import pickle, cPickle
       
    1:         def sorteditems(d):
   28:             L = d.items()
   28:             L.sort()
   28:             return L
       
               global C
    2:         class C(object):
    1:             def __init__(self, a, b):
>>>>>>                 super(C, self).__init__()
>>>>>>                 self.a = a
>>>>>>                 self.b = b
    1:             def __repr__(self):
>>>>>>                 return "C(%r, %r)" % (self.a, self.b)
       
               global C1
    2:         class C1(list):
    1:             def __new__(cls, a, b):
   10:                 return super(C1, cls).__new__(cls)
    1:             def __getnewargs__(self):
    3:                 return (self.a, self.b)
    1:             def __init__(self, a, b):
    7:                 self.a = a
    7:                 self.b = b
    1:             def __repr__(self):
   14:                 return "C1(%r, %r)<%r>" % (self.a, self.b, list(self))
       
               global C2
    2:         class C2(int):
    1:             def __new__(cls, a, b, val=0):
   10:                 return super(C2, cls).__new__(cls, val)
    1:             def __getnewargs__(self):
    3:                 return (self.a, self.b, int(self))
    1:             def __init__(self, a, b, val=0):
    7:                 self.a = a
    7:                 self.b = b
    1:             def __repr__(self):
   14:                 return "C2(%r, %r)<%r>" % (self.a, self.b, int(self))
       
               global C3
    2:         class C3(object):
    1:             def __init__(self, foo):
    6:                 self.foo = foo
    1:             def __getstate__(self):
    6:                 return self.foo
    1:             def __setstate__(self, foo):
    6:                 self.foo = foo
       
               global C4classic, C4
    2:         class C4classic: # classic
    1:             pass
    2:         class C4(C4classic, object): # mixed inheritance
    1:             pass
       
    3:         for p in pickle, cPickle:
    8:             for bin in range(p.HIGHEST_PROTOCOL + 1):
   24:                 for cls in C, C1, C2:
   18:                     s = p.dumps(cls, bin)
   18:                     cls2 = p.loads(s)
   18:                     self.assertIs(cls2, cls)
       
    6:                 a = C1(1, 2); a.append(42); a.append(24)
    6:                 b = C2("hello", "world", 42)
    6:                 s = p.dumps((a, b), bin)
    6:                 x, y = p.loads(s)
    6:                 self.assertEqual(x.__class__, a.__class__)
    6:                 self.assertEqual(sorteditems(x.__dict__), sorteditems(a.__dict__))
    6:                 self.assertEqual(y.__class__, b.__class__)
    6:                 self.assertEqual(sorteditems(y.__dict__), sorteditems(b.__dict__))
    6:                 self.assertEqual(repr(x), repr(a))
    6:                 self.assertEqual(repr(y), repr(b))
                       # Test for __getstate__ and __setstate__ on new style class
    6:                 u = C3(42)
    6:                 s = p.dumps(u, bin)
    6:                 v = p.loads(s)
    6:                 self.assertEqual(u.__class__, v.__class__)
    6:                 self.assertEqual(u.foo, v.foo)
                       # Test for picklability of hybrid class
    6:                 u = C4()
    6:                 u.foo = 42
    6:                 s = p.dumps(u, bin)
    6:                 v = p.loads(s)
    6:                 self.assertEqual(u.__class__, v.__class__)
    6:                 self.assertEqual(u.foo, v.foo)
       
               # Testing copy.deepcopy()
    1:         import copy
    4:         for cls in C, C1, C2:
    3:             cls2 = copy.deepcopy(cls)
    3:             self.assertIs(cls2, cls)
       
    1:         a = C1(1, 2); a.append(42); a.append(24)
    1:         b = C2("hello", "world", 42)
    1:         x, y = copy.deepcopy((a, b))
    1:         self.assertEqual(x.__class__, a.__class__)
    1:         self.assertEqual(sorteditems(x.__dict__), sorteditems(a.__dict__))
    1:         self.assertEqual(y.__class__, b.__class__)
    1:         self.assertEqual(sorteditems(y.__dict__), sorteditems(b.__dict__))
    1:         self.assertEqual(repr(x), repr(a))
    1:         self.assertEqual(repr(y), repr(b))
       
    1:     def test_pickle_slots(self):
               # Testing pickling of classes with __slots__ ...
    1:         import pickle, cPickle
               # Pickling of classes with __slots__ but without __getstate__ should fail
               global B, C, D, E
    2:         class B(object):
    1:             pass
    3:         for base in [object, B]:
    4:             class C(base):
    2:                 __slots__ = ['a']
    4:             class D(C):
    2:                 pass
    6:             for proto in range(2):
    4:                 try:
    4:                     pickle.dumps(C(), proto)
    4:                 except TypeError:
    4:                     pass
                       else:
>>>>>>                     self.fail("should fail: pickle C instance - %s" % base)
    4:                 try:
    4:                     cPickle.dumps(C(), proto)
    4:                 except TypeError:
    4:                     pass
                       else:
>>>>>>                     self.fail("should fail: cPickle C instance - %s" % base)
    4:                 try:
    4:                     pickle.dumps(C(), proto)
    4:                 except TypeError:
    4:                     pass
                       else:
>>>>>>                     self.fail("should fail: pickle D instance - %s" % base)
    4:                 try:
    4:                     cPickle.dumps(D(), proto)
    4:                 except TypeError:
    4:                     pass
                       else:
>>>>>>                     self.fail("should fail: cPickle D instance - %s" % base)
                   # Give C a nice generic __getstate__ and __setstate__
    4:             class C(base):
    2:                 __slots__ = ['a']
    2:                 def __getstate__(self):
   48:                     try:
   48:                         d = self.__dict__.copy()
   18:                     except AttributeError:
   18:                         d = {}
  192:                     for cls in self.__class__.__mro__:
  204:                         for sn in cls.__dict__.get('__slots__', ()):
   60:                             try:
   60:                                 d[sn] = getattr(self, sn)
   12:                             except AttributeError:
   12:                                 pass
   48:                     return d
    2:                 def __setstate__(self, d):
  100:                     for k, v in d.items():
   60:                         setattr(self, k, v)
    4:             class D(C):
    2:                 pass
                   # Now it should work
    2:             x = C()
    8:             for proto in range(pickle.HIGHEST_PROTOCOL + 1):
    6:                 y = pickle.loads(pickle.dumps(x, proto))
    6:                 self.assertNotHasAttr(y, 'a')
    6:                 y = cPickle.loads(cPickle.dumps(x, proto))
    6:                 self.assertNotHasAttr(y, 'a')
    2:             x.a = 42
    8:             for proto in range(pickle.HIGHEST_PROTOCOL + 1):
    6:                 y = pickle.loads(pickle.dumps(x, proto))
    6:                 self.assertEqual(y.a, 42)
    6:                 y = cPickle.loads(cPickle.dumps(x, proto))
    6:                 self.assertEqual(y.a, 42)
    2:             x = D()
    2:             x.a = 42
    2:             x.b = 100
    8:             for proto in range(pickle.HIGHEST_PROTOCOL + 1):
    6:                 y = pickle.loads(pickle.dumps(x, proto))
    6:                 self.assertEqual(y.a + y.b, 142)
    6:                 y = cPickle.loads(cPickle.dumps(x, proto))
    6:                 self.assertEqual(y.a + y.b, 142)
                   # A subclass that adds a slot should also work
    4:             class E(C):
    2:                 __slots__ = ['b']
    2:             x = E()
    2:             x.a = 42
    2:             x.b = "foo"
    8:             for proto in range(pickle.HIGHEST_PROTOCOL + 1):
    6:                 y = pickle.loads(pickle.dumps(x, proto))
    6:                 self.assertEqual(y.a, x.a)
    6:                 self.assertEqual(y.b, x.b)
    6:                 y = cPickle.loads(cPickle.dumps(x, proto))
    6:                 self.assertEqual(y.a, x.a)
    6:                 self.assertEqual(y.b, x.b)
       
    1:     def test_binary_operator_override(self):
               # Testing overrides of binary operations...
    2:         class I(int):
    1:             def __repr__(self):
    7:                 return "I(%r)" % int(self)
    1:             def __add__(self, other):
    3:                 return I(int(self) + int(other))
    1:             __radd__ = __add__
    1:             def __pow__(self, other, mod=None):
    3:                 if mod is None:
    2:                     return I(pow(int(self), int(other)))
                       else:
    1:                     return I(pow(int(self), int(other), int(mod)))
    1:             def __rpow__(self, other, mod=None):
    1:                 if mod is None:
    1:                     return I(pow(int(other), int(self), mod))
                       else:
>>>>>>                     return I(pow(int(other), int(self), int(mod)))
       
    1:         self.assertEqual(repr(I(1) + I(2)), "I(3)")
    1:         self.assertEqual(repr(I(1) + 2), "I(3)")
    1:         self.assertEqual(repr(1 + I(2)), "I(3)")
    1:         self.assertEqual(repr(I(2) ** I(3)), "I(8)")
    1:         self.assertEqual(repr(2 ** I(3)), "I(8)")
    1:         self.assertEqual(repr(I(2) ** 3), "I(8)")
    1:         self.assertEqual(repr(pow(I(2), I(3), I(5))), "I(3)")
    2:         class S(str):
    1:             def __eq__(self, other):
>>>>>>                 return self.lower() == other.lower()
    1:             __hash__ = None # Silence Py3k warning
       
    1:     def test_subclass_propagation(self):
               # Testing propagation of slot functions to subclasses...
>>>>>>         class A(object):
>>>>>>             pass
>>>>>>         class B(A):
>>>>>>             pass
>>>>>>         class C(A):
>>>>>>             pass
>>>>>>         class D(B, C):
>>>>>>             pass
>>>>>>         d = D()
>>>>>>         orig_hash = hash(d) # related to id(d) in platform-dependent ways
>>>>>>         A.__hash__ = lambda self: 42
>>>>>>         self.assertEqual(hash(d), 42)
>>>>>>         C.__hash__ = lambda self: 314
>>>>>>         self.assertEqual(hash(d), 314)
>>>>>>         B.__hash__ = lambda self: 144
>>>>>>         self.assertEqual(hash(d), 144)
>>>>>>         D.__hash__ = lambda self: 100
>>>>>>         self.assertEqual(hash(d), 100)
>>>>>>         D.__hash__ = None
>>>>>>         self.assertRaises(TypeError, hash, d)
>>>>>>         del D.__hash__
>>>>>>         self.assertEqual(hash(d), 144)
>>>>>>         B.__hash__ = None
>>>>>>         self.assertRaises(TypeError, hash, d)
>>>>>>         del B.__hash__
>>>>>>         self.assertEqual(hash(d), 314)
>>>>>>         C.__hash__ = None
>>>>>>         self.assertRaises(TypeError, hash, d)
>>>>>>         del C.__hash__
>>>>>>         self.assertEqual(hash(d), 42)
>>>>>>         A.__hash__ = None
>>>>>>         self.assertRaises(TypeError, hash, d)
>>>>>>         del A.__hash__
>>>>>>         self.assertEqual(hash(d), orig_hash)
>>>>>>         d.foo = 42
>>>>>>         d.bar = 42
>>>>>>         self.assertEqual(d.foo, 42)
>>>>>>         self.assertEqual(d.bar, 42)
>>>>>>         def __getattribute__(self, name):
>>>>>>             if name == "foo":
>>>>>>                 return 24
>>>>>>             return object.__getattribute__(self, name)
>>>>>>         A.__getattribute__ = __getattribute__
>>>>>>         self.assertEqual(d.foo, 24)
>>>>>>         self.assertEqual(d.bar, 42)
>>>>>>         def __getattr__(self, name):
>>>>>>             if name in ("spam", "foo", "bar"):
>>>>>>                 return "hello"
>>>>>>             raise AttributeError, name
>>>>>>         B.__getattr__ = __getattr__
>>>>>>         self.assertEqual(d.spam, "hello")
>>>>>>         self.assertEqual(d.foo, 24)
>>>>>>         self.assertEqual(d.bar, 42)
>>>>>>         del A.__getattribute__
>>>>>>         self.assertEqual(d.foo, 42)
>>>>>>         del d.foo
>>>>>>         self.assertEqual(d.foo, "hello")
>>>>>>         self.assertEqual(d.bar, 42)
>>>>>>         del B.__getattr__
>>>>>>         try:
>>>>>>             d.foo
>>>>>>         except AttributeError:
>>>>>>             pass
               else:
>>>>>>             self.fail("d.foo should be undefined now")
       
               # Test a nasty bug in recurse_down_subclasses()
>>>>>>         class A(object):
>>>>>>             pass
>>>>>>         class B(A):
>>>>>>             pass
>>>>>>         del B
>>>>>>         test_support.gc_collect()
>>>>>>         A.__setitem__ = lambda *a: None # crash
       
    1:     def test_buffer_inheritance(self):
               # Testing that buffer interface is inherited ...
       
    1:         import binascii
               # SF bug [#470040] ParseTuple t# vs subclasses.
       
    2:         class MyStr(str):
    1:             pass
    1:         base = 'abc'
    1:         m = MyStr(base)
               # b2a_hex uses the buffer interface to get its argument's value, via
               # PyArg_ParseTuple 't#' code.
    1:         self.assertEqual(binascii.b2a_hex(m), binascii.b2a_hex(base))
       
               # It's not clear that unicode will continue to support the character
               # buffer interface, and this test will fail if that's taken away.
    2:         class MyUni(unicode):
    1:             pass
    1:         base = u'abc'
    1:         m = MyUni(base)
    1:         self.assertEqual(binascii.b2a_hex(m), binascii.b2a_hex(base))
       
    2:         class MyInt(int):
    1:             pass
    1:         m = MyInt(42)
    1:         try:
    1:             binascii.b2a_hex(m)
>>>>>>             self.fail('subclass of int should not have a buffer interface')
    1:         except TypeError:
    1:             pass
       
    1:     def test_str_of_str_subclass(self):
               # Testing __str__ defined in subclass of str ...
>>>>>>         import binascii
>>>>>>         import cStringIO
       
>>>>>>         class octetstring(str):
>>>>>>             def __str__(self):
>>>>>>                 return binascii.b2a_hex(self)
>>>>>>             def __repr__(self):
>>>>>>                 return self + " repr"
       
>>>>>>         o = octetstring('A')
>>>>>>         self.assertEqual(type(o), octetstring)
>>>>>>         self.assertEqual(type(str(o)), str)
>>>>>>         self.assertEqual(type(repr(o)), str)
>>>>>>         self.assertEqual(ord(o), 0x41)
>>>>>>         self.assertEqual(str(o), '41')
>>>>>>         self.assertEqual(repr(o), 'A repr')
>>>>>>         self.assertEqual(o.__str__(), '41')
>>>>>>         self.assertEqual(o.__repr__(), 'A repr')
       
>>>>>>         capture = cStringIO.StringIO()
               # Calling str() or not exercises different internal paths.
>>>>>>         print >> capture, o
>>>>>>         print >> capture, str(o)
>>>>>>         self.assertEqual(capture.getvalue(), '41\n41\n')
>>>>>>         capture.close()
       
    1:     def test_keyword_arguments(self):
               # Testing keyword arguments to __init__, __call__...
    2:         def f(a): return a
    1:         self.assertEqual(f.__call__(a=42), 42)
    1:         a = []
    1:         list.__init__(a, sequence=[0, 1, 2])
    1:         self.assertEqual(a, [0, 1, 2])
       
    1:     def test_recursive_call(self):
               # Testing recursive __call__() by setting to instance of class...
>>>>>>         class A(object):
>>>>>>             pass
       
>>>>>>         A.__call__ = A()
>>>>>>         try:
>>>>>>             A()()
>>>>>>         except RuntimeError:
>>>>>>             pass
               else:
>>>>>>             self.fail("Recursion limit should have been reached for __call__()")
       
    1:     def test_delete_hook(self):
               # Testing __del__ hook...
    1:         log = []
    2:         class C(object):
    1:             def __del__(self):
>>>>>>                 log.append(1)
    1:         c = C()
    1:         self.assertEqual(log, [])
    1:         del c
    1:         test_support.gc_collect()
    1:         self.assertEqual(log, [1])
       
    2:         class D(object): pass
    1:         d = D()
    1:         try: del d[0]
    1:         except TypeError: pass
>>>>>>         else: self.fail("invalid del() didn't raise TypeError")
       
    1:     def test_hash_inheritance(self):
               # Testing hash of mutable subclasses...
       
    2:         class mydict(dict):
    1:             pass
    1:         d = mydict()
    1:         try:
    1:             hash(d)
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("hash() of dict subclass should fail")
       
    2:         class mylist(list):
    1:             pass
    1:         d = mylist()
    1:         try:
    1:             hash(d)
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("hash() of list subclass should fail")
       
    1:     def test_str_operations(self):
>>>>>>         try: 'a' + 5
>>>>>>         except TypeError: pass
>>>>>>         else: self.fail("'' + 5 doesn't raise TypeError")
       
>>>>>>         try: ''.split('')
>>>>>>         except ValueError: pass
>>>>>>         else: self.fail("''.split('') doesn't raise ValueError")
       
>>>>>>         try: ''.join([0])
>>>>>>         except TypeError: pass
>>>>>>         else: self.fail("''.join([0]) doesn't raise TypeError")
       
>>>>>>         try: ''.rindex('5')
>>>>>>         except ValueError: pass
>>>>>>         else: self.fail("''.rindex('5') doesn't raise ValueError")
       
>>>>>>         try: '%(n)s' % None
>>>>>>         except TypeError: pass
>>>>>>         else: self.fail("'%(n)s' % None doesn't raise TypeError")
       
>>>>>>         try: '%(n' % {}
>>>>>>         except ValueError: pass
>>>>>>         else: self.fail("'%(n' % {} '' doesn't raise ValueError")
       
>>>>>>         try: '%*s' % ('abc')
>>>>>>         except TypeError: pass
>>>>>>         else: self.fail("'%*s' % ('abc') doesn't raise TypeError")
       
>>>>>>         try: '%*.*s' % ('abc', 5)
>>>>>>         except TypeError: pass
>>>>>>         else: self.fail("'%*.*s' % ('abc', 5) doesn't raise TypeError")
       
>>>>>>         try: '%s' % (1, 2)
>>>>>>         except TypeError: pass
>>>>>>         else: self.fail("'%s' % (1, 2) doesn't raise TypeError")
       
>>>>>>         try: '%' % None
>>>>>>         except ValueError: pass
>>>>>>         else: self.fail("'%' % None doesn't raise ValueError")
       
>>>>>>         self.assertEqual('534253'.isdigit(), 1)
>>>>>>         self.assertEqual('534253x'.isdigit(), 0)
>>>>>>         self.assertEqual('%c' % 5, '\x05')
>>>>>>         self.assertEqual('%c' % '5', '5')
       
    1:     def test_deepcopy_recursive(self):
               # Testing deepcopy of recursive objects...
    2:         class Node:
    1:             pass
    1:         a = Node()
    1:         b = Node()
    1:         a.b = b
    1:         b.a = a
    1:         z = deepcopy(a) # This blew up before
       
    1:     def test_uninitialized_modules(self):
               # Testing uninitialized module objects...
>>>>>>         from types import ModuleType as M
>>>>>>         m = M.__new__(M)
>>>>>>         str(m)
>>>>>>         self.assertNotHasAttr(m, "__name__")
>>>>>>         self.assertNotHasAttr(m, "__file__")
>>>>>>         self.assertNotHasAttr(m, "foo")
>>>>>>         self.assertFalse(m.__dict__)   # None or {} are both reasonable answers
>>>>>>         m.foo = 1
>>>>>>         self.assertEqual(m.__dict__, {"foo": 1})
       
    1:     def test_funny_new(self):
               # Testing __new__ returning something unexpected...
    2:         class C(object):
    1:             def __new__(cls, arg):
    5:                 if isinstance(arg, str): return [1, 2, 3]
    3:                 elif isinstance(arg, int): return object.__new__(D)
    1:                 else: return object.__new__(cls)
    2:         class D(C):
    1:             def __init__(self, arg):
    3:                 self.foo = arg
    1:         self.assertEqual(C("1"), [1, 2, 3])
    1:         self.assertEqual(D("1"), [1, 2, 3])
    1:         d = D(None)
    1:         self.assertEqual(d.foo, None)
    1:         d = C(1)
    1:         self.assertEqual(isinstance(d, D), True)
    1:         self.assertEqual(d.foo, 1)
    1:         d = D(1)
    1:         self.assertEqual(isinstance(d, D), True)
    1:         self.assertEqual(d.foo, 1)
       
    2:         class C(object):
    1:             @staticmethod
                   def __new__(*args):
    2:                 return args
    1:         self.assertEqual(C(1, 2), (C, 1, 2))
    2:         class D(C):
    1:             pass
    1:         self.assertEqual(D(1, 2), (D, 1, 2))
       
    2:         class C(object):
    1:             @classmethod
                   def __new__(*args):
    2:                 return args
    1:         self.assertEqual(C(1, 2), (C, C, 1, 2))
    2:         class D(C):
    1:             pass
    1:         self.assertEqual(D(1, 2), (D, D, 1, 2))
       
    1:     def test_imul_bug(self):
               # Testing for __imul__ problems...
               # SF bug 544647
    2:         class C(object):
    1:             def __imul__(self, other):
    6:                 return (self, other)
    1:         x = C()
    1:         y = x
    1:         y *= 1.0
    1:         self.assertEqual(y, (x, 1.0))
    1:         y = x
    1:         y *= 2
    1:         self.assertEqual(y, (x, 2))
    1:         y = x
    1:         y *= 3L
    1:         self.assertEqual(y, (x, 3L))
    1:         y = x
    1:         y *= 1L<<100
    1:         self.assertEqual(y, (x, 1L<<100))
    1:         y = x
    1:         y *= None
    1:         self.assertEqual(y, (x, None))
    1:         y = x
    1:         y *= "foo"
    1:         self.assertEqual(y, (x, "foo"))
       
    1:     def test_copy_setstate(self):
               # Testing that copy.*copy() correctly uses __setstate__...
    1:         import copy
    2:         class C(object):
    1:             def __init__(self, foo=None):
    1:                 self.foo = foo
    1:                 self.__foo = foo
    1:             def setfoo(self, foo=None):
    1:                 self.foo = foo
    1:             def getfoo(self):
    3:                 return self.__foo
    1:             def __getstate__(self):
    2:                 return [self.foo]
    1:             def __setstate__(self_, lst):
    2:                 self.assertEqual(len(lst), 1)
    2:                 self_.__foo = self_.foo = lst[0]
    1:         a = C(42)
    1:         a.setfoo(24)
    1:         self.assertEqual(a.foo, 24)
    1:         self.assertEqual(a.getfoo(), 42)
    1:         b = copy.copy(a)
    1:         self.assertEqual(b.foo, 24)
    1:         self.assertEqual(b.getfoo(), 24)
    1:         b = copy.deepcopy(a)
    1:         self.assertEqual(b.foo, 24)
    1:         self.assertEqual(b.getfoo(), 24)
       
    1:     def test_slices(self):
               # Testing cases with slices and overridden __getitem__ ...
       
               # Strings
>>>>>>         self.assertEqual("hello"[:4], "hell")
>>>>>>         self.assertEqual("hello"[slice(4)], "hell")
>>>>>>         self.assertEqual(str.__getitem__("hello", slice(4)), "hell")
>>>>>>         class S(str):
>>>>>>             def __getitem__(self, x):
>>>>>>                 return str.__getitem__(self, x)
>>>>>>         self.assertEqual(S("hello")[:4], "hell")
>>>>>>         self.assertEqual(S("hello")[slice(4)], "hell")
>>>>>>         self.assertEqual(S("hello").__getitem__(slice(4)), "hell")
               # Tuples
>>>>>>         self.assertEqual((1,2,3)[:2], (1,2))
>>>>>>         self.assertEqual((1,2,3)[slice(2)], (1,2))
>>>>>>         self.assertEqual(tuple.__getitem__((1,2,3), slice(2)), (1,2))
>>>>>>         class T(tuple):
>>>>>>             def __getitem__(self, x):
>>>>>>                 return tuple.__getitem__(self, x)
>>>>>>         self.assertEqual(T((1,2,3))[:2], (1,2))
>>>>>>         self.assertEqual(T((1,2,3))[slice(2)], (1,2))
>>>>>>         self.assertEqual(T((1,2,3)).__getitem__(slice(2)), (1,2))
               # Lists
>>>>>>         self.assertEqual([1,2,3][:2], [1,2])
>>>>>>         self.assertEqual([1,2,3][slice(2)], [1,2])
>>>>>>         self.assertEqual(list.__getitem__([1,2,3], slice(2)), [1,2])
>>>>>>         class L(list):
>>>>>>             def __getitem__(self, x):
>>>>>>                 return list.__getitem__(self, x)
>>>>>>         self.assertEqual(L([1,2,3])[:2], [1,2])
>>>>>>         self.assertEqual(L([1,2,3])[slice(2)], [1,2])
>>>>>>         self.assertEqual(L([1,2,3]).__getitem__(slice(2)), [1,2])
               # Now do lists and __setitem__
>>>>>>         a = L([1,2,3])
>>>>>>         a[slice(1, 3)] = [3,2]
>>>>>>         self.assertEqual(a, [1,3,2])
>>>>>>         a[slice(0, 2, 1)] = [3,1]
>>>>>>         self.assertEqual(a, [3,1,2])
>>>>>>         a.__setitem__(slice(1, 3), [2,1])
>>>>>>         self.assertEqual(a, [3,2,1])
>>>>>>         a.__setitem__(slice(0, 2, 1), [2,3])
>>>>>>         self.assertEqual(a, [2,3,1])
       
    1:     def test_subtype_resurrection(self):
               # Testing resurrection of new-style instance...
       
>>>>>>         class C(object):
>>>>>>             container = []
       
>>>>>>             def __del__(self):
                       # resurrect the instance
>>>>>>                 C.container.append(self)
       
>>>>>>         c = C()
>>>>>>         c.attr = 42
       
               # The most interesting thing here is whether this blows up, due to
               # flawed GC tracking logic in typeobject.c's call_finalizer() (a 2.2.1
               # bug).
>>>>>>         del c
       
               # If that didn't blow up, it's also interesting to see whether clearing
               # the last container slot works: that will attempt to delete c again,
               # which will cause c to get appended back to the container again
               # "during" the del.  (On non-CPython implementations, however, __del__
               # is typically not called again.)
>>>>>>         test_support.gc_collect()
>>>>>>         self.assertEqual(len(C.container), 1)
>>>>>>         del C.container[-1]
>>>>>>         if test_support.check_impl_detail():
>>>>>>             test_support.gc_collect()
>>>>>>             self.assertEqual(len(C.container), 1)
>>>>>>             self.assertEqual(C.container[-1].attr, 42)
       
               # Make c mortal again, so that the test framework with -l doesn't report
               # it as a leak.
>>>>>>         del C.__del__
       
    1:     def test_slots_trash(self):
               # Testing slot trash...
               # Deallocating deeply nested slotted trash caused stack overflows
>>>>>>         class trash(object):
>>>>>>             __slots__ = ['x']
>>>>>>             def __init__(self, x):
>>>>>>                 self.x = x
>>>>>>         o = None
>>>>>>         for i in xrange(50000):
>>>>>>             o = trash(o)
>>>>>>         del o
       
    1:     def test_slots_multiple_inheritance(self):
               # SF bug 575229, multiple inheritance w/ slots dumps core
>>>>>>         class A(object):
>>>>>>             __slots__=()
>>>>>>         class B(object):
>>>>>>             pass
>>>>>>         class C(A,B) :
>>>>>>             __slots__=()
>>>>>>         if test_support.check_impl_detail():
>>>>>>             self.assertEqual(C.__basicsize__, B.__basicsize__)
>>>>>>         self.assertHasAttr(C, '__dict__')
>>>>>>         self.assertHasAttr(C, '__weakref__')
>>>>>>         C().x = 2
       
    1:     def test_rmul(self):
               # Testing correct invocation of __rmul__...
               # SF patch 592646
>>>>>>         class C(object):
>>>>>>             def __mul__(self, other):
>>>>>>                 return "mul"
>>>>>>             def __rmul__(self, other):
>>>>>>                 return "rmul"
>>>>>>         a = C()
>>>>>>         self.assertEqual(a*2, "mul")
>>>>>>         self.assertEqual(a*2.2, "mul")
>>>>>>         self.assertEqual(2*a, "rmul")
>>>>>>         self.assertEqual(2.2*a, "rmul")
       
    1:     def test_ipow(self):
               # Testing correct invocation of __ipow__...
               # [SF bug 620179]
    2:         class C(object):
    1:             def __ipow__(self, other):
    1:                 pass
    1:         a = C()
    1:         a **= 2
       
    1:     def test_mutable_bases(self):
               # Testing mutable bases...
       
               # stuff that should work:
    2:         class C(object):
    1:             pass
    2:         class C2(object):
    1:             def __getattribute__(self, attr):
    4:                 if attr == 'a':
    2:                     return 2
                       else:
    2:                     return super(C2, self).__getattribute__(attr)
    1:             def meth(self):
    2:                 return 1
    2:         class D(C):
    1:             pass
    2:         class E(D):
    1:             pass
    1:         d = D()
    1:         e = E()
    1:         D.__bases__ = (C,)
    1:         D.__bases__ = (C2,)
    1:         self.assertEqual(d.meth(), 1)
    1:         self.assertEqual(e.meth(), 1)
    1:         self.assertEqual(d.a, 2)
    1:         self.assertEqual(e.a, 2)
    1:         self.assertEqual(C2.__subclasses__(), [D])
       
    1:         try:
    1:             del D.__bases__
    1:         except (TypeError, AttributeError):
    1:             pass
               else:
>>>>>>             self.fail("shouldn't be able to delete .__bases__")
       
    1:         try:
    1:             D.__bases__ = ()
    1:         except TypeError, msg:
    1:             if str(msg) == "a new-style class can't have only classic bases":
>>>>>>                 self.fail("wrong error message for .__bases__ = ()")
               else:
>>>>>>             self.fail("shouldn't be able to set .__bases__ to ()")
       
    1:         try:
    1:             D.__bases__ = (D,)
    1:         except TypeError:
    1:             pass
               else:
                   # actually, we'll have crashed by here...
>>>>>>             self.fail("shouldn't be able to create inheritance cycles")
       
    1:         try:
    1:             D.__bases__ = (C, C)
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("didn't detect repeated base classes")
       
    1:         try:
    1:             D.__bases__ = (E,)
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("shouldn't be able to create inheritance cycles")
       
               # let's throw a classic class into the mix:
    2:         class Classic:
    1:             def meth2(self):
    2:                 return 3
       
    1:         D.__bases__ = (C, Classic)
       
    1:         self.assertEqual(d.meth2(), 3)
    1:         self.assertEqual(e.meth2(), 3)
    1:         try:
    1:             d.a
    1:         except AttributeError:
    1:             pass
               else:
>>>>>>             self.fail("attribute should have vanished")
       
    1:         try:
    1:             D.__bases__ = (Classic,)
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("new-style class must have a new-style base")
       
    1:     def test_builtin_bases(self):
               # Make sure all the builtin types can have their base queried without
               # segfaulting. See issue #5787.
  145:         builtin_types = [tp for tp in __builtin__.__dict__.itervalues()
  144:                          if isinstance(tp, type)]
   77:         for tp in builtin_types:
   76:             object.__getattribute__(tp, "__bases__")
   76:             if tp is not object:
   75:                 self.assertEqual(len(tp.__bases__), 1, tp)
       
    2:         class L(list):
    1:             pass
       
    2:         class C(object):
    1:             pass
       
    2:         class D(C):
    1:             pass
       
    1:         try:
    1:             L.__bases__ = (dict,)
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("shouldn't turn list subclass into dict subclass")
       
    1:         try:
    1:             list.__bases__ = (dict,)
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("shouldn't be able to assign to list.__bases__")
       
    1:         try:
    1:             D.__bases__ = (C, list)
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             assert 0, "best_base calculation found wanting"
       
    1:     def test_unsubclassable_types(self):
>>>>>>         with self.assertRaises(TypeError):
>>>>>>             class X(types.NoneType):
>>>>>>                 pass
>>>>>>         with self.assertRaises(TypeError):
>>>>>>             class X(object, types.NoneType):
>>>>>>                 pass
>>>>>>         with self.assertRaises(TypeError):
>>>>>>             class X(types.NoneType, object):
>>>>>>                 pass
>>>>>>         class O(object):
>>>>>>             pass
>>>>>>         with self.assertRaises(TypeError):
>>>>>>             class X(O, types.NoneType):
>>>>>>                 pass
>>>>>>         with self.assertRaises(TypeError):
>>>>>>             class X(types.NoneType, O):
>>>>>>                 pass
       
>>>>>>         class X(object):
>>>>>>             pass
>>>>>>         with self.assertRaises(TypeError):
>>>>>>             X.__bases__ = types.NoneType,
>>>>>>         with self.assertRaises(TypeError):
>>>>>>             X.__bases__ = object, types.NoneType
>>>>>>         with self.assertRaises(TypeError):
>>>>>>             X.__bases__ = types.NoneType, object
>>>>>>         with self.assertRaises(TypeError):
>>>>>>             X.__bases__ = O, types.NoneType
>>>>>>         with self.assertRaises(TypeError):
>>>>>>             X.__bases__ = types.NoneType, O
       
    1:     def test_mutable_bases_with_failing_mro(self):
               # Testing mutable bases with failing mro...
    2:         class WorkOnce(type):
    1:             def __new__(self, name, bases, ns):
    1:                 self.flag = 0
    1:                 return super(WorkOnce, self).__new__(WorkOnce, name, bases, ns)
    1:             def mro(self):
    2:                 if self.flag > 0:
    1:                     raise RuntimeError, "bozo"
                       else:
    1:                     self.flag += 1
    1:                     return type.mro(self)
       
    2:         class WorkAlways(type):
    1:             def mro(self):
                       # this is here to make sure that .mro()s aren't called
                       # with an exception set (which was possible at one point).
                       # An error message will be printed in a debug build.
                       # What's a good way to test for this?
    1:                 return type.mro(self)
       
    2:         class C(object):
    1:             pass
       
    2:         class C2(object):
    1:             pass
       
    2:         class D(C):
    1:             pass
       
    2:         class E(D):
    1:             pass
       
    2:         class F(D):
    1:             __metaclass__ = WorkOnce
       
    2:         class G(D):
    1:             __metaclass__ = WorkAlways
       
               # Immediate subclasses have their mro's adjusted in alphabetical
               # order, so E's will get adjusted before adjusting F's fails.  We
               # check here that E's gets restored.
       
    1:         E_mro_before = E.__mro__
    1:         D_mro_before = D.__mro__
       
    1:         try:
    1:             D.__bases__ = (C2,)
    1:         except RuntimeError:
    1:             self.assertEqual(E.__mro__, E_mro_before)
    1:             self.assertEqual(D.__mro__, D_mro_before)
               else:
>>>>>>             self.fail("exception not propagated")
       
    1:     def test_mutable_bases_catch_mro_conflict(self):
               # Testing mutable bases catch mro conflict...
    2:         class A(object):
    1:             pass
       
    2:         class B(object):
    1:             pass
       
    2:         class C(A, B):
    1:             pass
       
    2:         class D(A, B):
    1:             pass
       
    2:         class E(C, D):
    1:             pass
       
    1:         try:
    1:             C.__bases__ = (B, A)
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("didn't catch MRO conflict")
       
    1:     def test_mutable_names(self):
               # Testing mutable names...
    2:         class C(object):
    1:             pass
       
               # C.__module__ could be 'test_descr' or '__main__'
    1:         mod = C.__module__
       
    1:         C.__name__ = 'D'
    1:         self.assertEqual((C.__module__, C.__name__), (mod, 'D'))
       
    1:         C.__name__ = 'D.E'
    1:         self.assertEqual((C.__module__, C.__name__), (mod, 'D.E'))
       
    1:     def test_evil_type_name(self):
               # A badly placed Py_DECREF in type_set_name led to arbitrary code
               # execution while the type structure was not in a sane state, and a
               # possible segmentation fault as a result.  See bug #16447.
    2:         class Nasty(str):
    1:             def __del__(self):
    1:                 C.__name__ = "other"
       
    2:         class C(object):
    1:             pass
       
    1:         C.__name__ = Nasty("abc")
    1:         C.__name__ = "normal"
       
    1:     def test_subclass_right_op(self):
               # Testing correct dispatch of subclass overloading __r<op>__...
       
               # This code tests various cases where right-dispatch of a subclass
               # should be preferred over left-dispatch of a base class.
       
               # Case 1: subclass of int; this tests code in abstract.c::binary_op1()
       
>>>>>>         class B(int):
>>>>>>             def __floordiv__(self, other):
>>>>>>                 return "B.__floordiv__"
>>>>>>             def __rfloordiv__(self, other):
>>>>>>                 return "B.__rfloordiv__"
       
>>>>>>         self.assertEqual(B(1) // 1, "B.__floordiv__")
>>>>>>         self.assertEqual(1 // B(1), "B.__rfloordiv__")
       
               # Case 2: subclass of object; this is just the baseline for case 3
       
>>>>>>         class C(object):
>>>>>>             def __floordiv__(self, other):
>>>>>>                 return "C.__floordiv__"
>>>>>>             def __rfloordiv__(self, other):
>>>>>>                 return "C.__rfloordiv__"
       
>>>>>>         self.assertEqual(C() // 1, "C.__floordiv__")
>>>>>>         self.assertEqual(1 // C(), "C.__rfloordiv__")
       
               # Case 3: subclass of new-style class; here it gets interesting
       
>>>>>>         class D(C):
>>>>>>             def __floordiv__(self, other):
>>>>>>                 return "D.__floordiv__"
>>>>>>             def __rfloordiv__(self, other):
>>>>>>                 return "D.__rfloordiv__"
       
>>>>>>         self.assertEqual(D() // C(), "D.__floordiv__")
>>>>>>         self.assertEqual(C() // D(), "D.__rfloordiv__")
       
               # Case 4: this didn't work right in 2.2.2 and 2.3a1
       
>>>>>>         class E(C):
>>>>>>             pass
       
>>>>>>         self.assertEqual(E.__rfloordiv__, C.__rfloordiv__)
       
>>>>>>         self.assertEqual(E() // 1, "C.__floordiv__")
>>>>>>         self.assertEqual(1 // E(), "C.__rfloordiv__")
>>>>>>         self.assertEqual(E() // C(), "C.__floordiv__")
>>>>>>         self.assertEqual(C() // E(), "C.__floordiv__") # This one would fail
       
    1:     @test_support.impl_detail("testing an internal kind of method object")
           def test_meth_class_get(self):
               # Testing __get__ method of METH_CLASS C methods...
               # Full coverage of descrobject.c::classmethod_get()
       
               # Baseline
    1:         arg = [1, 2, 3]
    1:         res = {1: None, 2: None, 3: None}
    1:         self.assertEqual(dict.fromkeys(arg), res)
    1:         self.assertEqual({}.fromkeys(arg), res)
       
               # Now get the descriptor
    1:         descr = dict.__dict__["fromkeys"]
       
               # More baseline using the descriptor directly
    1:         self.assertEqual(descr.__get__(None, dict)(arg), res)
    1:         self.assertEqual(descr.__get__({})(arg), res)
       
               # Now check various error cases
    1:         try:
    1:             descr.__get__(None, None)
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("shouldn't have allowed descr.__get__(None, None)")
    1:         try:
    1:             descr.__get__(42)
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("shouldn't have allowed descr.__get__(42)")
    1:         try:
    1:             descr.__get__(None, 42)
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("shouldn't have allowed descr.__get__(None, 42)")
    1:         try:
    1:             descr.__get__(None, int)
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("shouldn't have allowed descr.__get__(None, int)")
       
    1:     def test_isinst_isclass(self):
               # Testing proxy isinstance() and isclass()...
    2:         class Proxy(object):
    1:             def __init__(self, obj):
    4:                 self.__obj = obj
    1:             def __getattribute__(self, name):
    8:                 if name.startswith("_Proxy__"):
    4:                     return object.__getattribute__(self, name)
                       else:
    4:                     return getattr(self.__obj, name)
               # Test with a classic class
    2:         class C:
    1:             pass
    1:         a = C()
    1:         pa = Proxy(a)
    1:         self.assertIsInstance(a, C)  # Baseline
    1:         self.assertIsInstance(pa, C) # Test
               # Test with a classic subclass
    2:         class D(C):
    1:             pass
    1:         a = D()
    1:         pa = Proxy(a)
    1:         self.assertIsInstance(a, C)  # Baseline
    1:         self.assertIsInstance(pa, C) # Test
               # Test with a new-style class
    2:         class C(object):
    1:             pass
    1:         a = C()
    1:         pa = Proxy(a)
    1:         self.assertIsInstance(a, C)  # Baseline
    1:         self.assertIsInstance(pa, C) # Test
               # Test with a new-style subclass
    2:         class D(C):
    1:             pass
    1:         a = D()
    1:         pa = Proxy(a)
    1:         self.assertIsInstance(a, C)  # Baseline
    1:         self.assertIsInstance(pa, C) # Test
       
    1:     def test_proxy_super(self):
               # Testing super() for a proxy object...
    2:         class Proxy(object):
    1:             def __init__(self, obj):
    1:                 self.__obj = obj
    1:             def __getattribute__(self, name):
    2:                 if name.startswith("_Proxy__"):
    1:                     return object.__getattribute__(self, name)
                       else:
    1:                     return getattr(self.__obj, name)
       
    2:         class B(object):
    1:             def f(self):
    1:                 return "B.f"
       
    2:         class C(B):
    1:             def f(self):
    1:                 return super(C, self).f() + "->C.f"
       
    1:         obj = C()
    1:         p = Proxy(obj)
    1:         self.assertEqual(C.__dict__["f"](p), "B.f->C.f")
       
    1:     def test_carloverre(self):
               # Testing prohibition of Carlo Verre's hack...
    1:         try:
    1:             object.__setattr__(str, "foo", 42)
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("Carlo Verre __setattr__ succeeded!")
    1:         try:
    1:             object.__delattr__(str, "lower")
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("Carlo Verre __delattr__ succeeded!")
       
    1:     def test_weakref_segfault(self):
               # Testing weakref segfault...
               # SF 742911
>>>>>>         import weakref
       
>>>>>>         class Provoker:
>>>>>>             def __init__(self, referrent):
>>>>>>                 self.ref = weakref.ref(referrent)
       
>>>>>>             def __del__(self):
>>>>>>                 x = self.ref()
       
>>>>>>         class Oops(object):
>>>>>>             pass
       
>>>>>>         o = Oops()
>>>>>>         o.whatever = Provoker(o)
>>>>>>         del o
       
    1:     def test_wrapper_segfault(self):
               # SF 927248: deeply nested wrappers could cause stack overflow
>>>>>>         f = lambda:None
>>>>>>         for i in xrange(1000000):
>>>>>>             f = f.__call__
>>>>>>         f = None
       
    1:     def test_file_fault(self):
               # Testing sys.stdout is changed in getattr...
    1:         test_stdout = sys.stdout
    2:         class StdoutGuard:
    1:             def __getattr__(self, attr):
    2:                 sys.stdout = sys.__stdout__
    2:                 raise RuntimeError("Premature access to sys.stdout.%s" % attr)
    1:         sys.stdout = StdoutGuard()
    1:         try:
    1:             print "Oops!"
    1:         except RuntimeError:
    1:             pass
               finally:
    1:             sys.stdout = test_stdout
       
    1:     def test_vicious_descriptor_nonsense(self):
               # Testing vicious_descriptor_nonsense...
       
               # A potential segfault spotted by Thomas Wouters in mail to
               # python-dev 2003-04-17, turned into an example & fixed by Michael
               # Hudson just less than four months later...
       
>>>>>>         class Evil(object):
>>>>>>             def __hash__(self):
>>>>>>                 return hash('attr')
>>>>>>             def __eq__(self, other):
>>>>>>                 del C.attr
>>>>>>                 return 0
       
>>>>>>         class Descr(object):
>>>>>>             def __get__(self, ob, type=None):
>>>>>>                 return 1
       
>>>>>>         class C(object):
>>>>>>             attr = Descr()
       
>>>>>>         c = C()
>>>>>>         c.__dict__[Evil()] = 0
       
>>>>>>         self.assertEqual(c.attr, 1)
               # this makes a crash more likely:
>>>>>>         test_support.gc_collect()
>>>>>>         self.assertNotHasAttr(c, 'attr')
       
    1:     def test_init(self):
               # SF 1155938
    2:         class Foo(object):
    1:             def __init__(self):
    1:                 return 10
    1:         try:
    1:             Foo()
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("did not test __init__() for None return")
       
    1:     def test_method_wrapper(self):
               # Testing method-wrapper objects...
               # <type 'method-wrapper'> did not support any reflection before 2.5
       
    1:         l = []
    1:         self.assertEqual(l.__add__, l.__add__)
    1:         self.assertEqual(l.__add__, [].__add__)
    1:         self.assertNotEqual(l.__add__, [5].__add__)
    1:         self.assertNotEqual(l.__add__, l.__mul__)
    1:         self.assertEqual(l.__add__.__name__, '__add__')
    1:         if hasattr(l.__add__, '__self__'):
                   # CPython
    1:             self.assertIs(l.__add__.__self__, l)
    1:             self.assertIs(l.__add__.__objclass__, list)
               else:
                   # Python implementations where [].__add__ is a normal bound method
>>>>>>             self.assertIs(l.__add__.im_self, l)
>>>>>>             self.assertIs(l.__add__.im_class, list)
    1:         self.assertEqual(l.__add__.__doc__, list.__add__.__doc__)
    1:         try:
    1:             hash(l.__add__)
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("no TypeError from hash([].__add__)")
       
    1:         t = ()
    1:         t += (7,)
    1:         self.assertEqual(t.__add__, (7,).__add__)
    1:         self.assertEqual(hash(t.__add__), hash((7,).__add__))
       
    1:     def test_not_implemented(self):
               # Testing NotImplemented...
               # all binary methods should be able to return a NotImplemented
    1:         import operator
       
    1:         def specialmethod(self, other):
  542:             return NotImplemented
       
    1:         def check(expr, x, y):
  460:             try:
  460:                 exec expr in {'x': x, 'y': y, 'operator': operator}
  460:             except TypeError:
  460:                 pass
                   else:
>>>>>>                 self.fail("no TypeError from %r" % (expr,))
       
    1:         N1 = sys.maxint + 1L    # might trigger OverflowErrors instead of
                                       # TypeErrors
    1:         N2 = sys.maxint         # if sizeof(int) < sizeof(long), might trigger
                                       #   ValueErrors instead of TypeErrors
    3:         for metaclass in [type, types.ClassType]:
    2:             for name, expr, iexpr in [
    2:                     ('__add__',      'x + y',                   'x += y'),
    2:                     ('__sub__',      'x - y',                   'x -= y'),
    2:                     ('__mul__',      'x * y',                   'x *= y'),
    2:                     ('__truediv__',  'operator.truediv(x, y)',  None),
    2:                     ('__floordiv__', 'operator.floordiv(x, y)', None),
    2:                     ('__div__',      'x / y',                   'x /= y'),
    2:                     ('__mod__',      'x % y',                   'x %= y'),
    2:                     ('__divmod__',   'divmod(x, y)',            None),
    2:                     ('__pow__',      'x ** y',                  'x **= y'),
    2:                     ('__lshift__',   'x << y',                  'x <<= y'),
    2:                     ('__rshift__',   'x >> y',                  'x >>= y'),
    2:                     ('__and__',      'x & y',                   'x &= y'),
    2:                     ('__or__',       'x | y',                   'x |= y'),
    2:                     ('__xor__',      'x ^ y',                   'x ^= y'),
   32:                     ('__coerce__',   'coerce(x, y)',            None)]:
   30:                 if name == '__coerce__':
    2:                     rname = name
                       else:
   28:                     rname = '__r' + name[2:]
   30:                 A = metaclass('A', (), {name: specialmethod})
   30:                 B = metaclass('B', (), {rname: specialmethod})
   30:                 a = A()
   30:                 b = B()
   30:                 check(expr, a, a)
   30:                 check(expr, a, b)
   30:                 check(expr, b, a)
   30:                 check(expr, b, b)
   30:                 check(expr, a, N1)
   30:                 check(expr, a, N2)
   30:                 check(expr, N1, b)
   30:                 check(expr, N2, b)
   30:                 if iexpr:
   22:                     check(iexpr, a, a)
   22:                     check(iexpr, a, b)
   22:                     check(iexpr, b, a)
   22:                     check(iexpr, b, b)
   22:                     check(iexpr, a, N1)
   22:                     check(iexpr, a, N2)
   22:                     iname = '__i' + name[2:]
   22:                     C = metaclass('C', (), {iname: specialmethod})
   22:                     c = C()
   22:                     check(iexpr, c, a)
   22:                     check(iexpr, c, b)
   22:                     check(iexpr, c, N1)
   22:                     check(iexpr, c, N2)
       
    1:     def test_assign_slice(self):
               # ceval.c's assign_slice used to check for
               # tp->tp_as_sequence->sq_slice instead of
               # tp->tp_as_sequence->sq_ass_slice
       
    2:         class C(object):
    1:             def __setslice__(self, start, stop, value):
    1:                 self.value = value
       
    1:         c = C()
    1:         c[1:2] = 3
    1:         self.assertEqual(c.value, 3)
       
    1:     def test_set_and_no_get(self):
               # See
               # http://mail.python.org/pipermail/python-dev/2010-January/095637.html
>>>>>>         class Descr(object):
       
>>>>>>             def __init__(self, name):
>>>>>>                 self.name = name
       
>>>>>>             def __set__(self, obj, value):
>>>>>>                 obj.__dict__[self.name] = value
>>>>>>         descr = Descr("a")
       
>>>>>>         class X(object):
>>>>>>             a = descr
       
>>>>>>         x = X()
>>>>>>         self.assertIs(x.a, descr)
>>>>>>         x.a = 42
>>>>>>         self.assertEqual(x.a, 42)
       
               # Also check type_getattro for correctness.
>>>>>>         class Meta(type):
>>>>>>             pass
>>>>>>         class X(object):
>>>>>>             __metaclass__ = Meta
>>>>>>         X.a = 42
>>>>>>         Meta.a = Descr("a")
>>>>>>         self.assertEqual(X.a, 42)
       
    1:     def test_getattr_hooks(self):
               # issue 4230
       
    2:         class Descriptor(object):
    1:             counter = 0
    1:             def __get__(self, obj, objtype=None):
    4:                 def getter(name):
    4:                     self.counter += 1
    4:                     raise AttributeError(name)
    4:                 return getter
       
    1:         descr = Descriptor()
    2:         class A(object):
    1:             __getattribute__ = descr
    2:         class B(object):
    1:             __getattr__ = descr
    2:         class C(object):
    1:             __getattribute__ = descr
    1:             __getattr__ = descr
       
    1:         self.assertRaises(AttributeError, getattr, A(), "attr")
    1:         self.assertEqual(descr.counter, 1)
    1:         self.assertRaises(AttributeError, getattr, B(), "attr")
    1:         self.assertEqual(descr.counter, 2)
    1:         self.assertRaises(AttributeError, getattr, C(), "attr")
    1:         self.assertEqual(descr.counter, 4)
       
    2:         class EvilGetattribute(object):
                   # This used to segfault
    1:             def __getattr__(self, name):
    1:                 raise AttributeError(name)
    1:             def __getattribute__(self, name):
    1:                 del EvilGetattribute.__getattr__
    6:                 for i in range(5):
    5:                     gc.collect()
    1:                 raise AttributeError(name)
       
    1:         self.assertRaises(AttributeError, getattr, EvilGetattribute(), "attr")
       
    1:     def test_type___getattribute__(self):
>>>>>>         self.assertRaises(TypeError, type.__getattribute__, list, type)
       
    1:     def test_abstractmethods(self):
               # type pretends not to have __abstractmethods__.
    1:         self.assertRaises(AttributeError, getattr, type, "__abstractmethods__")
    2:         class meta(type):
    1:             pass
    1:         self.assertRaises(AttributeError, getattr, meta, "__abstractmethods__")
    2:         class X(object):
    1:             pass
    1:         with self.assertRaises(AttributeError):
    1:             del X.__abstractmethods__
       
    1:     def test_proxy_call(self):
    2:         class FakeStr(object):
    1:             __class__ = str
       
    1:         fake_str = FakeStr()
               # isinstance() reads __class__ on new style classes
    1:         self.assertIsInstance(fake_str, str)
       
               # call a method descriptor
    1:         with self.assertRaises(TypeError):
    1:             str.split(fake_str)
       
               # call a slot wrapper descriptor
    1:         with self.assertRaises(TypeError):
    1:             str.__add__(fake_str, "abc")
       
    1:     def test_repr_as_str(self):
               # Issue #11603: crash or infinite loop when rebinding __str__ as
               # __repr__.
>>>>>>         class Foo(object):
>>>>>>             pass
>>>>>>         Foo.__repr__ = Foo.__str__
>>>>>>         foo = Foo()
>>>>>>         self.assertRaises(RuntimeError, str, foo)
>>>>>>         self.assertRaises(RuntimeError, repr, foo)
       
    1:     def test_mixing_slot_wrappers(self):
    2:         class X(dict):
    1:             __setattr__ = dict.__setitem__
    1:         x = X()
    1:         x.y = 42
    1:         self.assertEqual(x["y"], 42)
       
    1:     def test_cycle_through_dict(self):
               # See bug #1469629
    2:         class X(dict):
    1:             def __init__(self):
    1:                 dict.__init__(self)
    1:                 self.__dict__ = self
    1:         x = X()
    1:         x.attr = 42
    1:         wr = weakref.ref(x)
    1:         del x
    1:         test_support.gc_collect()
    1:         self.assertIsNone(wr())
55678:         for o in gc.get_objects():
55677:             self.assertIsNot(type(o), X)
       
       
    2: class DictProxyTests(unittest.TestCase):
    1:     def setUp(self):
>>>>>>         class C(object):
>>>>>>             def meth(self):
>>>>>>                 pass
>>>>>>         self.C = C
       
    1:     def test_repr(self):
>>>>>>         self.assertIn('dict_proxy({', repr(vars(self.C)))
>>>>>>         self.assertIn("'meth':", repr(vars(self.C)))
       
    1:     def test_iter_keys(self):
               # Testing dict-proxy iterkeys...
>>>>>>         keys = [ key for key in self.C.__dict__.iterkeys() ]
>>>>>>         keys.sort()
>>>>>>         self.assertEqual(keys, ['__dict__', '__doc__', '__module__',
>>>>>>             '__weakref__', 'meth'])
       
    1:     def test_iter_values(self):
               # Testing dict-proxy itervalues...
>>>>>>         values = [ values for values in self.C.__dict__.itervalues() ]
>>>>>>         self.assertEqual(len(values), 5)
       
    1:     def test_iter_items(self):
               # Testing dict-proxy iteritems...
>>>>>>         keys = [ key for (key, value) in self.C.__dict__.iteritems() ]
>>>>>>         keys.sort()
>>>>>>         self.assertEqual(keys, ['__dict__', '__doc__', '__module__',
>>>>>>             '__weakref__', 'meth'])
       
    1:     def test_dict_type_with_metaclass(self):
               # Testing type of __dict__ when __metaclass__ set...
>>>>>>         class B(object):
>>>>>>             pass
>>>>>>         class M(type):
>>>>>>             pass
>>>>>>         class C:
                   # In 2.3a1, C.__dict__ was a real dict rather than a dict proxy
>>>>>>             __metaclass__ = M
>>>>>>         self.assertEqual(type(C.__dict__), type(B.__dict__))
       
       
    2: class PTypesLongInitTest(unittest.TestCase):
           # This is in its own TestCase so that it can be run before any other tests.
    1:     def test_pytype_long_ready(self):
               # Testing SF bug 551412 ...
       
               # This dumps core when SF bug 551412 isn't fixed --
               # but only when test_descr.py is run separately.
               # (That can't be helped -- as soon as PyType_Ready()
               # is called for PyLong_Type, the bug is gone.)
    2:         class UserLong(object):
    1:             def __pow__(self, *args):
>>>>>>                 pass
    1:         try:
    1:             pow(0L, UserLong(), 0L)
    1:         except:
    1:             pass
       
               # Another segfault only when run early
               # (before PyType_Ready(tuple) is called)
    1:         type.mro(tuple)
       
       
    2: class PicklingTests(unittest.TestCase):
       
    1:     def test_issue24097(self):
               # Slot name is freed inside __getattr__ and is later used.
>>>>>>         class S(str):  # Not interned
>>>>>>             pass
>>>>>>         class A(object):
>>>>>>             __slotnames__ = [S('spam')]
>>>>>>             def __getattr__(self, attr):
>>>>>>                 if attr == 'spam':
>>>>>>                     A.__slotnames__[:] = [S('spam')]
>>>>>>                     return 42
                       else:
>>>>>>                     raise AttributeError
       
>>>>>>         import copy_reg
>>>>>>         expected = (copy_reg.__newobj__, (A,), ({}, {'spam': 42}), None, None)
>>>>>>         self.assertEqual(A().__reduce__(2), expected)
       
       
    1: def test_main():
    1:     deprecations = [(r'complex divmod\(\), // and % are deprecated$',
    1:                      DeprecationWarning)]
    1:     if sys.py3kwarning:
>>>>>>         deprecations += [
>>>>>>             ("classic (int|long) division", DeprecationWarning),
>>>>>>             ("coerce.. not supported", DeprecationWarning),
>>>>>>             (".+__(get|set|del)slice__ has been removed", DeprecationWarning)]
    1:     with test_support.check_warnings(*deprecations):
               # Run all local test cases, with PTypesLongInitTest first.
    1:         test_support.run_unittest(PTypesLongInitTest, OperatorsTest,
    1:                                   ClassPropertiesAndMethods, DictProxyTests,
    1:                                   PicklingTests)
       
    1: if __name__ == "__main__":
>>>>>>     test_main()
