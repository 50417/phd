    1: import unittest
    1: from test import test_support
    1: from itertools import *
    1: import weakref
    1: from decimal import Decimal
    1: from fractions import Fraction
    1: import sys
    1: import operator
    1: import random
    1: import copy
    1: import pickle
    1: from functools import reduce
    1: maxsize = test_support.MAX_Py_ssize_t
    1: minsize = -maxsize-1
       
    1: def onearg(x):
           'Test function of one argument'
 1180:     return 2*x
       
    1: def errfunc(*args):
           'Test function that raises an error'
    4:     raise ValueError
       
    1: def gen3():
           'Non-restartable source sequence'
    4:     for i in (0, 1, 2):
    3:         yield i
       
    1: def isEven(x):
           'Test predicate'
15877:     return x%2==0
       
    1: def isOdd(x):
           'Test predicate'
 5310:     return x%2==1
       
    2: class StopNow:
    1:     'Class emulating an empty iterable.'
    1:     def __iter__(self):
   13:         return self
    1:     def next(self):
   13:         raise StopIteration
       
    1: def take(n, seq):
           'Convenience function for partially consuming a long of infinite iterable'
   32:     return list(islice(seq, n))
       
    1: def prod(iterable):
  564:     return reduce(operator.mul, iterable, 1)
       
    1: def fact(n):
           'Factorial'
  464:     return prod(range(1, n+1))
       
    2: class TestBasicOps(unittest.TestCase):
    1:     def test_chain(self):
       
    1:         def chain2(*iterables):
                   'Pure python version in the docs'
   10:             for it in iterables:
   19:                 for element in it:
   13:                     yield element
       
    3:         for c in (chain, chain2):
    2:             self.assertEqual(list(c('abc', 'def')), list('abcdef'))
    2:             self.assertEqual(list(c('abc')), list('abc'))
    2:             self.assertEqual(list(c('')), [])
    2:             self.assertEqual(take(4, c('abc', 'def')), list('abcd'))
    2:             self.assertRaises(TypeError, list,c(2, 3))
       
    1:     def test_chain_from_iterable(self):
    1:         self.assertEqual(list(chain.from_iterable(['abc', 'def'])), list('abcdef'))
    1:         self.assertEqual(list(chain.from_iterable(['abc'])), list('abc'))
    1:         self.assertEqual(list(chain.from_iterable([''])), [])
    1:         self.assertEqual(take(4, chain.from_iterable(['abc', 'def'])), list('abcd'))
    1:         self.assertRaises(TypeError, list, chain.from_iterable([2, 3]))
       
    1:     def test_combinations(self):
    1:         self.assertRaises(TypeError, combinations, 'abc')       # missing r argument
    1:         self.assertRaises(TypeError, combinations, 'abc', 2, 1) # too many arguments
    1:         self.assertRaises(TypeError, combinations, None)        # pool is not iterable
    1:         self.assertRaises(ValueError, combinations, 'abc', -2)  # r is negative
    1:         self.assertEqual(list(combinations('abc', 32)), [])     # r > n
    1:         self.assertEqual(list(combinations(range(4), 3)),
    1:                                            [(0,1,2), (0,1,3), (0,2,3), (1,2,3)])
       
    1:         def combinations1(iterable, r):
                   'Pure python version shown in the docs'
   35:             pool = tuple(iterable)
   35:             n = len(pool)
   35:             if r > n:
    7:                 return
   28:             indices = range(r)
  112:             yield tuple(pool[i] for i in indices)
   28:             while 1:
  247:                 for i in reversed(range(r)):
  219:                     if indices[i] != i + n - r:
   99:                         break
                       else:
   28:                     return
   99:                 indices[i] += 1
  163:                 for j in range(i+1, r):
   64:                     indices[j] = indices[j-1] + 1
  463:                 yield tuple(pool[i] for i in indices)
       
    1:         def combinations2(iterable, r):
                   'Pure python version shown in the docs'
   35:             pool = tuple(iterable)
   35:             n = len(pool)
 2407:             for indices in permutations(range(n), r):
 2372:                 if sorted(indices) == list(indices):
  575:                     yield tuple(pool[i] for i in indices)
       
    1:         def combinations3(iterable, r):
                   'Pure python version from cwr()'
   35:             pool = tuple(iterable)
   35:             n = len(pool)
 2388:             for indices in combinations_with_replacement(range(n), r):
 2353:                 if len(set(indices)) == r:
  575:                     yield tuple(pool[i] for i in indices)
       
    8:         for n in range(7):
   28:             values = [5*x-12 for x in range(n)]
   42:             for r in range(n+2):
   35:                 result = list(combinations(values, r))
   35:                 self.assertEqual(len(result), 0 if r>n else fact(n) // fact(r) // fact(n-r)) # right number of combs
   35:                 self.assertEqual(len(result), len(set(result)))         # no repeats
   35:                 self.assertEqual(result, sorted(result))                # lexicographic order
  162:                 for c in result:
  127:                     self.assertEqual(len(c), r)                         # r-length combinations
  127:                     self.assertEqual(len(set(c)), r)                    # no duplicate elements
  127:                     self.assertEqual(list(c), sorted(c))                # keep original ordering
  575:                     self.assertTrue(all(e in values for e in c))           # elements taken from input iterable
  127:                     self.assertEqual(list(c),
  769:                                      [e for e in values if e in c])      # comb is a subsequence of the input iterable
   35:                 self.assertEqual(result, list(combinations1(values, r))) # matches first pure python version
   35:                 self.assertEqual(result, list(combinations2(values, r))) # matches second pure python version
   35:                 self.assertEqual(result, list(combinations3(values, r))) # matches second pure python version
       
    1:     @test_support.bigaddrspacetest
           def test_combinations_overflow(self):
>>>>>>         with self.assertRaises((OverflowError, MemoryError)):
>>>>>>             combinations("AA", 2**29)
       
    1:     @test_support.impl_detail("tuple reuse is specific to CPython")
           def test_combinations_tuple_reuse(self):
    1:         self.assertEqual(len(set(map(id, combinations('abcde', 3)))), 1)
    1:         self.assertNotEqual(len(set(map(id, list(combinations('abcde', 3))))), 1)
       
    1:     def test_combinations_with_replacement(self):
    1:         cwr = combinations_with_replacement
    1:         self.assertRaises(TypeError, cwr, 'abc')       # missing r argument
    1:         self.assertRaises(TypeError, cwr, 'abc', 2, 1) # too many arguments
    1:         self.assertRaises(TypeError, cwr, None)        # pool is not iterable
    1:         self.assertRaises(ValueError, cwr, 'abc', -2)  # r is negative
    1:         self.assertEqual(list(cwr('ABC', 2)),
    1:                          [('A','A'), ('A','B'), ('A','C'), ('B','B'), ('B','C'), ('C','C')])
       
    1:         def cwr1(iterable, r):
                   'Pure python version shown in the docs'
                   # number items returned:  (n+r-1)! / r! / (n-1)! when n>0
   35:             pool = tuple(iterable)
   35:             n = len(pool)
   35:             if not n and r:
    1:                 return
   34:             indices = [0] * r
  151:             yield tuple(pool[i] for i in indices)
   34:             while 1:
 4705:                 for i in reversed(range(r)):
 4671:                     if indices[i] != n - 1:
 2319:                         break
                       else:
   34:                     return
 2319:                 indices[i:] = [indices[i] + 1] * (r - i)
17793:                 yield tuple(pool[i] for i in indices)
       
    1:         def cwr2(iterable, r):
                   'Pure python version shown in the docs'
   35:             pool = tuple(iterable)
   35:             n = len(pool)
356994:             for indices in product(range(n), repeat=r):
356959:                 if sorted(indices) == list(indices):
17944:                     yield tuple(pool[i] for i in indices)
       
    1:         def numcombs(n, r):
   35:             if not n:
    2:                 return 0 if r else 1
   33:             return fact(n+r-1) // fact(r) // fact(n-1)
       
    8:         for n in range(7):
   28:             values = [5*x-12 for x in range(n)]
   42:             for r in range(n+2):
   35:                 result = list(cwr(values, r))
       
   35:                 self.assertEqual(len(result), numcombs(n, r))           # right number of combs
   35:                 self.assertEqual(len(result), len(set(result)))         # no repeats
   35:                 self.assertEqual(result, sorted(result))                # lexicographic order
       
   35:                 regular_combs = list(combinations(values, r))           # compare to combs without replacement
   35:                 if n == 0 or r <= 1:
   14:                     self.assertEqual(result, regular_combs)            # cases that should be identical
                       else:
   21:                     self.assertTrue(set(result) >= set(regular_combs))     # rest should be supersets of regular combs
       
 2388:                 for c in result:
 2353:                     self.assertEqual(len(c), r)                         # r-length combinations
 9511:                     noruns = [k for k,v in groupby(c)]                  # combo without consecutive repeats
 2353:                     self.assertEqual(len(noruns), len(set(noruns)))     # no repeats other than consecutive
 2353:                     self.assertEqual(list(c), sorted(c))                # keep original ordering
17944:                     self.assertTrue(all(e in values for e in c))           # elements taken from input iterable
 2353:                     self.assertEqual(noruns,
15591:                                      [e for e in values if e in c])     # comb is a subsequence of the input iterable
   35:                 self.assertEqual(result, list(cwr1(values, r)))         # matches first pure python version
   35:                 self.assertEqual(result, list(cwr2(values, r)))         # matches second pure python version
       
    1:     @test_support.bigaddrspacetest
           def test_combinations_with_replacement_overflow(self):
>>>>>>         with self.assertRaises((OverflowError, MemoryError)):
>>>>>>             combinations_with_replacement("AA", 2**30)
       
    1:     @test_support.impl_detail("tuple reuse is specific to CPython")
           def test_combinations_with_replacement_tuple_reuse(self):
    1:         cwr = combinations_with_replacement
    1:         self.assertEqual(len(set(map(id, cwr('abcde', 3)))), 1)
    1:         self.assertNotEqual(len(set(map(id, list(cwr('abcde', 3))))), 1)
       
    1:     def test_permutations(self):
    1:         self.assertRaises(TypeError, permutations)              # too few arguments
    1:         self.assertRaises(TypeError, permutations, 'abc', 2, 1) # too many arguments
    1:         self.assertRaises(TypeError, permutations, None)        # pool is not iterable
    1:         self.assertRaises(ValueError, permutations, 'abc', -2)  # r is negative
    1:         self.assertEqual(list(permutations('abc', 32)), [])     # r > n
    1:         self.assertRaises(TypeError, permutations, 'abc', 's')  # r is not an int or None
    1:         self.assertEqual(list(permutations(range(3), 2)),
    1:                                            [(0,1), (0,2), (1,0), (1,2), (2,0), (2,1)])
       
    1:         def permutations1(iterable, r=None):
                   'Pure python version shown in the docs'
   35:             pool = tuple(iterable)
   35:             n = len(pool)
   35:             r = n if r is None else r
   35:             if r > n:
    7:                 return
   28:             indices = range(n)
   28:             cycles = range(n, n-r, -1)
  112:             yield tuple(pool[i] for i in indices[:r])
 2372:             while n:
 4736:                 for i in reversed(range(r)):
 4709:                     cycles[i] -= 1
 4709:                     if cycles[i] == 0:
 2365:                         indices[i:] = indices[i+1:] + indices[i:i+1]
 2365:                         cycles[i] = n - i
                           else:
 2344:                         j = cycles[i]
 2344:                         indices[i], indices[-j] = indices[-j], indices[i]
15959:                         yield tuple(pool[i] for i in indices[:r])
 2344:                         break
                       else:
   27:                     return
       
    1:         def permutations2(iterable, r=None):
                   'Pure python version shown in the docs'
   35:             pool = tuple(iterable)
   35:             n = len(pool)
   35:             r = n if r is None else r
356994:             for indices in product(range(n), repeat=r):
356959:                 if len(set(indices)) == r:
16071:                     yield tuple(pool[i] for i in indices)
       
    8:         for n in range(7):
   28:             values = [5*x-12 for x in range(n)]
   42:             for r in range(n+2):
   35:                 result = list(permutations(values, r))
   35:                 self.assertEqual(len(result), 0 if r>n else fact(n) // fact(n-r))      # right number of perms
   35:                 self.assertEqual(len(result), len(set(result)))         # no repeats
   35:                 self.assertEqual(result, sorted(result))                # lexicographic order
 2407:                 for p in result:
 2372:                     self.assertEqual(len(p), r)                         # r-length permutations
 2372:                     self.assertEqual(len(set(p)), r)                    # no duplicate elements
16071:                     self.assertTrue(all(e in values for e in p))           # elements taken from input iterable
   35:                 self.assertEqual(result, list(permutations1(values, r))) # matches first pure python version
   35:                 self.assertEqual(result, list(permutations2(values, r))) # matches second pure python version
   35:                 if r == n:
    7:                     self.assertEqual(result, list(permutations(values, None))) # test r as None
    7:                     self.assertEqual(result, list(permutations(values)))       # test default r
       
    1:     @test_support.bigaddrspacetest
           def test_permutations_overflow(self):
>>>>>>         with self.assertRaises((OverflowError, MemoryError)):
>>>>>>             permutations("A", 2**30)
       
    1:     @test_support.impl_detail("tuple reuse is specific to CPython")
           def test_permutations_tuple_reuse(self):
    1:         self.assertEqual(len(set(map(id, permutations('abcde', 3)))), 1)
    1:         self.assertNotEqual(len(set(map(id, list(permutations('abcde', 3))))), 1)
       
    1:     def test_combinatorics(self):
               # Test relationships between product(), permutations(),
               # combinations() and combinations_with_replacement().
       
    7:         for n in range(6):
    6:             s = 'ABCDEFG'[:n]
   54:             for r in range(8):
   48:                 prod = list(product(s, repeat=r))
   48:                 cwr = list(combinations_with_replacement(s, r))
   48:                 perm = list(permutations(s, r))
   48:                 comb = list(combinations(s, r))
       
                       # Check size
   48:                 self.assertEqual(len(prod), n**r)
   48:                 self.assertEqual(len(cwr), (fact(n+r-1) // fact(r) // fact(n-1)) if n else (not r))
   48:                 self.assertEqual(len(perm), 0 if r>n else fact(n) // fact(n-r))
   48:                 self.assertEqual(len(comb), 0 if r>n else fact(n) // fact(r) // fact(n-r))
       
                       # Check lexicographic order without repeated tuples
   48:                 self.assertEqual(prod, sorted(set(prod)))
   48:                 self.assertEqual(cwr, sorted(set(cwr)))
   48:                 self.assertEqual(perm, sorted(set(perm)))
   48:                 self.assertEqual(comb, sorted(set(comb)))
       
                       # Check interrelationships
123093:                 self.assertEqual(cwr, [t for t in prod if sorted(t)==list(t)]) # cwr: prods which are sorted
123093:                 self.assertEqual(perm, [t for t in prod if len(set(t))==r])    # perm: prods with no dups
  463:                 self.assertEqual(comb, [t for t in perm if sorted(t)==list(t)]) # comb: perms that are sorted
 1335:                 self.assertEqual(comb, [t for t in cwr if len(set(t))==r])      # comb: cwrs without dups
   48:                 self.assertEqual(comb, filter(set(cwr).__contains__, perm))     # comb: perm that is a cwr
   48:                 self.assertEqual(comb, filter(set(perm).__contains__, cwr))     # comb: cwr that is a perm
   48:                 self.assertEqual(comb, sorted(set(cwr) & set(perm)))            # comb: both a cwr and a perm
       
    1:     def test_compress(self):
    1:         self.assertEqual(list(compress(data='ABCDEF', selectors=[1,0,1,0,1,1])), list('ACEF'))
    1:         self.assertEqual(list(compress('ABCDEF', [1,0,1,0,1,1])), list('ACEF'))
    1:         self.assertEqual(list(compress('ABCDEF', [0,0,0,0,0,0])), list(''))
    1:         self.assertEqual(list(compress('ABCDEF', [1,1,1,1,1,1])), list('ABCDEF'))
    1:         self.assertEqual(list(compress('ABCDEF', [1,0,1])), list('AC'))
    1:         self.assertEqual(list(compress('ABC', [0,1,1,1,1,1])), list('BC'))
    1:         n = 10000
    1:         data = chain.from_iterable(repeat(range(6), n))
    1:         selectors = chain.from_iterable(repeat((0, 1)))
    1:         self.assertEqual(list(compress(data, selectors)), [1,3,5] * n)
    1:         self.assertRaises(TypeError, compress, None, range(6))      # 1st arg not iterable
    1:         self.assertRaises(TypeError, compress, range(6), None)      # 2nd arg not iterable
    1:         self.assertRaises(TypeError, compress, range(6))            # too few args
    1:         self.assertRaises(TypeError, compress, range(6), None)      # too many args
       
    1:     def test_count(self):
    1:         self.assertEqual(zip('abc',count()), [('a', 0), ('b', 1), ('c', 2)])
    1:         self.assertEqual(zip('abc',count(3)), [('a', 3), ('b', 4), ('c', 5)])
    1:         self.assertEqual(take(2, zip('abc',count(3))), [('a', 3), ('b', 4)])
    1:         self.assertEqual(take(2, zip('abc',count(-1))), [('a', -1), ('b', 0)])
    1:         self.assertEqual(take(2, zip('abc',count(-3))), [('a', -3), ('b', -2)])
    1:         self.assertRaises(TypeError, count, 2, 3, 4)
    1:         self.assertRaises(TypeError, count, 'a')
    1:         self.assertEqual(take(10, count(maxsize-5)), range(maxsize-5, maxsize+5))
    1:         self.assertEqual(take(10, count(-maxsize-5)), range(-maxsize-5, -maxsize+5))
    1:         self.assertEqual(take(3, count(3.25)), [3.25, 4.25, 5.25])
    1:         self.assertEqual(take(3, count(3.25-4j)), [3.25-4j, 4.25-4j, 5.25-4j])
    1:         self.assertEqual(take(3, count(Decimal('1.1'))),
    1:                          [Decimal('1.1'), Decimal('2.1'), Decimal('3.1')])
    1:         self.assertEqual(take(3, count(Fraction(2, 3))),
    1:                          [Fraction(2, 3), Fraction(5, 3), Fraction(8, 3)])
    1:         BIGINT = 1<<1000
    1:         self.assertEqual(take(3, count(BIGINT)), [BIGINT, BIGINT+1, BIGINT+2])
    1:         c = count(3)
    1:         self.assertEqual(repr(c), 'count(3)')
    1:         c.next()
    1:         self.assertEqual(repr(c), 'count(4)')
    1:         c = count(-9)
    1:         self.assertEqual(repr(c), 'count(-9)')
    1:         c.next()
    1:         self.assertEqual(next(c), -8)
    1:         self.assertEqual(repr(count(10.25)), 'count(10.25)')
    1:         self.assertEqual(repr(count(10.0)), 'count(10.0)')
    1:         self.assertEqual(type(next(count(10.0))), float)
    9:         for i in (-sys.maxint-5, -sys.maxint+5 ,-10, -1, 0, 10, sys.maxint-5, sys.maxint+5):
                   # Test repr (ignoring the L in longs)
    8:             r1 = repr(count(i)).replace('L', '')
    8:             r2 = 'count(%r)'.__mod__(i).replace('L', '')
    8:             self.assertEqual(r1, r2)
       
               # check copy, deepcopy, pickle
    5:         for value in -3, 3, sys.maxint-5, sys.maxint+5:
    4:             c = count(value)
    4:             self.assertEqual(next(copy.copy(c)), value)
    4:             self.assertEqual(next(copy.deepcopy(c)), value)
   16:             for proto in range(pickle.HIGHEST_PROTOCOL + 1):
   12:                 self.assertEqual(next(pickle.loads(pickle.dumps(c, proto))), value)
       
    1:     def test_count_with_stride(self):
    1:         self.assertEqual(zip('abc',count(2,3)), [('a', 2), ('b', 5), ('c', 8)])
    1:         self.assertEqual(zip('abc',count(start=2,step=3)),
    1:                          [('a', 2), ('b', 5), ('c', 8)])
    1:         self.assertEqual(zip('abc',count(step=-1)),
    1:                          [('a', 0), ('b', -1), ('c', -2)])
    1:         self.assertRaises(TypeError, count, 'a', 'b')
    1:         self.assertEqual(zip('abc',count(2,0)), [('a', 2), ('b', 2), ('c', 2)])
    1:         self.assertEqual(zip('abc',count(2,1)), [('a', 2), ('b', 3), ('c', 4)])
    1:         self.assertEqual(zip('abc',count(2,3)), [('a', 2), ('b', 5), ('c', 8)])
    1:         self.assertEqual(zip('abc',count(2,1L)), [('a', 2), ('b', 3), ('c', 4)])
    1:         self.assertEqual(zip('abc',count(2,3L)), [('a', 2), ('b', 5), ('c', 8)])
    1:         self.assertEqual(take(20, count(maxsize-15, 3)), take(20, range(maxsize-15, maxsize+100, 3)))
    1:         self.assertEqual(take(20, count(-maxsize-15, 3)), take(20, range(-maxsize-15,-maxsize+100, 3)))
    1:         self.assertEqual(take(3, count(10, maxsize+5)),
    1:                          range(10, 10+3*(maxsize+5), maxsize+5))
    1:         self.assertEqual(take(3, count(2, 1.25)), [2, 3.25, 4.5])
    1:         self.assertEqual(take(3, count(2, 3.25-4j)), [2, 5.25-4j, 8.5-8j])
    1:         self.assertEqual(take(3, count(Decimal('1.1'), Decimal('.1'))),
    1:                          [Decimal('1.1'), Decimal('1.2'), Decimal('1.3')])
    1:         self.assertEqual(take(3, count(Fraction(2,3), Fraction(1,7))),
    1:                          [Fraction(2,3), Fraction(17,21), Fraction(20,21)])
    1:         BIGINT = 1<<1000
    1:         self.assertEqual(take(3, count(step=BIGINT)), [0, BIGINT, 2*BIGINT])
    1:         self.assertEqual(repr(take(3, count(10, 2.5))), repr([10, 12.5, 15.0]))
    1:         c = count(3, 5)
    1:         self.assertEqual(repr(c), 'count(3, 5)')
    1:         c.next()
    1:         self.assertEqual(repr(c), 'count(8, 5)')
    1:         c = count(-9, 0)
    1:         self.assertEqual(repr(c), 'count(-9, 0)')
    1:         c.next()
    1:         self.assertEqual(repr(c), 'count(-9, 0)')
    1:         c = count(-9, -3)
    1:         self.assertEqual(repr(c), 'count(-9, -3)')
    1:         c.next()
    1:         self.assertEqual(repr(c), 'count(-12, -3)')
    1:         self.assertEqual(repr(c), 'count(-12, -3)')
    1:         self.assertEqual(repr(count(10.5, 1.25)), 'count(10.5, 1.25)')
    1:         self.assertEqual(repr(count(10.5, 1)), 'count(10.5)')           # suppress step=1 when it's an int
    1:         self.assertEqual(repr(count(10.5, 1.00)), 'count(10.5, 1.0)')   # do show float values lilke 1.0
    1:         self.assertEqual(repr(count(10, 1.00)), 'count(10, 1.0)')
    1:         c = count(10, 1.0)
    1:         self.assertEqual(type(next(c)), int)
    1:         self.assertEqual(type(next(c)), float)
    9:         for i in (-sys.maxint-5, -sys.maxint+5 ,-10, -1, 0, 10, sys.maxint-5, sys.maxint+5):
   80:             for j in  (-sys.maxint-5, -sys.maxint+5 ,-10, -1, 0, 1, 10, sys.maxint-5, sys.maxint+5):
                       # Test repr (ignoring the L in longs)
   72:                 r1 = repr(count(i, j)).replace('L', '')
   72:                 if j == 1:
    8:                     r2 = ('count(%r)' % i).replace('L', '')
                       else:
   64:                     r2 = ('count(%r, %r)' % (i, j)).replace('L', '')
   72:                 self.assertEqual(r1, r2)
       
    1:     def test_cycle(self):
    1:         self.assertEqual(take(10, cycle('abc')), list('abcabcabca'))
    1:         self.assertEqual(list(cycle('')), [])
    1:         self.assertRaises(TypeError, cycle)
    1:         self.assertRaises(TypeError, cycle, 5)
    1:         self.assertEqual(list(islice(cycle(gen3()),10)), [0,1,2,0,1,2,0,1,2,0])
       
    1:     def test_groupby(self):
               # Check whether it accepts arguments correctly
    1:         self.assertEqual([], list(groupby([])))
    1:         self.assertEqual([], list(groupby([], key=id)))
    1:         self.assertRaises(TypeError, list, groupby('abc', []))
    1:         self.assertRaises(TypeError, groupby, None)
    1:         self.assertRaises(TypeError, groupby, 'abc', lambda x:x, 10)
       
               # Check normal input
    1:         s = [(0, 10, 20), (0, 11,21), (0,12,21), (1,13,21), (1,14,22),
    1:              (2,15,22), (3,16,23), (3,17,23)]
    1:         dup = []
   13:         for k, g in groupby(s, lambda r:r[0]):
   12:             for elem in g:
    8:                 self.assertEqual(k, elem[0])
    8:                 dup.append(elem)
    1:         self.assertEqual(s, dup)
       
               # Check nested case
    1:         dup = []
   13:         for k, g in groupby(s, lambda r:r[0]):
   18:             for ik, ig in groupby(g, lambda r:r[2]):
   14:                 for elem in ig:
    8:                     self.assertEqual(k, elem[0])
    8:                     self.assertEqual(ik, elem[2])
    8:                     dup.append(elem)
    1:         self.assertEqual(s, dup)
       
               # Check case where inner iterator is not used
   13:         keys = [k for k, g in groupby(s, lambda r:r[0])]
    9:         expectedkeys = set([r[0] for r in s])
    1:         self.assertEqual(set(keys), expectedkeys)
    1:         self.assertEqual(len(keys), len(expectedkeys))
       
               # Exercise pipes and filters style
    1:         s = 'abracadabra'
               # sort s | uniq
    6:         r = [k for k, g in groupby(sorted(s))]
    1:         self.assertEqual(r, ['a', 'b', 'c', 'd', 'r'])
               # sort s | uniq -d
    6:         r = [k for k, g in groupby(sorted(s)) if list(islice(g,1,2))]
    1:         self.assertEqual(r, ['a', 'b', 'r'])
               # sort s | uniq -c
    6:         r = [(len(list(g)), k) for k, g in groupby(sorted(s))]
    1:         self.assertEqual(r, [(5, 'a'), (2, 'b'), (1, 'c'), (1, 'd'), (2, 'r')])
               # sort s | uniq -c | sort -rn | head -3
    6:         r = sorted([(len(list(g)) , k) for k, g in groupby(sorted(s))], reverse=True)[:3]
    1:         self.assertEqual(r, [(5, 'a'), (2, 'r'), (2, 'b')])
       
               # iter.next failure
    2:         class ExpectedError(Exception):
    1:             pass
    1:         def delayed_raise(n=0):
    3:             for i in range(n):
    1:                 yield 'yo'
    2:             raise ExpectedError
    1:         def gulp(iterable, keyp=None, func=list):
    7:             return [func(g) for k, g in groupby(iterable, keyp)]
       
               # iter.next failure on outer object
    1:         self.assertRaises(ExpectedError, gulp, delayed_raise(0))
               # iter.next failure on inner object
    1:         self.assertRaises(ExpectedError, gulp, delayed_raise(1))
       
               # __cmp__ failure
    2:         class DummyCmp:
    1:             def __cmp__(self, dst):
    2:                 raise ExpectedError
    1:         s = [DummyCmp(), DummyCmp(), None]
       
               # __cmp__ failure on outer object
    1:         self.assertRaises(ExpectedError, gulp, s, func=id)
               # __cmp__ failure on inner object
    1:         self.assertRaises(ExpectedError, gulp, s)
       
               # keyfunc failure
    1:         def keyfunc(obj):
    3:             if keyfunc.skip > 0:
    1:                 keyfunc.skip -= 1
    1:                 return obj
                   else:
    2:                 raise ExpectedError
       
               # keyfunc failure on outer object
    1:         keyfunc.skip = 0
    1:         self.assertRaises(ExpectedError, gulp, [None], keyfunc)
    1:         keyfunc.skip = 1
    1:         self.assertRaises(ExpectedError, gulp, [None, None], keyfunc)
       
    1:     def test_ifilter(self):
    1:         self.assertEqual(list(ifilter(isEven, range(6))), [0,2,4])
    1:         self.assertEqual(list(ifilter(None, [0,1,0,2,0])), [1,2])
    1:         self.assertEqual(list(ifilter(bool, [0,1,0,2,0])), [1,2])
    1:         self.assertEqual(take(4, ifilter(isEven, count())), [0,2,4,6])
    1:         self.assertRaises(TypeError, ifilter)
    1:         self.assertRaises(TypeError, ifilter, lambda x:x)
    1:         self.assertRaises(TypeError, ifilter, lambda x:x, range(6), 7)
    1:         self.assertRaises(TypeError, ifilter, isEven, 3)
    1:         self.assertRaises(TypeError, ifilter(range(6), range(6)).next)
       
    1:     def test_ifilterfalse(self):
    1:         self.assertEqual(list(ifilterfalse(isEven, range(6))), [1,3,5])
    1:         self.assertEqual(list(ifilterfalse(None, [0,1,0,2,0])), [0,0,0])
    1:         self.assertEqual(list(ifilterfalse(bool, [0,1,0,2,0])), [0,0,0])
    1:         self.assertEqual(take(4, ifilterfalse(isEven, count())), [1,3,5,7])
    1:         self.assertRaises(TypeError, ifilterfalse)
    1:         self.assertRaises(TypeError, ifilterfalse, lambda x:x)
    1:         self.assertRaises(TypeError, ifilterfalse, lambda x:x, range(6), 7)
    1:         self.assertRaises(TypeError, ifilterfalse, isEven, 3)
    1:         self.assertRaises(TypeError, ifilterfalse(range(6), range(6)).next)
       
    1:     def test_izip(self):
    4:         ans = [(x,y) for x, y in izip('abc',count())]
    1:         self.assertEqual(ans, [('a', 0), ('b', 1), ('c', 2)])
    1:         self.assertEqual(list(izip('abc', range(6))), zip('abc', range(6)))
    1:         self.assertEqual(list(izip('abcdef', range(3))), zip('abcdef', range(3)))
    1:         self.assertEqual(take(3,izip('abcdef', count())), zip('abcdef', range(3)))
    1:         self.assertEqual(list(izip('abcdef')), zip('abcdef'))
    1:         self.assertEqual(list(izip()), zip())
    1:         self.assertRaises(TypeError, izip, 3)
    1:         self.assertRaises(TypeError, izip, range(3), 3)
    4:         self.assertEqual([tuple(list(pair)) for pair in izip('abc', 'def')],
    1:                          zip('abc', 'def'))
    4:         self.assertEqual([pair for pair in izip('abc', 'def')],
    1:                          zip('abc', 'def'))
       
    1:     @test_support.impl_detail("tuple reuse is specific to CPython")
           def test_izip_tuple_reuse(self):
    1:         ids = map(id, izip('abc', 'def'))
    1:         self.assertEqual(min(ids), max(ids))
    1:         ids = map(id, list(izip('abc', 'def')))
    1:         self.assertEqual(len(dict.fromkeys(ids)), len(ids))
       
    1:     def test_iziplongest(self):
    1:         for args in [
    1:                 ['abc', range(6)],
    1:                 [range(6), 'abc'],
    1:                 [range(1000), range(2000,2100), range(3000,3050)],
    1:                 [range(1000), range(0), range(3000,3050), range(1200), range(1500)],
    6:                 [range(1000), range(0), range(3000,3050), range(1200), range(1500), range(0)],
                   ]:
                   # target = map(None, *args) <- this raises a py3k warning
                   # this is the replacement:
    5:             target = [tuple([arg[i] if i < len(arg) else None for arg in args])
23541:                       for i in range(max(map(len, args)))]
    5:             self.assertEqual(list(izip_longest(*args)), target)
    5:             self.assertEqual(list(izip_longest(*args, **{})), target)
27553:             target = [tuple((e is None and 'X' or e) for e in t) for t in target]   # Replace None fills with 'X'
    5:             self.assertEqual(list(izip_longest(*args, **dict(fillvalue='X'))), target)
       
    1:         self.assertEqual(take(3,izip_longest('abcdef', count())), zip('abcdef', range(3))) # take 3 from infinite input
       
    1:         self.assertEqual(list(izip_longest()), zip())
    1:         self.assertEqual(list(izip_longest([])), zip([]))
    1:         self.assertEqual(list(izip_longest('abcdef')), zip('abcdef'))
       
    1:         self.assertEqual(list(izip_longest('abc', 'defg', **{})),
    1:                          zip(list('abc') + [None], 'defg'))  # empty keyword dict
    1:         self.assertRaises(TypeError, izip_longest, 3)
    1:         self.assertRaises(TypeError, izip_longest, range(3), 3)
       
    1:         for stmt in [
    1:             "izip_longest('abc', fv=1)",
    3:             "izip_longest('abc', fillvalue=1, bogus_keyword=None)",
               ]:
    2:             try:
    2:                 eval(stmt, globals(), locals())
    2:             except TypeError:
    2:                 pass
                   else:
>>>>>>                 self.fail('Did not raise Type in:  ' + stmt)
       
    4:         self.assertEqual([tuple(list(pair)) for pair in izip_longest('abc', 'def')],
    1:                          zip('abc', 'def'))
    4:         self.assertEqual([pair for pair in izip_longest('abc', 'def')],
    1:                          zip('abc', 'def'))
       
    1:     @test_support.impl_detail("tuple reuse is specific to CPython")
           def test_izip_longest_tuple_reuse(self):
    1:         ids = map(id, izip_longest('abc', 'def'))
    1:         self.assertEqual(min(ids), max(ids))
    1:         ids = map(id, list(izip_longest('abc', 'def')))
    1:         self.assertEqual(len(dict.fromkeys(ids)), len(ids))
       
    1:     def test_bug_7244(self):
       
    2:         class Repeater(object):
                   # this class is similar to itertools.repeat
    1:             def __init__(self, o, t, e):
    4:                 self.o = o
    4:                 self.t = int(t)
    4:                 self.e = e
    1:             def __iter__(self): # its iterator is itself
    4:                 return self
    1:             def next(self):
   16:                 if self.t > 0:
   13:                     self.t -= 1
   13:                     return self.o
                       else:
    3:                     raise self.e
       
               # Formerly this code in would fail in debug mode
               # with Undetected Error and Stop Iteration
    1:         r1 = Repeater(1, 3, StopIteration)
    1:         r2 = Repeater(2, 4, StopIteration)
    1:         def run(r1, r2):
    1:             result = []
    5:             for i, j in izip_longest(r1, r2, fillvalue=0):
    4:                 with test_support.captured_output('stdout'):
    4:                     print (i, j)
    4:                 result.append((i, j))
    1:             return result
    1:         self.assertEqual(run(r1, r2), [(1,2), (1,2), (1,2), (0,2)])
       
               # Formerly, the RuntimeError would be lost
               # and StopIteration would stop as expected
    1:         r1 = Repeater(1, 3, RuntimeError)
    1:         r2 = Repeater(2, 4, StopIteration)
    1:         it = izip_longest(r1, r2, fillvalue=0)
    1:         self.assertEqual(next(it), (1, 2))
    1:         self.assertEqual(next(it), (1, 2))
    1:         self.assertEqual(next(it), (1, 2))
    1:         self.assertRaises(RuntimeError, next, it)
       
    1:     def test_product(self):
    1:         for args, result in [
    1:             ([], [()]),                     # zero iterables
    1:             (['ab'], [('a',), ('b',)]),     # one iterable
    1:             ([range(2), range(3)], [(0,0), (0,1), (0,2), (1,0), (1,1), (1,2)]),     # two iterables
    1:             ([range(0), range(2), range(3)], []),           # first iterable with zero length
    1:             ([range(2), range(0), range(3)], []),           # middle iterable with zero length
    7:             ([range(2), range(3), range(0)], []),           # last iterable with zero length
                   ]:
    6:             self.assertEqual(list(product(*args)), result)
   30:             for r in range(4):
   24:                 self.assertEqual(list(product(*(args*r))),
   24:                                  list(product(*args, **dict(repeat=r))))
    1:         self.assertEqual(len(list(product(*[range(7)]*6))), 7**6)
    1:         self.assertRaises(TypeError, product, range(6), None)
       
    1:         def product1(*args, **kwds):
  100:             pools = map(tuple, args) * kwds.get('repeat', 1)
  100:             n = len(pools)
  100:             if n == 0:
    8:                 yield ()
    8:                 return
  296:             if any(len(pool) == 0 for pool in pools):
   58:                 return
   34:             indices = [0] * n
  139:             yield tuple(pool[i] for pool, i in zip(pools, indices))
   34:             while 1:
54876:                 for i in reversed(range(n)):  # right to left
54842:                     if indices[i] == len(pools[i]) - 1:
 4859:                         continue
49983:                     indices[i] += 1
54771:                     for j in range(i+1, n):
 4788:                         indices[j] = 0
298068:                     yield tuple(pool[i] for pool, i in zip(pools, indices))
49983:                     break
                       else:
   34:                     return
       
    1:         def product2(*args, **kwds):
                   'Pure python version used in docs'
  100:             pools = map(tuple, args) * kwds.get('repeat', 1)
  100:             result = [[]]
  323:             for pool in pools:
62036:                 result = [x+[y] for x in result for y in pool]
50125:             for prod in result:
50025:                 yield tuple(prod)
       
    1:         argtypes = ['', 'abc', '', xrange(0), xrange(4), dict(a=1, b=2, c=3),
    1:                     set('abcdefg'), range(11), tuple(range(13))]
  101:         for i in range(100):
  323:             args = [random.choice(argtypes) for j in range(random.randrange(5))]
  100:             expected_len = prod(map(len, args))
  100:             self.assertEqual(len(list(product(*args))), expected_len)
  100:             self.assertEqual(list(product(*args)), list(product1(*args)))
  100:             self.assertEqual(list(product(*args)), list(product2(*args)))
  100:             args = map(iter, args)
  100:             self.assertEqual(len(list(product(*args))), expected_len)
       
    1:     @test_support.bigaddrspacetest
           def test_product_overflow(self):
>>>>>>         with self.assertRaises((OverflowError, MemoryError)):
>>>>>>             product(*(['ab']*2**5), repeat=2**25)
       
    1:     @test_support.impl_detail("tuple reuse is specific to CPython")
           def test_product_tuple_reuse(self):
    1:         self.assertEqual(len(set(map(id, product('abc', 'def')))), 1)
    1:         self.assertNotEqual(len(set(map(id, list(product('abc', 'def'))))), 1)
       
    1:     def test_repeat(self):
    1:         self.assertEqual(list(repeat(object='a', times=3)), ['a', 'a', 'a'])
    1:         self.assertEqual(list(repeat(object='a', times=0)), [])
    1:         self.assertEqual(list(repeat(object='a', times=-1)), [])
    1:         self.assertEqual(list(repeat(object='a', times=-2)), [])
    1:         self.assertEqual(zip(xrange(3),repeat('a')),
    1:                          [(0, 'a'), (1, 'a'), (2, 'a')])
    1:         self.assertEqual(list(repeat('a', 3)), ['a', 'a', 'a'])
    1:         self.assertEqual(take(3, repeat('a')), ['a', 'a', 'a'])
    1:         self.assertEqual(list(repeat('a', 0)), [])
    1:         self.assertEqual(list(repeat('a', -3)), [])
    1:         self.assertRaises(TypeError, repeat)
    1:         self.assertRaises(TypeError, repeat, None, 3, 4)
    1:         self.assertRaises(TypeError, repeat, None, 'a')
    1:         r = repeat(1+0j)
    1:         self.assertEqual(repr(r), 'repeat((1+0j))')
    1:         r = repeat(1+0j, 5)
    1:         self.assertEqual(repr(r), 'repeat((1+0j), 5)')
    1:         list(r)
    1:         self.assertEqual(repr(r), 'repeat((1+0j), 0)')
       
    1:     def test_repeat_with_negative_times(self):
    1:         self.assertEqual(repr(repeat('a', -1)), "repeat('a', 0)")
    1:         self.assertEqual(repr(repeat('a', -2)), "repeat('a', 0)")
    1:         self.assertEqual(repr(repeat('a', times=-1)), "repeat('a', 0)")
    1:         self.assertEqual(repr(repeat('a', times=-2)), "repeat('a', 0)")
       
    1:     def test_imap(self):
    1:         self.assertEqual(list(imap(operator.pow, range(3), range(1,7))),
    1:                          [0**1, 1**2, 2**3])
    1:         self.assertEqual(list(imap(None, 'abc', range(5))),
    1:                          [('a',0),('b',1),('c',2)])
    1:         self.assertEqual(list(imap(None, 'abc', count())),
    1:                          [('a',0),('b',1),('c',2)])
    1:         self.assertEqual(take(2,imap(None, 'abc', count())),
    1:                          [('a',0),('b',1)])
    1:         self.assertEqual(list(imap(operator.pow, [])), [])
    1:         self.assertRaises(TypeError, imap)
    1:         self.assertRaises(TypeError, imap, operator.neg)
    1:         self.assertRaises(TypeError, imap(10, range(5)).next)
    1:         self.assertRaises(ValueError, imap(errfunc, [4], [5]).next)
    1:         self.assertRaises(TypeError, imap(onearg, [4], [5]).next)
       
    1:     def test_starmap(self):
    1:         self.assertEqual(list(starmap(operator.pow, zip(range(3), range(1,7)))),
    1:                          [0**1, 1**2, 2**3])
    1:         self.assertEqual(take(3, starmap(operator.pow, izip(count(), count(1)))),
    1:                          [0**1, 1**2, 2**3])
    1:         self.assertEqual(list(starmap(operator.pow, [])), [])
    1:         self.assertEqual(list(starmap(operator.pow, [iter([4,5])])), [4**5])
    1:         self.assertRaises(TypeError, list, starmap(operator.pow, [None]))
    1:         self.assertRaises(TypeError, starmap)
    1:         self.assertRaises(TypeError, starmap, operator.pow, [(4,5)], 'extra')
    1:         self.assertRaises(TypeError, starmap(10, [(4,5)]).next)
    1:         self.assertRaises(ValueError, starmap(errfunc, [(4,5)]).next)
    1:         self.assertRaises(TypeError, starmap(onearg, [(4,5)]).next)
       
    1:     def test_islice(self):
    1:         for args in [          # islice(args) should agree with range(args)
    1:                 (10, 20, 3),
    1:                 (10, 3, 20),
    1:                 (10, 20),
    1:                 (10, 3),
    6:                 (20,)
                       ]:
    5:             self.assertEqual(list(islice(xrange(100), *args)), range(*args))
       
    1:         for args, tgtargs in [  # Stop when seqn is exhausted
    1:                 ((10, 110, 3), ((10, 100, 3))),
    1:                 ((10, 110), ((10, 100))),
    4:                 ((110,), (100,))
                       ]:
    3:             self.assertEqual(list(islice(xrange(100), *args)), range(*tgtargs))
       
               # Test stop=None
    1:         self.assertEqual(list(islice(xrange(10), None)), range(10))
    1:         self.assertEqual(list(islice(xrange(10), None, None)), range(10))
    1:         self.assertEqual(list(islice(xrange(10), None, None, None)), range(10))
    1:         self.assertEqual(list(islice(xrange(10), 2, None)), range(2, 10))
    1:         self.assertEqual(list(islice(xrange(10), 1, None, 2)), range(1, 10, 2))
       
               # Test number of items consumed     SF #1171417
    1:         it = iter(range(10))
    1:         self.assertEqual(list(islice(it, 3)), range(3))
    1:         self.assertEqual(list(it), range(3, 10))
       
               # Test invalid arguments
    1:         self.assertRaises(TypeError, islice, xrange(10))
    1:         self.assertRaises(TypeError, islice, xrange(10), 1, 2, 3, 4)
    1:         self.assertRaises(ValueError, islice, xrange(10), -5, 10, 1)
    1:         self.assertRaises(ValueError, islice, xrange(10), 1, -5, -1)
    1:         self.assertRaises(ValueError, islice, xrange(10), 1, 10, -1)
    1:         self.assertRaises(ValueError, islice, xrange(10), 1, 10, 0)
    1:         self.assertRaises(ValueError, islice, xrange(10), 'a')
    1:         self.assertRaises(ValueError, islice, xrange(10), 'a', 1)
    1:         self.assertRaises(ValueError, islice, xrange(10), 1, 'a')
    1:         self.assertRaises(ValueError, islice, xrange(10), 'a', 1, 1)
    1:         self.assertRaises(ValueError, islice, xrange(10), 1, 'a', 1)
    1:         self.assertEqual(len(list(islice(count(), 1, 10, maxsize))), 1)
       
               # Issue #10323:  Less islice in a predictable state
    1:         c = count()
    1:         self.assertEqual(list(islice(c, 1, 3, 50)), [1])
    1:         self.assertEqual(next(c), 3)
       
               # Issue #21321: check source iterator is not referenced
               # from islice() after the latter has been exhausted
    2:         it = (x for x in (1, 2))
    1:         wr = weakref.ref(it)
    1:         it = islice(it, 1)
    1:         self.assertIsNotNone(wr())
    1:         list(it) # exhaust the iterator
    1:         test_support.gc_collect()
    1:         self.assertIsNone(wr())
       
    1:     def test_takewhile(self):
    1:         data = [1, 3, 5, 20, 2, 4, 6, 8]
    5:         underten = lambda x: x<10
    1:         self.assertEqual(list(takewhile(underten, data)), [1, 3, 5])
    1:         self.assertEqual(list(takewhile(underten, [])), [])
    1:         self.assertRaises(TypeError, takewhile)
    1:         self.assertRaises(TypeError, takewhile, operator.pow)
    1:         self.assertRaises(TypeError, takewhile, operator.pow, [(4,5)], 'extra')
    1:         self.assertRaises(TypeError, takewhile(10, [(4,5)]).next)
    1:         self.assertRaises(ValueError, takewhile(errfunc, [(4,5)]).next)
    1:         t = takewhile(bool, [1, 1, 1, 0, 0, 0])
    1:         self.assertEqual(list(t), [1, 1, 1])
    1:         self.assertRaises(StopIteration, t.next)
       
    1:     def test_dropwhile(self):
    1:         data = [1, 3, 5, 20, 2, 4, 6, 8]
    5:         underten = lambda x: x<10
    1:         self.assertEqual(list(dropwhile(underten, data)), [20, 2, 4, 6, 8])
    1:         self.assertEqual(list(dropwhile(underten, [])), [])
    1:         self.assertRaises(TypeError, dropwhile)
    1:         self.assertRaises(TypeError, dropwhile, operator.pow)
    1:         self.assertRaises(TypeError, dropwhile, operator.pow, [(4,5)], 'extra')
    1:         self.assertRaises(TypeError, dropwhile(10, [(4,5)]).next)
    1:         self.assertRaises(ValueError, dropwhile(errfunc, [(4,5)]).next)
       
    1:     def test_tee(self):
    1:         n = 200
    1:         def irange(n):
 1804:             for i in xrange(n):
 1800:                 yield i
       
    1:         a, b = tee([])        # test empty iterator
    1:         self.assertEqual(list(a), [])
    1:         self.assertEqual(list(b), [])
       
    1:         a, b = tee(irange(n)) # test 100% interleaved
    1:         self.assertEqual(zip(a,b), zip(range(n),range(n)))
       
    1:         a, b = tee(irange(n)) # test 0% interleaved
    1:         self.assertEqual(list(a), range(n))
    1:         self.assertEqual(list(b), range(n))
       
    1:         a, b = tee(irange(n)) # test dealloc of leading iterator
  101:         for i in xrange(100):
  100:             self.assertEqual(a.next(), i)
    1:         del a
    1:         self.assertEqual(list(b), range(n))
       
    1:         a, b = tee(irange(n)) # test dealloc of trailing iterator
  101:         for i in xrange(100):
  100:             self.assertEqual(a.next(), i)
    1:         del b
    1:         self.assertEqual(list(a), range(100, n))
       
    6:         for j in xrange(5):   # test randomly interleaved
    5:             order = [0]*n + [1]*n
    5:             random.shuffle(order)
    5:             lists = ([], [])
    5:             its = tee(irange(n))
 2005:             for i in order:
 2000:                 value = its[i].next()
 2000:                 lists[i].append(value)
    5:             self.assertEqual(lists[0], range(n))
    5:             self.assertEqual(lists[1], range(n))
       
               # test argument format checking
    1:         self.assertRaises(TypeError, tee)
    1:         self.assertRaises(TypeError, tee, 3)
    1:         self.assertRaises(TypeError, tee, [1,2], 'x')
    1:         self.assertRaises(TypeError, tee, [1,2], 3, 'x')
       
               # tee object should be instantiable
    1:         a, b = tee('abc')
    1:         c = type(a)('def')
    1:         self.assertEqual(list(c), list('def'))
       
               # test long-lagged and multi-way split
    1:         a, b, c = tee(xrange(2000), 3)
  101:         for i in xrange(100):
  100:             self.assertEqual(a.next(), i)
    1:         self.assertEqual(list(b), range(2000))
    1:         self.assertEqual([c.next(), c.next()], range(2))
    1:         self.assertEqual(list(a), range(100,2000))
    1:         self.assertEqual(list(c), range(2,2000))
       
               # test values of n
    1:         self.assertRaises(TypeError, tee, 'abc', 'invalid')
    1:         self.assertRaises(ValueError, tee, [], -1)
    6:         for n in xrange(5):
    5:             result = tee('abc', n)
    5:             self.assertEqual(type(result), tuple)
    5:             self.assertEqual(len(result), n)
    5:             self.assertEqual(map(list, result), [list('abc')]*n)
       
               # tee pass-through to copyable iterator
    1:         a, b = tee('abc')
    1:         c, d = tee(a)
    1:         self.assertTrue(a is c)
       
               # test tee_new
    1:         t1, t2 = tee('abc')
    1:         tnew = type(t1)
    1:         self.assertRaises(TypeError, tnew)
    1:         self.assertRaises(TypeError, tnew, 10)
    1:         t3 = tnew(t1)
    1:         self.assertTrue(list(t1) == list(t2) == list(t3) == list('abc'))
       
               # test that tee objects are weak referencable
    1:         a, b = tee(xrange(10))
    1:         p = weakref.proxy(a)
    1:         self.assertEqual(getattr(p, '__class__'), type(b))
    1:         del a
    1:         self.assertRaises(ReferenceError, getattr, p, '__class__')
       
           # Issue 13454: Crash when deleting backward iterator from tee()
    1:     def test_tee_del_backward(self):
    1:         forward, backward = tee(repeat(None, 20000000))
    1:         try:
    1:             any(forward)  # exhaust the iterator
    1:             del backward
>>>>>>         except:
>>>>>>             del forward, backward
>>>>>>             raise
       
    1:     def test_StopIteration(self):
    1:         self.assertRaises(StopIteration, izip().next)
       
    5:         for f in (chain, cycle, izip, groupby):
    4:             self.assertRaises(StopIteration, f([]).next)
    4:             self.assertRaises(StopIteration, f(StopNow()).next)
       
    1:         self.assertRaises(StopIteration, islice([], None).next)
    1:         self.assertRaises(StopIteration, islice(StopNow(), None).next)
       
    1:         p, q = tee([])
    1:         self.assertRaises(StopIteration, p.next)
    1:         self.assertRaises(StopIteration, q.next)
    1:         p, q = tee(StopNow())
    1:         self.assertRaises(StopIteration, p.next)
    1:         self.assertRaises(StopIteration, q.next)
       
    1:         self.assertRaises(StopIteration, repeat(None, 0).next)
       
    7:         for f in (ifilter, ifilterfalse, imap, takewhile, dropwhile, starmap):
    6:             self.assertRaises(StopIteration, f(lambda x:x, []).next)
    6:             self.assertRaises(StopIteration, f(lambda x:x, StopNow()).next)
       
    2: class TestExamples(unittest.TestCase):
       
    1:     def test_chain(self):
    1:         self.assertEqual(''.join(chain('ABC', 'DEF')), 'ABCDEF')
       
    1:     def test_chain_from_iterable(self):
    1:         self.assertEqual(''.join(chain.from_iterable(['ABC', 'DEF'])), 'ABCDEF')
       
    1:     def test_combinations(self):
    1:         self.assertEqual(list(combinations('ABCD', 2)),
    1:                          [('A','B'), ('A','C'), ('A','D'), ('B','C'), ('B','D'), ('C','D')])
    1:         self.assertEqual(list(combinations(range(4), 3)),
    1:                          [(0,1,2), (0,1,3), (0,2,3), (1,2,3)])
       
    1:     def test_combinations_with_replacement(self):
    1:         self.assertEqual(list(combinations_with_replacement('ABC', 2)),
    1:                          [('A','A'), ('A','B'), ('A','C'), ('B','B'), ('B','C'), ('C','C')])
       
    1:     def test_compress(self):
    1:         self.assertEqual(list(compress('ABCDEF', [1,0,1,0,1,1])), list('ACEF'))
       
    1:     def test_count(self):
    1:         self.assertEqual(list(islice(count(10), 5)), [10, 11, 12, 13, 14])
       
    1:     def test_cycle(self):
    1:         self.assertEqual(list(islice(cycle('ABCD'), 12)), list('ABCDABCDABCD'))
       
    1:     def test_dropwhile(self):
    4:         self.assertEqual(list(dropwhile(lambda x: x<5, [1,4,6,4,1])), [6,4,1])
       
    1:     def test_groupby(self):
    7:         self.assertEqual([k for k, g in groupby('AAAABBBCCDAABBB')],
    1:                          list('ABCDAB'))
    5:         self.assertEqual([(list(g)) for k, g in groupby('AAAABBBCCD')],
    1:                          [list('AAAA'), list('BBB'), list('CC'), list('D')])
       
    1:     def test_ifilter(self):
   11:         self.assertEqual(list(ifilter(lambda x: x%2, range(10))), [1,3,5,7,9])
       
    1:     def test_ifilterfalse(self):
   11:         self.assertEqual(list(ifilterfalse(lambda x: x%2, range(10))), [0,2,4,6,8])
       
    1:     def test_imap(self):
    1:         self.assertEqual(list(imap(pow, (2,3,10), (5,2,3))), [32, 9, 1000])
       
    1:     def test_islice(self):
    1:         self.assertEqual(list(islice('ABCDEFG', 2)), list('AB'))
    1:         self.assertEqual(list(islice('ABCDEFG', 2, 4)), list('CD'))
    1:         self.assertEqual(list(islice('ABCDEFG', 2, None)), list('CDEFG'))
    1:         self.assertEqual(list(islice('ABCDEFG', 0, None, 2)), list('ACEG'))
       
    1:     def test_izip(self):
    1:         self.assertEqual(list(izip('ABCD', 'xy')), [('A', 'x'), ('B', 'y')])
       
    1:     def test_izip_longest(self):
    1:         self.assertEqual(list(izip_longest('ABCD', 'xy', fillvalue='-')),
    1:                          [('A', 'x'), ('B', 'y'), ('C', '-'), ('D', '-')])
       
    1:     def test_permutations(self):
    1:         self.assertEqual(list(permutations('ABCD', 2)),
    1:                          map(tuple, 'AB AC AD BA BC BD CA CB CD DA DB DC'.split()))
    1:         self.assertEqual(list(permutations(range(3))),
    1:                          [(0,1,2), (0,2,1), (1,0,2), (1,2,0), (2,0,1), (2,1,0)])
       
    1:     def test_product(self):
    1:         self.assertEqual(list(product('ABCD', 'xy')),
    1:                          map(tuple, 'Ax Ay Bx By Cx Cy Dx Dy'.split()))
    1:         self.assertEqual(list(product(range(2), repeat=3)),
    1:                         [(0,0,0), (0,0,1), (0,1,0), (0,1,1),
    1:                          (1,0,0), (1,0,1), (1,1,0), (1,1,1)])
       
    1:     def test_repeat(self):
    1:         self.assertEqual(list(repeat(10, 3)), [10, 10, 10])
       
    1:     def test_stapmap(self):
    1:         self.assertEqual(list(starmap(pow, [(2,5), (3,2), (10,3)])),
    1:                          [32, 9, 1000])
       
    1:     def test_takewhile(self):
    4:         self.assertEqual(list(takewhile(lambda x: x<5, [1,4,6,4,1])), [1,4])
       
       
    2: class TestGC(unittest.TestCase):
       
    1:     def makecycle(self, iterator, container):
   21:         container.append(iterator)
   21:         iterator.next()
   21:         del container, iterator
       
    1:     def test_chain(self):
    1:         a = []
    1:         self.makecycle(chain(a), a)
       
    1:     def test_chain_from_iterable(self):
    1:         a = []
    1:         self.makecycle(chain.from_iterable([a]), a)
       
    1:     def test_combinations(self):
    1:         a = []
    1:         self.makecycle(combinations([1,2,a,3], 3), a)
       
    1:     def test_combinations_with_replacement(self):
    1:         a = []
    1:         self.makecycle(combinations_with_replacement([1,2,a,3], 3), a)
       
    1:     def test_compress(self):
    1:         a = []
    1:         self.makecycle(compress('ABCDEF', [1,0,1,0,1,0]), a)
       
    1:     def test_count(self):
    1:         a = []
    1:         Int = type('Int', (int,), dict(x=a))
    1:         self.makecycle(count(Int(0), Int(1)), a)
       
    1:     def test_cycle(self):
    1:         a = []
    1:         self.makecycle(cycle([a]*2), a)
       
    1:     def test_dropwhile(self):
    1:         a = []
    1:         self.makecycle(dropwhile(bool, [0, a, a]), a)
       
    1:     def test_groupby(self):
    1:         a = []
    2:         self.makecycle(groupby([a]*2, lambda x:x), a)
       
    1:     def test_issue2246(self):
               # Issue 2246 -- the _grouper iterator was not included in GC
    1:         n = 10
   11:         keyfunc = lambda x: x
   11:         for i, j in groupby(xrange(n), key=keyfunc):
   10:             keyfunc.__dict__.setdefault('x',[]).append(j)
       
    1:     def test_ifilter(self):
    1:         a = []
    2:         self.makecycle(ifilter(lambda x:True, [a]*2), a)
       
    1:     def test_ifilterfalse(self):
    1:         a = []
    2:         self.makecycle(ifilterfalse(lambda x:False, a), a)
       
    1:     def test_izip(self):
    1:         a = []
    1:         self.makecycle(izip([a]*2, [a]*3), a)
       
    1:     def test_izip_longest(self):
    1:         a = []
    1:         self.makecycle(izip_longest([a]*2, [a]*3), a)
    1:         b = [a, None]
    1:         self.makecycle(izip_longest([a]*2, [a]*3, fillvalue=b), a)
       
    1:     def test_imap(self):
    1:         a = []
    2:         self.makecycle(imap(lambda x:x, [a]*2), a)
       
    1:     def test_islice(self):
    1:         a = []
    1:         self.makecycle(islice([a]*2, None), a)
       
    1:     def test_permutations(self):
    1:         a = []
    1:         self.makecycle(permutations([1,2,a,3], 3), a)
       
    1:     def test_product(self):
    1:         a = []
    1:         self.makecycle(product([1,2,a,3], repeat=3), a)
       
    1:     def test_repeat(self):
    1:         a = []
    1:         self.makecycle(repeat(a), a)
       
    1:     def test_starmap(self):
    1:         a = []
    2:         self.makecycle(starmap(lambda *t: t, [(a,a)]*2), a)
       
    1:     def test_takewhile(self):
    1:         a = []
    1:         self.makecycle(takewhile(bool, [1, 0, a, a]), a)
       
    1: def R(seqn):
           'Regular generator'
75824:     for i in seqn:
75422:         yield i
       
    2: class G:
    1:     'Sequence using __getitem__'
    1:     def __init__(self, seqn):
  460:         self.seqn = seqn
    1:     def __getitem__(self, i):
75824:         return self.seqn[i]
       
    2: class I:
    1:     'Sequence using iterator protocol'
    1:     def __init__(self, seqn):
  230:         self.seqn = seqn
  230:         self.i = 0
    1:     def __iter__(self):
  235:         return self
    1:     def next(self):
37917:         if self.i >= len(self.seqn): raise StopIteration
37711:         v = self.seqn[self.i]
37711:         self.i += 1
37711:         return v
       
    2: class Ig:
    1:     'Sequence using iterator protocol defined with a generator'
    1:     def __init__(self, seqn):
  460:         self.seqn = seqn
  460:         self.i = 0
    1:     def __iter__(self):
75824:         for val in self.seqn:
75422:             yield val
       
    2: class X:
    1:     'Missing __getitem__ and __iter__'
    1:     def __init__(self, seqn):
   75:         self.seqn = seqn
   75:         self.i = 0
    1:     def next(self):
>>>>>>         if self.i >= len(self.seqn): raise StopIteration
>>>>>>         v = self.seqn[self.i]
>>>>>>         self.i += 1
>>>>>>         return v
       
    2: class N:
    1:     'Iterator missing next()'
    1:     def __init__(self, seqn):
   75:         self.seqn = seqn
   75:         self.i = 0
    1:     def __iter__(self):
   80:         return self
       
    2: class E:
    1:     'Test propagation of exceptions'
    1:     def __init__(self, seqn):
   75:         self.seqn = seqn
   75:         self.i = 0
    1:     def __iter__(self):
   80:         return self
    1:     def next(self):
   75:         3 // 0
       
    2: class S:
    1:     'Test immediate stop'
    1:     def __init__(self, seqn):
  230:         pass
    1:     def __iter__(self):
  235:         return self
    1:     def next(self):
  214:         raise StopIteration
       
    1: def L(seqn):
           'Test multiple tiers of iterators'
37941:     return chain(imap(lambda x:x, R(Ig(G(seqn)))))
       
       
    2: class TestVariousIteratorArgs(unittest.TestCase):
       
    1:     def test_chain(self):
    6:         for s in ("123", "", range(1000), ('do', 1.2), xrange(2000,2200,5)):
   35:             for g in (G, I, Ig, S, L, R):
   30:                 self.assertEqual(list(chain(g(s))), list(g(s)))
   30:                 self.assertEqual(list(chain(g(s), g(s))), list(g(s))+list(g(s)))
    5:             self.assertRaises(TypeError, list, chain(X(s)))
    5:             self.assertRaises(TypeError, list, chain(N(s)))
    5:             self.assertRaises(ZeroDivisionError, list, chain(E(s)))
       
    1:     def test_compress(self):
    6:         for s in ("123", "", range(1000), ('do', 1.2), xrange(2000,2200,5)):
    5:             n = len(s)
   35:             for g in (G, I, Ig, S, L, R):
   30:                 self.assertEqual(list(compress(g(s), repeat(1))), list(g(s)))
    5:             self.assertRaises(TypeError, compress, X(s), repeat(1))
    5:             self.assertRaises(TypeError, list, compress(N(s), repeat(1)))
    5:             self.assertRaises(ZeroDivisionError, list, compress(E(s), repeat(1)))
       
    1:     def test_product(self):
    6:         for s in ("123", "", range(1000), ('do', 1.2), xrange(2000,2200,5)):
    5:             self.assertRaises(TypeError, product, X(s))
    5:             self.assertRaises(TypeError, product, N(s))
    5:             self.assertRaises(ZeroDivisionError, product, E(s))
       
    1:     def test_cycle(self):
    6:         for s in ("123", "", range(1000), ('do', 1.2), xrange(2000,2200,5)):
   35:             for g in (G, I, Ig, S, L, R):
   30:                 tgtlen = len(s) * 3
   30:                 expected = list(g(s))*3
   30:                 actual = list(islice(cycle(g(s)), tgtlen))
   30:                 self.assertEqual(actual, expected)
    5:             self.assertRaises(TypeError, cycle, X(s))
    5:             self.assertRaises(TypeError, list, cycle(N(s)))
    5:             self.assertRaises(ZeroDivisionError, list, cycle(E(s)))
       
    1:     def test_groupby(self):
    6:         for s in (range(10), range(0), range(1000), (7,11), xrange(2000,2200,5)):
   35:             for g in (G, I, Ig, S, L, R):
 5290:                 self.assertEqual([k for k, sb in groupby(g(s))], list(g(s)))
    5:             self.assertRaises(TypeError, groupby, X(s))
    5:             self.assertRaises(TypeError, list, groupby(N(s)))
    5:             self.assertRaises(ZeroDivisionError, list, groupby(E(s)))
       
    1:     def test_ifilter(self):
    6:         for s in (range(10), range(0), range(1000), (7,11), xrange(2000,2200,5)):
   35:             for g in (G, I, Ig, S, L, R):
   30:                 self.assertEqual(list(ifilter(isEven, g(s))), filter(isEven, g(s)))
    5:             self.assertRaises(TypeError, ifilter, isEven, X(s))
    5:             self.assertRaises(TypeError, list, ifilter(isEven, N(s)))
    5:             self.assertRaises(ZeroDivisionError, list, ifilter(isEven, E(s)))
       
    1:     def test_ifilterfalse(self):
    6:         for s in (range(10), range(0), range(1000), (7,11), xrange(2000,2200,5)):
   35:             for g in (G, I, Ig, S, L, R):
   30:                 self.assertEqual(list(ifilterfalse(isEven, g(s))), filter(isOdd, g(s)))
    5:             self.assertRaises(TypeError, ifilterfalse, isEven, X(s))
    5:             self.assertRaises(TypeError, list, ifilterfalse(isEven, N(s)))
    5:             self.assertRaises(ZeroDivisionError, list, ifilterfalse(isEven, E(s)))
       
    1:     def test_izip(self):
    6:         for s in ("123", "", range(1000), ('do', 1.2), xrange(2000,2200,5)):
   35:             for g in (G, I, Ig, S, L, R):
   30:                 self.assertEqual(list(izip(g(s))), zip(g(s)))
   30:                 self.assertEqual(list(izip(g(s), g(s))), zip(g(s), g(s)))
    5:             self.assertRaises(TypeError, izip, X(s))
    5:             self.assertRaises(TypeError, list, izip(N(s)))
    5:             self.assertRaises(ZeroDivisionError, list, izip(E(s)))
       
    1:     def test_iziplongest(self):
    6:         for s in ("123", "", range(1000), ('do', 1.2), xrange(2000,2200,5)):
   35:             for g in (G, I, Ig, S, L, R):
   30:                 self.assertEqual(list(izip_longest(g(s))), zip(g(s)))
   30:                 self.assertEqual(list(izip_longest(g(s), g(s))), zip(g(s), g(s)))
    5:             self.assertRaises(TypeError, izip_longest, X(s))
    5:             self.assertRaises(TypeError, list, izip_longest(N(s)))
    5:             self.assertRaises(ZeroDivisionError, list, izip_longest(E(s)))
       
    1:     def test_imap(self):
    6:         for s in (range(10), range(0), range(100), (7,11), xrange(20,50,5)):
   35:             for g in (G, I, Ig, S, L, R):
   30:                 self.assertEqual(list(imap(onearg, g(s))), map(onearg, g(s)))
   30:                 self.assertEqual(list(imap(operator.pow, g(s), g(s))), map(operator.pow, g(s), g(s)))
    5:             self.assertRaises(TypeError, imap, onearg, X(s))
    5:             self.assertRaises(TypeError, list, imap(onearg, N(s)))
    5:             self.assertRaises(ZeroDivisionError, list, imap(onearg, E(s)))
       
    1:     def test_islice(self):
    6:         for s in ("12345", "", range(1000), ('do', 1.2), xrange(2000,2200,5)):
   35:             for g in (G, I, Ig, S, L, R):
   30:                 self.assertEqual(list(islice(g(s),1,None,2)), list(g(s))[1::2])
    5:             self.assertRaises(TypeError, islice, X(s), 10)
    5:             self.assertRaises(TypeError, list, islice(N(s), 10))
    5:             self.assertRaises(ZeroDivisionError, list, islice(E(s), 10))
       
    1:     def test_starmap(self):
    6:         for s in (range(10), range(0), range(100), (7,11), xrange(20,50,5)):
   35:             for g in (G, I, Ig, S, L, R):
   30:                 ss = zip(s, s)
   30:                 self.assertEqual(list(starmap(operator.pow, g(ss))), map(operator.pow, g(s), g(s)))
    5:             self.assertRaises(TypeError, starmap, operator.pow, X(ss))
    5:             self.assertRaises(TypeError, list, starmap(operator.pow, N(ss)))
    5:             self.assertRaises(ZeroDivisionError, list, starmap(operator.pow, E(ss)))
       
    1:     def test_takewhile(self):
    6:         for s in (range(10), range(0), range(1000), (7,11), xrange(2000,2200,5)):
   35:             for g in (G, I, Ig, S, L, R):
   30:                 tgt = []
   45:                 for elem in g(s):
   35:                     if not isEven(elem): break
   15:                     tgt.append(elem)
   30:                 self.assertEqual(list(takewhile(isEven, g(s))), tgt)
    5:             self.assertRaises(TypeError, takewhile, isEven, X(s))
    5:             self.assertRaises(TypeError, list, takewhile(isEven, N(s)))
    5:             self.assertRaises(ZeroDivisionError, list, takewhile(isEven, E(s)))
       
    1:     def test_dropwhile(self):
    6:         for s in (range(10), range(0), range(1000), (7,11), xrange(2000,2200,5)):
   35:             for g in (G, I, Ig, S, L, R):
   30:                 tgt = []
 5290:                 for elem in g(s):
 5260:                     if not tgt and isOdd(elem): continue
 5250:                     tgt.append(elem)
   30:                 self.assertEqual(list(dropwhile(isOdd, g(s))), tgt)
    5:             self.assertRaises(TypeError, dropwhile, isOdd, X(s))
    5:             self.assertRaises(TypeError, list, dropwhile(isOdd, N(s)))
    5:             self.assertRaises(ZeroDivisionError, list, dropwhile(isOdd, E(s)))
       
    1:     def test_tee(self):
    6:         for s in ("123", "", range(1000), ('do', 1.2), xrange(2000,2200,5)):
   35:             for g in (G, I, Ig, S, L, R):
   30:                 it1, it2 = tee(g(s))
   30:                 self.assertEqual(list(it1), list(g(s)))
   30:                 self.assertEqual(list(it2), list(g(s)))
    5:             self.assertRaises(TypeError, tee, X(s))
    5:             self.assertRaises(TypeError, list, tee(N(s))[0])
    5:             self.assertRaises(ZeroDivisionError, list, tee(E(s))[0])
       
    2: class LengthTransparency(unittest.TestCase):
       
    1:     def test_repeat(self):
    1:         from test.test_iterlen import len
    1:         self.assertEqual(len(repeat(None, 50)), 50)
    1:         self.assertRaises(TypeError, len, repeat(None))
       
    2: class RegressionTests(unittest.TestCase):
       
    1:     def test_sf_793826(self):
               # Fix Armin Rigo's successful efforts to wreak havoc
       
    1:         def mutatingtuple(tuple1, f, tuple2):
                   # this builds a tuple t which is a copy of tuple1,
                   # then calls f(t), then mutates t to be equal to tuple2
                   # (needs len(tuple1) == len(tuple2)).
    1:             def g(value, first=[1]):
    6:                 if first:
    1:                     del first[:]
    1:                     f(z.next())
    6:                 return value
    1:             items = list(tuple2)
    1:             items[1:1] = list(tuple1)
    1:             gen = imap(g, items)
    1:             z = izip(*[gen]*len(tuple1))
    1:             z.next()
       
    1:         def f(t):
                   global T
    1:             T = t
    1:             first[:] = list(T)
       
    1:         first = []
    1:         mutatingtuple((1,2,3), f, (4,5,6))
    1:         second = list(T)
    1:         self.assertEqual(first, second)
       
       
    1:     def test_sf_950057(self):
               # Make sure that chain() and cycle() catch exceptions immediately
               # rather than when shifting between input sources
       
    1:         def gen1():
    3:             hist.append(0)
    3:             yield 1
    3:             hist.append(1)
    3:             raise AssertionError
>>>>>>             hist.append(2)
       
    1:         def gen2(x):
>>>>>>             hist.append(3)
>>>>>>             yield 2
>>>>>>             hist.append(4)
>>>>>>             if x:
>>>>>>                 raise StopIteration
       
    1:         hist = []
    1:         self.assertRaises(AssertionError, list, chain(gen1(), gen2(False)))
    1:         self.assertEqual(hist, [0,1])
       
    1:         hist = []
    1:         self.assertRaises(AssertionError, list, chain(gen1(), gen2(True)))
    1:         self.assertEqual(hist, [0,1])
       
    1:         hist = []
    1:         self.assertRaises(AssertionError, list, cycle(gen1()))
    1:         self.assertEqual(hist, [0,1])
       
    1:     def test_long_chain_of_empty_iterables(self):
               # Make sure itertools.chain doesn't run into recursion limits when
               # dealing with long chains of empty iterables. Even with a high
               # number this would probably only fail in Py_DEBUG mode.
10000002:         it = chain.from_iterable(() for unused in xrange(10000000))
    1:         with self.assertRaises(StopIteration):
    1:             next(it)
       
    2: class SubclassWithKwargsTest(unittest.TestCase):
    1:     def test_keywords_in_subclass(self):
               # count is not subclassable...
    1:         for cls in (repeat, izip, ifilter, ifilterfalse, chain, imap,
   13:                     starmap, islice, takewhile, dropwhile, cycle, compress):
   24:             class Subclass(cls):
   12:                 def __init__(self, newarg=None, *args):
    2:                     cls.__init__(self, *args)
   12:             try:
   12:                 Subclass(newarg=1)
   10:             except TypeError, err:
                       # we expect type errors because of wrong argument count
   10:                 self.assertNotIn("does not take keyword arguments", err.args[0])
       
       
       libreftest = """ Doctest for examples in the library reference: libitertools.tex
       
       
       >>> amounts = [120.15, 764.05, 823.14]
       >>> for checknum, amount in izip(count(1200), amounts):
       ...     print 'Check %d is for $%.2f' % (checknum, amount)
       ...
       Check 1200 is for $120.15
       Check 1201 is for $764.05
       Check 1202 is for $823.14
       
       >>> import operator
       >>> for cube in imap(operator.pow, xrange(1,4), repeat(3)):
       ...    print cube
       ...
       1
       8
       27
       
       >>> reportlines = ['EuroPython', 'Roster', '', 'alex', '', 'laura', '', 'martin', '', 'walter', '', 'samuele']
       >>> for name in islice(reportlines, 3, None, 2):
       ...    print name.title()
       ...
       Alex
       Laura
       Martin
       Walter
       Samuele
       
       >>> from operator import itemgetter
       >>> d = dict(a=1, b=2, c=1, d=2, e=1, f=2, g=3)
       >>> di = sorted(sorted(d.iteritems()), key=itemgetter(1))
       >>> for k, g in groupby(di, itemgetter(1)):
       ...     print k, map(itemgetter(0), g)
       ...
       1 ['a', 'c', 'e']
       2 ['b', 'd', 'f']
       3 ['g']
       
       # Find runs of consecutive numbers using groupby.  The key to the solution
       # is differencing with a range so that consecutive numbers all appear in
       # same group.
       >>> data = [ 1,  4,5,6, 10, 15,16,17,18, 22, 25,26,27,28]
       >>> for k, g in groupby(enumerate(data), lambda t:t[0]-t[1]):
       ...     print map(operator.itemgetter(1), g)
       ...
       [1]
       [4, 5, 6]
       [10]
       [15, 16, 17, 18]
       [22]
       [25, 26, 27, 28]
       
       >>> def take(n, iterable):
       ...     "Return first n items of the iterable as a list"
       ...     return list(islice(iterable, n))
       
       >>> def enumerate(iterable, start=0):
       ...     return izip(count(start), iterable)
       
       >>> def tabulate(function, start=0):
       ...     "Return function(0), function(1), ..."
       ...     return imap(function, count(start))
       
       >>> def nth(iterable, n, default=None):
       ...     "Returns the nth item or a default value"
       ...     return next(islice(iterable, n, None), default)
       
       >>> def all_equal(iterable):
       ...     "Returns True if all the elements are equal to each other"
       ...     g = groupby(iterable)
       ...     return next(g, True) and not next(g, False)
       
       >>> def quantify(iterable, pred=bool):
       ...     "Count how many times the predicate is true"
       ...     return sum(imap(pred, iterable))
       
       >>> def padnone(iterable):
       ...     "Returns the sequence elements and then returns None indefinitely"
       ...     return chain(iterable, repeat(None))
       
       >>> def ncycles(iterable, n):
       ...     "Returns the sequence elements n times"
       ...     return chain(*repeat(iterable, n))
       
       >>> def dotproduct(vec1, vec2):
       ...     return sum(imap(operator.mul, vec1, vec2))
       
       >>> def flatten(listOfLists):
       ...     return list(chain.from_iterable(listOfLists))
       
       >>> def repeatfunc(func, times=None, *args):
       ...     "Repeat calls to func with specified arguments."
       ...     "   Example:  repeatfunc(random.random)"
       ...     if times is None:
       ...         return starmap(func, repeat(args))
       ...     else:
       ...         return starmap(func, repeat(args, times))
       
       >>> def pairwise(iterable):
       ...     "s -> (s0,s1), (s1,s2), (s2, s3), ..."
       ...     a, b = tee(iterable)
       ...     for elem in b:
       ...         break
       ...     return izip(a, b)
       
       >>> def grouper(n, iterable, fillvalue=None):
       ...     "grouper(3, 'ABCDEFG', 'x') --> ABC DEF Gxx"
       ...     args = [iter(iterable)] * n
       ...     return izip_longest(fillvalue=fillvalue, *args)
       
       >>> def roundrobin(*iterables):
       ...     "roundrobin('ABC', 'D', 'EF') --> A D E B F C"
       ...     # Recipe credited to George Sakkis
       ...     pending = len(iterables)
       ...     nexts = cycle(iter(it).next for it in iterables)
       ...     while pending:
       ...         try:
       ...             for next in nexts:
       ...                 yield next()
       ...         except StopIteration:
       ...             pending -= 1
       ...             nexts = cycle(islice(nexts, pending))
       
       >>> def powerset(iterable):
       ...     "powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"
       ...     s = list(iterable)
       ...     return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))
       
       >>> def unique_everseen(iterable, key=None):
       ...     "List unique elements, preserving order. Remember all elements ever seen."
       ...     # unique_everseen('AAAABBBCCDAABBB') --> A B C D
       ...     # unique_everseen('ABBCcAD', str.lower) --> A B C D
       ...     seen = set()
       ...     seen_add = seen.add
       ...     if key is None:
       ...         for element in iterable:
       ...             if element not in seen:
       ...                 seen_add(element)
       ...                 yield element
       ...     else:
       ...         for element in iterable:
       ...             k = key(element)
       ...             if k not in seen:
       ...                 seen_add(k)
       ...                 yield element
       
       >>> def unique_justseen(iterable, key=None):
       ...     "List unique elements, preserving order. Remember only the element just seen."
       ...     # unique_justseen('AAAABBBCCDAABBB') --> A B C D A B
       ...     # unique_justseen('ABBCcAD', str.lower) --> A B C A D
       ...     return imap(next, imap(itemgetter(1), groupby(iterable, key)))
       
       This is not part of the examples but it tests to make sure the definitions
       perform as purported.
       
       >>> take(10, count())
       [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
       
       >>> list(enumerate('abc'))
       [(0, 'a'), (1, 'b'), (2, 'c')]
       
       >>> list(islice(tabulate(lambda x: 2*x), 4))
       [0, 2, 4, 6]
       
       >>> nth('abcde', 3)
       'd'
       
       >>> nth('abcde', 9) is None
       True
       
       >>> [all_equal(s) for s in ('', 'A', 'AAAA', 'AAAB', 'AAABA')]
       [True, True, True, False, False]
       
       >>> quantify(xrange(99), lambda x: x%2==0)
       50
       
       >>> a = [[1, 2, 3], [4, 5, 6]]
       >>> flatten(a)
       [1, 2, 3, 4, 5, 6]
       
       >>> list(repeatfunc(pow, 5, 2, 3))
       [8, 8, 8, 8, 8]
       
       >>> import random
       >>> take(5, imap(int, repeatfunc(random.random)))
       [0, 0, 0, 0, 0]
       
       >>> list(pairwise('abcd'))
       [('a', 'b'), ('b', 'c'), ('c', 'd')]
       
       >>> list(pairwise([]))
       []
       
       >>> list(pairwise('a'))
       []
       
       >>> list(islice(padnone('abc'), 0, 6))
       ['a', 'b', 'c', None, None, None]
       
       >>> list(ncycles('abc', 3))
       ['a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c']
       
       >>> dotproduct([1,2,3], [4,5,6])
       32
       
       >>> list(grouper(3, 'abcdefg', 'x'))
       [('a', 'b', 'c'), ('d', 'e', 'f'), ('g', 'x', 'x')]
       
       >>> list(roundrobin('abc', 'd', 'ef'))
       ['a', 'd', 'e', 'b', 'f', 'c']
       
       >>> list(powerset([1,2,3]))
       [(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)]
       
       >>> all(len(list(powerset(range(n)))) == 2**n for n in range(18))
       True
       
       >>> list(powerset('abcde')) == sorted(sorted(set(powerset('abcde'))), key=len)
       True
       
       >>> list(unique_everseen('AAAABBBCCDAABBB'))
       ['A', 'B', 'C', 'D']
       
       >>> list(unique_everseen('ABBCcAD', str.lower))
       ['A', 'B', 'C', 'D']
       
       >>> list(unique_justseen('AAAABBBCCDAABBB'))
       ['A', 'B', 'C', 'D', 'A', 'B']
       
       >>> list(unique_justseen('ABBCcAD', str.lower))
       ['A', 'B', 'C', 'A', 'D']
       
    1: """
       
    1: __test__ = {'libreftest' : libreftest}
       
    1: def test_main(verbose=None):
    1:     test_classes = (TestBasicOps, TestVariousIteratorArgs, TestGC,
    1:                     RegressionTests, LengthTransparency,
    1:                     SubclassWithKwargsTest, TestExamples)
    1:     test_support.run_unittest(*test_classes)
       
           # verify reference counting
    1:     if verbose and hasattr(sys, "gettotalrefcount"):
>>>>>>         import gc
>>>>>>         counts = [None] * 5
>>>>>>         for i in xrange(len(counts)):
>>>>>>             test_support.run_unittest(*test_classes)
>>>>>>             gc.collect()
>>>>>>             counts[i] = sys.gettotalrefcount()
>>>>>>         print counts
       
           # doctest the examples in the library reference
    1:     test_support.run_doctest(sys.modules[__name__], verbose)
       
    1: if __name__ == "__main__":
>>>>>>     test_main(verbose=True)
