    1: """ Test suite for the fixer modules """
       
       # Python imports
    1: import os
    1: import unittest
    1: from itertools import chain
    1: from operator import itemgetter
       
       # Local imports
    1: from lib2to3 import pygram, pytree, refactor, fixer_util
    1: from lib2to3.tests import support
       
       
    2: class FixerTestCase(support.TestCase):
       
           # Other test cases can subclass this class and replace "fixer_pkg" with
           # their own.
    1:     def setUp(self, fix_list=None, fixer_pkg="lib2to3", options=None):
  456:         if fix_list is None:
  448:             fix_list = [self.fixer]
  456:         self.refactor = support.get_refactorer(fixer_pkg, fix_list, options)
  456:         self.fixer_log = []
  456:         self.filename = u"<string>"
       
  456:         for fixer in chain(self.refactor.pre_order,
  920:                            self.refactor.post_order):
  464:             fixer.log = self.fixer_log
       
    1:     def _check(self, before, after):
 2035:         before = support.reformat(before)
 2035:         after = support.reformat(after)
 2035:         tree = self.refactor.refactor_string(before, self.filename)
 2035:         self.assertEqual(after, unicode(tree))
 2035:         return tree
       
    1:     def check(self, before, after, ignore_warnings=False):
 1588:         tree = self._check(before, after)
 1588:         self.assertTrue(tree.was_changed)
 1588:         if not ignore_warnings:
 1585:             self.assertEqual(self.fixer_log, [])
       
    1:     def warns(self, before, after, message, unchanged=False):
   43:         tree = self._check(before, after)
   43:         self.assertIn(message, "".join(self.fixer_log))
   43:         if not unchanged:
    3:             self.assertTrue(tree.was_changed)
       
    1:     def warns_unchanged(self, before, message):
   40:         self.warns(before, before, message, unchanged=True)
       
    1:     def unchanged(self, before, ignore_warnings=False):
  404:         self._check(before, before)
  404:         if not ignore_warnings:
  393:             self.assertEqual(self.fixer_log, [])
       
    1:     def assert_runs_after(self, *names):
    4:         fixes = [self.fixer]
    4:         fixes.extend(names)
    4:         r = support.get_refactorer("lib2to3", fixes)
    4:         (pre, post) = r.get_fixers()
    4:         n = "fix_" + self.fixer
    4:         if post and post[-1].__class__.__module__.endswith(n):
                   # We're the last fixer to run
    4:             return
>>>>>>         if pre and pre[-1].__class__.__module__.endswith(n) and not post:
                   # We're the last in pre and post is empty
>>>>>>             return
>>>>>>         self.fail("Fixer run order (%s) is incorrect; %s should be last."\
>>>>>>                %(", ".join([x.__class__.__module__ for x in (pre+post)]), n))
       
    2: class Test_ne(FixerTestCase):
    1:     fixer = "ne"
       
    1:     def test_basic(self):
               b = """if x <> y:
    1:             pass"""
       
               a = """if x != y:
    1:             pass"""
    1:         self.check(b, a)
       
    1:     def test_no_spaces(self):
               b = """if x<>y:
    1:             pass"""
       
               a = """if x!=y:
    1:             pass"""
    1:         self.check(b, a)
       
    1:     def test_chained(self):
               b = """if x<>y<>z:
    1:             pass"""
       
               a = """if x!=y!=z:
    1:             pass"""
    1:         self.check(b, a)
       
    2: class Test_has_key(FixerTestCase):
    1:     fixer = "has_key"
       
    1:     def test_1(self):
    1:         b = """x = d.has_key("x") or d.has_key("y")"""
    1:         a = """x = "x" in d or "y" in d"""
    1:         self.check(b, a)
       
    1:     def test_2(self):
    1:         b = """x = a.b.c.d.has_key("x") ** 3"""
    1:         a = """x = ("x" in a.b.c.d) ** 3"""
    1:         self.check(b, a)
       
    1:     def test_3(self):
    1:         b = """x = a.b.has_key(1 + 2).__repr__()"""
    1:         a = """x = (1 + 2 in a.b).__repr__()"""
    1:         self.check(b, a)
       
    1:     def test_4(self):
    1:         b = """x = a.b.has_key(1 + 2).__repr__() ** -3 ** 4"""
    1:         a = """x = (1 + 2 in a.b).__repr__() ** -3 ** 4"""
    1:         self.check(b, a)
       
    1:     def test_5(self):
    1:         b = """x = a.has_key(f or g)"""
    1:         a = """x = (f or g) in a"""
    1:         self.check(b, a)
       
    1:     def test_6(self):
    1:         b = """x = a + b.has_key(c)"""
    1:         a = """x = a + (c in b)"""
    1:         self.check(b, a)
       
    1:     def test_7(self):
    1:         b = """x = a.has_key(lambda: 12)"""
    1:         a = """x = (lambda: 12) in a"""
    1:         self.check(b, a)
       
    1:     def test_8(self):
    1:         b = """x = a.has_key(a for a in b)"""
    1:         a = """x = (a for a in b) in a"""
    1:         self.check(b, a)
       
    1:     def test_9(self):
    1:         b = """if not a.has_key(b): pass"""
    1:         a = """if b not in a: pass"""
    1:         self.check(b, a)
       
    1:     def test_10(self):
    1:         b = """if not a.has_key(b).__repr__(): pass"""
    1:         a = """if not (b in a).__repr__(): pass"""
    1:         self.check(b, a)
       
    1:     def test_11(self):
    1:         b = """if not a.has_key(b) ** 2: pass"""
    1:         a = """if not (b in a) ** 2: pass"""
    1:         self.check(b, a)
       
    2: class Test_apply(FixerTestCase):
    1:     fixer = "apply"
       
    1:     def test_1(self):
    1:         b = """x = apply(f, g + h)"""
    1:         a = """x = f(*g + h)"""
    1:         self.check(b, a)
       
    1:     def test_2(self):
    1:         b = """y = apply(f, g, h)"""
    1:         a = """y = f(*g, **h)"""
    1:         self.check(b, a)
       
    1:     def test_3(self):
    1:         b = """z = apply(fs[0], g or h, h or g)"""
    1:         a = """z = fs[0](*g or h, **h or g)"""
    1:         self.check(b, a)
       
    1:     def test_4(self):
    1:         b = """apply(f, (x, y) + t)"""
    1:         a = """f(*(x, y) + t)"""
    1:         self.check(b, a)
       
    1:     def test_5(self):
    1:         b = """apply(f, args,)"""
    1:         a = """f(*args)"""
    1:         self.check(b, a)
       
    1:     def test_6(self):
    1:         b = """apply(f, args, kwds,)"""
    1:         a = """f(*args, **kwds)"""
    1:         self.check(b, a)
       
           # Test that complex functions are parenthesized
       
    1:     def test_complex_1(self):
    1:         b = """x = apply(f+g, args)"""
    1:         a = """x = (f+g)(*args)"""
    1:         self.check(b, a)
       
    1:     def test_complex_2(self):
    1:         b = """x = apply(f*g, args)"""
    1:         a = """x = (f*g)(*args)"""
    1:         self.check(b, a)
       
    1:     def test_complex_3(self):
    1:         b = """x = apply(f**g, args)"""
    1:         a = """x = (f**g)(*args)"""
    1:         self.check(b, a)
       
           # But dotted names etc. not
       
    1:     def test_dotted_name(self):
    1:         b = """x = apply(f.g, args)"""
    1:         a = """x = f.g(*args)"""
    1:         self.check(b, a)
       
    1:     def test_subscript(self):
    1:         b = """x = apply(f[x], args)"""
    1:         a = """x = f[x](*args)"""
    1:         self.check(b, a)
       
    1:     def test_call(self):
    1:         b = """x = apply(f(), args)"""
    1:         a = """x = f()(*args)"""
    1:         self.check(b, a)
       
           # Extreme case
    1:     def test_extreme(self):
    1:         b = """x = apply(a.b.c.d.e.f, args, kwds)"""
    1:         a = """x = a.b.c.d.e.f(*args, **kwds)"""
    1:         self.check(b, a)
       
           # XXX Comments in weird places still get lost
    1:     def test_weird_comments(self):
               b = """apply(   # foo
                 f, # bar
    1:           args)"""
    1:         a = """f(*args)"""
    1:         self.check(b, a)
       
           # These should *not* be touched
       
    1:     def test_unchanged_1(self):
    1:         s = """apply()"""
    1:         self.unchanged(s)
       
    1:     def test_unchanged_2(self):
    1:         s = """apply(f)"""
    1:         self.unchanged(s)
       
    1:     def test_unchanged_3(self):
    1:         s = """apply(f,)"""
    1:         self.unchanged(s)
       
    1:     def test_unchanged_4(self):
    1:         s = """apply(f, args, kwds, extras)"""
    1:         self.unchanged(s)
       
    1:     def test_unchanged_5(self):
    1:         s = """apply(f, *args, **kwds)"""
    1:         self.unchanged(s)
       
    1:     def test_unchanged_6(self):
    1:         s = """apply(f, *args)"""
    1:         self.unchanged(s)
       
    1:     def test_unchanged_6b(self):
    1:         s = """apply(f, **kwds)"""
    1:         self.unchanged(s)
       
    1:     def test_unchanged_7(self):
    1:         s = """apply(func=f, args=args, kwds=kwds)"""
    1:         self.unchanged(s)
       
    1:     def test_unchanged_8(self):
    1:         s = """apply(f, args=args, kwds=kwds)"""
    1:         self.unchanged(s)
       
    1:     def test_unchanged_9(self):
    1:         s = """apply(f, args, kwds=kwds)"""
    1:         self.unchanged(s)
       
    1:     def test_space_1(self):
    1:         a = """apply(  f,  args,   kwds)"""
    1:         b = """f(*args, **kwds)"""
    1:         self.check(a, b)
       
    1:     def test_space_2(self):
    1:         a = """apply(  f  ,args,kwds   )"""
    1:         b = """f(*args, **kwds)"""
    1:         self.check(a, b)
       
    2: class Test_intern(FixerTestCase):
    1:     fixer = "intern"
       
    1:     def test_prefix_preservation(self):
    1:         b = """x =   intern(  a  )"""
    1:         a = """import sys\nx =   sys.intern(  a  )"""
    1:         self.check(b, a)
       
               b = """y = intern("b" # test
    1:               )"""
               a = """import sys\ny = sys.intern("b" # test
    1:               )"""
    1:         self.check(b, a)
       
    1:         b = """z = intern(a+b+c.d,   )"""
    1:         a = """import sys\nz = sys.intern(a+b+c.d,   )"""
    1:         self.check(b, a)
       
    1:     def test(self):
    1:         b = """x = intern(a)"""
    1:         a = """import sys\nx = sys.intern(a)"""
    1:         self.check(b, a)
       
    1:         b = """z = intern(a+b+c.d,)"""
    1:         a = """import sys\nz = sys.intern(a+b+c.d,)"""
    1:         self.check(b, a)
       
    1:         b = """intern("y%s" % 5).replace("y", "")"""
    1:         a = """import sys\nsys.intern("y%s" % 5).replace("y", "")"""
    1:         self.check(b, a)
       
           # These should not be refactored
       
    1:     def test_unchanged(self):
    1:         s = """intern(a=1)"""
    1:         self.unchanged(s)
       
    1:         s = """intern(f, g)"""
    1:         self.unchanged(s)
       
    1:         s = """intern(*h)"""
    1:         self.unchanged(s)
       
    1:         s = """intern(**i)"""
    1:         self.unchanged(s)
       
    1:         s = """intern()"""
    1:         self.unchanged(s)
       
    2: class Test_reduce(FixerTestCase):
    1:     fixer = "reduce"
       
    1:     def test_simple_call(self):
    1:         b = "reduce(a, b, c)"
    1:         a = "from functools import reduce\nreduce(a, b, c)"
    1:         self.check(b, a)
       
    1:     def test_bug_7253(self):
               # fix_tuple_params was being bad and orphaning nodes in the tree.
    1:         b = "def x(arg): reduce(sum, [])"
    1:         a = "from functools import reduce\ndef x(arg): reduce(sum, [])"
    1:         self.check(b, a)
       
    1:     def test_call_with_lambda(self):
    1:         b = "reduce(lambda x, y: x + y, seq)"
    1:         a = "from functools import reduce\nreduce(lambda x, y: x + y, seq)"
    1:         self.check(b, a)
       
    1:     def test_unchanged(self):
    1:         s = "reduce(a)"
    1:         self.unchanged(s)
       
    1:         s = "reduce(a, b=42)"
    1:         self.unchanged(s)
       
    1:         s = "reduce(a, b, c, d)"
    1:         self.unchanged(s)
       
    1:         s = "reduce(**c)"
    1:         self.unchanged(s)
       
    1:         s = "reduce()"
    1:         self.unchanged(s)
       
    2: class Test_print(FixerTestCase):
    1:     fixer = "print"
       
    1:     def test_prefix_preservation(self):
    1:         b = """print 1,   1+1,   1+1+1"""
    1:         a = """print(1,   1+1,   1+1+1)"""
    1:         self.check(b, a)
       
    1:     def test_idempotency(self):
    1:         s = """print()"""
    1:         self.unchanged(s)
       
    1:         s = """print('')"""
    1:         self.unchanged(s)
       
    1:     def test_idempotency_print_as_function(self):
    1:         self.refactor.driver.grammar = pygram.python_grammar_no_print_statement
    1:         s = """print(1, 1+1, 1+1+1)"""
    1:         self.unchanged(s)
       
    1:         s = """print()"""
    1:         self.unchanged(s)
       
    1:         s = """print('')"""
    1:         self.unchanged(s)
       
    1:     def test_1(self):
    1:         b = """print 1, 1+1, 1+1+1"""
    1:         a = """print(1, 1+1, 1+1+1)"""
    1:         self.check(b, a)
       
    1:     def test_2(self):
    1:         b = """print 1, 2"""
    1:         a = """print(1, 2)"""
    1:         self.check(b, a)
       
    1:     def test_3(self):
    1:         b = """print"""
    1:         a = """print()"""
    1:         self.check(b, a)
       
    1:     def test_4(self):
               # from bug 3000
    1:         b = """print whatever; print"""
    1:         a = """print(whatever); print()"""
    1:         self.check(b, a)
       
    1:     def test_5(self):
    1:         b = """print; print whatever;"""
    1:         a = """print(); print(whatever);"""
    1:         self.check(b, a)
       
    1:     def test_tuple(self):
    1:         b = """print (a, b, c)"""
    1:         a = """print((a, b, c))"""
    1:         self.check(b, a)
       
           # trailing commas
       
    1:     def test_trailing_comma_1(self):
    1:         b = """print 1, 2, 3,"""
    1:         a = """print(1, 2, 3, end=' ')"""
    1:         self.check(b, a)
       
    1:     def test_trailing_comma_2(self):
    1:         b = """print 1, 2,"""
    1:         a = """print(1, 2, end=' ')"""
    1:         self.check(b, a)
       
    1:     def test_trailing_comma_3(self):
    1:         b = """print 1,"""
    1:         a = """print(1, end=' ')"""
    1:         self.check(b, a)
       
           # >> stuff
       
    1:     def test_vargs_without_trailing_comma(self):
    1:         b = """print >>sys.stderr, 1, 2, 3"""
    1:         a = """print(1, 2, 3, file=sys.stderr)"""
    1:         self.check(b, a)
       
    1:     def test_with_trailing_comma(self):
    1:         b = """print >>sys.stderr, 1, 2,"""
    1:         a = """print(1, 2, end=' ', file=sys.stderr)"""
    1:         self.check(b, a)
       
    1:     def test_no_trailing_comma(self):
    1:         b = """print >>sys.stderr, 1+1"""
    1:         a = """print(1+1, file=sys.stderr)"""
    1:         self.check(b, a)
       
    1:     def test_spaces_before_file(self):
    1:         b = """print >>  sys.stderr"""
    1:         a = """print(file=sys.stderr)"""
    1:         self.check(b, a)
       
    1:     def test_with_future_print_function(self):
    1:         s = "from __future__ import print_function\n" \
                   "print('Hai!', end=' ')"
    1:         self.unchanged(s)
       
    1:         b = "print 'Hello, world!'"
    1:         a = "print('Hello, world!')"
    1:         self.check(b, a)
       
       
    2: class Test_exec(FixerTestCase):
    1:     fixer = "exec"
       
    1:     def test_prefix_preservation(self):
    1:         b = """  exec code in ns1,   ns2"""
    1:         a = """  exec(code, ns1,   ns2)"""
    1:         self.check(b, a)
       
    1:     def test_basic(self):
    1:         b = """exec code"""
    1:         a = """exec(code)"""
    1:         self.check(b, a)
       
    1:     def test_with_globals(self):
    1:         b = """exec code in ns"""
    1:         a = """exec(code, ns)"""
    1:         self.check(b, a)
       
    1:     def test_with_globals_locals(self):
    1:         b = """exec code in ns1, ns2"""
    1:         a = """exec(code, ns1, ns2)"""
    1:         self.check(b, a)
       
    1:     def test_complex_1(self):
    1:         b = """exec (a.b()) in ns"""
    1:         a = """exec((a.b()), ns)"""
    1:         self.check(b, a)
       
    1:     def test_complex_2(self):
    1:         b = """exec a.b() + c in ns"""
    1:         a = """exec(a.b() + c, ns)"""
    1:         self.check(b, a)
       
           # These should not be touched
       
    1:     def test_unchanged_1(self):
    1:         s = """exec(code)"""
    1:         self.unchanged(s)
       
    1:     def test_unchanged_2(self):
    1:         s = """exec (code)"""
    1:         self.unchanged(s)
       
    1:     def test_unchanged_3(self):
    1:         s = """exec(code, ns)"""
    1:         self.unchanged(s)
       
    1:     def test_unchanged_4(self):
    1:         s = """exec(code, ns1, ns2)"""
    1:         self.unchanged(s)
       
    2: class Test_repr(FixerTestCase):
    1:     fixer = "repr"
       
    1:     def test_prefix_preservation(self):
    1:         b = """x =   `1 + 2`"""
    1:         a = """x =   repr(1 + 2)"""
    1:         self.check(b, a)
       
    1:     def test_simple_1(self):
    1:         b = """x = `1 + 2`"""
    1:         a = """x = repr(1 + 2)"""
    1:         self.check(b, a)
       
    1:     def test_simple_2(self):
    1:         b = """y = `x`"""
    1:         a = """y = repr(x)"""
    1:         self.check(b, a)
       
    1:     def test_complex(self):
    1:         b = """z = `y`.__repr__()"""
    1:         a = """z = repr(y).__repr__()"""
    1:         self.check(b, a)
       
    1:     def test_tuple(self):
    1:         b = """x = `1, 2, 3`"""
    1:         a = """x = repr((1, 2, 3))"""
    1:         self.check(b, a)
       
    1:     def test_nested(self):
    1:         b = """x = `1 + `2``"""
    1:         a = """x = repr(1 + repr(2))"""
    1:         self.check(b, a)
       
    1:     def test_nested_tuples(self):
    1:         b = """x = `1, 2 + `3, 4``"""
    1:         a = """x = repr((1, 2 + repr((3, 4))))"""
    1:         self.check(b, a)
       
    2: class Test_except(FixerTestCase):
    1:     fixer = "except"
       
    1:     def test_prefix_preservation(self):
               b = """
                   try:
                       pass
                   except (RuntimeError, ImportError),    e:
    1:                 pass"""
               a = """
                   try:
                       pass
                   except (RuntimeError, ImportError) as    e:
    1:                 pass"""
    1:         self.check(b, a)
       
    1:     def test_simple(self):
               b = """
                   try:
                       pass
                   except Foo, e:
    1:                 pass"""
               a = """
                   try:
                       pass
                   except Foo as e:
    1:                 pass"""
    1:         self.check(b, a)
       
    1:     def test_simple_no_space_before_target(self):
               b = """
                   try:
                       pass
                   except Foo,e:
    1:                 pass"""
               a = """
                   try:
                       pass
                   except Foo as e:
    1:                 pass"""
    1:         self.check(b, a)
       
    1:     def test_tuple_unpack(self):
               b = """
                   def foo():
                       try:
                           pass
                       except Exception, (f, e):
                           pass
                       except ImportError, e:
    1:                     pass"""
       
               a = """
                   def foo():
                       try:
                           pass
                       except Exception as xxx_todo_changeme:
                           (f, e) = xxx_todo_changeme.args
                           pass
                       except ImportError as e:
    1:                     pass"""
    1:         self.check(b, a)
       
    1:     def test_multi_class(self):
               b = """
                   try:
                       pass
                   except (RuntimeError, ImportError), e:
    1:                 pass"""
       
               a = """
                   try:
                       pass
                   except (RuntimeError, ImportError) as e:
    1:                 pass"""
    1:         self.check(b, a)
       
    1:     def test_list_unpack(self):
               b = """
                   try:
                       pass
                   except Exception, [a, b]:
    1:                 pass"""
       
               a = """
                   try:
                       pass
                   except Exception as xxx_todo_changeme:
                       [a, b] = xxx_todo_changeme.args
    1:                 pass"""
    1:         self.check(b, a)
       
    1:     def test_weird_target_1(self):
               b = """
                   try:
                       pass
                   except Exception, d[5]:
    1:                 pass"""
       
               a = """
                   try:
                       pass
                   except Exception as xxx_todo_changeme:
                       d[5] = xxx_todo_changeme
    1:                 pass"""
    1:         self.check(b, a)
       
    1:     def test_weird_target_2(self):
               b = """
                   try:
                       pass
                   except Exception, a.foo:
    1:                 pass"""
       
               a = """
                   try:
                       pass
                   except Exception as xxx_todo_changeme:
                       a.foo = xxx_todo_changeme
    1:                 pass"""
    1:         self.check(b, a)
       
    1:     def test_weird_target_3(self):
               b = """
                   try:
                       pass
                   except Exception, a().foo:
    1:                 pass"""
       
               a = """
                   try:
                       pass
                   except Exception as xxx_todo_changeme:
                       a().foo = xxx_todo_changeme
    1:                 pass"""
    1:         self.check(b, a)
       
    1:     def test_bare_except(self):
               b = """
                   try:
                       pass
                   except Exception, a:
                       pass
                   except:
    1:                 pass"""
       
               a = """
                   try:
                       pass
                   except Exception as a:
                       pass
                   except:
    1:                 pass"""
    1:         self.check(b, a)
       
    1:     def test_bare_except_and_else_finally(self):
               b = """
                   try:
                       pass
                   except Exception, a:
                       pass
                   except:
                       pass
                   else:
                       pass
                   finally:
    1:                 pass"""
       
               a = """
                   try:
                       pass
                   except Exception as a:
                       pass
                   except:
                       pass
                   else:
                       pass
                   finally:
    1:                 pass"""
    1:         self.check(b, a)
       
    1:     def test_multi_fixed_excepts_before_bare_except(self):
               b = """
                   try:
                       pass
                   except TypeError, b:
                       pass
                   except Exception, a:
                       pass
                   except:
    1:                 pass"""
       
               a = """
                   try:
                       pass
                   except TypeError as b:
                       pass
                   except Exception as a:
                       pass
                   except:
    1:                 pass"""
    1:         self.check(b, a)
       
    1:     def test_one_line_suites(self):
               b = """
                   try: raise TypeError
                   except TypeError, e:
                       pass
    1:             """
               a = """
                   try: raise TypeError
                   except TypeError as e:
                       pass
    1:             """
    1:         self.check(b, a)
               b = """
                   try:
                       raise TypeError
                   except TypeError, e: pass
    1:             """
               a = """
                   try:
                       raise TypeError
                   except TypeError as e: pass
    1:             """
    1:         self.check(b, a)
               b = """
                   try: raise TypeError
                   except TypeError, e: pass
    1:             """
               a = """
                   try: raise TypeError
                   except TypeError as e: pass
    1:             """
    1:         self.check(b, a)
               b = """
                   try: raise TypeError
                   except TypeError, e: pass
                   else: function()
                   finally: done()
    1:             """
               a = """
                   try: raise TypeError
                   except TypeError as e: pass
                   else: function()
                   finally: done()
    1:             """
    1:         self.check(b, a)
       
           # These should not be touched:
       
    1:     def test_unchanged_1(self):
               s = """
                   try:
                       pass
                   except:
    1:                 pass"""
    1:         self.unchanged(s)
       
    1:     def test_unchanged_2(self):
               s = """
                   try:
                       pass
                   except Exception:
    1:                 pass"""
    1:         self.unchanged(s)
       
    1:     def test_unchanged_3(self):
               s = """
                   try:
                       pass
                   except (Exception, SystemExit):
    1:                 pass"""
    1:         self.unchanged(s)
       
    2: class Test_raise(FixerTestCase):
    1:     fixer = "raise"
       
    1:     def test_basic(self):
    1:         b = """raise Exception, 5"""
    1:         a = """raise Exception(5)"""
    1:         self.check(b, a)
       
    1:     def test_prefix_preservation(self):
    1:         b = """raise Exception,5"""
    1:         a = """raise Exception(5)"""
    1:         self.check(b, a)
       
    1:         b = """raise   Exception,    5"""
    1:         a = """raise   Exception(5)"""
    1:         self.check(b, a)
       
    1:     def test_with_comments(self):
    1:         b = """raise Exception, 5 # foo"""
    1:         a = """raise Exception(5) # foo"""
    1:         self.check(b, a)
       
    1:         b = """raise E, (5, 6) % (a, b) # foo"""
    1:         a = """raise E((5, 6) % (a, b)) # foo"""
    1:         self.check(b, a)
       
               b = """def foo():
    1:                     raise Exception, 5, 6 # foo"""
               a = """def foo():
    1:                     raise Exception(5).with_traceback(6) # foo"""
    1:         self.check(b, a)
       
    1:     def test_None_value(self):
    1:         b = """raise Exception(5), None, tb"""
    1:         a = """raise Exception(5).with_traceback(tb)"""
    1:         self.check(b, a)
       
    1:     def test_tuple_value(self):
    1:         b = """raise Exception, (5, 6, 7)"""
    1:         a = """raise Exception(5, 6, 7)"""
    1:         self.check(b, a)
       
    1:     def test_tuple_detection(self):
    1:         b = """raise E, (5, 6) % (a, b)"""
    1:         a = """raise E((5, 6) % (a, b))"""
    1:         self.check(b, a)
       
    1:     def test_tuple_exc_1(self):
    1:         b = """raise (((E1, E2), E3), E4), V"""
    1:         a = """raise E1(V)"""
    1:         self.check(b, a)
       
    1:     def test_tuple_exc_2(self):
    1:         b = """raise (E1, (E2, E3), E4), V"""
    1:         a = """raise E1(V)"""
    1:         self.check(b, a)
       
           # These should produce a warning
       
    1:     def test_string_exc(self):
    1:         s = """raise 'foo'"""
    1:         self.warns_unchanged(s, "Python 3 does not support string exceptions")
       
    1:     def test_string_exc_val(self):
    1:         s = """raise "foo", 5"""
    1:         self.warns_unchanged(s, "Python 3 does not support string exceptions")
       
    1:     def test_string_exc_val_tb(self):
    1:         s = """raise "foo", 5, 6"""
    1:         self.warns_unchanged(s, "Python 3 does not support string exceptions")
       
           # These should result in traceback-assignment
       
    1:     def test_tb_1(self):
               b = """def foo():
    1:                     raise Exception, 5, 6"""
               a = """def foo():
    1:                     raise Exception(5).with_traceback(6)"""
    1:         self.check(b, a)
       
    1:     def test_tb_2(self):
               b = """def foo():
                           a = 5
                           raise Exception, 5, 6
    1:                     b = 6"""
               a = """def foo():
                           a = 5
                           raise Exception(5).with_traceback(6)
    1:                     b = 6"""
    1:         self.check(b, a)
       
    1:     def test_tb_3(self):
               b = """def foo():
    1:                     raise Exception,5,6"""
               a = """def foo():
    1:                     raise Exception(5).with_traceback(6)"""
    1:         self.check(b, a)
       
    1:     def test_tb_4(self):
               b = """def foo():
                           a = 5
                           raise Exception,5,6
    1:                     b = 6"""
               a = """def foo():
                           a = 5
                           raise Exception(5).with_traceback(6)
    1:                     b = 6"""
    1:         self.check(b, a)
       
    1:     def test_tb_5(self):
               b = """def foo():
    1:                     raise Exception, (5, 6, 7), 6"""
               a = """def foo():
    1:                     raise Exception(5, 6, 7).with_traceback(6)"""
    1:         self.check(b, a)
       
    1:     def test_tb_6(self):
               b = """def foo():
                           a = 5
                           raise Exception, (5, 6, 7), 6
    1:                     b = 6"""
               a = """def foo():
                           a = 5
                           raise Exception(5, 6, 7).with_traceback(6)
    1:                     b = 6"""
    1:         self.check(b, a)
       
    2: class Test_throw(FixerTestCase):
    1:     fixer = "throw"
       
    1:     def test_1(self):
    1:         b = """g.throw(Exception, 5)"""
    1:         a = """g.throw(Exception(5))"""
    1:         self.check(b, a)
       
    1:     def test_2(self):
    1:         b = """g.throw(Exception,5)"""
    1:         a = """g.throw(Exception(5))"""
    1:         self.check(b, a)
       
    1:     def test_3(self):
    1:         b = """g.throw(Exception, (5, 6, 7))"""
    1:         a = """g.throw(Exception(5, 6, 7))"""
    1:         self.check(b, a)
       
    1:     def test_4(self):
    1:         b = """5 + g.throw(Exception, 5)"""
    1:         a = """5 + g.throw(Exception(5))"""
    1:         self.check(b, a)
       
           # These should produce warnings
       
    1:     def test_warn_1(self):
    1:         s = """g.throw("foo")"""
    1:         self.warns_unchanged(s, "Python 3 does not support string exceptions")
       
    1:     def test_warn_2(self):
    1:         s = """g.throw("foo", 5)"""
    1:         self.warns_unchanged(s, "Python 3 does not support string exceptions")
       
    1:     def test_warn_3(self):
    1:         s = """g.throw("foo", 5, 6)"""
    1:         self.warns_unchanged(s, "Python 3 does not support string exceptions")
       
           # These should not be touched
       
    1:     def test_untouched_1(self):
    1:         s = """g.throw(Exception)"""
    1:         self.unchanged(s)
       
    1:     def test_untouched_2(self):
    1:         s = """g.throw(Exception(5, 6))"""
    1:         self.unchanged(s)
       
    1:     def test_untouched_3(self):
    1:         s = """5 + g.throw(Exception(5, 6))"""
    1:         self.unchanged(s)
       
           # These should result in traceback-assignment
       
    1:     def test_tb_1(self):
               b = """def foo():
    1:                     g.throw(Exception, 5, 6)"""
               a = """def foo():
    1:                     g.throw(Exception(5).with_traceback(6))"""
    1:         self.check(b, a)
       
    1:     def test_tb_2(self):
               b = """def foo():
                           a = 5
                           g.throw(Exception, 5, 6)
    1:                     b = 6"""
               a = """def foo():
                           a = 5
                           g.throw(Exception(5).with_traceback(6))
    1:                     b = 6"""
    1:         self.check(b, a)
       
    1:     def test_tb_3(self):
               b = """def foo():
    1:                     g.throw(Exception,5,6)"""
               a = """def foo():
    1:                     g.throw(Exception(5).with_traceback(6))"""
    1:         self.check(b, a)
       
    1:     def test_tb_4(self):
               b = """def foo():
                           a = 5
                           g.throw(Exception,5,6)
    1:                     b = 6"""
               a = """def foo():
                           a = 5
                           g.throw(Exception(5).with_traceback(6))
    1:                     b = 6"""
    1:         self.check(b, a)
       
    1:     def test_tb_5(self):
               b = """def foo():
    1:                     g.throw(Exception, (5, 6, 7), 6)"""
               a = """def foo():
    1:                     g.throw(Exception(5, 6, 7).with_traceback(6))"""
    1:         self.check(b, a)
       
    1:     def test_tb_6(self):
               b = """def foo():
                           a = 5
                           g.throw(Exception, (5, 6, 7), 6)
    1:                     b = 6"""
               a = """def foo():
                           a = 5
                           g.throw(Exception(5, 6, 7).with_traceback(6))
    1:                     b = 6"""
    1:         self.check(b, a)
       
    1:     def test_tb_7(self):
               b = """def foo():
    1:                     a + g.throw(Exception, 5, 6)"""
               a = """def foo():
    1:                     a + g.throw(Exception(5).with_traceback(6))"""
    1:         self.check(b, a)
       
    1:     def test_tb_8(self):
               b = """def foo():
                           a = 5
                           a + g.throw(Exception, 5, 6)
    1:                     b = 6"""
               a = """def foo():
                           a = 5
                           a + g.throw(Exception(5).with_traceback(6))
    1:                     b = 6"""
    1:         self.check(b, a)
       
    2: class Test_long(FixerTestCase):
    1:     fixer = "long"
       
    1:     def test_1(self):
    1:         b = """x = long(x)"""
    1:         a = """x = int(x)"""
    1:         self.check(b, a)
       
    1:     def test_2(self):
    1:         b = """y = isinstance(x, long)"""
    1:         a = """y = isinstance(x, int)"""
    1:         self.check(b, a)
       
    1:     def test_3(self):
    1:         b = """z = type(x) in (int, long)"""
    1:         a = """z = type(x) in (int, int)"""
    1:         self.check(b, a)
       
    1:     def test_unchanged(self):
    1:         s = """long = True"""
    1:         self.unchanged(s)
       
    1:         s = """s.long = True"""
    1:         self.unchanged(s)
       
    1:         s = """def long(): pass"""
    1:         self.unchanged(s)
       
    1:         s = """class long(): pass"""
    1:         self.unchanged(s)
       
    1:         s = """def f(long): pass"""
    1:         self.unchanged(s)
       
    1:         s = """def f(g, long): pass"""
    1:         self.unchanged(s)
       
    1:         s = """def f(x, long=True): pass"""
    1:         self.unchanged(s)
       
    1:     def test_prefix_preservation(self):
    1:         b = """x =   long(  x  )"""
    1:         a = """x =   int(  x  )"""
    1:         self.check(b, a)
       
       
    2: class Test_execfile(FixerTestCase):
    1:     fixer = "execfile"
       
    1:     def test_conversion(self):
    1:         b = """execfile("fn")"""
    1:         a = """exec(compile(open("fn").read(), "fn", 'exec'))"""
    1:         self.check(b, a)
       
    1:         b = """execfile("fn", glob)"""
    1:         a = """exec(compile(open("fn").read(), "fn", 'exec'), glob)"""
    1:         self.check(b, a)
       
    1:         b = """execfile("fn", glob, loc)"""
    1:         a = """exec(compile(open("fn").read(), "fn", 'exec'), glob, loc)"""
    1:         self.check(b, a)
       
    1:         b = """execfile("fn", globals=glob)"""
    1:         a = """exec(compile(open("fn").read(), "fn", 'exec'), globals=glob)"""
    1:         self.check(b, a)
       
    1:         b = """execfile("fn", locals=loc)"""
    1:         a = """exec(compile(open("fn").read(), "fn", 'exec'), locals=loc)"""
    1:         self.check(b, a)
       
    1:         b = """execfile("fn", globals=glob, locals=loc)"""
    1:         a = """exec(compile(open("fn").read(), "fn", 'exec'), globals=glob, locals=loc)"""
    1:         self.check(b, a)
       
    1:     def test_spacing(self):
    1:         b = """execfile( "fn" )"""
    1:         a = """exec(compile(open( "fn" ).read(), "fn", 'exec'))"""
    1:         self.check(b, a)
       
    1:         b = """execfile("fn",  globals = glob)"""
    1:         a = """exec(compile(open("fn").read(), "fn", 'exec'),  globals = glob)"""
    1:         self.check(b, a)
       
       
    2: class Test_isinstance(FixerTestCase):
    1:     fixer = "isinstance"
       
    1:     def test_remove_multiple_items(self):
    1:         b = """isinstance(x, (int, int, int))"""
    1:         a = """isinstance(x, int)"""
    1:         self.check(b, a)
       
    1:         b = """isinstance(x, (int, float, int, int, float))"""
    1:         a = """isinstance(x, (int, float))"""
    1:         self.check(b, a)
       
    1:         b = """isinstance(x, (int, float, int, int, float, str))"""
    1:         a = """isinstance(x, (int, float, str))"""
    1:         self.check(b, a)
       
    1:         b = """isinstance(foo() + bar(), (x(), y(), x(), int, int))"""
    1:         a = """isinstance(foo() + bar(), (x(), y(), x(), int))"""
    1:         self.check(b, a)
       
    1:     def test_prefix_preservation(self):
    1:         b = """if    isinstance(  foo(), (  bar, bar, baz )) : pass"""
    1:         a = """if    isinstance(  foo(), (  bar, baz )) : pass"""
    1:         self.check(b, a)
       
    1:     def test_unchanged(self):
    1:         self.unchanged("isinstance(x, (str, int))")
       
    2: class Test_dict(FixerTestCase):
    1:     fixer = "dict"
       
    1:     def test_prefix_preservation(self):
    1:         b = "if   d. keys  (  )  : pass"
    1:         a = "if   list(d. keys  (  ))  : pass"
    1:         self.check(b, a)
       
    1:         b = "if   d. items  (  )  : pass"
    1:         a = "if   list(d. items  (  ))  : pass"
    1:         self.check(b, a)
       
    1:         b = "if   d. iterkeys  ( )  : pass"
    1:         a = "if   iter(d. keys  ( ))  : pass"
    1:         self.check(b, a)
       
    1:         b = "[i for i in    d.  iterkeys(  )  ]"
    1:         a = "[i for i in    d.  keys(  )  ]"
    1:         self.check(b, a)
       
    1:         b = "if   d. viewkeys  ( )  : pass"
    1:         a = "if   d. keys  ( )  : pass"
    1:         self.check(b, a)
       
    1:         b = "[i for i in    d.  viewkeys(  )  ]"
    1:         a = "[i for i in    d.  keys(  )  ]"
    1:         self.check(b, a)
       
    1:     def test_trailing_comment(self):
    1:         b = "d.keys() # foo"
    1:         a = "list(d.keys()) # foo"
    1:         self.check(b, a)
       
    1:         b = "d.items()  # foo"
    1:         a = "list(d.items())  # foo"
    1:         self.check(b, a)
       
    1:         b = "d.iterkeys()  # foo"
    1:         a = "iter(d.keys())  # foo"
    1:         self.check(b, a)
       
               b = """[i for i in d.iterkeys() # foo
    1:                ]"""
               a = """[i for i in d.keys() # foo
    1:                ]"""
    1:         self.check(b, a)
       
               b = """[i for i in d.iterkeys() # foo
    1:                ]"""
               a = """[i for i in d.keys() # foo
    1:                ]"""
    1:         self.check(b, a)
       
    1:         b = "d.viewitems()  # foo"
    1:         a = "d.items()  # foo"
    1:         self.check(b, a)
       
    1:     def test_unchanged(self):
   11:         for wrapper in fixer_util.consuming_calls:
   10:             s = "s = %s(d.keys())" % wrapper
   10:             self.unchanged(s)
       
   10:             s = "s = %s(d.values())" % wrapper
   10:             self.unchanged(s)
       
   10:             s = "s = %s(d.items())" % wrapper
   10:             self.unchanged(s)
       
    1:     def test_01(self):
    1:         b = "d.keys()"
    1:         a = "list(d.keys())"
    1:         self.check(b, a)
       
    1:         b = "a[0].foo().keys()"
    1:         a = "list(a[0].foo().keys())"
    1:         self.check(b, a)
       
    1:     def test_02(self):
    1:         b = "d.items()"
    1:         a = "list(d.items())"
    1:         self.check(b, a)
       
    1:     def test_03(self):
    1:         b = "d.values()"
    1:         a = "list(d.values())"
    1:         self.check(b, a)
       
    1:     def test_04(self):
    1:         b = "d.iterkeys()"
    1:         a = "iter(d.keys())"
    1:         self.check(b, a)
       
    1:     def test_05(self):
    1:         b = "d.iteritems()"
    1:         a = "iter(d.items())"
    1:         self.check(b, a)
       
    1:     def test_06(self):
    1:         b = "d.itervalues()"
    1:         a = "iter(d.values())"
    1:         self.check(b, a)
       
    1:     def test_07(self):
    1:         s = "list(d.keys())"
    1:         self.unchanged(s)
       
    1:     def test_08(self):
    1:         s = "sorted(d.keys())"
    1:         self.unchanged(s)
       
    1:     def test_09(self):
    1:         b = "iter(d.keys())"
    1:         a = "iter(list(d.keys()))"
    1:         self.check(b, a)
       
    1:     def test_10(self):
    1:         b = "foo(d.keys())"
    1:         a = "foo(list(d.keys()))"
    1:         self.check(b, a)
       
    1:     def test_11(self):
    1:         b = "for i in d.keys(): print i"
    1:         a = "for i in list(d.keys()): print i"
    1:         self.check(b, a)
       
    1:     def test_12(self):
    1:         b = "for i in d.iterkeys(): print i"
    1:         a = "for i in d.keys(): print i"
    1:         self.check(b, a)
       
    1:     def test_13(self):
    1:         b = "[i for i in d.keys()]"
    1:         a = "[i for i in list(d.keys())]"
    1:         self.check(b, a)
       
    1:     def test_14(self):
    1:         b = "[i for i in d.iterkeys()]"
    1:         a = "[i for i in d.keys()]"
    1:         self.check(b, a)
       
    1:     def test_15(self):
    1:         b = "(i for i in d.keys())"
    1:         a = "(i for i in list(d.keys()))"
    1:         self.check(b, a)
       
    1:     def test_16(self):
    1:         b = "(i for i in d.iterkeys())"
    1:         a = "(i for i in d.keys())"
    1:         self.check(b, a)
       
    1:     def test_17(self):
    1:         b = "iter(d.iterkeys())"
    1:         a = "iter(d.keys())"
    1:         self.check(b, a)
       
    1:     def test_18(self):
    1:         b = "list(d.iterkeys())"
    1:         a = "list(d.keys())"
    1:         self.check(b, a)
       
    1:     def test_19(self):
    1:         b = "sorted(d.iterkeys())"
    1:         a = "sorted(d.keys())"
    1:         self.check(b, a)
       
    1:     def test_20(self):
    1:         b = "foo(d.iterkeys())"
    1:         a = "foo(iter(d.keys()))"
    1:         self.check(b, a)
       
    1:     def test_21(self):
    1:         b = "print h.iterkeys().next()"
    1:         a = "print iter(h.keys()).next()"
    1:         self.check(b, a)
       
    1:     def test_22(self):
    1:         b = "print h.keys()[0]"
    1:         a = "print list(h.keys())[0]"
    1:         self.check(b, a)
       
    1:     def test_23(self):
    1:         b = "print list(h.iterkeys().next())"
    1:         a = "print list(iter(h.keys()).next())"
    1:         self.check(b, a)
       
    1:     def test_24(self):
    1:         b = "for x in h.keys()[0]: print x"
    1:         a = "for x in list(h.keys())[0]: print x"
    1:         self.check(b, a)
       
    1:     def test_25(self):
    1:         b = "d.viewkeys()"
    1:         a = "d.keys()"
    1:         self.check(b, a)
       
    1:     def test_26(self):
    1:         b = "d.viewitems()"
    1:         a = "d.items()"
    1:         self.check(b, a)
       
    1:     def test_27(self):
    1:         b = "d.viewvalues()"
    1:         a = "d.values()"
    1:         self.check(b, a)
       
    1:     def test_28(self):
    1:         b = "[i for i in d.viewkeys()]"
    1:         a = "[i for i in d.keys()]"
    1:         self.check(b, a)
       
    1:     def test_29(self):
    1:         b = "(i for i in d.viewkeys())"
    1:         a = "(i for i in d.keys())"
    1:         self.check(b, a)
       
    1:     def test_30(self):
    1:         b = "iter(d.viewkeys())"
    1:         a = "iter(d.keys())"
    1:         self.check(b, a)
       
    1:     def test_31(self):
    1:         b = "list(d.viewkeys())"
    1:         a = "list(d.keys())"
    1:         self.check(b, a)
       
    1:     def test_32(self):
    1:         b = "sorted(d.viewkeys())"
    1:         a = "sorted(d.keys())"
    1:         self.check(b, a)
       
    2: class Test_xrange(FixerTestCase):
    1:     fixer = "xrange"
       
    1:     def test_prefix_preservation(self):
    1:         b = """x =    xrange(  10  )"""
    1:         a = """x =    range(  10  )"""
    1:         self.check(b, a)
       
    1:         b = """x = xrange(  1  ,  10   )"""
    1:         a = """x = range(  1  ,  10   )"""
    1:         self.check(b, a)
       
    1:         b = """x = xrange(  0  ,  10 ,  2 )"""
    1:         a = """x = range(  0  ,  10 ,  2 )"""
    1:         self.check(b, a)
       
    1:     def test_single_arg(self):
    1:         b = """x = xrange(10)"""
    1:         a = """x = range(10)"""
    1:         self.check(b, a)
       
    1:     def test_two_args(self):
    1:         b = """x = xrange(1, 10)"""
    1:         a = """x = range(1, 10)"""
    1:         self.check(b, a)
       
    1:     def test_three_args(self):
    1:         b = """x = xrange(0, 10, 2)"""
    1:         a = """x = range(0, 10, 2)"""
    1:         self.check(b, a)
       
    1:     def test_wrap_in_list(self):
    1:         b = """x = range(10, 3, 9)"""
    1:         a = """x = list(range(10, 3, 9))"""
    1:         self.check(b, a)
       
    1:         b = """x = foo(range(10, 3, 9))"""
    1:         a = """x = foo(list(range(10, 3, 9)))"""
    1:         self.check(b, a)
       
    1:         b = """x = range(10, 3, 9) + [4]"""
    1:         a = """x = list(range(10, 3, 9)) + [4]"""
    1:         self.check(b, a)
       
    1:         b = """x = range(10)[::-1]"""
    1:         a = """x = list(range(10))[::-1]"""
    1:         self.check(b, a)
       
    1:         b = """x = range(10)  [3]"""
    1:         a = """x = list(range(10))  [3]"""
    1:         self.check(b, a)
       
    1:     def test_xrange_in_for(self):
    1:         b = """for i in xrange(10):\n    j=i"""
    1:         a = """for i in range(10):\n    j=i"""
    1:         self.check(b, a)
       
    1:         b = """[i for i in xrange(10)]"""
    1:         a = """[i for i in range(10)]"""
    1:         self.check(b, a)
       
    1:     def test_range_in_for(self):
    1:         self.unchanged("for i in range(10): pass")
    1:         self.unchanged("[i for i in range(10)]")
       
    1:     def test_in_contains_test(self):
    1:         self.unchanged("x in range(10, 3, 9)")
       
    1:     def test_in_consuming_context(self):
   11:         for call in fixer_util.consuming_calls:
   10:             self.unchanged("a = %s(range(10))" % call)
       
    2: class Test_xrange_with_reduce(FixerTestCase):
       
    1:     def setUp(self):
    1:         super(Test_xrange_with_reduce, self).setUp(["xrange", "reduce"])
       
    1:     def test_double_transform(self):
    1:         b = """reduce(x, xrange(5))"""
               a = """from functools import reduce
    1: reduce(x, range(5))"""
    1:         self.check(b, a)
       
    2: class Test_raw_input(FixerTestCase):
    1:     fixer = "raw_input"
       
    1:     def test_prefix_preservation(self):
    1:         b = """x =    raw_input(   )"""
    1:         a = """x =    input(   )"""
    1:         self.check(b, a)
       
    1:         b = """x = raw_input(   ''   )"""
    1:         a = """x = input(   ''   )"""
    1:         self.check(b, a)
       
    1:     def test_1(self):
    1:         b = """x = raw_input()"""
    1:         a = """x = input()"""
    1:         self.check(b, a)
       
    1:     def test_2(self):
    1:         b = """x = raw_input('')"""
    1:         a = """x = input('')"""
    1:         self.check(b, a)
       
    1:     def test_3(self):
    1:         b = """x = raw_input('prompt')"""
    1:         a = """x = input('prompt')"""
    1:         self.check(b, a)
       
    1:     def test_4(self):
    1:         b = """x = raw_input(foo(a) + 6)"""
    1:         a = """x = input(foo(a) + 6)"""
    1:         self.check(b, a)
       
    1:     def test_5(self):
    1:         b = """x = raw_input(invite).split()"""
    1:         a = """x = input(invite).split()"""
    1:         self.check(b, a)
       
    1:     def test_6(self):
    1:         b = """x = raw_input(invite) . split ()"""
    1:         a = """x = input(invite) . split ()"""
    1:         self.check(b, a)
       
    1:     def test_8(self):
    1:         b = "x = int(raw_input())"
    1:         a = "x = int(input())"
    1:         self.check(b, a)
       
    2: class Test_funcattrs(FixerTestCase):
    1:     fixer = "funcattrs"
       
    1:     attrs = ["closure", "doc", "name", "defaults", "code", "globals", "dict"]
       
    1:     def test(self):
    8:         for attr in self.attrs:
    7:             b = "a.func_%s" % attr
    7:             a = "a.__%s__" % attr
    7:             self.check(b, a)
       
    7:             b = "self.foo.func_%s.foo_bar" % attr
    7:             a = "self.foo.__%s__.foo_bar" % attr
    7:             self.check(b, a)
       
    1:     def test_unchanged(self):
    8:         for attr in self.attrs:
    7:             s = "foo(func_%s + 5)" % attr
    7:             self.unchanged(s)
       
    7:             s = "f(foo.__%s__)" % attr
    7:             self.unchanged(s)
       
    7:             s = "f(foo.__%s__.foo)" % attr
    7:             self.unchanged(s)
       
    2: class Test_xreadlines(FixerTestCase):
    1:     fixer = "xreadlines"
       
    1:     def test_call(self):
    1:         b = "for x in f.xreadlines(): pass"
    1:         a = "for x in f: pass"
    1:         self.check(b, a)
       
    1:         b = "for x in foo().xreadlines(): pass"
    1:         a = "for x in foo(): pass"
    1:         self.check(b, a)
       
    1:         b = "for x in (5 + foo()).xreadlines(): pass"
    1:         a = "for x in (5 + foo()): pass"
    1:         self.check(b, a)
       
    1:     def test_attr_ref(self):
    1:         b = "foo(f.xreadlines + 5)"
    1:         a = "foo(f.__iter__ + 5)"
    1:         self.check(b, a)
       
    1:         b = "foo(f().xreadlines + 5)"
    1:         a = "foo(f().__iter__ + 5)"
    1:         self.check(b, a)
       
    1:         b = "foo((5 + f()).xreadlines + 5)"
    1:         a = "foo((5 + f()).__iter__ + 5)"
    1:         self.check(b, a)
       
    1:     def test_unchanged(self):
    1:         s = "for x in f.xreadlines(5): pass"
    1:         self.unchanged(s)
       
    1:         s = "for x in f.xreadlines(k=5): pass"
    1:         self.unchanged(s)
       
    1:         s = "for x in f.xreadlines(*k, **v): pass"
    1:         self.unchanged(s)
       
    1:         s = "foo(xreadlines)"
    1:         self.unchanged(s)
       
       
    2: class ImportsFixerTests:
       
    1:     def test_import_module(self):
   59:         for old, new in self.modules.items():
   56:             b = "import %s" % old
   56:             a = "import %s" % new
   56:             self.check(b, a)
       
   56:             b = "import foo, %s, bar" % old
   56:             a = "import foo, %s, bar" % new
   56:             self.check(b, a)
       
    1:     def test_import_from(self):
   59:         for old, new in self.modules.items():
   56:             b = "from %s import foo" % old
   56:             a = "from %s import foo" % new
   56:             self.check(b, a)
       
   56:             b = "from %s import foo, bar" % old
   56:             a = "from %s import foo, bar" % new
   56:             self.check(b, a)
       
   56:             b = "from %s import (yes, no)" % old
   56:             a = "from %s import (yes, no)" % new
   56:             self.check(b, a)
       
    1:     def test_import_module_as(self):
   59:         for old, new in self.modules.items():
   56:             b = "import %s as foo_bar" % old
   56:             a = "import %s as foo_bar" % new
   56:             self.check(b, a)
       
   56:             b = "import %s as foo_bar" % old
   56:             a = "import %s as foo_bar" % new
   56:             self.check(b, a)
       
    1:     def test_import_from_as(self):
   59:         for old, new in self.modules.items():
   56:             b = "from %s import foo as bar" % old
   56:             a = "from %s import foo as bar" % new
   56:             self.check(b, a)
       
    1:     def test_star(self):
   59:         for old, new in self.modules.items():
   56:             b = "from %s import *" % old
   56:             a = "from %s import *" % new
   56:             self.check(b, a)
       
    1:     def test_import_module_usage(self):
   59:         for old, new in self.modules.items():
                   b = """
                       import %s
                       foo(%s.bar)
   56:                 """ % (old, old)
                   a = """
                       import %s
                       foo(%s.bar)
   56:                 """ % (new, new)
   56:             self.check(b, a)
       
                   b = """
                       from %s import x
                       %s = 23
   56:                 """ % (old, old)
                   a = """
                       from %s import x
                       %s = 23
   56:                 """ % (new, old)
   56:             self.check(b, a)
       
                   s = """
                       def f():
                           %s.method()
   56:                 """ % (old,)
   56:             self.unchanged(s)
       
                   # test nested usage
                   b = """
                       import %s
                       %s.bar(%s.foo)
   56:                 """ % (old, old, old)
                   a = """
                       import %s
                       %s.bar(%s.foo)
   56:                 """ % (new, new, new)
   56:             self.check(b, a)
       
                   b = """
                       import %s
                       x.%s
   56:                 """ % (old, old)
                   a = """
                       import %s
                       x.%s
   56:                 """ % (new, old)
   56:             self.check(b, a)
       
       
    2: class Test_imports(FixerTestCase, ImportsFixerTests):
    1:     fixer = "imports"
    1:     from ..fixes.fix_imports import MAPPING as modules
       
    1:     def test_multiple_imports(self):
    1:         b = """import urlparse, cStringIO"""
    1:         a = """import urllib.parse, io"""
    1:         self.check(b, a)
       
    1:     def test_multiple_imports_as(self):
               b = """
                   import copy_reg as bar, HTMLParser as foo, urlparse
                   s = urlparse.spam(bar.foo())
    1:             """
               a = """
                   import copyreg as bar, html.parser as foo, urllib.parse
                   s = urllib.parse.spam(bar.foo())
    1:             """
    1:         self.check(b, a)
       
       
    2: class Test_imports2(FixerTestCase, ImportsFixerTests):
    1:     fixer = "imports2"
    1:     from ..fixes.fix_imports2 import MAPPING as modules
       
       
    2: class Test_imports_fixer_order(FixerTestCase, ImportsFixerTests):
       
    1:     def setUp(self):
    7:         super(Test_imports_fixer_order, self).setUp(['imports', 'imports2'])
    7:         from ..fixes.fix_imports2 import MAPPING as mapping2
    7:         self.modules = mapping2.copy()
    7:         from ..fixes.fix_imports import MAPPING as mapping1
   35:         for key in ('dbhash', 'dumbdbm', 'dbm', 'gdbm'):
   28:             self.modules[key] = mapping1[key]
       
    1:     def test_after_local_imports_refactoring(self):
    3:         for fix in ("imports", "imports2"):
    2:             self.fixer = fix
    2:             self.assert_runs_after("import")
       
       
    2: class Test_urllib(FixerTestCase):
    1:     fixer = "urllib"
    1:     from ..fixes.fix_urllib import MAPPING as modules
       
    1:     def test_import_module(self):
    3:         for old, changes in self.modules.items():
    2:             b = "import %s" % old
    2:             a = "import %s" % ", ".join(map(itemgetter(0), changes))
    2:             self.check(b, a)
       
    1:     def test_import_from(self):
    3:         for old, changes in self.modules.items():
    2:             all_members = []
    8:             for new, members in changes:
   71:                 for member in members:
   65:                     all_members.append(member)
   65:                     b = "from %s import %s" % (old, member)
   65:                     a = "from %s import %s" % (new, member)
   65:                     self.check(b, a)
       
   65:                     s = "from foo import %s" % member
   65:                     self.unchanged(s)
       
    6:                 b = "from %s import %s" % (old, ", ".join(members))
    6:                 a = "from %s import %s" % (new, ", ".join(members))
    6:                 self.check(b, a)
       
    6:                 s = "from foo import %s" % ", ".join(members)
    6:                 self.unchanged(s)
       
                   # test the breaking of a module into multiple replacements
    2:             b = "from %s import %s" % (old, ", ".join(all_members))
    2:             a = "\n".join(["from %s import %s" % (new, ", ".join(members))
    8:                             for (new, members) in changes])
    2:             self.check(b, a)
       
    1:     def test_import_module_as(self):
    3:         for old in self.modules:
    2:             s = "import %s as foo" % old
    2:             self.warns_unchanged(s, "This module is now multiple modules")
       
    1:     def test_import_from_as(self):
    3:         for old, changes in self.modules.items():
    8:             for new, members in changes:
   71:                 for member in members:
   65:                     b = "from %s import %s as foo_bar" % (old, member)
   65:                     a = "from %s import %s as foo_bar" % (new, member)
   65:                     self.check(b, a)
   65:                     b = "from %s import %s as blah, %s" % (old, member, member)
   65:                     a = "from %s import %s as blah, %s" % (new, member, member)
   65:                     self.check(b, a)
       
    1:     def test_star(self):
    3:         for old in self.modules:
    2:             s = "from %s import *" % old
    2:             self.warns_unchanged(s, "Cannot handle star imports")
       
    1:     def test_indented(self):
               b = """
       def foo():
           from urllib import urlencode, urlopen
    1: """
               a = """
       def foo():
           from urllib.parse import urlencode
           from urllib.request import urlopen
    1: """
    1:         self.check(b, a)
       
               b = """
       def foo():
           other()
           from urllib import urlencode, urlopen
    1: """
               a = """
       def foo():
           other()
           from urllib.parse import urlencode
           from urllib.request import urlopen
    1: """
    1:         self.check(b, a)
       
       
       
    1:     def test_import_module_usage(self):
    3:         for old, changes in self.modules.items():
    8:             for new, members in changes:
   71:                 for member in members:
   65:                     new_import = ", ".join([n for (n, mems)
  260:                                             in self.modules[old]])
                           b = """
                               import %s
                               foo(%s.%s)
   65:                         """ % (old, old, member)
                           a = """
                               import %s
                               foo(%s.%s)
   65:                         """ % (new_import, new, member)
   65:                     self.check(b, a)
                           b = """
                               import %s
                               %s.%s(%s.%s)
   65:                         """ % (old, old, member, old, member)
                           a = """
                               import %s
                               %s.%s(%s.%s)
   65:                         """ % (new_import, new, member, new, member)
   65:                     self.check(b, a)
       
       
    2: class Test_input(FixerTestCase):
    1:     fixer = "input"
       
    1:     def test_prefix_preservation(self):
    1:         b = """x =   input(   )"""
    1:         a = """x =   eval(input(   ))"""
    1:         self.check(b, a)
       
    1:         b = """x = input(   ''   )"""
    1:         a = """x = eval(input(   ''   ))"""
    1:         self.check(b, a)
       
    1:     def test_trailing_comment(self):
    1:         b = """x = input()  #  foo"""
    1:         a = """x = eval(input())  #  foo"""
    1:         self.check(b, a)
       
    1:     def test_idempotency(self):
    1:         s = """x = eval(input())"""
    1:         self.unchanged(s)
       
    1:         s = """x = eval(input(''))"""
    1:         self.unchanged(s)
       
    1:         s = """x = eval(input(foo(5) + 9))"""
    1:         self.unchanged(s)
       
    1:     def test_1(self):
    1:         b = """x = input()"""
    1:         a = """x = eval(input())"""
    1:         self.check(b, a)
       
    1:     def test_2(self):
    1:         b = """x = input('')"""
    1:         a = """x = eval(input(''))"""
    1:         self.check(b, a)
       
    1:     def test_3(self):
    1:         b = """x = input('prompt')"""
    1:         a = """x = eval(input('prompt'))"""
    1:         self.check(b, a)
       
    1:     def test_4(self):
    1:         b = """x = input(foo(5) + 9)"""
    1:         a = """x = eval(input(foo(5) + 9))"""
    1:         self.check(b, a)
       
    2: class Test_tuple_params(FixerTestCase):
    1:     fixer = "tuple_params"
       
    1:     def test_unchanged_1(self):
    1:         s = """def foo(): pass"""
    1:         self.unchanged(s)
       
    1:     def test_unchanged_2(self):
    1:         s = """def foo(a, b, c): pass"""
    1:         self.unchanged(s)
       
    1:     def test_unchanged_3(self):
    1:         s = """def foo(a=3, b=4, c=5): pass"""
    1:         self.unchanged(s)
       
    1:     def test_1(self):
               b = """
                   def foo(((a, b), c)):
    1:                 x = 5"""
       
               a = """
                   def foo(xxx_todo_changeme):
                       ((a, b), c) = xxx_todo_changeme
    1:                 x = 5"""
    1:         self.check(b, a)
       
    1:     def test_2(self):
               b = """
                   def foo(((a, b), c), d):
    1:                 x = 5"""
       
               a = """
                   def foo(xxx_todo_changeme, d):
                       ((a, b), c) = xxx_todo_changeme
    1:                 x = 5"""
    1:         self.check(b, a)
       
    1:     def test_3(self):
               b = """
                   def foo(((a, b), c), d) -> e:
    1:                 x = 5"""
       
               a = """
                   def foo(xxx_todo_changeme, d) -> e:
                       ((a, b), c) = xxx_todo_changeme
    1:                 x = 5"""
    1:         self.check(b, a)
       
    1:     def test_semicolon(self):
               b = """
    1:             def foo(((a, b), c)): x = 5; y = 7"""
       
               a = """
    1:             def foo(xxx_todo_changeme): ((a, b), c) = xxx_todo_changeme; x = 5; y = 7"""
    1:         self.check(b, a)
       
    1:     def test_keywords(self):
               b = """
                   def foo(((a, b), c), d, e=5) -> z:
    1:                 x = 5"""
       
               a = """
                   def foo(xxx_todo_changeme, d, e=5) -> z:
                       ((a, b), c) = xxx_todo_changeme
    1:                 x = 5"""
    1:         self.check(b, a)
       
    1:     def test_varargs(self):
               b = """
                   def foo(((a, b), c), d, *vargs, **kwargs) -> z:
    1:                 x = 5"""
       
               a = """
                   def foo(xxx_todo_changeme, d, *vargs, **kwargs) -> z:
                       ((a, b), c) = xxx_todo_changeme
    1:                 x = 5"""
    1:         self.check(b, a)
       
    1:     def test_multi_1(self):
               b = """
                   def foo(((a, b), c), (d, e, f)) -> z:
    1:                 x = 5"""
       
               a = """
                   def foo(xxx_todo_changeme, xxx_todo_changeme1) -> z:
                       ((a, b), c) = xxx_todo_changeme
                       (d, e, f) = xxx_todo_changeme1
    1:                 x = 5"""
    1:         self.check(b, a)
       
    1:     def test_multi_2(self):
               b = """
                   def foo(x, ((a, b), c), d, (e, f, g), y) -> z:
    1:                 x = 5"""
       
               a = """
                   def foo(x, xxx_todo_changeme, d, xxx_todo_changeme1, y) -> z:
                       ((a, b), c) = xxx_todo_changeme
                       (e, f, g) = xxx_todo_changeme1
    1:                 x = 5"""
    1:         self.check(b, a)
       
    1:     def test_docstring(self):
               b = """
                   def foo(((a, b), c), (d, e, f)) -> z:
                       "foo foo foo foo"
    1:                 x = 5"""
       
               a = """
                   def foo(xxx_todo_changeme, xxx_todo_changeme1) -> z:
                       "foo foo foo foo"
                       ((a, b), c) = xxx_todo_changeme
                       (d, e, f) = xxx_todo_changeme1
    1:                 x = 5"""
    1:         self.check(b, a)
       
    1:     def test_lambda_no_change(self):
    1:         s = """lambda x: x + 5"""
    1:         self.unchanged(s)
       
    1:     def test_lambda_parens_single_arg(self):
    1:         b = """lambda (x): x + 5"""
    1:         a = """lambda x: x + 5"""
    1:         self.check(b, a)
       
    1:         b = """lambda(x): x + 5"""
    1:         a = """lambda x: x + 5"""
    1:         self.check(b, a)
       
    1:         b = """lambda ((((x)))): x + 5"""
    1:         a = """lambda x: x + 5"""
    1:         self.check(b, a)
       
    1:         b = """lambda((((x)))): x + 5"""
    1:         a = """lambda x: x + 5"""
    1:         self.check(b, a)
       
    1:     def test_lambda_simple(self):
    1:         b = """lambda (x, y): x + f(y)"""
    1:         a = """lambda x_y: x_y[0] + f(x_y[1])"""
    1:         self.check(b, a)
       
    1:         b = """lambda(x, y): x + f(y)"""
    1:         a = """lambda x_y: x_y[0] + f(x_y[1])"""
    1:         self.check(b, a)
       
    1:         b = """lambda (((x, y))): x + f(y)"""
    1:         a = """lambda x_y: x_y[0] + f(x_y[1])"""
    1:         self.check(b, a)
       
    1:         b = """lambda(((x, y))): x + f(y)"""
    1:         a = """lambda x_y: x_y[0] + f(x_y[1])"""
    1:         self.check(b, a)
       
    1:     def test_lambda_one_tuple(self):
    1:         b = """lambda (x,): x + f(x)"""
    1:         a = """lambda x1: x1[0] + f(x1[0])"""
    1:         self.check(b, a)
       
    1:         b = """lambda (((x,))): x + f(x)"""
    1:         a = """lambda x1: x1[0] + f(x1[0])"""
    1:         self.check(b, a)
       
    1:     def test_lambda_simple_multi_use(self):
    1:         b = """lambda (x, y): x + x + f(x) + x"""
    1:         a = """lambda x_y: x_y[0] + x_y[0] + f(x_y[0]) + x_y[0]"""
    1:         self.check(b, a)
       
    1:     def test_lambda_simple_reverse(self):
    1:         b = """lambda (x, y): y + x"""
    1:         a = """lambda x_y: x_y[1] + x_y[0]"""
    1:         self.check(b, a)
       
    1:     def test_lambda_nested(self):
    1:         b = """lambda (x, (y, z)): x + y + z"""
    1:         a = """lambda x_y_z: x_y_z[0] + x_y_z[1][0] + x_y_z[1][1]"""
    1:         self.check(b, a)
       
    1:         b = """lambda (((x, (y, z)))): x + y + z"""
    1:         a = """lambda x_y_z: x_y_z[0] + x_y_z[1][0] + x_y_z[1][1]"""
    1:         self.check(b, a)
       
    1:     def test_lambda_nested_multi_use(self):
    1:         b = """lambda (x, (y, z)): x + y + f(y)"""
    1:         a = """lambda x_y_z: x_y_z[0] + x_y_z[1][0] + f(x_y_z[1][0])"""
    1:         self.check(b, a)
       
    2: class Test_methodattrs(FixerTestCase):
    1:     fixer = "methodattrs"
       
    1:     attrs = ["func", "self", "class"]
       
    1:     def test(self):
    4:         for attr in self.attrs:
    3:             b = "a.im_%s" % attr
    3:             if attr == "class":
    1:                 a = "a.__self__.__class__"
                   else:
    2:                 a = "a.__%s__" % attr
    3:             self.check(b, a)
       
    3:             b = "self.foo.im_%s.foo_bar" % attr
    3:             if attr == "class":
    1:                 a = "self.foo.__self__.__class__.foo_bar"
                   else:
    2:                 a = "self.foo.__%s__.foo_bar" % attr
    3:             self.check(b, a)
       
    1:     def test_unchanged(self):
    4:         for attr in self.attrs:
    3:             s = "foo(im_%s + 5)" % attr
    3:             self.unchanged(s)
       
    3:             s = "f(foo.__%s__)" % attr
    3:             self.unchanged(s)
       
    3:             s = "f(foo.__%s__.foo)" % attr
    3:             self.unchanged(s)
       
    2: class Test_next(FixerTestCase):
    1:     fixer = "next"
       
    1:     def test_1(self):
    1:         b = """it.next()"""
    1:         a = """next(it)"""
    1:         self.check(b, a)
       
    1:     def test_2(self):
    1:         b = """a.b.c.d.next()"""
    1:         a = """next(a.b.c.d)"""
    1:         self.check(b, a)
       
    1:     def test_3(self):
    1:         b = """(a + b).next()"""
    1:         a = """next((a + b))"""
    1:         self.check(b, a)
       
    1:     def test_4(self):
    1:         b = """a().next()"""
    1:         a = """next(a())"""
    1:         self.check(b, a)
       
    1:     def test_5(self):
    1:         b = """a().next() + b"""
    1:         a = """next(a()) + b"""
    1:         self.check(b, a)
       
    1:     def test_6(self):
    1:         b = """c(      a().next() + b)"""
    1:         a = """c(      next(a()) + b)"""
    1:         self.check(b, a)
       
    1:     def test_prefix_preservation_1(self):
               b = """
                   for a in b:
                       foo(a)
                       a.next()
    1:             """
               a = """
                   for a in b:
                       foo(a)
                       next(a)
    1:             """
    1:         self.check(b, a)
       
    1:     def test_prefix_preservation_2(self):
               b = """
                   for a in b:
                       foo(a) # abc
                       # def
                       a.next()
    1:             """
               a = """
                   for a in b:
                       foo(a) # abc
                       # def
                       next(a)
    1:             """
    1:         self.check(b, a)
       
    1:     def test_prefix_preservation_3(self):
               b = """
                   next = 5
                   for a in b:
                       foo(a)
                       a.next()
    1:             """
               a = """
                   next = 5
                   for a in b:
                       foo(a)
                       a.__next__()
    1:             """
    1:         self.check(b, a, ignore_warnings=True)
       
    1:     def test_prefix_preservation_4(self):
               b = """
                   next = 5
                   for a in b:
                       foo(a) # abc
                       # def
                       a.next()
    1:             """
               a = """
                   next = 5
                   for a in b:
                       foo(a) # abc
                       # def
                       a.__next__()
    1:             """
    1:         self.check(b, a, ignore_warnings=True)
       
    1:     def test_prefix_preservation_5(self):
               b = """
                   next = 5
                   for a in b:
                       foo(foo(a), # abc
                           a.next())
    1:             """
               a = """
                   next = 5
                   for a in b:
                       foo(foo(a), # abc
                           a.__next__())
    1:             """
    1:         self.check(b, a, ignore_warnings=True)
       
    1:     def test_prefix_preservation_6(self):
               b = """
                   for a in b:
                       foo(foo(a), # abc
                           a.next())
    1:             """
               a = """
                   for a in b:
                       foo(foo(a), # abc
                           next(a))
    1:             """
    1:         self.check(b, a)
       
    1:     def test_method_1(self):
               b = """
                   class A:
                       def next(self):
                           pass
    1:             """
               a = """
                   class A:
                       def __next__(self):
                           pass
    1:             """
    1:         self.check(b, a)
       
    1:     def test_method_2(self):
               b = """
                   class A(object):
                       def next(self):
                           pass
    1:             """
               a = """
                   class A(object):
                       def __next__(self):
                           pass
    1:             """
    1:         self.check(b, a)
       
    1:     def test_method_3(self):
               b = """
                   class A:
                       def next(x):
                           pass
    1:             """
               a = """
                   class A:
                       def __next__(x):
                           pass
    1:             """
    1:         self.check(b, a)
       
    1:     def test_method_4(self):
               b = """
                   class A:
                       def __init__(self, foo):
                           self.foo = foo
       
                       def next(self):
                           pass
       
                       def __iter__(self):
                           return self
    1:             """
               a = """
                   class A:
                       def __init__(self, foo):
                           self.foo = foo
       
                       def __next__(self):
                           pass
       
                       def __iter__(self):
                           return self
    1:             """
    1:         self.check(b, a)
       
    1:     def test_method_unchanged(self):
               s = """
                   class A:
                       def next(self, a, b):
                           pass
    1:             """
    1:         self.unchanged(s)
       
    1:     def test_shadowing_assign_simple(self):
               s = """
                   next = foo
       
                   class A:
                       def next(self, a, b):
                           pass
    1:             """
    1:         self.warns_unchanged(s, "Calls to builtin next() possibly shadowed")
       
    1:     def test_shadowing_assign_tuple_1(self):
               s = """
                   (next, a) = foo
       
                   class A:
                       def next(self, a, b):
                           pass
    1:             """
    1:         self.warns_unchanged(s, "Calls to builtin next() possibly shadowed")
       
    1:     def test_shadowing_assign_tuple_2(self):
               s = """
                   (a, (b, (next, c)), a) = foo
       
                   class A:
                       def next(self, a, b):
                           pass
    1:             """
    1:         self.warns_unchanged(s, "Calls to builtin next() possibly shadowed")
       
    1:     def test_shadowing_assign_list_1(self):
               s = """
                   [next, a] = foo
       
                   class A:
                       def next(self, a, b):
                           pass
    1:             """
    1:         self.warns_unchanged(s, "Calls to builtin next() possibly shadowed")
       
    1:     def test_shadowing_assign_list_2(self):
               s = """
                   [a, [b, [next, c]], a] = foo
       
                   class A:
                       def next(self, a, b):
                           pass
    1:             """
    1:         self.warns_unchanged(s, "Calls to builtin next() possibly shadowed")
       
    1:     def test_builtin_assign(self):
               s = """
                   def foo():
                       __builtin__.next = foo
       
                   class A:
                       def next(self, a, b):
                           pass
    1:             """
    1:         self.warns_unchanged(s, "Calls to builtin next() possibly shadowed")
       
    1:     def test_builtin_assign_in_tuple(self):
               s = """
                   def foo():
                       (a, __builtin__.next) = foo
       
                   class A:
                       def next(self, a, b):
                           pass
    1:             """
    1:         self.warns_unchanged(s, "Calls to builtin next() possibly shadowed")
       
    1:     def test_builtin_assign_in_list(self):
               s = """
                   def foo():
                       [a, __builtin__.next] = foo
       
                   class A:
                       def next(self, a, b):
                           pass
    1:             """
    1:         self.warns_unchanged(s, "Calls to builtin next() possibly shadowed")
       
    1:     def test_assign_to_next(self):
               s = """
                   def foo():
                       A.next = foo
       
                   class A:
                       def next(self, a, b):
                           pass
    1:             """
    1:         self.unchanged(s)
       
    1:     def test_assign_to_next_in_tuple(self):
               s = """
                   def foo():
                       (a, A.next) = foo
       
                   class A:
                       def next(self, a, b):
                           pass
    1:             """
    1:         self.unchanged(s)
       
    1:     def test_assign_to_next_in_list(self):
               s = """
                   def foo():
                       [a, A.next] = foo
       
                   class A:
                       def next(self, a, b):
                           pass
    1:             """
    1:         self.unchanged(s)
       
    1:     def test_shadowing_import_1(self):
               s = """
                   import foo.bar as next
       
                   class A:
                       def next(self, a, b):
                           pass
    1:             """
    1:         self.warns_unchanged(s, "Calls to builtin next() possibly shadowed")
       
    1:     def test_shadowing_import_2(self):
               s = """
                   import bar, bar.foo as next
       
                   class A:
                       def next(self, a, b):
                           pass
    1:             """
    1:         self.warns_unchanged(s, "Calls to builtin next() possibly shadowed")
       
    1:     def test_shadowing_import_3(self):
               s = """
                   import bar, bar.foo as next, baz
       
                   class A:
                       def next(self, a, b):
                           pass
    1:             """
    1:         self.warns_unchanged(s, "Calls to builtin next() possibly shadowed")
       
    1:     def test_shadowing_import_from_1(self):
               s = """
                   from x import next
       
                   class A:
                       def next(self, a, b):
                           pass
    1:             """
    1:         self.warns_unchanged(s, "Calls to builtin next() possibly shadowed")
       
    1:     def test_shadowing_import_from_2(self):
               s = """
                   from x.a import next
       
                   class A:
                       def next(self, a, b):
                           pass
    1:             """
    1:         self.warns_unchanged(s, "Calls to builtin next() possibly shadowed")
       
    1:     def test_shadowing_import_from_3(self):
               s = """
                   from x import a, next, b
       
                   class A:
                       def next(self, a, b):
                           pass
    1:             """
    1:         self.warns_unchanged(s, "Calls to builtin next() possibly shadowed")
       
    1:     def test_shadowing_import_from_4(self):
               s = """
                   from x.a import a, next, b
       
                   class A:
                       def next(self, a, b):
                           pass
    1:             """
    1:         self.warns_unchanged(s, "Calls to builtin next() possibly shadowed")
       
    1:     def test_shadowing_funcdef_1(self):
               s = """
                   def next(a):
                       pass
       
                   class A:
                       def next(self, a, b):
                           pass
    1:             """
    1:         self.warns_unchanged(s, "Calls to builtin next() possibly shadowed")
       
    1:     def test_shadowing_funcdef_2(self):
               b = """
                   def next(a):
                       pass
       
                   class A:
                       def next(self):
                           pass
       
                   it.next()
    1:             """
               a = """
                   def next(a):
                       pass
       
                   class A:
                       def __next__(self):
                           pass
       
                   it.__next__()
    1:             """
    1:         self.warns(b, a, "Calls to builtin next() possibly shadowed")
       
    1:     def test_shadowing_global_1(self):
               s = """
                   def f():
                       global next
                       next = 5
    1:             """
    1:         self.warns_unchanged(s, "Calls to builtin next() possibly shadowed")
       
    1:     def test_shadowing_global_2(self):
               s = """
                   def f():
                       global a, next, b
                       next = 5
    1:             """
    1:         self.warns_unchanged(s, "Calls to builtin next() possibly shadowed")
       
    1:     def test_shadowing_for_simple(self):
               s = """
                   for next in it():
                       pass
       
                   b = 5
                   c = 6
    1:             """
    1:         self.warns_unchanged(s, "Calls to builtin next() possibly shadowed")
       
    1:     def test_shadowing_for_tuple_1(self):
               s = """
                   for next, b in it():
                       pass
       
                   b = 5
                   c = 6
    1:             """
    1:         self.warns_unchanged(s, "Calls to builtin next() possibly shadowed")
       
    1:     def test_shadowing_for_tuple_2(self):
               s = """
                   for a, (next, c), b in it():
                       pass
       
                   b = 5
                   c = 6
    1:             """
    1:         self.warns_unchanged(s, "Calls to builtin next() possibly shadowed")
       
    1:     def test_noncall_access_1(self):
    1:         b = """gnext = g.next"""
    1:         a = """gnext = g.__next__"""
    1:         self.check(b, a)
       
    1:     def test_noncall_access_2(self):
    1:         b = """f(g.next + 5)"""
    1:         a = """f(g.__next__ + 5)"""
    1:         self.check(b, a)
       
    1:     def test_noncall_access_3(self):
    1:         b = """f(g().next + 5)"""
    1:         a = """f(g().__next__ + 5)"""
    1:         self.check(b, a)
       
    2: class Test_nonzero(FixerTestCase):
    1:     fixer = "nonzero"
       
    1:     def test_1(self):
               b = """
                   class A:
                       def __nonzero__(self):
                           pass
    1:             """
               a = """
                   class A:
                       def __bool__(self):
                           pass
    1:             """
    1:         self.check(b, a)
       
    1:     def test_2(self):
               b = """
                   class A(object):
                       def __nonzero__(self):
                           pass
    1:             """
               a = """
                   class A(object):
                       def __bool__(self):
                           pass
    1:             """
    1:         self.check(b, a)
       
    1:     def test_unchanged_1(self):
               s = """
                   class A(object):
                       def __bool__(self):
                           pass
    1:             """
    1:         self.unchanged(s)
       
    1:     def test_unchanged_2(self):
               s = """
                   class A(object):
                       def __nonzero__(self, a):
                           pass
    1:             """
    1:         self.unchanged(s)
       
    1:     def test_unchanged_func(self):
               s = """
                   def __nonzero__(self):
                       pass
    1:             """
    1:         self.unchanged(s)
       
    2: class Test_numliterals(FixerTestCase):
    1:     fixer = "numliterals"
       
    1:     def test_octal_1(self):
    1:         b = """0755"""
    1:         a = """0o755"""
    1:         self.check(b, a)
       
    1:     def test_long_int_1(self):
    1:         b = """a = 12L"""
    1:         a = """a = 12"""
    1:         self.check(b, a)
       
    1:     def test_long_int_2(self):
    1:         b = """a = 12l"""
    1:         a = """a = 12"""
    1:         self.check(b, a)
       
    1:     def test_long_hex(self):
    1:         b = """b = 0x12l"""
    1:         a = """b = 0x12"""
    1:         self.check(b, a)
       
    1:     def test_comments_and_spacing(self):
    1:         b = """b =   0x12L"""
    1:         a = """b =   0x12"""
    1:         self.check(b, a)
       
    1:         b = """b = 0755 # spam"""
    1:         a = """b = 0o755 # spam"""
    1:         self.check(b, a)
       
    1:     def test_unchanged_int(self):
    1:         s = """5"""
    1:         self.unchanged(s)
       
    1:     def test_unchanged_float(self):
    1:         s = """5.0"""
    1:         self.unchanged(s)
       
    1:     def test_unchanged_octal(self):
    1:         s = """0o755"""
    1:         self.unchanged(s)
       
    1:     def test_unchanged_hex(self):
    1:         s = """0xABC"""
    1:         self.unchanged(s)
       
    1:     def test_unchanged_exp(self):
    1:         s = """5.0e10"""
    1:         self.unchanged(s)
       
    1:     def test_unchanged_complex_int(self):
    1:         s = """5 + 4j"""
    1:         self.unchanged(s)
       
    1:     def test_unchanged_complex_float(self):
    1:         s = """5.4 + 4.9j"""
    1:         self.unchanged(s)
       
    1:     def test_unchanged_complex_bare(self):
    1:         s = """4j"""
    1:         self.unchanged(s)
    1:         s = """4.4j"""
    1:         self.unchanged(s)
       
    2: class Test_renames(FixerTestCase):
    1:     fixer = "renames"
       
    1:     modules = {"sys":  ("maxint", "maxsize"),
                     }
       
    1:     def test_import_from(self):
    2:         for mod, (old, new) in self.modules.items():
    1:             b = "from %s import %s" % (mod, old)
    1:             a = "from %s import %s" % (mod, new)
    1:             self.check(b, a)
       
    1:             s = "from foo import %s" % old
    1:             self.unchanged(s)
       
    1:     def test_import_from_as(self):
    2:         for mod, (old, new) in self.modules.items():
    1:             b = "from %s import %s as foo_bar" % (mod, old)
    1:             a = "from %s import %s as foo_bar" % (mod, new)
    1:             self.check(b, a)
       
    1:     def test_import_module_usage(self):
    2:         for mod, (old, new) in self.modules.items():
                   b = """
                       import %s
                       foo(%s, %s.%s)
    1:                 """ % (mod, mod, mod, old)
                   a = """
                       import %s
                       foo(%s, %s.%s)
    1:                 """ % (mod, mod, mod, new)
    1:             self.check(b, a)
       
    1:     def XXX_test_from_import_usage(self):
               # not implemented yet
>>>>>>         for mod, (old, new) in self.modules.items():
                   b = """
                       from %s import %s
                       foo(%s, %s)
>>>>>>                 """ % (mod, old, mod, old)
                   a = """
                       from %s import %s
                       foo(%s, %s)
>>>>>>                 """ % (mod, new, mod, new)
>>>>>>             self.check(b, a)
       
    2: class Test_unicode(FixerTestCase):
    1:     fixer = "unicode"
       
    1:     def test_whitespace(self):
    1:         b = """unicode( x)"""
    1:         a = """str( x)"""
    1:         self.check(b, a)
       
    1:         b = """ unicode(x )"""
    1:         a = """ str(x )"""
    1:         self.check(b, a)
       
    1:         b = """ u'h'"""
    1:         a = """ 'h'"""
    1:         self.check(b, a)
       
    1:     def test_unicode_call(self):
    1:         b = """unicode(x, y, z)"""
    1:         a = """str(x, y, z)"""
    1:         self.check(b, a)
       
    1:     def test_unichr(self):
    1:         b = """unichr(u'h')"""
    1:         a = """chr('h')"""
    1:         self.check(b, a)
       
    1:     def test_unicode_literal_1(self):
    1:         b = '''u"x"'''
    1:         a = '''"x"'''
    1:         self.check(b, a)
       
    1:     def test_unicode_literal_2(self):
    1:         b = """ur'x'"""
    1:         a = """r'x'"""
    1:         self.check(b, a)
       
    1:     def test_unicode_literal_3(self):
    1:         b = """UR'''x''' """
    1:         a = """R'''x''' """
    1:         self.check(b, a)
       
    1:     def test_native_literal_escape_u(self):
    1:         b = """'\\\\\\u20ac\\U0001d121\\\\u20ac'"""
    1:         a = """'\\\\\\\\u20ac\\\\U0001d121\\\\u20ac'"""
    1:         self.check(b, a)
       
    1:         b = """r'\\\\\\u20ac\\U0001d121\\\\u20ac'"""
    1:         a = """r'\\\\\\u20ac\\U0001d121\\\\u20ac'"""
    1:         self.check(b, a)
       
    1:     def test_bytes_literal_escape_u(self):
    1:         b = """b'\\\\\\u20ac\\U0001d121\\\\u20ac'"""
    1:         a = """b'\\\\\\u20ac\\U0001d121\\\\u20ac'"""
    1:         self.check(b, a)
       
    1:         b = """br'\\\\\\u20ac\\U0001d121\\\\u20ac'"""
    1:         a = """br'\\\\\\u20ac\\U0001d121\\\\u20ac'"""
    1:         self.check(b, a)
       
    1:     def test_unicode_literal_escape_u(self):
    1:         b = """u'\\\\\\u20ac\\U0001d121\\\\u20ac'"""
    1:         a = """'\\\\\\u20ac\\U0001d121\\\\u20ac'"""
    1:         self.check(b, a)
       
    1:         b = """ur'\\\\\\u20ac\\U0001d121\\\\u20ac'"""
    1:         a = """r'\\\\\\u20ac\\U0001d121\\\\u20ac'"""
    1:         self.check(b, a)
       
    1:     def test_native_unicode_literal_escape_u(self):
    1:         f = 'from __future__ import unicode_literals\n'
    1:         b = f + """'\\\\\\u20ac\\U0001d121\\\\u20ac'"""
    1:         a = f + """'\\\\\\u20ac\\U0001d121\\\\u20ac'"""
    1:         self.check(b, a)
       
    1:         b = f + """r'\\\\\\u20ac\\U0001d121\\\\u20ac'"""
    1:         a = f + """r'\\\\\\u20ac\\U0001d121\\\\u20ac'"""
    1:         self.check(b, a)
       
       
    2: class Test_filter(FixerTestCase):
    1:     fixer = "filter"
       
    1:     def test_prefix_preservation(self):
    1:         b = """x =   filter(    foo,     'abc'   )"""
    1:         a = """x =   list(filter(    foo,     'abc'   ))"""
    1:         self.check(b, a)
       
    1:         b = """x =   filter(  None , 'abc'  )"""
    1:         a = """x =   [_f for _f in 'abc' if _f]"""
    1:         self.check(b, a)
       
    1:     def test_filter_basic(self):
    1:         b = """x = filter(None, 'abc')"""
    1:         a = """x = [_f for _f in 'abc' if _f]"""
    1:         self.check(b, a)
       
    1:         b = """x = len(filter(f, 'abc'))"""
    1:         a = """x = len(list(filter(f, 'abc')))"""
    1:         self.check(b, a)
       
    1:         b = """x = filter(lambda x: x%2 == 0, range(10))"""
    1:         a = """x = [x for x in range(10) if x%2 == 0]"""
    1:         self.check(b, a)
       
               # Note the parens around x
    1:         b = """x = filter(lambda (x): x%2 == 0, range(10))"""
    1:         a = """x = [x for x in range(10) if x%2 == 0]"""
    1:         self.check(b, a)
       
               # XXX This (rare) case is not supported
       ##         b = """x = filter(f, 'abc')[0]"""
       ##         a = """x = list(filter(f, 'abc'))[0]"""
       ##         self.check(b, a)
       
    1:     def test_filter_nochange(self):
    1:         a = """b.join(filter(f, 'abc'))"""
    1:         self.unchanged(a)
    1:         a = """(a + foo(5)).join(filter(f, 'abc'))"""
    1:         self.unchanged(a)
    1:         a = """iter(filter(f, 'abc'))"""
    1:         self.unchanged(a)
    1:         a = """list(filter(f, 'abc'))"""
    1:         self.unchanged(a)
    1:         a = """list(filter(f, 'abc'))[0]"""
    1:         self.unchanged(a)
    1:         a = """set(filter(f, 'abc'))"""
    1:         self.unchanged(a)
    1:         a = """set(filter(f, 'abc')).pop()"""
    1:         self.unchanged(a)
    1:         a = """tuple(filter(f, 'abc'))"""
    1:         self.unchanged(a)
    1:         a = """any(filter(f, 'abc'))"""
    1:         self.unchanged(a)
    1:         a = """all(filter(f, 'abc'))"""
    1:         self.unchanged(a)
    1:         a = """sum(filter(f, 'abc'))"""
    1:         self.unchanged(a)
    1:         a = """sorted(filter(f, 'abc'))"""
    1:         self.unchanged(a)
    1:         a = """sorted(filter(f, 'abc'), key=blah)"""
    1:         self.unchanged(a)
    1:         a = """sorted(filter(f, 'abc'), key=blah)[0]"""
    1:         self.unchanged(a)
    1:         a = """enumerate(filter(f, 'abc'))"""
    1:         self.unchanged(a)
    1:         a = """enumerate(filter(f, 'abc'), start=1)"""
    1:         self.unchanged(a)
    1:         a = """for i in filter(f, 'abc'): pass"""
    1:         self.unchanged(a)
    1:         a = """[x for x in filter(f, 'abc')]"""
    1:         self.unchanged(a)
    1:         a = """(x for x in filter(f, 'abc'))"""
    1:         self.unchanged(a)
       
    1:     def test_future_builtins(self):
    1:         a = "from future_builtins import spam, filter; filter(f, 'ham')"
    1:         self.unchanged(a)
       
    1:         b = """from future_builtins import spam; x = filter(f, 'abc')"""
    1:         a = """from future_builtins import spam; x = list(filter(f, 'abc'))"""
    1:         self.check(b, a)
       
    1:         a = "from future_builtins import *; filter(f, 'ham')"
    1:         self.unchanged(a)
       
    2: class Test_map(FixerTestCase):
    1:     fixer = "map"
       
    1:     def check(self, b, a):
    8:         self.unchanged("from future_builtins import map; " + b, a)
    8:         super(Test_map, self).check(b, a)
       
    1:     def test_prefix_preservation(self):
    1:         b = """x =    map(   f,    'abc'   )"""
    1:         a = """x =    list(map(   f,    'abc'   ))"""
    1:         self.check(b, a)
       
    1:     def test_trailing_comment(self):
    1:         b = """x = map(f, 'abc')   #   foo"""
    1:         a = """x = list(map(f, 'abc'))   #   foo"""
    1:         self.check(b, a)
       
    1:     def test_None_with_multiple_arguments(self):
    1:         s = """x = map(None, a, b, c)"""
    1:         self.warns_unchanged(s, "cannot convert map(None, ...) with "
                                    "multiple arguments")
       
    1:     def test_map_basic(self):
    1:         b = """x = map(f, 'abc')"""
    1:         a = """x = list(map(f, 'abc'))"""
    1:         self.check(b, a)
       
    1:         b = """x = len(map(f, 'abc', 'def'))"""
    1:         a = """x = len(list(map(f, 'abc', 'def')))"""
    1:         self.check(b, a)
       
    1:         b = """x = map(None, 'abc')"""
    1:         a = """x = list('abc')"""
    1:         self.check(b, a)
       
    1:         b = """x = map(lambda x: x+1, range(4))"""
    1:         a = """x = [x+1 for x in range(4)]"""
    1:         self.check(b, a)
       
               # Note the parens around x
    1:         b = """x = map(lambda (x): x+1, range(4))"""
    1:         a = """x = [x+1 for x in range(4)]"""
    1:         self.check(b, a)
       
               b = """
                   foo()
                   # foo
                   map(f, x)
    1:             """
               a = """
                   foo()
                   # foo
                   list(map(f, x))
    1:             """
    1:         self.warns(b, a, "You should use a for loop here")
       
               # XXX This (rare) case is not supported
       ##         b = """x = map(f, 'abc')[0]"""
       ##         a = """x = list(map(f, 'abc'))[0]"""
       ##         self.check(b, a)
       
    1:     def test_map_nochange(self):
    1:         a = """b.join(map(f, 'abc'))"""
    1:         self.unchanged(a)
    1:         a = """(a + foo(5)).join(map(f, 'abc'))"""
    1:         self.unchanged(a)
    1:         a = """iter(map(f, 'abc'))"""
    1:         self.unchanged(a)
    1:         a = """list(map(f, 'abc'))"""
    1:         self.unchanged(a)
    1:         a = """list(map(f, 'abc'))[0]"""
    1:         self.unchanged(a)
    1:         a = """set(map(f, 'abc'))"""
    1:         self.unchanged(a)
    1:         a = """set(map(f, 'abc')).pop()"""
    1:         self.unchanged(a)
    1:         a = """tuple(map(f, 'abc'))"""
    1:         self.unchanged(a)
    1:         a = """any(map(f, 'abc'))"""
    1:         self.unchanged(a)
    1:         a = """all(map(f, 'abc'))"""
    1:         self.unchanged(a)
    1:         a = """sum(map(f, 'abc'))"""
    1:         self.unchanged(a)
    1:         a = """sorted(map(f, 'abc'))"""
    1:         self.unchanged(a)
    1:         a = """sorted(map(f, 'abc'), key=blah)"""
    1:         self.unchanged(a)
    1:         a = """sorted(map(f, 'abc'), key=blah)[0]"""
    1:         self.unchanged(a)
    1:         a = """enumerate(map(f, 'abc'))"""
    1:         self.unchanged(a)
    1:         a = """enumerate(map(f, 'abc'), start=1)"""
    1:         self.unchanged(a)
    1:         a = """for i in map(f, 'abc'): pass"""
    1:         self.unchanged(a)
    1:         a = """[x for x in map(f, 'abc')]"""
    1:         self.unchanged(a)
    1:         a = """(x for x in map(f, 'abc'))"""
    1:         self.unchanged(a)
       
    1:     def test_future_builtins(self):
    1:         a = "from future_builtins import spam, map, eggs; map(f, 'ham')"
    1:         self.unchanged(a)
       
    1:         b = """from future_builtins import spam, eggs; x = map(f, 'abc')"""
    1:         a = """from future_builtins import spam, eggs; x = list(map(f, 'abc'))"""
    1:         self.check(b, a)
       
    1:         a = "from future_builtins import *; map(f, 'ham')"
    1:         self.unchanged(a)
       
    2: class Test_zip(FixerTestCase):
    1:     fixer = "zip"
       
    1:     def check(self, b, a):
    3:         self.unchanged("from future_builtins import zip; " + b, a)
    3:         super(Test_zip, self).check(b, a)
       
    1:     def test_zip_basic(self):
    1:         b = """x = zip(a, b, c)"""
    1:         a = """x = list(zip(a, b, c))"""
    1:         self.check(b, a)
       
    1:         b = """x = len(zip(a, b))"""
    1:         a = """x = len(list(zip(a, b)))"""
    1:         self.check(b, a)
       
    1:     def test_zip_nochange(self):
    1:         a = """b.join(zip(a, b))"""
    1:         self.unchanged(a)
    1:         a = """(a + foo(5)).join(zip(a, b))"""
    1:         self.unchanged(a)
    1:         a = """iter(zip(a, b))"""
    1:         self.unchanged(a)
    1:         a = """list(zip(a, b))"""
    1:         self.unchanged(a)
    1:         a = """list(zip(a, b))[0]"""
    1:         self.unchanged(a)
    1:         a = """set(zip(a, b))"""
    1:         self.unchanged(a)
    1:         a = """set(zip(a, b)).pop()"""
    1:         self.unchanged(a)
    1:         a = """tuple(zip(a, b))"""
    1:         self.unchanged(a)
    1:         a = """any(zip(a, b))"""
    1:         self.unchanged(a)
    1:         a = """all(zip(a, b))"""
    1:         self.unchanged(a)
    1:         a = """sum(zip(a, b))"""
    1:         self.unchanged(a)
    1:         a = """sorted(zip(a, b))"""
    1:         self.unchanged(a)
    1:         a = """sorted(zip(a, b), key=blah)"""
    1:         self.unchanged(a)
    1:         a = """sorted(zip(a, b), key=blah)[0]"""
    1:         self.unchanged(a)
    1:         a = """enumerate(zip(a, b))"""
    1:         self.unchanged(a)
    1:         a = """enumerate(zip(a, b), start=1)"""
    1:         self.unchanged(a)
    1:         a = """for i in zip(a, b): pass"""
    1:         self.unchanged(a)
    1:         a = """[x for x in zip(a, b)]"""
    1:         self.unchanged(a)
    1:         a = """(x for x in zip(a, b))"""
    1:         self.unchanged(a)
       
    1:     def test_future_builtins(self):
    1:         a = "from future_builtins import spam, zip, eggs; zip(a, b)"
    1:         self.unchanged(a)
       
    1:         b = """from future_builtins import spam, eggs; x = zip(a, b)"""
    1:         a = """from future_builtins import spam, eggs; x = list(zip(a, b))"""
    1:         self.check(b, a)
       
    1:         a = "from future_builtins import *; zip(a, b)"
    1:         self.unchanged(a)
       
    2: class Test_standarderror(FixerTestCase):
    1:     fixer = "standarderror"
       
    1:     def test(self):
    1:         b = """x =    StandardError()"""
    1:         a = """x =    Exception()"""
    1:         self.check(b, a)
       
    1:         b = """x = StandardError(a, b, c)"""
    1:         a = """x = Exception(a, b, c)"""
    1:         self.check(b, a)
       
    1:         b = """f(2 + StandardError(a, b, c))"""
    1:         a = """f(2 + Exception(a, b, c))"""
    1:         self.check(b, a)
       
    2: class Test_types(FixerTestCase):
    1:     fixer = "types"
       
    1:     def test_basic_types_convert(self):
    1:         b = """types.StringType"""
    1:         a = """bytes"""
    1:         self.check(b, a)
       
    1:         b = """types.DictType"""
    1:         a = """dict"""
    1:         self.check(b, a)
       
    1:         b = """types . IntType"""
    1:         a = """int"""
    1:         self.check(b, a)
       
    1:         b = """types.ListType"""
    1:         a = """list"""
    1:         self.check(b, a)
       
    1:         b = """types.LongType"""
    1:         a = """int"""
    1:         self.check(b, a)
       
    1:         b = """types.NoneType"""
    1:         a = """type(None)"""
    1:         self.check(b, a)
       
    1:         b = "types.StringTypes"
    1:         a = "(str,)"
    1:         self.check(b, a)
       
    2: class Test_idioms(FixerTestCase):
    1:     fixer = "idioms"
       
    1:     def test_while(self):
    1:         b = """while 1: foo()"""
    1:         a = """while True: foo()"""
    1:         self.check(b, a)
       
    1:         b = """while   1: foo()"""
    1:         a = """while   True: foo()"""
    1:         self.check(b, a)
       
               b = """
                   while 1:
                       foo()
    1:             """
               a = """
                   while True:
                       foo()
    1:             """
    1:         self.check(b, a)
       
    1:     def test_while_unchanged(self):
    1:         s = """while 11: foo()"""
    1:         self.unchanged(s)
       
    1:         s = """while 0: foo()"""
    1:         self.unchanged(s)
       
    1:         s = """while foo(): foo()"""
    1:         self.unchanged(s)
       
    1:         s = """while []: foo()"""
    1:         self.unchanged(s)
       
    1:     def test_eq_simple(self):
    1:         b = """type(x) == T"""
    1:         a = """isinstance(x, T)"""
    1:         self.check(b, a)
       
    1:         b = """if   type(x) == T: pass"""
    1:         a = """if   isinstance(x, T): pass"""
    1:         self.check(b, a)
       
    1:     def test_eq_reverse(self):
    1:         b = """T == type(x)"""
    1:         a = """isinstance(x, T)"""
    1:         self.check(b, a)
       
    1:         b = """if   T == type(x): pass"""
    1:         a = """if   isinstance(x, T): pass"""
    1:         self.check(b, a)
       
    1:     def test_eq_expression(self):
    1:         b = """type(x+y) == d.get('T')"""
    1:         a = """isinstance(x+y, d.get('T'))"""
    1:         self.check(b, a)
       
    1:         b = """type(   x  +  y) == d.get('T')"""
    1:         a = """isinstance(x  +  y, d.get('T'))"""
    1:         self.check(b, a)
       
    1:     def test_is_simple(self):
    1:         b = """type(x) is T"""
    1:         a = """isinstance(x, T)"""
    1:         self.check(b, a)
       
    1:         b = """if   type(x) is T: pass"""
    1:         a = """if   isinstance(x, T): pass"""
    1:         self.check(b, a)
       
    1:     def test_is_reverse(self):
    1:         b = """T is type(x)"""
    1:         a = """isinstance(x, T)"""
    1:         self.check(b, a)
       
    1:         b = """if   T is type(x): pass"""
    1:         a = """if   isinstance(x, T): pass"""
    1:         self.check(b, a)
       
    1:     def test_is_expression(self):
    1:         b = """type(x+y) is d.get('T')"""
    1:         a = """isinstance(x+y, d.get('T'))"""
    1:         self.check(b, a)
       
    1:         b = """type(   x  +  y) is d.get('T')"""
    1:         a = """isinstance(x  +  y, d.get('T'))"""
    1:         self.check(b, a)
       
    1:     def test_is_not_simple(self):
    1:         b = """type(x) is not T"""
    1:         a = """not isinstance(x, T)"""
    1:         self.check(b, a)
       
    1:         b = """if   type(x) is not T: pass"""
    1:         a = """if   not isinstance(x, T): pass"""
    1:         self.check(b, a)
       
    1:     def test_is_not_reverse(self):
    1:         b = """T is not type(x)"""
    1:         a = """not isinstance(x, T)"""
    1:         self.check(b, a)
       
    1:         b = """if   T is not type(x): pass"""
    1:         a = """if   not isinstance(x, T): pass"""
    1:         self.check(b, a)
       
    1:     def test_is_not_expression(self):
    1:         b = """type(x+y) is not d.get('T')"""
    1:         a = """not isinstance(x+y, d.get('T'))"""
    1:         self.check(b, a)
       
    1:         b = """type(   x  +  y) is not d.get('T')"""
    1:         a = """not isinstance(x  +  y, d.get('T'))"""
    1:         self.check(b, a)
       
    1:     def test_ne_simple(self):
    1:         b = """type(x) != T"""
    1:         a = """not isinstance(x, T)"""
    1:         self.check(b, a)
       
    1:         b = """if   type(x) != T: pass"""
    1:         a = """if   not isinstance(x, T): pass"""
    1:         self.check(b, a)
       
    1:     def test_ne_reverse(self):
    1:         b = """T != type(x)"""
    1:         a = """not isinstance(x, T)"""
    1:         self.check(b, a)
       
    1:         b = """if   T != type(x): pass"""
    1:         a = """if   not isinstance(x, T): pass"""
    1:         self.check(b, a)
       
    1:     def test_ne_expression(self):
    1:         b = """type(x+y) != d.get('T')"""
    1:         a = """not isinstance(x+y, d.get('T'))"""
    1:         self.check(b, a)
       
    1:         b = """type(   x  +  y) != d.get('T')"""
    1:         a = """not isinstance(x  +  y, d.get('T'))"""
    1:         self.check(b, a)
       
    1:     def test_type_unchanged(self):
    1:         a = """type(x).__name__"""
    1:         self.unchanged(a)
       
    1:     def test_sort_list_call(self):
               b = """
                   v = list(t)
                   v.sort()
                   foo(v)
    1:             """
               a = """
                   v = sorted(t)
                   foo(v)
    1:             """
    1:         self.check(b, a)
       
               b = """
                   v = list(foo(b) + d)
                   v.sort()
                   foo(v)
    1:             """
               a = """
                   v = sorted(foo(b) + d)
                   foo(v)
    1:             """
    1:         self.check(b, a)
       
               b = """
                   while x:
                       v = list(t)
                       v.sort()
                       foo(v)
    1:             """
               a = """
                   while x:
                       v = sorted(t)
                       foo(v)
    1:             """
    1:         self.check(b, a)
       
               b = """
                   v = list(t)
                   # foo
                   v.sort()
                   foo(v)
    1:             """
               a = """
                   v = sorted(t)
                   # foo
                   foo(v)
    1:             """
    1:         self.check(b, a)
       
               b = r"""
                   v = list(   t)
                   v.sort()
                   foo(v)
    1:             """
               a = r"""
                   v = sorted(   t)
                   foo(v)
    1:             """
    1:         self.check(b, a)
       
               b = r"""
                   try:
                       m = list(s)
                       m.sort()
                   except: pass
    1:             """
       
               a = r"""
                   try:
                       m = sorted(s)
                   except: pass
    1:             """
    1:         self.check(b, a)
       
               b = r"""
                   try:
                       m = list(s)
                       # foo
                       m.sort()
                   except: pass
    1:             """
       
               a = r"""
                   try:
                       m = sorted(s)
                       # foo
                   except: pass
    1:             """
    1:         self.check(b, a)
       
               b = r"""
                   m = list(s)
                   # more comments
    1:             m.sort()"""
       
               a = r"""
                   m = sorted(s)
    1:             # more comments"""
    1:         self.check(b, a)
       
    1:     def test_sort_simple_expr(self):
               b = """
                   v = t
                   v.sort()
                   foo(v)
    1:             """
               a = """
                   v = sorted(t)
                   foo(v)
    1:             """
    1:         self.check(b, a)
       
               b = """
                   v = foo(b)
                   v.sort()
                   foo(v)
    1:             """
               a = """
                   v = sorted(foo(b))
                   foo(v)
    1:             """
    1:         self.check(b, a)
       
               b = """
                   v = b.keys()
                   v.sort()
                   foo(v)
    1:             """
               a = """
                   v = sorted(b.keys())
                   foo(v)
    1:             """
    1:         self.check(b, a)
       
               b = """
                   v = foo(b) + d
                   v.sort()
                   foo(v)
    1:             """
               a = """
                   v = sorted(foo(b) + d)
                   foo(v)
    1:             """
    1:         self.check(b, a)
       
               b = """
                   while x:
                       v = t
                       v.sort()
                       foo(v)
    1:             """
               a = """
                   while x:
                       v = sorted(t)
                       foo(v)
    1:             """
    1:         self.check(b, a)
       
               b = """
                   v = t
                   # foo
                   v.sort()
                   foo(v)
    1:             """
               a = """
                   v = sorted(t)
                   # foo
                   foo(v)
    1:             """
    1:         self.check(b, a)
       
               b = r"""
                   v =   t
                   v.sort()
                   foo(v)
    1:             """
               a = r"""
                   v =   sorted(t)
                   foo(v)
    1:             """
    1:         self.check(b, a)
       
    1:     def test_sort_unchanged(self):
               s = """
                   v = list(t)
                   w.sort()
                   foo(w)
    1:             """
    1:         self.unchanged(s)
       
               s = """
                   v = list(t)
                   v.sort(u)
                   foo(v)
    1:             """
    1:         self.unchanged(s)
       
    2: class Test_basestring(FixerTestCase):
    1:     fixer = "basestring"
       
    1:     def test_basestring(self):
    1:         b = """isinstance(x, basestring)"""
    1:         a = """isinstance(x, str)"""
    1:         self.check(b, a)
       
    2: class Test_buffer(FixerTestCase):
    1:     fixer = "buffer"
       
    1:     def test_buffer(self):
    1:         b = """x = buffer(y)"""
    1:         a = """x = memoryview(y)"""
    1:         self.check(b, a)
       
    1:     def test_slicing(self):
    1:         b = """buffer(y)[4:5]"""
    1:         a = """memoryview(y)[4:5]"""
    1:         self.check(b, a)
       
    2: class Test_future(FixerTestCase):
    1:     fixer = "future"
       
    1:     def test_future(self):
    1:         b = """from __future__ import braces"""
    1:         a = """"""
    1:         self.check(b, a)
       
    1:         b = """# comment\nfrom __future__ import braces"""
    1:         a = """# comment\n"""
    1:         self.check(b, a)
       
    1:         b = """from __future__ import braces\n# comment"""
    1:         a = """\n# comment"""
    1:         self.check(b, a)
       
    1:     def test_run_order(self):
    1:         self.assert_runs_after('print')
       
    2: class Test_itertools(FixerTestCase):
    1:     fixer = "itertools"
       
    1:     def checkall(self, before, after):
               # Because we need to check with and without the itertools prefix
               # and on each of the three functions, these loops make it all
               # much easier
    6:         for i in ('itertools.', ''):
   16:             for f in ('map', 'filter', 'zip'):
   12:                 b = before %(i+'i'+f)
   12:                 a = after %(f)
   12:                 self.check(b, a)
       
    1:     def test_0(self):
               # A simple example -- test_1 covers exactly the same thing,
               # but it's not quite as clear.
    1:         b = "itertools.izip(a, b)"
    1:         a = "zip(a, b)"
    1:         self.check(b, a)
       
    1:     def test_1(self):
    1:         b = """%s(f, a)"""
    1:         a = """%s(f, a)"""
    1:         self.checkall(b, a)
       
    1:     def test_qualified(self):
    1:         b = """itertools.ifilterfalse(a, b)"""
    1:         a = """itertools.filterfalse(a, b)"""
    1:         self.check(b, a)
       
    1:         b = """itertools.izip_longest(a, b)"""
    1:         a = """itertools.zip_longest(a, b)"""
    1:         self.check(b, a)
       
    1:     def test_2(self):
    1:         b = """ifilterfalse(a, b)"""
    1:         a = """filterfalse(a, b)"""
    1:         self.check(b, a)
       
    1:         b = """izip_longest(a, b)"""
    1:         a = """zip_longest(a, b)"""
    1:         self.check(b, a)
       
    1:     def test_space_1(self):
    1:         b = """    %s(f, a)"""
    1:         a = """    %s(f, a)"""
    1:         self.checkall(b, a)
       
    1:     def test_space_2(self):
    1:         b = """    itertools.ifilterfalse(a, b)"""
    1:         a = """    itertools.filterfalse(a, b)"""
    1:         self.check(b, a)
       
    1:         b = """    itertools.izip_longest(a, b)"""
    1:         a = """    itertools.zip_longest(a, b)"""
    1:         self.check(b, a)
       
    1:     def test_run_order(self):
    1:         self.assert_runs_after('map', 'zip', 'filter')
       
       
    2: class Test_itertools_imports(FixerTestCase):
    1:     fixer = 'itertools_imports'
       
    1:     def test_reduced(self):
    1:         b = "from itertools import imap, izip, foo"
    1:         a = "from itertools import foo"
    1:         self.check(b, a)
       
    1:         b = "from itertools import bar, imap, izip, foo"
    1:         a = "from itertools import bar, foo"
    1:         self.check(b, a)
       
    1:         b = "from itertools import chain, imap, izip"
    1:         a = "from itertools import chain"
    1:         self.check(b, a)
       
    1:     def test_comments(self):
    1:         b = "#foo\nfrom itertools import imap, izip"
    1:         a = "#foo\n"
    1:         self.check(b, a)
       
    1:     def test_none(self):
    1:         b = "from itertools import imap, izip"
    1:         a = ""
    1:         self.check(b, a)
       
    1:         b = "from itertools import izip"
    1:         a = ""
    1:         self.check(b, a)
       
    1:     def test_import_as(self):
    1:         b = "from itertools import izip, bar as bang, imap"
    1:         a = "from itertools import bar as bang"
    1:         self.check(b, a)
       
    1:         b = "from itertools import izip as _zip, imap, bar"
    1:         a = "from itertools import bar"
    1:         self.check(b, a)
       
    1:         b = "from itertools import imap as _map"
    1:         a = ""
    1:         self.check(b, a)
       
    1:         b = "from itertools import imap as _map, izip as _zip"
    1:         a = ""
    1:         self.check(b, a)
       
    1:         s = "from itertools import bar as bang"
    1:         self.unchanged(s)
       
    1:     def test_ifilter_and_zip_longest(self):
    3:         for name in "filterfalse", "zip_longest":
    2:             b = "from itertools import i%s" % (name,)
    2:             a = "from itertools import %s" % (name,)
    2:             self.check(b, a)
       
    2:             b = "from itertools import imap, i%s, foo" % (name,)
    2:             a = "from itertools import %s, foo" % (name,)
    2:             self.check(b, a)
       
    2:             b = "from itertools import bar, i%s, foo" % (name,)
    2:             a = "from itertools import bar, %s, foo" % (name,)
    2:             self.check(b, a)
       
    1:     def test_import_star(self):
    1:         s = "from itertools import *"
    1:         self.unchanged(s)
       
       
    1:     def test_unchanged(self):
    1:         s = "from itertools import foo"
    1:         self.unchanged(s)
       
       
    2: class Test_import(FixerTestCase):
    1:     fixer = "import"
       
    1:     def setUp(self):
   16:         super(Test_import, self).setUp()
               # Need to replace fix_import's exists method
               # so we can check that it's doing the right thing
   16:         self.files_checked = []
   16:         self.present_files = set()
   16:         self.always_exists = True
   16:         def fake_exists(name):
  101:             self.files_checked.append(name)
  101:             return self.always_exists or (name in self.present_files)
       
   16:         from lib2to3.fixes import fix_import
   16:         fix_import.exists = fake_exists
       
    1:     def tearDown(self):
   16:         from lib2to3.fixes import fix_import
   16:         fix_import.exists = os.path.exists
       
    1:     def check_both(self, b, a):
   14:         self.always_exists = True
   14:         super(Test_import, self).check(b, a)
   14:         self.always_exists = False
   14:         super(Test_import, self).unchanged(b)
       
    1:     def test_files_checked(self):
    1:         def p(path):
                   # Takes a unix path and returns a path with correct separators
    2:             return os.path.pathsep.join(path.split("/"))
       
    1:         self.always_exists = False
    1:         self.present_files = set(['__init__.py'])
    1:         expected_extensions = ('.py', os.path.sep, '.pyc', '.so', '.sl', '.pyd')
    1:         names_to_test = (p("/spam/eggs.py"), "ni.py", p("../../shrubbery.py"))
       
    4:         for name in names_to_test:
    3:             self.files_checked = []
    3:             self.filename = name
    3:             self.unchanged("import jam")
       
    3:             if os.path.dirname(name):
>>>>>>                 name = os.path.dirname(name) + '/jam'
                   else:
    3:                 name = 'jam'
   24:             expected_checks = set(name + ext for ext in expected_extensions)
    3:             expected_checks.add("__init__.py")
       
    3:             self.assertEqual(set(self.files_checked), expected_checks)
       
    1:     def test_not_in_package(self):
    1:         s = "import bar"
    1:         self.always_exists = False
    1:         self.present_files = set(["bar.py"])
    1:         self.unchanged(s)
       
    1:     def test_with_absolute_import_enabled(self):
    1:         s = "from __future__ import absolute_import\nimport bar"
    1:         self.always_exists = False
    1:         self.present_files = set(["__init__.py", "bar.py"])
    1:         self.unchanged(s)
       
    1:     def test_in_package(self):
    1:         b = "import bar"
    1:         a = "from . import bar"
    1:         self.always_exists = False
    1:         self.present_files = set(["__init__.py", "bar.py"])
    1:         self.check(b, a)
       
    1:     def test_import_from_package(self):
    1:         b = "import bar"
    1:         a = "from . import bar"
    1:         self.always_exists = False
    1:         self.present_files = set(["__init__.py", "bar" + os.path.sep])
    1:         self.check(b, a)
       
    1:     def test_already_relative_import(self):
    1:         s = "from . import bar"
    1:         self.unchanged(s)
       
    1:     def test_comments_and_indent(self):
    1:         b = "import bar # Foo"
    1:         a = "from . import bar # Foo"
    1:         self.check(b, a)
       
    1:     def test_from(self):
    1:         b = "from foo import bar, baz"
    1:         a = "from .foo import bar, baz"
    1:         self.check_both(b, a)
       
    1:         b = "from foo import bar"
    1:         a = "from .foo import bar"
    1:         self.check_both(b, a)
       
    1:         b = "from foo import (bar, baz)"
    1:         a = "from .foo import (bar, baz)"
    1:         self.check_both(b, a)
       
    1:     def test_dotted_from(self):
    1:         b = "from green.eggs import ham"
    1:         a = "from .green.eggs import ham"
    1:         self.check_both(b, a)
       
    1:     def test_from_as(self):
    1:         b = "from green.eggs import ham as spam"
    1:         a = "from .green.eggs import ham as spam"
    1:         self.check_both(b, a)
       
    1:     def test_import(self):
    1:         b = "import foo"
    1:         a = "from . import foo"
    1:         self.check_both(b, a)
       
    1:         b = "import foo, bar"
    1:         a = "from . import foo, bar"
    1:         self.check_both(b, a)
       
    1:         b = "import foo, bar, x"
    1:         a = "from . import foo, bar, x"
    1:         self.check_both(b, a)
       
    1:         b = "import x, y, z"
    1:         a = "from . import x, y, z"
    1:         self.check_both(b, a)
       
    1:     def test_import_as(self):
    1:         b = "import foo as x"
    1:         a = "from . import foo as x"
    1:         self.check_both(b, a)
       
    1:         b = "import a as b, b as c, c as d"
    1:         a = "from . import a as b, b as c, c as d"
    1:         self.check_both(b, a)
       
    1:     def test_local_and_absolute(self):
    1:         self.always_exists = False
    1:         self.present_files = set(["foo.py", "__init__.py"])
       
    1:         s = "import foo, bar"
    1:         self.warns_unchanged(s, "absolute and local imports together")
       
    1:     def test_dotted_import(self):
    1:         b = "import foo.bar"
    1:         a = "from . import foo.bar"
    1:         self.check_both(b, a)
       
    1:     def test_dotted_import_as(self):
    1:         b = "import foo.bar as bang"
    1:         a = "from . import foo.bar as bang"
    1:         self.check_both(b, a)
       
    1:     def test_prefix(self):
               b = """
               # prefix
               import foo.bar
    1:         """
               a = """
               # prefix
               from . import foo.bar
    1:         """
    1:         self.check_both(b, a)
       
       
    2: class Test_set_literal(FixerTestCase):
       
    1:     fixer = "set_literal"
       
    1:     def test_basic(self):
    1:         b = """set([1, 2, 3])"""
    1:         a = """{1, 2, 3}"""
    1:         self.check(b, a)
       
    1:         b = """set((1, 2, 3))"""
    1:         a = """{1, 2, 3}"""
    1:         self.check(b, a)
       
    1:         b = """set((1,))"""
    1:         a = """{1}"""
    1:         self.check(b, a)
       
    1:         b = """set([1])"""
    1:         self.check(b, a)
       
    1:         b = """set((a, b))"""
    1:         a = """{a, b}"""
    1:         self.check(b, a)
       
    1:         b = """set([a, b])"""
    1:         self.check(b, a)
       
    1:         b = """set((a*234, f(args=23)))"""
    1:         a = """{a*234, f(args=23)}"""
    1:         self.check(b, a)
       
    1:         b = """set([a*23, f(23)])"""
    1:         a = """{a*23, f(23)}"""
    1:         self.check(b, a)
       
    1:         b = """set([a-234**23])"""
    1:         a = """{a-234**23}"""
    1:         self.check(b, a)
       
    1:     def test_listcomps(self):
    1:         b = """set([x for x in y])"""
    1:         a = """{x for x in y}"""
    1:         self.check(b, a)
       
    1:         b = """set([x for x in y if x == m])"""
    1:         a = """{x for x in y if x == m}"""
    1:         self.check(b, a)
       
    1:         b = """set([x for x in y for a in b])"""
    1:         a = """{x for x in y for a in b}"""
    1:         self.check(b, a)
       
    1:         b = """set([f(x) - 23 for x in y])"""
    1:         a = """{f(x) - 23 for x in y}"""
    1:         self.check(b, a)
       
    1:     def test_whitespace(self):
    1:         b = """set( [1, 2])"""
    1:         a = """{1, 2}"""
    1:         self.check(b, a)
       
    1:         b = """set([1 ,  2])"""
    1:         a = """{1 ,  2}"""
    1:         self.check(b, a)
       
    1:         b = """set([ 1 ])"""
    1:         a = """{ 1 }"""
    1:         self.check(b, a)
       
    1:         b = """set( [1] )"""
    1:         a = """{1}"""
    1:         self.check(b, a)
       
    1:         b = """set([  1,  2  ])"""
    1:         a = """{  1,  2  }"""
    1:         self.check(b, a)
       
    1:         b = """set([x  for x in y ])"""
    1:         a = """{x  for x in y }"""
    1:         self.check(b, a)
       
               b = """set(
                          [1, 2]
                      )
    1:             """
    1:         a = """{1, 2}\n"""
    1:         self.check(b, a)
       
    1:     def test_comments(self):
    1:         b = """set((1, 2)) # Hi"""
    1:         a = """{1, 2} # Hi"""
    1:         self.check(b, a)
       
               # This isn't optimal behavior, but the fixer is optional.
               b = """
                   # Foo
                   set( # Bar
                      (1, 2)
                   )
    1:             """
               a = """
                   # Foo
                   {1, 2}
    1:             """
    1:         self.check(b, a)
       
    1:     def test_unchanged(self):
    1:         s = """set()"""
    1:         self.unchanged(s)
       
    1:         s = """set(a)"""
    1:         self.unchanged(s)
       
    1:         s = """set(a, b, c)"""
    1:         self.unchanged(s)
       
               # Don't transform generators because they might have to be lazy.
    1:         s = """set(x for x in y)"""
    1:         self.unchanged(s)
       
    1:         s = """set(x for x in y if z)"""
    1:         self.unchanged(s)
       
    1:         s = """set(a*823-23**2 + f(23))"""
    1:         self.unchanged(s)
       
       
    2: class Test_sys_exc(FixerTestCase):
    1:     fixer = "sys_exc"
       
    1:     def test_0(self):
    1:         b = "sys.exc_type"
    1:         a = "sys.exc_info()[0]"
    1:         self.check(b, a)
       
    1:     def test_1(self):
    1:         b = "sys.exc_value"
    1:         a = "sys.exc_info()[1]"
    1:         self.check(b, a)
       
    1:     def test_2(self):
    1:         b = "sys.exc_traceback"
    1:         a = "sys.exc_info()[2]"
    1:         self.check(b, a)
       
    1:     def test_3(self):
    1:         b = "sys.exc_type # Foo"
    1:         a = "sys.exc_info()[0] # Foo"
    1:         self.check(b, a)
       
    1:     def test_4(self):
    1:         b = "sys.  exc_type"
    1:         a = "sys.  exc_info()[0]"
    1:         self.check(b, a)
       
    1:     def test_5(self):
    1:         b = "sys  .exc_type"
    1:         a = "sys  .exc_info()[0]"
    1:         self.check(b, a)
       
       
    2: class Test_paren(FixerTestCase):
    1:     fixer = "paren"
       
    1:     def test_0(self):
    1:         b = """[i for i in 1, 2 ]"""
    1:         a = """[i for i in (1, 2) ]"""
    1:         self.check(b, a)
       
    1:     def test_1(self):
    1:         b = """[i for i in 1, 2, ]"""
    1:         a = """[i for i in (1, 2,) ]"""
    1:         self.check(b, a)
       
    1:     def test_2(self):
    1:         b = """[i for i  in     1, 2 ]"""
    1:         a = """[i for i  in     (1, 2) ]"""
    1:         self.check(b, a)
       
    1:     def test_3(self):
    1:         b = """[i for i in 1, 2 if i]"""
    1:         a = """[i for i in (1, 2) if i]"""
    1:         self.check(b, a)
       
    1:     def test_4(self):
    1:         b = """[i for i in 1,    2    ]"""
    1:         a = """[i for i in (1,    2)    ]"""
    1:         self.check(b, a)
       
    1:     def test_5(self):
    1:         b = """(i for i in 1, 2)"""
    1:         a = """(i for i in (1, 2))"""
    1:         self.check(b, a)
       
    1:     def test_6(self):
    1:         b = """(i for i in 1   ,2   if i)"""
    1:         a = """(i for i in (1   ,2)   if i)"""
    1:         self.check(b, a)
       
    1:     def test_unchanged_0(self):
    1:         s = """[i for i in (1, 2)]"""
    1:         self.unchanged(s)
       
    1:     def test_unchanged_1(self):
    1:         s = """[i for i in foo()]"""
    1:         self.unchanged(s)
       
    1:     def test_unchanged_2(self):
    1:         s = """[i for i in (1, 2) if nothing]"""
    1:         self.unchanged(s)
       
    1:     def test_unchanged_3(self):
    1:         s = """(i for i in (1, 2))"""
    1:         self.unchanged(s)
       
    1:     def test_unchanged_4(self):
    1:         s = """[i for i in m]"""
    1:         self.unchanged(s)
       
    2: class Test_metaclass(FixerTestCase):
       
    1:     fixer = 'metaclass'
       
    1:     def test_unchanged(self):
    1:         self.unchanged("class X(): pass")
    1:         self.unchanged("class X(object): pass")
    1:         self.unchanged("class X(object1, object2): pass")
    1:         self.unchanged("class X(object1, object2, object3): pass")
    1:         self.unchanged("class X(metaclass=Meta): pass")
    1:         self.unchanged("class X(b, arg=23, metclass=Meta): pass")
    1:         self.unchanged("class X(b, arg=23, metaclass=Meta, other=42): pass")
       
               s = """
               class X:
                   def __metaclass__(self): pass
    1:         """
    1:         self.unchanged(s)
       
               s = """
               class X:
                   a[23] = 74
    1:         """
    1:         self.unchanged(s)
       
    1:     def test_comments(self):
               b = """
               class X:
                   # hi
                   __metaclass__ = AppleMeta
    1:         """
               a = """
               class X(metaclass=AppleMeta):
                   # hi
                   pass
    1:         """
    1:         self.check(b, a)
       
               b = """
               class X:
                   __metaclass__ = Meta
                   # Bedtime!
    1:         """
               a = """
               class X(metaclass=Meta):
                   pass
                   # Bedtime!
    1:         """
    1:         self.check(b, a)
       
    1:     def test_meta(self):
               # no-parent class, odd body
               b = """
               class X():
                   __metaclass__ = Q
                   pass
    1:         """
               a = """
               class X(metaclass=Q):
                   pass
    1:         """
    1:         self.check(b, a)
       
               # one parent class, no body
    1:         b = """class X(object): __metaclass__ = Q"""
    1:         a = """class X(object, metaclass=Q): pass"""
    1:         self.check(b, a)
       
       
               # one parent, simple body
               b = """
               class X(object):
                   __metaclass__ = Meta
                   bar = 7
    1:         """
               a = """
               class X(object, metaclass=Meta):
                   bar = 7
    1:         """
    1:         self.check(b, a)
       
               b = """
               class X:
                   __metaclass__ = Meta; x = 4; g = 23
    1:         """
               a = """
               class X(metaclass=Meta):
                   x = 4; g = 23
    1:         """
    1:         self.check(b, a)
       
               # one parent, simple body, __metaclass__ last
               b = """
               class X(object):
                   bar = 7
                   __metaclass__ = Meta
    1:         """
               a = """
               class X(object, metaclass=Meta):
                   bar = 7
    1:         """
    1:         self.check(b, a)
       
               # redefining __metaclass__
               b = """
               class X():
                   __metaclass__ = A
                   __metaclass__ = B
                   bar = 7
    1:         """
               a = """
               class X(metaclass=B):
                   bar = 7
    1:         """
    1:         self.check(b, a)
       
               # multiple inheritance, simple body
               b = """
               class X(clsA, clsB):
                   __metaclass__ = Meta
                   bar = 7
    1:         """
               a = """
               class X(clsA, clsB, metaclass=Meta):
                   bar = 7
    1:         """
    1:         self.check(b, a)
       
               # keywords in the class statement
    1:         b = """class m(a, arg=23): __metaclass__ = Meta"""
    1:         a = """class m(a, arg=23, metaclass=Meta): pass"""
    1:         self.check(b, a)
       
               b = """
               class X(expression(2 + 4)):
                   __metaclass__ = Meta
    1:         """
               a = """
               class X(expression(2 + 4), metaclass=Meta):
                   pass
    1:         """
    1:         self.check(b, a)
       
               b = """
               class X(expression(2 + 4), x**4):
                   __metaclass__ = Meta
    1:         """
               a = """
               class X(expression(2 + 4), x**4, metaclass=Meta):
                   pass
    1:         """
    1:         self.check(b, a)
       
               b = """
               class X:
                   __metaclass__ = Meta
                   save.py = 23
    1:         """
               a = """
               class X(metaclass=Meta):
                   save.py = 23
    1:         """
    1:         self.check(b, a)
       
       
    2: class Test_getcwdu(FixerTestCase):
       
    1:     fixer = 'getcwdu'
       
    1:     def test_basic(self):
    1:         b = """os.getcwdu"""
    1:         a = """os.getcwd"""
    1:         self.check(b, a)
       
    1:         b = """os.getcwdu()"""
    1:         a = """os.getcwd()"""
    1:         self.check(b, a)
       
    1:         b = """meth = os.getcwdu"""
    1:         a = """meth = os.getcwd"""
    1:         self.check(b, a)
       
    1:         b = """os.getcwdu(args)"""
    1:         a = """os.getcwd(args)"""
    1:         self.check(b, a)
       
    1:     def test_comment(self):
    1:         b = """os.getcwdu() # Foo"""
    1:         a = """os.getcwd() # Foo"""
    1:         self.check(b, a)
       
    1:     def test_unchanged(self):
    1:         s = """os.getcwd()"""
    1:         self.unchanged(s)
       
    1:         s = """getcwdu()"""
    1:         self.unchanged(s)
       
    1:         s = """os.getcwdb()"""
    1:         self.unchanged(s)
       
    1:     def test_indentation(self):
               b = """
                   if 1:
                       os.getcwdu()
    1:             """
               a = """
                   if 1:
                       os.getcwd()
    1:             """
    1:         self.check(b, a)
       
    1:     def test_multilation(self):
    1:         b = """os .getcwdu()"""
    1:         a = """os .getcwd()"""
    1:         self.check(b, a)
       
    1:         b = """os.  getcwdu"""
    1:         a = """os.  getcwd"""
    1:         self.check(b, a)
       
    1:         b = """os.getcwdu (  )"""
    1:         a = """os.getcwd (  )"""
    1:         self.check(b, a)
       
       
    2: class Test_operator(FixerTestCase):
       
    1:     fixer = "operator"
       
    1:     def test_operator_isCallable(self):
    1:         b = "operator.isCallable(x)"
    1:         a = "hasattr(x, '__call__')"
    1:         self.check(b, a)
       
    1:     def test_operator_sequenceIncludes(self):
    1:         b = "operator.sequenceIncludes(x, y)"
    1:         a = "operator.contains(x, y)"
    1:         self.check(b, a)
       
    1:         b = "operator .sequenceIncludes(x, y)"
    1:         a = "operator .contains(x, y)"
    1:         self.check(b, a)
       
    1:         b = "operator.  sequenceIncludes(x, y)"
    1:         a = "operator.  contains(x, y)"
    1:         self.check(b, a)
       
    1:     def test_operator_isSequenceType(self):
    1:         b = "operator.isSequenceType(x)"
    1:         a = "import collections\nisinstance(x, collections.Sequence)"
    1:         self.check(b, a)
       
    1:     def test_operator_isMappingType(self):
    1:         b = "operator.isMappingType(x)"
    1:         a = "import collections\nisinstance(x, collections.Mapping)"
    1:         self.check(b, a)
       
    1:     def test_operator_isNumberType(self):
    1:         b = "operator.isNumberType(x)"
    1:         a = "import numbers\nisinstance(x, numbers.Number)"
    1:         self.check(b, a)
       
    1:     def test_operator_repeat(self):
    1:         b = "operator.repeat(x, n)"
    1:         a = "operator.mul(x, n)"
    1:         self.check(b, a)
       
    1:         b = "operator .repeat(x, n)"
    1:         a = "operator .mul(x, n)"
    1:         self.check(b, a)
       
    1:         b = "operator.  repeat(x, n)"
    1:         a = "operator.  mul(x, n)"
    1:         self.check(b, a)
       
    1:     def test_operator_irepeat(self):
    1:         b = "operator.irepeat(x, n)"
    1:         a = "operator.imul(x, n)"
    1:         self.check(b, a)
       
    1:         b = "operator .irepeat(x, n)"
    1:         a = "operator .imul(x, n)"
    1:         self.check(b, a)
       
    1:         b = "operator.  irepeat(x, n)"
    1:         a = "operator.  imul(x, n)"
    1:         self.check(b, a)
       
    1:     def test_bare_isCallable(self):
    1:         s = "isCallable(x)"
    1:         t = "You should use 'hasattr(x, '__call__')' here."
    1:         self.warns_unchanged(s, t)
       
    1:     def test_bare_sequenceIncludes(self):
    1:         s = "sequenceIncludes(x, y)"
    1:         t = "You should use 'operator.contains(x, y)' here."
    1:         self.warns_unchanged(s, t)
       
    1:     def test_bare_operator_isSequenceType(self):
    1:         s = "isSequenceType(z)"
    1:         t = "You should use 'isinstance(z, collections.Sequence)' here."
    1:         self.warns_unchanged(s, t)
       
    1:     def test_bare_operator_isMappingType(self):
    1:         s = "isMappingType(x)"
    1:         t = "You should use 'isinstance(x, collections.Mapping)' here."
    1:         self.warns_unchanged(s, t)
       
    1:     def test_bare_operator_isNumberType(self):
    1:         s = "isNumberType(y)"
    1:         t = "You should use 'isinstance(y, numbers.Number)' here."
    1:         self.warns_unchanged(s, t)
       
    1:     def test_bare_operator_repeat(self):
    1:         s = "repeat(x, n)"
    1:         t = "You should use 'operator.mul(x, n)' here."
    1:         self.warns_unchanged(s, t)
       
    1:     def test_bare_operator_irepeat(self):
    1:         s = "irepeat(y, 187)"
    1:         t = "You should use 'operator.imul(y, 187)' here."
    1:         self.warns_unchanged(s, t)
       
       
    2: class Test_exitfunc(FixerTestCase):
       
    1:     fixer = "exitfunc"
       
    1:     def test_simple(self):
               b = """
                   import sys
                   sys.exitfunc = my_atexit
    1:             """
               a = """
                   import sys
                   import atexit
                   atexit.register(my_atexit)
    1:             """
    1:         self.check(b, a)
       
    1:     def test_names_import(self):
               b = """
                   import sys, crumbs
                   sys.exitfunc = my_func
    1:             """
               a = """
                   import sys, crumbs, atexit
                   atexit.register(my_func)
    1:             """
    1:         self.check(b, a)
       
    1:     def test_complex_expression(self):
               b = """
                   import sys
                   sys.exitfunc = do(d)/a()+complex(f=23, g=23)*expression
    1:             """
               a = """
                   import sys
                   import atexit
                   atexit.register(do(d)/a()+complex(f=23, g=23)*expression)
    1:             """
    1:         self.check(b, a)
       
    1:     def test_comments(self):
               b = """
                   import sys # Foo
                   sys.exitfunc = f # Blah
    1:             """
               a = """
                   import sys
                   import atexit # Foo
                   atexit.register(f) # Blah
    1:             """
    1:         self.check(b, a)
       
               b = """
                   import apples, sys, crumbs, larry # Pleasant comments
                   sys.exitfunc = func
    1:             """
               a = """
                   import apples, sys, crumbs, larry, atexit # Pleasant comments
                   atexit.register(func)
    1:             """
    1:         self.check(b, a)
       
    1:     def test_in_a_function(self):
               b = """
                   import sys
                   def f():
                       sys.exitfunc = func
    1:             """
               a = """
                   import sys
                   import atexit
                   def f():
                       atexit.register(func)
    1:              """
    1:         self.check(b, a)
       
    1:     def test_no_sys_import(self):
    1:         b = """sys.exitfunc = f"""
    1:         a = """atexit.register(f)"""
    1:         msg = ("Can't find sys import; Please add an atexit import at the "
                   "top of your file.")
    1:         self.warns(b, a, msg)
       
       
    1:     def test_unchanged(self):
    1:         s = """f(sys.exitfunc)"""
    1:         self.unchanged(s)
       
       
    2: class Test_asserts(FixerTestCase):
       
    1:     fixer = "asserts"
       
    1:     def test_deprecated_names(self):
               tests = [
    1:             ('self.assert_(True)', 'self.assertTrue(True)'),
    1:             ('self.assertEquals(2, 2)', 'self.assertEqual(2, 2)'),
    1:             ('self.assertNotEquals(2, 3)', 'self.assertNotEqual(2, 3)'),
    1:             ('self.assertAlmostEquals(2, 3)', 'self.assertAlmostEqual(2, 3)'),
    1:             ('self.assertNotAlmostEquals(2, 8)', 'self.assertNotAlmostEqual(2, 8)'),
    1:             ('self.failUnlessEqual(2, 2)', 'self.assertEqual(2, 2)'),
    1:             ('self.failIfEqual(2, 3)', 'self.assertNotEqual(2, 3)'),
    1:             ('self.failUnlessAlmostEqual(2, 3)', 'self.assertAlmostEqual(2, 3)'),
    1:             ('self.failIfAlmostEqual(2, 8)', 'self.assertNotAlmostEqual(2, 8)'),
    1:             ('self.failUnless(True)', 'self.assertTrue(True)'),
    1:             ('self.failUnlessRaises(foo)', 'self.assertRaises(foo)'),
    1:             ('self.failIf(False)', 'self.assertFalse(False)'),
               ]
   13:         for b, a in tests:
   12:             self.check(b, a)
       
    1:     def test_variants(self):
    1:         b = 'eq = self.assertEquals'
    1:         a = 'eq = self.assertEqual'
    1:         self.check(b, a)
    1:         b = 'self.assertEquals(2, 3, msg="fail")'
    1:         a = 'self.assertEqual(2, 3, msg="fail")'
    1:         self.check(b, a)
    1:         b = 'self.assertEquals(2, 3, msg="fail") # foo'
    1:         a = 'self.assertEqual(2, 3, msg="fail") # foo'
    1:         self.check(b, a)
    1:         b = 'self.assertEquals (2, 3)'
    1:         a = 'self.assertEqual (2, 3)'
    1:         self.check(b, a)
    1:         b = '  self.assertEquals (2, 3)'
    1:         a = '  self.assertEqual (2, 3)'
    1:         self.check(b, a)
    1:         b = 'with self.failUnlessRaises(Explosion): explode()'
    1:         a = 'with self.assertRaises(Explosion): explode()'
    1:         self.check(b, a)
    1:         b = 'with self.failUnlessRaises(Explosion) as cm: explode()'
    1:         a = 'with self.assertRaises(Explosion) as cm: explode()'
    1:         self.check(b, a)
       
    1:     def test_unchanged(self):
    1:         self.unchanged('self.assertEqualsOnSaturday')
    1:         self.unchanged('self.assertEqualsOnSaturday(3, 5)')
