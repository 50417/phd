       """distutils.dist
       
       Provides the Distribution class, which represents the module distribution
       being built/installed/distributed.
    2: """
       
    2: __revision__ = "$Id$"
       
    2: import sys, os, re
    2: from email import message_from_file
       
    2: try:
    2:     import warnings
>>>>>> except ImportError:
>>>>>>     warnings = None
       
    2: from distutils.errors import (DistutilsOptionError, DistutilsArgError,
                                     DistutilsModuleError, DistutilsClassError)
    2: from distutils.fancy_getopt import FancyGetopt, translate_longopt
    2: from distutils.util import check_environ, strtobool, rfc822_escape
    2: from distutils import log
    2: from distutils.debug import DEBUG
       
       # Encoding used for the PKG-INFO files
    2: PKG_INFO_ENCODING = 'utf-8'
       
       # Regex to define acceptable Distutils command names.  This is not *quite*
       # the same as a Python NAME -- I don't allow leading underscores.  The fact
       # that they're very similar is no coincidence; the default naming scheme is
       # to look for a Python module named after the command.
    2: command_re = re.compile (r'^[a-zA-Z]([a-zA-Z0-9_]*)$')
       
       
    4: class Distribution:
           """The core of the Distutils.  Most of the work hiding behind 'setup'
           is really done within a Distribution instance, which farms the work out
           to the Distutils commands specified on the command line.
       
           Setup scripts will almost never instantiate Distribution directly,
           unless the 'setup()' function is totally inadequate to their needs.
           However, it is conceivable that a setup script might wish to subclass
           Distribution for some specialized purpose, and then pass the subclass
           to 'setup()' as the 'distclass' keyword argument.  If so, it is
           necessary to respect the expectations that 'setup' has of Distribution.
           See the code for 'setup()', in core.py, for details.
    2:     """
       
       
           # 'global_options' describes the command-line options that may be
           # supplied to the setup script prior to any actual commands.
           # Eg. "./setup.py -n" or "./setup.py --quiet" both take advantage of
           # these global options.  This list should be kept to a bare minimum,
           # since every global option is also valid as a command option -- and we
           # don't want to pollute the commands with too many options that they
           # have minimal control over.
           # The fourth entry for verbose means that it can be repeated.
    2:     global_options = [('verbose', 'v', "run verbosely (default)", 1),
    2:                       ('quiet', 'q', "run quietly (turns verbosity off)"),
    2:                       ('dry-run', 'n', "don't actually do anything"),
    2:                       ('help', 'h', "show detailed help message"),
                             ('no-user-cfg', None,
    2:                        'ignore pydistutils.cfg in your home directory'),
           ]
       
           # 'common_usage' is a short (2-3 line) string describing the common
           # usage of the setup script.
           common_usage = """\
       Common commands: (see '--help-commands' for more)
       
         setup.py build      will build the package underneath 'build/'
         setup.py install    will install the package
    2: """
       
           # options that are not propagated to the commands
           display_options = [
               ('help-commands', None,
    2:          "list all available commands"),
               ('name', None,
    2:          "print package name"),
               ('version', 'V',
    2:          "print package version"),
               ('fullname', None,
    2:          "print <package name>-<version>"),
               ('author', None,
    2:          "print the author's name"),
               ('author-email', None,
    2:          "print the author's email address"),
               ('maintainer', None,
    2:          "print the maintainer's name"),
               ('maintainer-email', None,
    2:          "print the maintainer's email address"),
               ('contact', None,
    2:          "print the maintainer's name if known, else the author's"),
               ('contact-email', None,
    2:          "print the maintainer's email address if known, else the author's"),
               ('url', None,
    2:          "print the URL for this package"),
               ('license', None,
    2:          "print the license of the package"),
               ('licence', None,
    2:          "alias for --license"),
               ('description', None,
    2:          "print the package description"),
               ('long-description', None,
    2:          "print the long package description"),
               ('platforms', None,
    2:          "print the list of platforms"),
               ('classifiers', None,
    2:          "print the list of classifiers"),
               ('keywords', None,
    2:          "print the list of keywords"),
               ('provides', None,
    2:          "print the list of packages/modules provided"),
               ('requires', None,
    2:          "print the list of packages/modules required"),
               ('obsoletes', None,
    2:          "print the list of packages/modules made obsolete")
               ]
   44:     display_option_names = map(lambda x: translate_longopt(x[0]),
    2:                                display_options)
       
           # negative options are options that exclude other options
    2:     negative_opt = {'quiet': 'verbose'}
       
       
           # -- Creation/initialization methods -------------------------------
       
    2:     def __init__ (self, attrs=None):
               """Construct a new Distribution instance: initialize all the
               attributes of a Distribution, and then use 'attrs' (a dictionary
               mapping attribute names to values) to assign some of those
               attributes their "real" values.  (Any attributes not mentioned in
               'attrs' will be assigned to some null value: 0, None, an empty list
               or dictionary, etc.)  Most importantly, initialize the
               'command_obj' attribute to the empty dictionary; this will be
               filled in with real command objects by 'parse_command_line()'.
               """
       
               # Default values for our command-line options
  154:         self.verbose = 1
  154:         self.dry_run = 0
  154:         self.help = 0
 3388:         for attr in self.display_option_names:
 3234:             setattr(self, attr, 0)
       
               # Store the distribution meta-data (name, version, author, and so
               # forth) in a separate object -- we're getting to have enough
               # information here (and enough command-line options) that it's
               # worth it.  Also delegate 'get_XXX()' methods to the 'metadata'
               # object in a sneaky and underhanded (but efficient!) way.
  154:         self.metadata = DistributionMetadata()
 3388:         for basename in self.metadata._METHOD_BASENAMES:
 3234:             method_name = "get_" + basename
 3234:             setattr(self, method_name, getattr(self.metadata, method_name))
       
               # 'cmdclass' maps command names to class objects, so we
               # can 1) quickly figure out which class to instantiate when
               # we need to create a new command object, and 2) have a way
               # for the setup script to override command classes
  154:         self.cmdclass = {}
       
               # 'command_packages' is a list of packages in which commands
               # are searched for.  The factory for command 'foo' is expected
               # to be named 'foo' in the module 'foo' in one of the packages
               # named here.  This list is searched from the left; an error
               # is raised if no named package provides the command being
               # searched for.  (Always access using get_command_packages().)
  154:         self.command_packages = None
       
               # 'script_name' and 'script_args' are usually set to sys.argv[0]
               # and sys.argv[1:], but they can be overridden when the caller is
               # not necessarily a setup script run from the command-line.
  154:         self.script_name = None
  154:         self.script_args = None
       
               # 'command_options' is where we store command options between
               # parsing them (from config files, the command-line, etc.) and when
               # they are actually needed -- ie. when the command in question is
               # instantiated.  It is a dictionary of dictionaries of 2-tuples:
               #   command_options = { command_name : { option : (source, value) } }
  154:         self.command_options = {}
       
               # 'dist_files' is the list of (command, pyversion, file) that
               # have been created by any dist commands run so far. This is
               # filled regardless of whether the run is dry or not. pyversion
               # gives sysconfig.get_python_version() if the dist file is
               # specific to a Python version, 'any' if it is good for all
               # Python versions on the target platform, and '' for a source
               # file. pyversion should not be used to specify minimum or
               # maximum required Python versions; use the metainfo for that
               # instead.
  154:         self.dist_files = []
       
               # These options are really the business of various commands, rather
               # than of the Distribution itself.  We provide aliases for them in
               # Distribution as a convenience to the developer.
  154:         self.packages = None
  154:         self.package_data = {}
  154:         self.package_dir = None
  154:         self.py_modules = None
  154:         self.libraries = None
  154:         self.headers = None
  154:         self.ext_modules = None
  154:         self.ext_package = None
  154:         self.include_dirs = None
  154:         self.extra_path = None
  154:         self.scripts = None
  154:         self.data_files = None
  154:         self.password = ''
       
               # And now initialize bookkeeping stuff that can't be supplied by
               # the caller at all.  'command_obj' maps command names to
               # Command instances -- that's how we enforce that every command
               # class is a singleton.
  154:         self.command_obj = {}
       
               # 'have_run' maps command names to boolean values; it keeps track
               # of whether we have actually run a particular command, to make it
               # cheap to "run" a command whenever we think we might need to -- if
               # it's already been done, no need for expensive filesystem
               # operations, we just check the 'have_run' dictionary and carry on.
               # It's only safe to query 'have_run' for a command class that has
               # been instantiated -- a false value will be inserted when the
               # command object is created, and replaced with a true value when
               # the command is successfully run.  Thus it's probably best to use
               # '.get()' rather than a straight lookup.
  154:         self.have_run = {}
       
               # Now we'll use the attrs dictionary (ultimately, keyword args from
               # the setup script) to possibly override any or all of these
               # distribution options.
       
  154:         if attrs:
                   # Pull out the set of command options and work on them
                   # specifically.  Note that this order guarantees that aliased
                   # command options will override any supplied redundantly
                   # through the general options dictionary.
   68:             options = attrs.get('options')
   68:             if options is not None:
    1:                 del attrs['options']
    1:                 for (command, cmd_options) in options.items():
>>>>>>                     opt_dict = self.get_option_dict(command)
>>>>>>                     for (opt, val) in cmd_options.items():
>>>>>>                         opt_dict[opt] = ("setup script", val)
       
   68:             if 'licence' in attrs:
>>>>>>                 attrs['license'] = attrs['licence']
>>>>>>                 del attrs['licence']
>>>>>>                 msg = "'licence' distribution option is deprecated; use 'license'"
>>>>>>                 if warnings is not None:
>>>>>>                     warnings.warn(msg)
                       else:
>>>>>>                     sys.stderr.write(msg + "\n")
       
                   # Now work on the rest of the attributes.  Any attribute that's
                   # not already defined is invalid!
  288:             for (key, val) in attrs.items():
  223:                 if hasattr(self.metadata, "set_" + key):
    7:                     getattr(self.metadata, "set_" + key)(val)
  216:                 elif hasattr(self.metadata, key):
  182:                     setattr(self.metadata, key, val)
   34:                 elif hasattr(self, key):
   34:                     setattr(self, key, val)
                       else:
>>>>>>                     msg = "Unknown distribution option: %s" % repr(key)
>>>>>>                     if warnings is not None:
>>>>>>                         warnings.warn(msg)
                           else:
>>>>>>                         sys.stderr.write(msg + "\n")
       
               # no-user-cfg is handled before other command line args
               # because other args override the config files, and this
               # one is needed before we can load the config files.
               # If attrs['script_args'] wasn't passed, assume false.
               #
               # This also make sure we just look at the global options
  151:         self.want_user_cfg = True
       
  151:         if self.script_args is not None:
   11:             for arg in self.script_args:
    9:                 if not arg.startswith('-'):
    2:                     break
    7:                 if arg == '--no-user-cfg':
    1:                     self.want_user_cfg = False
    1:                     break
       
  151:         self.finalize_options()
       
    2:     def get_option_dict(self, command):
               """Get the option dictionary for a given command.  If that
               command's option dictionary hasn't been created yet, then create it
               and return the new dictionary; otherwise, return the existing
               option dictionary.
               """
   14:         dict = self.command_options.get(command)
   14:         if dict is None:
   14:             dict = self.command_options[command] = {}
   14:         return dict
       
    2:     def dump_option_dicts(self, header=None, commands=None, indent=""):
    2:         from pprint import pformat
       
    2:         if commands is None:             # dump all command option dicts
    2:             commands = self.command_options.keys()
    2:             commands.sort()
       
    2:         if header is not None:
>>>>>>             self.announce(indent + header)
>>>>>>             indent = indent + "  "
       
    2:         if not commands:
    2:             self.announce(indent + "no commands known yet")
    2:             return
       
>>>>>>         for cmd_name in commands:
>>>>>>             opt_dict = self.command_options.get(cmd_name)
>>>>>>             if opt_dict is None:
>>>>>>                 self.announce(indent +
>>>>>>                               "no option dict for '%s' command" % cmd_name)
                   else:
>>>>>>                 self.announce(indent +
>>>>>>                               "option dict for '%s' command:" % cmd_name)
>>>>>>                 out = pformat(opt_dict)
>>>>>>                 for line in out.split('\n'):
>>>>>>                     self.announce(indent + "  " + line)
       
           # -- Config file finding/parsing methods ---------------------------
       
    2:     def find_config_files(self):
               """Find as many configuration files as should be processed for this
               platform, and return a list of filenames in the order in which they
               should be parsed.  The filenames returned are guaranteed to exist
               (modulo nasty race conditions).
       
               There are three possible config files: distutils.cfg in the
               Distutils installation directory (ie. where the top-level
               Distutils __inst__.py file lives), a file in the user's home
               directory named .pydistutils.cfg on Unix and pydistutils.cfg
               on Windows/Mac; and setup.cfg in the current directory.
       
               The file in the user's home directory can be disabled with the
               --no-user-cfg option.
               """
    7:         files = []
    7:         check_environ()
       
               # Where to look for the system-wide Distutils config file
    7:         sys_dir = os.path.dirname(sys.modules['distutils'].__file__)
       
               # Look for the system config file
    7:         sys_file = os.path.join(sys_dir, "distutils.cfg")
    7:         if os.path.isfile(sys_file):
>>>>>>             files.append(sys_file)
       
               # What to call the per-user config file
    7:         if os.name == 'posix':
    7:             user_filename = ".pydistutils.cfg"
               else:
>>>>>>             user_filename = "pydistutils.cfg"
       
               # And look for the user config file
    7:         if self.want_user_cfg:
    6:             user_file = os.path.join(os.path.expanduser('~'), user_filename)
    6:             if os.path.isfile(user_file):
    2:                 files.append(user_file)
       
               # All platforms support local setup.cfg
    7:         local_file = "setup.cfg"
    7:         if os.path.isfile(local_file):
>>>>>>             files.append(local_file)
       
    7:         if DEBUG:
>>>>>>             self.announce("using config files: %s" % ', '.join(files))
       
    7:         return files
       
    2:     def parse_config_files(self, filenames=None):
   11:         from ConfigParser import ConfigParser
       
   11:         if filenames is None:
   11:             filenames = self.find_config_files()
       
   11:         if DEBUG:
    1:             self.announce("Distribution.parse_config_files():")
       
   11:         parser = ConfigParser()
   16:         for filename in filenames:
    5:             if DEBUG:
    1:                 self.announce("  reading %s" % filename)
    5:             parser.read(filename)
   10:             for section in parser.sections():
    5:                 options = parser.options(section)
    5:                 opt_dict = self.get_option_dict(section)
       
   10:                 for opt in options:
    5:                     if opt != '__name__':
    5:                         val = parser.get(section,opt)
    5:                         opt = opt.replace('-', '_')
    5:                         opt_dict[opt] = (filename, val)
       
                   # Make the ConfigParser forget everything (so we retain
                   # the original filenames that options come from)
    5:             parser.__init__()
       
               # If there was a "global" section in the config file, use it
               # to set Distribution options.
       
   11:         if 'global' in self.command_options:
   10:             for (opt, (src, val)) in self.command_options['global'].items():
    5:                 alias = self.negative_opt.get(opt)
    5:                 try:
    5:                     if alias:
>>>>>>                         setattr(self, alias, not strtobool(val))
    5:                     elif opt in ('verbose', 'dry_run'): # ugh!
>>>>>>                         setattr(self, opt, strtobool(val))
                           else:
    5:                         setattr(self, opt, val)
>>>>>>                 except ValueError, msg:
>>>>>>                     raise DistutilsOptionError, msg
       
           # -- Command-line parsing methods ----------------------------------
       
    2:     def parse_command_line(self):
               """Parse the setup script's command line, taken from the
               'script_args' instance attribute (which defaults to 'sys.argv[1:]'
               -- see 'setup()' in core.py).  This list is first processed for
               "global options" -- options that set attributes of the Distribution
               instance.  Then, it is alternately scanned for Distutils commands
               and options for that command.  Each new command terminates the
               options for the previous command.  The allowed options for a
               command are determined by the 'user_options' attribute of the
               command class -- thus, we have to be able to load command classes
               in order to parse the command line.  Any error in that 'options'
               attribute raises DistutilsGetoptError; any error on the
               command-line raises DistutilsArgError.  If no Distutils commands
               were found on the command line, raises DistutilsArgError.  Return
               true if command-line was successfully parsed and we should carry
               on with executing commands; false if no errors but we shouldn't
               execute commands (currently, this only happens if user asks for
               help).
               """
               #
               # We now have enough information to show the Macintosh dialog
               # that allows the user to interactively specify the "command line".
               #
   14:         toplevel_options = self._get_toplevel_options()
       
               # We have to parse the command line a bit at a time -- global
               # options, then the first command, then its options, and so on --
               # because each command will be handled by a different class, and
               # the options that are valid for a particular class aren't known
               # until we have loaded the command class, which doesn't happen
               # until we know what the command is.
       
   14:         self.commands = []
   14:         parser = FancyGetopt(toplevel_options + self.display_options)
   14:         parser.set_negative_aliases(self.negative_opt)
   14:         parser.set_aliases({'licence': 'license'})
   14:         args = parser.getopt(args=self.script_args, object=self)
   12:         option_order = parser.get_option_order()
   12:         log.set_verbosity(self.verbose)
       
               # for display options we return immediately
   12:         if self.handle_display_options(option_order):
    2:             return
   19:         while args:
    9:             args = self._parse_command_opts(parser, args)
    9:             if args is None:            # user asked for help (and got it)
>>>>>>                 return
       
               # Handle the cases of --help as a "global" option, ie.
               # "setup.py --help" and "setup.py --help command ...".  For the
               # former, we show global options (--verbose, --dry-run, etc.)
               # and display-only options (--name, --version, etc.); for the
               # latter, we omit the display-only options and show help for
               # each command listed on the command line.
   10:         if self.help:
    1:             self._show_help(parser,
    1:                             display_options=len(self.commands) == 0,
    1:                             commands=self.commands)
    1:             return
       
               # Oops, no commands found -- an end-user error
    9:         if not self.commands:
>>>>>>             raise DistutilsArgError, "no commands supplied"
       
               # All is well: return true
    9:         return 1
       
    2:     def _get_toplevel_options(self):
               """Return the non-display options recognized at the top level.
       
               This includes options that are recognized *only* at the top
               level as well as options recognized for commands.
               """
   15:         return self.global_options + [
                   ("command-packages=", None,
   15:              "list of packages that provide distutils commands"),
                   ]
       
    2:     def _parse_command_opts(self, parser, args):
               """Parse the command-line options for a single command.
               'parser' must be a FancyGetopt instance; 'args' must be the list
               of arguments, starting with the current command (whose options
               we are about to parse).  Returns a new version of 'args' with
               the next command at the front of the list; will be the empty
               list if there are no more commands on the command line.  Returns
               None if the user asked for help on this command.
               """
               # late import because of mutual dependence between these modules
    9:         from distutils.cmd import Command
       
               # Pull the current command from the head of the command line
    9:         command = args[0]
    9:         if not command_re.match(command):
>>>>>>             raise SystemExit, "invalid command name '%s'" % command
    9:         self.commands.append(command)
       
               # Dig up the command class that implements this command, so we
               # 1) know that it's a valid command, and 2) know which options
               # it takes.
    9:         try:
    9:             cmd_class = self.get_command_class(command)
>>>>>>         except DistutilsModuleError, msg:
>>>>>>             raise DistutilsArgError, msg
       
               # Require that the command class be derived from Command -- want
               # to be sure that the basic "command" interface is implemented.
    9:         if not issubclass(cmd_class, Command):
>>>>>>             raise DistutilsClassError, \
>>>>>>                   "command class %s must subclass Command" % cmd_class
       
               # Also make sure that the command object provides a list of its
               # known options.
    9:         if not (hasattr(cmd_class, 'user_options') and
    9:                 isinstance(cmd_class.user_options, list)):
>>>>>>             raise DistutilsClassError, \
>>>>>>                   ("command class %s must provide " +
>>>>>>                    "'user_options' attribute (a list of tuples)") % \
>>>>>>                   cmd_class
       
               # If the command class has a list of negative alias options,
               # merge it in with the global negative aliases.
    9:         negative_opt = self.negative_opt
    9:         if hasattr(cmd_class, 'negative_opt'):
>>>>>>             negative_opt = negative_opt.copy()
>>>>>>             negative_opt.update(cmd_class.negative_opt)
       
               # Check for help_options in command class.  They have a different
               # format (tuple of four) so we need to preprocess them here.
    9:         if (hasattr(cmd_class, 'help_options') and
    8:             isinstance(cmd_class.help_options, list)):
    8:             help_options = fix_help_options(cmd_class.help_options)
               else:
    1:             help_options = []
       
       
               # All commands support the global options too, just by adding
               # in 'global_options'.
    9:         parser.set_option_table(self.global_options +
    9:                                 cmd_class.user_options +
    9:                                 help_options)
    9:         parser.set_negative_aliases(negative_opt)
    9:         (args, opts) = parser.getopt(args[1:])
    9:         if hasattr(opts, 'help') and opts.help:
>>>>>>             self._show_help(parser, display_options=0, commands=[cmd_class])
>>>>>>             return
       
    9:         if (hasattr(cmd_class, 'help_options') and
    8:             isinstance(cmd_class.help_options, list)):
    8:             help_option_found=0
   16:             for (help_option, short, desc, func) in cmd_class.help_options:
    8:                 if hasattr(opts, parser.get_attr_name(help_option)):
>>>>>>                     help_option_found=1
>>>>>>                     if hasattr(func, '__call__'):
>>>>>>                         func()
                           else:
>>>>>>                         raise DistutilsClassError(
>>>>>>                             "invalid help function %r for help option '%s': "
                                   "must be a callable object (function, etc.)"
>>>>>>                             % (func, help_option))
       
    8:             if help_option_found:
>>>>>>                 return
       
               # Put the options from the command-line into their official
               # holding pen, the 'command_options' dictionary.
    9:         opt_dict = self.get_option_dict(command)
   10:         for (name, value) in vars(opts).items():
    1:             opt_dict[name] = ("command line", value)
       
    9:         return args
       
    2:     def finalize_options(self):
               """Set final values for all the options on the Distribution
               instance, analogous to the .finalize_options() method of Command
               objects.
               """
  456:         for attr in ('keywords', 'platforms'):
  304:             value = getattr(self.metadata, attr)
  304:             if value is None:
  299:                 continue
    5:             if isinstance(value, str):
    6:                 value = [elm.strip() for elm in value.split(',')]
    2:                 setattr(self.metadata, attr, value)
       
    2:     def _show_help(self, parser, global_options=1, display_options=1,
    2:                    commands=[]):
               """Show help for the setup script command-line in the form of
               several lists of command-line options.  'parser' should be a
               FancyGetopt instance; do not expect it to be returned in the
               same state, as its option table will be reset to make it
               generate the correct help text.
       
               If 'global_options' is true, lists the global options:
               --verbose, --dry-run, etc.  If 'display_options' is true, lists
               the "display-only" options: --name, --version, etc.  Finally,
               lists per-command help for every command name or command class
               in 'commands'.
               """
               # late import because of mutual dependence between these modules
    1:         from distutils.core import gen_usage
    1:         from distutils.cmd import Command
       
    1:         if global_options:
    1:             if display_options:
    1:                 options = self._get_toplevel_options()
                   else:
>>>>>>                 options = self.global_options
    1:             parser.set_option_table(options)
    1:             parser.print_help(self.common_usage + "\nGlobal options:")
    1:             print('')
       
    1:         if display_options:
    1:             parser.set_option_table(self.display_options)
    1:             parser.print_help(
    1:                 "Information display options (just display " +
    1:                 "information, ignore any commands)")
    1:             print('')
       
    1:         for command in self.commands:
>>>>>>             if isinstance(command, type) and issubclass(command, Command):
>>>>>>                 klass = command
                   else:
>>>>>>                 klass = self.get_command_class(command)
>>>>>>             if (hasattr(klass, 'help_options') and
>>>>>>                 isinstance(klass.help_options, list)):
>>>>>>                 parser.set_option_table(klass.user_options +
>>>>>>                                         fix_help_options(klass.help_options))
                   else:
>>>>>>                 parser.set_option_table(klass.user_options)
>>>>>>             parser.print_help("Options for '%s' command:" % klass.__name__)
>>>>>>             print('')
       
    1:         print(gen_usage(self.script_name))
       
    2:     def handle_display_options(self, option_order):
               """If there were any non-global "display-only" options
               (--help-commands or the metadata display options) on the command
               line, display the requested info and return true; else return
               false.
               """
   12:         from distutils.core import gen_usage
       
               # User just wants a list of commands -- we'll print it out and stop
               # processing now (ie. if they ran "setup --help-commands foo bar",
               # we ignore "foo bar").
   12:         if self.help_commands:
>>>>>>             self.print_commands()
>>>>>>             print('')
>>>>>>             print(gen_usage(self.script_name))
>>>>>>             return 1
       
               # If user supplied any of the "display metadata" options, then
               # display that metadata in the order in which the user supplied the
               # metadata options.
   12:         any_display_options = 0
   12:         is_display_option = {}
  264:         for option in self.display_options:
  252:             is_display_option[option[0]] = 1
       
   17:         for (opt, val) in option_order:
    5:             if val and is_display_option.get(opt):
    2:                 opt = translate_longopt(opt)
    2:                 value = getattr(self.metadata, "get_"+opt)()
    2:                 if opt in ['keywords', 'platforms']:
>>>>>>                     print(','.join(value))
    2:                 elif opt in ('classifiers', 'provides', 'requires',
    2:                              'obsoletes'):
>>>>>>                     print('\n'.join(value))
                       else:
    2:                     print(value)
    2:                 any_display_options = 1
       
   12:         return any_display_options
       
    2:     def print_command_list(self, commands, header, max_length):
               """Print a subset of the list of all commands -- used by
               'print_commands()'.
               """
>>>>>>         print(header + ":")
       
>>>>>>         for cmd in commands:
>>>>>>             klass = self.cmdclass.get(cmd)
>>>>>>             if not klass:
>>>>>>                 klass = self.get_command_class(cmd)
>>>>>>             try:
>>>>>>                 description = klass.description
>>>>>>             except AttributeError:
>>>>>>                 description = "(no description available)"
       
>>>>>>             print("  %-*s  %s" % (max_length, cmd, description))
       
    2:     def print_commands(self):
               """Print out a help message listing all available commands with a
               description of each.  The list is divided into "standard commands"
               (listed in distutils.command.__all__) and "extra commands"
               (mentioned in self.cmdclass, but not a standard command).  The
               descriptions come from the command class attribute
               'description'.
               """
>>>>>>         import distutils.command
>>>>>>         std_commands = distutils.command.__all__
>>>>>>         is_std = {}
>>>>>>         for cmd in std_commands:
>>>>>>             is_std[cmd] = 1
       
>>>>>>         extra_commands = []
>>>>>>         for cmd in self.cmdclass.keys():
>>>>>>             if not is_std.get(cmd):
>>>>>>                 extra_commands.append(cmd)
       
>>>>>>         max_length = 0
>>>>>>         for cmd in (std_commands + extra_commands):
>>>>>>             if len(cmd) > max_length:
>>>>>>                 max_length = len(cmd)
       
>>>>>>         self.print_command_list(std_commands,
>>>>>>                                 "Standard commands",
>>>>>>                                 max_length)
>>>>>>         if extra_commands:
>>>>>>             print
>>>>>>             self.print_command_list(extra_commands,
>>>>>>                                     "Extra commands",
>>>>>>                                     max_length)
       
    2:     def get_command_list(self):
               """Get a list of (command, description) tuples.
               The list is divided into "standard commands" (listed in
               distutils.command.__all__) and "extra commands" (mentioned in
               self.cmdclass, but not a standard command).  The descriptions come
               from the command class attribute 'description'.
               """
               # Currently this is only used on Mac OS, for the Mac-only GUI
               # Distutils interface (by Jack Jansen)
       
>>>>>>         import distutils.command
>>>>>>         std_commands = distutils.command.__all__
>>>>>>         is_std = {}
>>>>>>         for cmd in std_commands:
>>>>>>             is_std[cmd] = 1
       
>>>>>>         extra_commands = []
>>>>>>         for cmd in self.cmdclass.keys():
>>>>>>             if not is_std.get(cmd):
>>>>>>                 extra_commands.append(cmd)
       
>>>>>>         rv = []
>>>>>>         for cmd in (std_commands + extra_commands):
>>>>>>             klass = self.cmdclass.get(cmd)
>>>>>>             if not klass:
>>>>>>                 klass = self.get_command_class(cmd)
>>>>>>             try:
>>>>>>                 description = klass.description
>>>>>>             except AttributeError:
>>>>>>                 description = "(no description available)"
>>>>>>             rv.append((cmd, description))
>>>>>>         return rv
       
           # -- Command class/object methods ----------------------------------
       
    2:     def get_command_packages(self):
               """Return a list of packages from which commands are loaded."""
  117:         pkgs = self.command_packages
  117:         if not isinstance(pkgs, list):
   59:             if pkgs is None:
   52:                 pkgs = ''
  123:             pkgs = [pkg.strip() for pkg in pkgs.split(',') if pkg != '']
   59:             if "distutils.command" not in pkgs:
   59:                 pkgs.insert(0, "distutils.command")
   59:             self.command_packages = pkgs
  117:         return pkgs
       
    2:     def get_command_class(self, command):
               """Return the class that implements the Distutils command named by
               'command'.  First we check the 'cmdclass' dictionary; if the
               command is mentioned there, we fetch the class object from the
               dictionary and return it.  Otherwise we load the command module
               ("distutils.command." + command) and fetch the command class from
               the module.  The loaded class is also stored in 'cmdclass'
               to speed future calls to 'get_command_class()'.
       
               Raises DistutilsModuleError if the expected module could not be
               found, or if that module does not define the expected class.
               """
  113:         klass = self.cmdclass.get(command)
  113:         if klass:
    3:             return klass
       
  112:         for pkgname in self.get_command_packages():
  112:             module_name = "%s.%s" % (pkgname, command)
  112:             klass_name = command
       
  112:             try:
  112:                 __import__ (module_name)
  110:                 module = sys.modules[module_name]
    2:             except ImportError:
    2:                 continue
       
  110:             try:
  110:                 klass = getattr(module, klass_name)
>>>>>>             except AttributeError:
>>>>>>                 raise DistutilsModuleError, \
>>>>>>                       "invalid command '%s' (no class '%s' in module '%s')" \
>>>>>>                       % (command, klass_name, module_name)
       
  110:             self.cmdclass[command] = klass
  110:             return klass
       
>>>>>>         raise DistutilsModuleError("invalid command '%s'" % command)
       
       
    2:     def get_command_obj(self, command, create=1):
               """Return the command object for 'command'.  Normally this object
               is cached on a previous call to 'get_command_obj()'; if no command
               object for 'command' is in the cache, then we either create and
               return it (if 'create' is true) or return None.
               """
  207:         cmd_obj = self.command_obj.get(command)
  207:         if not cmd_obj and create:
  104:             if DEBUG:
>>>>>>                 self.announce("Distribution.get_command_obj(): " \
>>>>>>                               "creating '%s' command object" % command)
       
  104:             klass = self.get_command_class(command)
  104:             cmd_obj = self.command_obj[command] = klass(self)
  104:             self.have_run[command] = 0
       
                   # Set any options that were supplied in config files
                   # or on the command line.  (NB. support for error
                   # reporting is lame here: any errors aren't reported
                   # until 'finalize_options()' is called, which means
                   # we won't report the source of the error.)
  104:             options = self.command_options.get(command)
  104:             if options:
    4:                 self._set_command_options(cmd_obj, options)
       
  207:         return cmd_obj
       
    2:     def _set_command_options(self, command_obj, option_dict=None):
               """Set the options for 'command_obj' from 'option_dict'.  Basically
               this means copying elements of a dictionary ('option_dict') to
               attributes of an instance ('command').
       
               'command_obj' must be a Command instance.  If 'option_dict' is not
               supplied, uses the standard option dictionary for this command
               (from 'self.command_options').
               """
    4:         command_name = command_obj.get_command_name()
    4:         if option_dict is None:
>>>>>>             option_dict = self.get_option_dict(command_name)
       
    4:         if DEBUG:
>>>>>>             self.announce("  setting options for '%s' command:" % command_name)
   11:         for (option, (source, value)) in option_dict.items():
    7:             if DEBUG:
>>>>>>                 self.announce("    %s = %s (from %s)" % (option, value,
>>>>>>                                                          source))
    7:             try:
    7:                 bool_opts = map(translate_longopt, command_obj.boolean_options)
    1:             except AttributeError:
    1:                 bool_opts = []
    7:             try:
    7:                 neg_opt = command_obj.negative_opt
    7:             except AttributeError:
    7:                 neg_opt = {}
       
    7:             try:
    7:                 is_string = isinstance(value, str)
    7:                 if option in neg_opt and is_string:
>>>>>>                     setattr(command_obj, neg_opt[option], not strtobool(value))
    7:                 elif option in bool_opts and is_string:
>>>>>>                     setattr(command_obj, option, strtobool(value))
    7:                 elif hasattr(command_obj, option):
    7:                     setattr(command_obj, option, value)
                       else:
>>>>>>                     raise DistutilsOptionError, \
>>>>>>                           ("error in %s: command '%s' has no such option '%s'"
>>>>>>                            % (source, command_name, option))
>>>>>>             except ValueError, msg:
>>>>>>                 raise DistutilsOptionError, msg
       
    2:     def reinitialize_command(self, command, reinit_subcommands=0):
               """Reinitializes a command to the state it was in when first
               returned by 'get_command_obj()': ie., initialized but not yet
               finalized.  This provides the opportunity to sneak option
               values in programmatically, overriding or supplementing
               user-supplied values from the config files and command line.
               You'll have to re-finalize the command object (by calling
               'finalize_options()' or 'ensure_finalized()') before using it for
               real.
       
               'command' should be a command name (string) or command object.  If
               'reinit_subcommands' is true, also reinitializes the command's
               sub-commands, as declared by the 'sub_commands' class attribute (if
               it has one).  See the "install" command for an example.  Only
               reinitializes the sub-commands that actually matter, ie. those
               whose test predicates return true.
       
               Returns the reinitialized command object.
               """
    1:         from distutils.cmd import Command
    1:         if not isinstance(command, Command):
    1:             command_name = command
    1:             command = self.get_command_obj(command_name)
               else:
>>>>>>             command_name = command.get_command_name()
       
    1:         if not command.finalized:
    1:             return command
>>>>>>         command.initialize_options()
>>>>>>         command.finalized = 0
>>>>>>         self.have_run[command_name] = 0
>>>>>>         self._set_command_options(command)
       
>>>>>>         if reinit_subcommands:
>>>>>>             for sub in command.get_sub_commands():
>>>>>>                 self.reinitialize_command(sub, reinit_subcommands)
       
>>>>>>         return command
       
           # -- Methods that operate on the Distribution ----------------------
       
    2:     def announce(self, msg, level=log.INFO):
    5:         log.log(level, msg)
       
    2:     def run_commands(self):
               """Run each command that was seen on the setup script command line.
               Uses the list of commands found and cache of command objects
               created by 'get_command_obj()'.
               """
    4:         for cmd in self.commands:
    2:             self.run_command(cmd)
       
           # -- Methods that operate on its Commands --------------------------
       
    2:     def run_command(self, command):
               """Do whatever it takes to run a command (including nothing at all,
               if the command has already been run).  Specifically: if we have
               already created and run the command named by 'command', return
               silently without doing anything.  If the command named by 'command'
               doesn't even have a command object yet, create one.  Then invoke
               'run()' on that command object (or an existing one).
               """
               # Already been here, done that? then return silently.
   46:         if self.have_run.get(command):
    9:             return
       
   37:         log.info("running %s", command)
   37:         cmd_obj = self.get_command_obj(command)
   37:         cmd_obj.ensure_finalized()
   37:         cmd_obj.run()
   35:         self.have_run[command] = 1
       
       
           # -- Distribution query methods ------------------------------------
       
    2:     def has_pure_modules(self):
   33:         return len(self.packages or self.py_modules or []) > 0
       
    2:     def has_ext_modules(self):
   27:         return self.ext_modules and len(self.ext_modules) > 0
       
    2:     def has_c_libraries(self):
   25:         return self.libraries and len(self.libraries) > 0
       
    2:     def has_modules(self):
>>>>>>         return self.has_pure_modules() or self.has_ext_modules()
       
    2:     def has_headers(self):
    5:         return self.headers and len(self.headers) > 0
       
    2:     def has_scripts(self):
   23:         return self.scripts and len(self.scripts) > 0
       
    2:     def has_data_files(self):
   17:         return self.data_files and len(self.data_files) > 0
       
    2:     def is_pure(self):
>>>>>>         return (self.has_pure_modules() and
>>>>>>                 not self.has_ext_modules() and
>>>>>>                 not self.has_c_libraries())
       
           # -- Metadata query methods ----------------------------------------
       
           # If you're looking for 'get_name()', 'get_version()', and so forth,
           # they are defined in a sneaky way: the constructor binds self.get_XXX
           # to self.metadata.get_XXX.  The actual code is in the
           # DistributionMetadata class, below.
       
    4: class DistributionMetadata:
           """Dummy class to hold the distribution meta-data: name, version,
           author, and so forth.
    2:     """
       
           _METHOD_BASENAMES = ("name", "version", "author", "author_email",
                                "maintainer", "maintainer_email", "url",
                                "license", "description", "long_description",
                                "keywords", "platforms", "fullname", "contact",
                                "contact_email", "license", "classifiers",
                                "download_url",
                                # PEP 314
    2:                          "provides", "requires", "obsoletes",
                                )
       
    2:     def __init__(self, path=None):
  154:         if path is not None:
>>>>>>             self.read_pkg_file(open(path))
               else:
  154:             self.name = None
  154:             self.version = None
  154:             self.author = None
  154:             self.author_email = None
  154:             self.maintainer = None
  154:             self.maintainer_email = None
  154:             self.url = None
  154:             self.license = None
  154:             self.description = None
  154:             self.long_description = None
  154:             self.keywords = None
  154:             self.platforms = None
  154:             self.classifiers = None
  154:             self.download_url = None
                   # PEP 314
  154:             self.provides = None
  154:             self.requires = None
  154:             self.obsoletes = None
       
    2:     def read_pkg_file(self, file):
               """Reads the metadata values from a file object."""
    1:         msg = message_from_file(file)
       
    1:         def _read_field(name):
   11:             value = msg[name]
   11:             if value == 'UNKNOWN':
    4:                 return None
    7:             return value
       
    1:         def _read_list(name):
    5:             values = msg.get_all(name, None)
    5:             if values == []:
>>>>>>                 return None
    5:             return values
       
    1:         metadata_version = msg['metadata-version']
    1:         self.name = _read_field('name')
    1:         self.version = _read_field('version')
    1:         self.description = _read_field('summary')
               # we are filling author only.
    1:         self.author = _read_field('author')
    1:         self.maintainer = None
    1:         self.author_email = _read_field('author-email')
    1:         self.maintainer_email = None
    1:         self.url = _read_field('home-page')
    1:         self.license = _read_field('license')
       
    1:         if 'download-url' in msg:
    1:             self.download_url = _read_field('download-url')
               else:
>>>>>>             self.download_url = None
       
    1:         self.long_description = _read_field('description')
    1:         self.description = _read_field('summary')
       
    1:         if 'keywords' in msg:
    1:             self.keywords = _read_field('keywords').split(',')
       
    1:         self.platforms = _read_list('platform')
    1:         self.classifiers = _read_list('classifier')
       
               # PEP 314 - these fields only exist in 1.1
    1:         if metadata_version == '1.1':
    1:             self.requires = _read_list('requires')
    1:             self.provides = _read_list('provides')
    1:             self.obsoletes = _read_list('obsoletes')
               else:
>>>>>>             self.requires = None
>>>>>>             self.provides = None
>>>>>>             self.obsoletes = None
       
    2:     def write_pkg_info(self, base_dir):
               """Write the PKG-INFO file into the release tree.
               """
   14:         pkg_info = open(os.path.join(base_dir, 'PKG-INFO'), 'w')
   14:         try:
   14:             self.write_pkg_file(pkg_info)
               finally:
   14:             pkg_info.close()
       
    2:     def write_pkg_file(self, file):
               """Write the PKG-INFO format data to a file object.
               """
   27:         version = '1.0'
   27:         if (self.provides or self.requires or self.obsoletes or
   23:             self.classifiers or self.download_url):
    6:             version = '1.1'
       
   27:         self._write_field(file, 'Metadata-Version', version)
   27:         self._write_field(file, 'Name', self.get_name())
   27:         self._write_field(file, 'Version', self.get_version())
   27:         self._write_field(file, 'Summary', self.get_description())
   27:         self._write_field(file, 'Home-page', self.get_url())
   27:         self._write_field(file, 'Author', self.get_contact())
   27:         self._write_field(file, 'Author-email', self.get_contact_email())
   27:         self._write_field(file, 'License', self.get_license())
   27:         if self.download_url:
    2:             self._write_field(file, 'Download-URL', self.download_url)
       
   27:         long_desc = rfc822_escape(self.get_long_description())
   27:         self._write_field(file, 'Description', long_desc)
       
   27:         keywords = ','.join(self.get_keywords())
   27:         if keywords:
    1:             self._write_field(file, 'Keywords', keywords)
       
   27:         self._write_list(file, 'Platform', self.get_platforms())
   27:         self._write_list(file, 'Classifier', self.get_classifiers())
       
               # PEP 314
   27:         self._write_list(file, 'Requires', self.get_requires())
   27:         self._write_list(file, 'Provides', self.get_provides())
   27:         self._write_list(file, 'Obsoletes', self.get_obsoletes())
       
    2:     def _write_field(self, file, name, value):
  281:         file.write('%s: %s\n' % (name, self._encode_field(value)))
       
    2:     def _write_list (self, file, name, values):
  170:         for value in values:
   35:             self._write_field(file, name, value)
       
    2:     def _encode_field(self, value):
  407:         if value is None:
   99:             return None
  308:         if isinstance(value, unicode):
    7:             return value.encode(PKG_INFO_ENCODING)
  301:         return str(value)
       
           # -- Metadata query methods ----------------------------------------
       
    2:     def get_name(self):
   85:         return self.name or "UNKNOWN"
       
    2:     def get_version(self):
   83:         return self.version or "0.0.0"
       
    2:     def get_fullname(self):
   38:         return "%s-%s" % (self.get_name(), self.get_version())
       
    2:     def get_author(self):
>>>>>>         return self._encode_field(self.author) or "UNKNOWN"
       
    2:     def get_author_email(self):
>>>>>>         return self.author_email or "UNKNOWN"
       
    2:     def get_maintainer(self):
>>>>>>         return self._encode_field(self.maintainer) or "UNKNOWN"
       
    2:     def get_maintainer_email(self):
>>>>>>         return self.maintainer_email or "UNKNOWN"
       
    2:     def get_contact(self):
   32:         return (self._encode_field(self.maintainer) or
   30:                 self._encode_field(self.author) or "UNKNOWN")
       
    2:     def get_contact_email(self):
   32:         return self.maintainer_email or self.author_email or "UNKNOWN"
       
    2:     def get_url(self):
   32:         return self.url or "UNKNOWN"
       
    2:     def get_license(self):
   32:         return self.license or "UNKNOWN"
    2:     get_licence = get_license
       
    2:     def get_description(self):
   32:         return self._encode_field(self.description) or "UNKNOWN"
       
    2:     def get_long_description(self):
   32:         return self._encode_field(self.long_description) or "UNKNOWN"
       
    2:     def get_keywords(self):
   32:         return self.keywords or []
       
    2:     def get_platforms(self):
   32:         return self.platforms or ["UNKNOWN"]
       
    2:     def get_classifiers(self):
   32:         return self.classifiers or []
       
    2:     def get_download_url(self):
    5:         return self.download_url or "UNKNOWN"
       
           # PEP 314
    2:     def get_requires(self):
   34:         return self.requires or []
       
    2:     def set_requires(self, value):
    3:         import distutils.versionpredicate
    6:         for v in value:
    4:             distutils.versionpredicate.VersionPredicate(v)
    2:         self.requires = value
       
    2:     def get_provides(self):
   34:         return self.provides or []
       
    2:     def set_provides(self, value):
    5:         value = [v.strip() for v in value]
    4:         for v in value:
    3:             import distutils.versionpredicate
    3:             distutils.versionpredicate.split_provision(v)
    1:         self.provides = value
       
    2:     def get_obsoletes(self):
   34:         return self.obsoletes or []
       
    2:     def set_obsoletes(self, value):
    2:         import distutils.versionpredicate
    4:         for v in value:
    3:             distutils.versionpredicate.VersionPredicate(v)
    1:         self.obsoletes = value
       
    2: def fix_help_options(options):
           """Convert a 4-tuple 'help_options' list as found in various command
           classes to the 3-tuple form required by FancyGetopt.
           """
    9:     new_options = []
   19:     for help_tuple in options:
   10:         new_options.append(help_tuple[0:3])
    9:     return new_options
