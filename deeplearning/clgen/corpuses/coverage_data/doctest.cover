       # Module doctest.
       # Released to the public domain 16-Jan-2001, by Tim Peters (tim@python.org).
       # Major enhancements and refactoring by:
       #     Jim Fulton
       #     Edward Loper
       
       # Provided as-is; use at your own risk; no warranty; no promises; enjoy!
       
       r"""Module doctest -- a framework for running examples in docstrings.
       
       In simplest use, end each module M to be tested with:
       
       def _test():
           import doctest
           doctest.testmod()
       
       if __name__ == "__main__":
           _test()
       
       Then running the module as a script will cause the examples in the
       docstrings to get executed and verified:
       
       python M.py
       
       This won't display anything unless an example fails, in which case the
       failing example(s) and the cause(s) of the failure(s) are printed to stdout
       (why not stderr? because stderr is a lame hack <0.2 wink>), and the final
       line of output is "Test failed.".
       
       Run it with the -v switch instead:
       
       python M.py -v
       
       and a detailed report of all examples tried is printed to stdout, along
       with assorted summaries at the end.
       
       You can force verbose mode by passing "verbose=True" to testmod, or prohibit
       it by passing "verbose=False".  In either of those cases, sys.argv is not
       examined by testmod.
       
       There are a variety of other ways to run doctests, including integration
       with the unittest framework, and support for running non-Python text
       files containing doctests.  There are also many ways to override parts
       of doctest's default behaviors.  See the Library Reference Manual for
       details.
    1: """
       
    1: __docformat__ = 'reStructuredText en'
       
       __all__ = [
           # 0, Option Flags
    1:     'register_optionflag',
    1:     'DONT_ACCEPT_TRUE_FOR_1',
    1:     'DONT_ACCEPT_BLANKLINE',
    1:     'NORMALIZE_WHITESPACE',
    1:     'ELLIPSIS',
    1:     'SKIP',
    1:     'IGNORE_EXCEPTION_DETAIL',
    1:     'COMPARISON_FLAGS',
    1:     'REPORT_UDIFF',
    1:     'REPORT_CDIFF',
    1:     'REPORT_NDIFF',
    1:     'REPORT_ONLY_FIRST_FAILURE',
    1:     'REPORTING_FLAGS',
           # 1. Utility Functions
           # 2. Example & DocTest
    1:     'Example',
    1:     'DocTest',
           # 3. Doctest Parser
    1:     'DocTestParser',
           # 4. Doctest Finder
    1:     'DocTestFinder',
           # 5. Doctest Runner
    1:     'DocTestRunner',
    1:     'OutputChecker',
    1:     'DocTestFailure',
    1:     'UnexpectedException',
    1:     'DebugRunner',
           # 6. Test Functions
    1:     'testmod',
    1:     'testfile',
    1:     'run_docstring_examples',
           # 7. Tester
    1:     'Tester',
           # 8. Unittest Support
    1:     'DocTestSuite',
    1:     'DocFileSuite',
    1:     'set_unittest_reportflags',
           # 9. Debugging Support
    1:     'script_from_examples',
    1:     'testsource',
    1:     'debug_src',
    1:     'debug',
       ]
       
    1: import __future__
       
    1: import sys, traceback, inspect, linecache, os, re
    1: import unittest, difflib, pdb, tempfile
    1: import warnings
    1: from StringIO import StringIO
    1: from collections import namedtuple
       
    1: TestResults = namedtuple('TestResults', 'failed attempted')
       
       # There are 4 basic classes:
       #  - Example: a <source, want> pair, plus an intra-docstring line number.
       #  - DocTest: a collection of examples, parsed from a docstring, plus
       #    info about where the docstring came from (name, filename, lineno).
       #  - DocTestFinder: extracts DocTests from a given object's docstring and
       #    its contained objects' docstrings.
       #  - DocTestRunner: runs DocTest cases, and accumulates statistics.
       #
       # So the basic picture is:
       #
       #                             list of:
       # +------+                   +---------+                   +-------+
       # |object| --DocTestFinder-> | DocTest | --DocTestRunner-> |results|
       # +------+                   +---------+                   +-------+
       #                            | Example |
       #                            |   ...   |
       #                            | Example |
       #                            +---------+
       
       # Option constants.
       
    1: OPTIONFLAGS_BY_NAME = {}
    1: def register_optionflag(name):
           # Create a new flag unless `name` is already known.
   14:     return OPTIONFLAGS_BY_NAME.setdefault(name, 1 << len(OPTIONFLAGS_BY_NAME))
       
    1: DONT_ACCEPT_TRUE_FOR_1 = register_optionflag('DONT_ACCEPT_TRUE_FOR_1')
    1: DONT_ACCEPT_BLANKLINE = register_optionflag('DONT_ACCEPT_BLANKLINE')
    1: NORMALIZE_WHITESPACE = register_optionflag('NORMALIZE_WHITESPACE')
    1: ELLIPSIS = register_optionflag('ELLIPSIS')
    1: SKIP = register_optionflag('SKIP')
    1: IGNORE_EXCEPTION_DETAIL = register_optionflag('IGNORE_EXCEPTION_DETAIL')
       
       COMPARISON_FLAGS = (DONT_ACCEPT_TRUE_FOR_1 |
                           DONT_ACCEPT_BLANKLINE |
                           NORMALIZE_WHITESPACE |
                           ELLIPSIS |
    1:                     SKIP |
    1:                     IGNORE_EXCEPTION_DETAIL)
       
    1: REPORT_UDIFF = register_optionflag('REPORT_UDIFF')
    1: REPORT_CDIFF = register_optionflag('REPORT_CDIFF')
    1: REPORT_NDIFF = register_optionflag('REPORT_NDIFF')
    1: REPORT_ONLY_FIRST_FAILURE = register_optionflag('REPORT_ONLY_FIRST_FAILURE')
       
       REPORTING_FLAGS = (REPORT_UDIFF |
                          REPORT_CDIFF |
    1:                    REPORT_NDIFF |
    1:                    REPORT_ONLY_FIRST_FAILURE)
       
       # Special string markers for use in `want` strings:
    1: BLANKLINE_MARKER = '<BLANKLINE>'
    1: ELLIPSIS_MARKER = '...'
       
       ######################################################################
       ## Table of Contents
       ######################################################################
       #  1. Utility Functions
       #  2. Example & DocTest -- store test cases
       #  3. DocTest Parser -- extracts examples from strings
       #  4. DocTest Finder -- extracts test cases from objects
       #  5. DocTest Runner -- runs test cases
       #  6. Test Functions -- convenient wrappers for testing
       #  7. Tester Class -- for backwards compatibility
       #  8. Unittest Support
       #  9. Debugging Support
       # 10. Example Usage
       
       ######################################################################
       ## 1. Utility Functions
       ######################################################################
       
    1: def _extract_future_flags(globs):
           """
           Return the compiler-flags associated with the future features that
           have been imported into the given namespace (globs).
           """
 1676:     flags = 0
13408:     for fname in __future__.all_feature_names:
11732:         feature = globs.get(fname, None)
11732:         if feature is getattr(__future__, fname):
   40:             flags |= feature.compiler_flag
 1676:     return flags
       
    1: def _normalize_module(module, depth=2):
           """
           Return the module specified by `module`.  In particular:
             - If `module` is a module, then return module.
             - If `module` is a string, then import and return the
               module with that name.
             - If `module` is None, then return the calling module.
               The calling module is assumed to be the module of
               the stack frame at the given depth in the call stack.
           """
   62:     if inspect.ismodule(module):
   39:         return module
   23:     elif isinstance(module, (str, unicode)):
   13:         return __import__(module, globals(), locals(), ["*"])
   10:     elif module is None:
   10:         return sys.modules[sys._getframe(depth).f_globals['__name__']]
           else:
>>>>>>         raise TypeError("Expected a module, string, or None")
       
    1: def _load_testfile(filename, package, module_relative):
   31:     if module_relative:
   30:         package = _normalize_module(package, 3)
   30:         filename = _module_relative_path(package, filename)
   30:         if hasattr(package, '__loader__'):
    7:             if hasattr(package.__loader__, 'get_data'):
    7:                 file_contents = package.__loader__.get_data(filename)
                       # get_data() opens files as 'rb', so one must do the equivalent
                       # conversion as universal newlines would do.
    7:                 return file_contents.replace(os.linesep, '\n'), filename
   24:     with open(filename, 'U') as f:
   24:         return f.read(), filename
       
       # Use sys.stdout encoding for output.
    1: _encoding = getattr(sys.__stdout__, 'encoding', None) or 'utf-8'
       
    1: def _indent(s, indent=4):
           """
           Add the given number of space characters to the beginning of
           every non-blank line in `s`, and return the result.
           If the string `s` is Unicode, it is encoded using the stdout
           encoding and the `backslashreplace` error handler.
           """
  326:     if isinstance(s, unicode):
    2:         s = s.encode(_encoding, 'backslashreplace')
           # This regexp matches the start of non-blank lines:
  326:     return re.sub('(?m)^(?!$)', indent*' ', s)
       
    1: def _exception_traceback(exc_info):
           """
           Return a string containing a traceback message for the given
           exc_info tuple (as returned by sys.exc_info()).
           """
           # Get a traceback message.
  263:     excout = StringIO()
  263:     exc_type, exc_val, exc_tb = exc_info
  263:     traceback.print_exception(exc_type, exc_val, exc_tb, file=excout)
  263:     return excout.getvalue()
       
       # Override some StringIO methods.
    2: class _SpoofOut(StringIO):
    1:     def getvalue(self):
 6238:         result = StringIO.getvalue(self)
               # If anything at all was written, make sure there's a trailing
               # newline.  There's no way for the expected output to indicate
               # that a trailing newline is missing.
 6238:         if result and not result.endswith("\n"):
   44:             result += "\n"
               # Prevent softspace from screwing up the next test case, in
               # case they used print with a trailing comma in an example.
 6238:         if hasattr(self, "softspace"):
 1791:             del self.softspace
 6238:         return result
       
    1:     def truncate(self,   size=None):
 3119:         StringIO.truncate(self, size)
 3119:         if hasattr(self, "softspace"):
>>>>>>             del self.softspace
 3119:         if not self.buf:
                   # Reset it to an empty string, to make sure it's not unicode.
 3119:             self.buf = ''
       
       # Worst-case linear-time ellipsis matching.
    1: def _ellipsis_match(want, got):
           """
           Essentially the only subtle case:
           >>> _ellipsis_match('aa...aa', 'aaa')
           False
           """
   84:     if ELLIPSIS_MARKER not in want:
>>>>>>         return want == got
       
           # Find "the real" strings.
   84:     ws = want.split(ELLIPSIS_MARKER)
   84:     assert len(ws) >= 2
       
           # Deal with exact matches possibly needed at one or both ends.
   84:     startpos, endpos = 0, len(got)
   84:     w = ws[0]
   84:     if w:   # starts with exact match
   84:         if got.startswith(w):
   84:             startpos = len(w)
   84:             del ws[0]
               else:
>>>>>>             return False
   84:     w = ws[-1]
   84:     if w:   # ends with exact match
   84:         if got.endswith(w):
   84:             endpos -= len(w)
   84:             del ws[-1]
               else:
>>>>>>             return False
       
   84:     if startpos > endpos:
               # Exact end matches required more characters than we have, as in
               # _ellipsis_match('aa...aa', 'aaa')
    1:         return False
       
           # For the rest, we only need to find the leftmost non-overlapping
           # match for each piece.  If there's no overall match that way alone,
           # there's no overall match period.
  123:     for w in ws:
               # w may be '' at times, if there are consecutive ellipses, or
               # due to an ellipsis at the start or end of `want`.  That's OK.
               # Search for an empty string succeeds, and doesn't change startpos.
   40:         startpos = got.find(w, startpos, endpos)
   40:         if startpos < 0:
>>>>>>             return False
   40:         startpos += len(w)
       
   83:     return True
       
    1: def _comment_line(line):
           "Return a commented form of the given line"
   15:     line = line.rstrip()
   15:     if line:
    5:         return '# '+line
           else:
   10:         return '#'
       
    1: def _strip_exception_details(msg):
           # Support for IGNORE_EXCEPTION_DETAIL.
           # Get rid of everything except the exception name; in particular, drop
           # the possibly dotted module path (if any) and the exception message (if
           # any).  We assume that a colon is never part of a dotted name, or of an
           # exception name.
           # E.g., given
           #    "foo.bar.MyError: la di da"
           # return "MyError"
           # Or for "abc.def" or "abc.def:\n" return "def".
       
   24:     start, end = 0, len(msg)
           # The exception name must appear on the first line.
   24:     i = msg.find("\n")
   24:     if i >= 0:
   24:         end = i
           # retain up to the first colon (if any)
   24:     i = msg.find(':', 0, end)
   24:     if i >= 0:
   18:         end = i
           # retain just the exception name
   24:     i = msg.rfind('.', 0, end)
   24:     if i >= 0:
    6:         start = i+1
   24:     return msg[start: end]
       
    2: class _OutputRedirectingPdb(pdb.Pdb):
           """
           A specialized version of the python debugger that redirects stdout
           to a given stream when interacting with the user.  Stdout is *not*
           redirected when traced code is executed.
    1:     """
    1:     def __init__(self, out):
 1676:         self.__out = out
 1676:         self.__debugger_used = False
 1676:         pdb.Pdb.__init__(self, stdout=out)
               # still use input() to get user input
 1676:         self.use_rawinput = 1
       
    1:     def set_trace(self, frame=None):
>>>>>>         self.__debugger_used = True
>>>>>>         if frame is None:
>>>>>>             frame = sys._getframe().f_back
>>>>>>         pdb.Pdb.set_trace(self, frame)
       
    1:     def set_continue(self):
               # Calling set_continue unconditionally would break unit test
               # coverage reporting, as Bdb.set_continue calls sys.settrace(None).
 3119:         if self.__debugger_used:
>>>>>>             pdb.Pdb.set_continue(self)
       
    1:     def trace_dispatch(self, *args):
               # Redirect stdout to the given stream.
>>>>>>         save_stdout = sys.stdout
>>>>>>         sys.stdout = self.__out
               # Call Pdb's trace dispatch method.
>>>>>>         try:
>>>>>>             return pdb.Pdb.trace_dispatch(self, *args)
               finally:
>>>>>>             sys.stdout = save_stdout
       
       # [XX] Normalize with respect to os.path.pardir?
    1: def _module_relative_path(module, path):
   30:     if not inspect.ismodule(module):
>>>>>>         raise TypeError, 'Expected a module: %r' % module
   30:     if path.startswith('/'):
>>>>>>         raise ValueError, 'Module-relative files may not have absolute paths'
       
           # Find the base directory for the path.
   30:     if hasattr(module, '__file__'):
               # A normal module/package
   29:         basedir = os.path.split(module.__file__)[0]
    1:     elif module.__name__ == '__main__':
               # An interactive session.
    1:         if len(sys.argv)>0 and sys.argv[0] != '':
    1:             basedir = os.path.split(sys.argv[0])[0]
               else:
>>>>>>             basedir = os.curdir
           else:
               # A module w/o __file__ (this includes builtins)
>>>>>>         raise ValueError("Can't resolve paths relative to the module " +
>>>>>>                          module + " (it has no __file__)")
       
           # Combine the base directory and the path.
   30:     return os.path.join(basedir, *(path.split('/')))
       
       ######################################################################
       ## 2. Example & DocTest
       ######################################################################
       ## - An "example" is a <source, want> pair, where "source" is a
       ##   fragment of source code, and "want" is the expected output for
       ##   "source."  The Example class also includes information about
       ##   where the example was extracted from.
       ##
       ## - A "doctest" is a collection of examples, typically extracted from
       ##   a string (such as an object's docstring).  The DocTest class also
       ##   includes information about where the string was extracted from.
       
    2: class Example:
           """
           A single doctest example, consisting of source code and expected
           output.  `Example` defines the following attributes:
       
             - source: A single Python statement, always ending with a newline.
               The constructor adds a newline if needed.
       
             - want: The expected output from running the source code (either
               from stdout, or a traceback in case of exception).  `want` ends
               with a newline unless it's empty, in which case it's an empty
               string.  The constructor adds a newline if needed.
       
             - exc_msg: The exception message generated by the example, if
               the example is expected to generate an exception; or `None` if
               it is not expected to generate an exception.  This exception
               message is compared against the return value of
               `traceback.format_exception_only()`.  `exc_msg` ends with a
               newline unless it's `None`.  The constructor adds a newline
               if needed.
       
             - lineno: The line number within the DocTest string containing
               this Example where the Example begins.  This line number is
               zero-based, with respect to the beginning of the DocTest.
       
             - indent: The example's indentation in the DocTest string.
               I.e., the number of space characters that precede the
               example's first prompt.
       
             - options: A dictionary mapping from option flags to True or
               False, which is used to override default options for this
               example.  Any option flags not contained in this dictionary
               are left at their default value (as specified by the
               DocTestRunner's optionflags).  By default, no options are set.
    1:     """
    1:     def __init__(self, source, want, exc_msg=None, lineno=0, indent=0,
    1:                  options=None):
               # Normalize inputs.
 3352:         if not source.endswith('\n'):
 3298:             source += '\n'
 3352:         if want and not want.endswith('\n'):
 1992:             want += '\n'
 3352:         if exc_msg is not None and not exc_msg.endswith('\n'):
  205:             exc_msg += '\n'
               # Store properties.
 3352:         self.source = source
 3352:         self.want = want
 3352:         self.lineno = lineno
 3352:         self.indent = indent
 3352:         if options is None: options = {}
 3352:         self.options = options
 3352:         self.exc_msg = exc_msg
       
    1:     def __eq__(self, other):
   20:         if type(self) is not type(other):
>>>>>>             return NotImplemented
       
   20:         return self.source == other.source and \
   12:                self.want == other.want and \
   12:                self.lineno == other.lineno and \
   12:                self.indent == other.indent and \
   12:                self.options == other.options and \
   12:                self.exc_msg == other.exc_msg
       
    1:     def __ne__(self, other):
    4:         return not self == other
       
    1:     def __hash__(self):
    4:         return hash((self.source, self.want, self.lineno, self.indent,
    4:                      self.exc_msg))
       
       
    2: class DocTest:
           """
           A collection of doctest examples that should be run in a single
           namespace.  Each `DocTest` defines the following attributes:
       
             - examples: the list of examples.
       
             - globs: The namespace (aka globals) that the examples should
               be run in.
       
             - name: A name identifying the DocTest (typically, the name of
               the object whose docstring this DocTest was extracted from).
       
             - filename: The name of the file that this DocTest was extracted
               from, or `None` if the filename is unknown.
       
             - lineno: The line number within filename where this DocTest
               begins, or `None` if the line number is unavailable.  This
               line number is zero-based, with respect to the beginning of
               the file.
       
             - docstring: The string that the examples were extracted from,
               or `None` if the string is unavailable.
    1:     """
    1:     def __init__(self, examples, globs, name, filename, lineno, docstring):
               """
               Create a new DocTest containing the given examples.  The
               DocTest's globals are initialized with a copy of `globs`.
               """
 1829:         assert not isinstance(examples, basestring), \
>>>>>>                "DocTest no longer accepts str; use DocTestParser instead"
 1829:         self.examples = examples
 1829:         self.docstring = docstring
 1829:         self.globs = globs.copy()
 1829:         self.name = name
 1829:         self.filename = filename
 1829:         self.lineno = lineno
       
    1:     def __repr__(self):
    6:         if len(self.examples) == 0:
    1:             examples = 'no examples'
    5:         elif len(self.examples) == 1:
    1:             examples = '1 example'
               else:
    4:             examples = '%d examples' % len(self.examples)
    6:         return ('<DocTest %s from %s:%s (%s)>' %
    6:                 (self.name, self.filename, self.lineno, examples))
       
    1:     def __eq__(self, other):
   16:         if type(self) is not type(other):
    4:             return NotImplemented
       
   12:         return self.examples == other.examples and \
    8:                self.docstring == other.docstring and \
    8:                self.globs == other.globs and \
    8:                self.name == other.name and \
    8:                self.filename == other.filename and \
    8:                self.lineno == other.lineno
       
    1:     def __ne__(self, other):
    6:         return not self == other
       
    1:     def __hash__(self):
    4:         return hash((self.docstring, self.name, self.filename, self.lineno))
       
           # This lets us sort tests by name:
    1:     def __cmp__(self, other):
 7648:         if not isinstance(other, DocTest):
    4:             return -1
 7644:         return cmp((self.name, self.filename, self.lineno, id(self)),
 7644:                    (other.name, other.filename, other.lineno, id(other)))
       
       ######################################################################
       ## 3. DocTestParser
       ######################################################################
       
    2: class DocTestParser:
           """
           A class used to parse strings containing doctest examples.
    1:     """
           # This regular expression is used to find doctest examples in a
           # string.  It defines three groups: `source` is the source code
           # (including leading indentation and prompts); `indent` is the
           # indentation of the first (PS1) line of the source code; and
           # `want` is the expected output (including leading indentation).
    1:     _EXAMPLE_RE = re.compile(r'''
               # Source consists of a PS1 line followed by zero or more PS2 lines.
               (?P<source>
                   (?:^(?P<indent> [ ]*) >>>    .*)    # PS1 line
                   (?:\n           [ ]*  \.\.\. .*)*)  # PS2 lines
               \n?
               # Want consists of any non-blank lines that do not start with PS1.
               (?P<want> (?:(?![ ]*$)    # Not a blank line
                            (?![ ]*>>>)  # Not a line starting with PS1
                            .+$\n?       # But any other line
                         )*)
    1:         ''', re.MULTILINE | re.VERBOSE)
       
           # A regular expression for handling `want` strings that contain
           # expected exceptions.  It divides `want` into three pieces:
           #    - the traceback header line (`hdr`)
           #    - the traceback stack (`stack`)
           #    - the exception message (`msg`), as generated by
           #      traceback.format_exception_only()
           # `msg` may have multiple lines.  We assume/require that the
           # exception message is the first non-indented line starting with a word
           # character following the traceback header line.
    1:     _EXCEPTION_RE = re.compile(r"""
               # Grab the traceback header.  Different versions of Python have
               # said different things on the first traceback line.
               ^(?P<hdr> Traceback\ \(
                   (?: most\ recent\ call\ last
                   |   innermost\ last
                   ) \) :
               )
               \s* $                # toss trailing whitespace on the header.
               (?P<stack> .*?)      # don't blink: absorb stuff until...
               ^ (?P<msg> \w+ .*)   #     a line *starts* with alphanum.
    1:         """, re.VERBOSE | re.MULTILINE | re.DOTALL)
       
           # A callable returning a true value iff its argument is a blank line
           # or contains a single comment.
    1:     _IS_BLANK_OR_COMMENT = re.compile(r'^[ ]*(#.*)?$').match
       
    1:     def parse(self, string, name='<string>'):
               """
               Divide the given string into examples and intervening text,
               and return them as a list of alternating Examples and strings.
               Line numbers for the Examples are 0-based.  The optional
               argument `name` is a name identifying this string, and is only
               used for error messages.
               """
 1850:         string = string.expandtabs()
               # If all lines begin with the same indentation, then strip it.
 1850:         min_indent = self._min_indent(string)
 1850:         if min_indent > 0:
 3489:             string = '\n'.join([l[min_indent:] for l in string.split('\n')])
       
 1850:         output = []
 1850:         charno, lineno = 0, 0
               # Find all doctest examples in the string:
 5253:         for m in self._EXAMPLE_RE.finditer(string):
                   # Add the pre-example text to `output`.
 3417:             output.append(string[charno:m.start()])
                   # Update lineno (lines before this example)
 3417:             lineno += string.count('\n', charno, m.start())
                   # Extract info from the regexp match.
                   (source, options, want, exc_msg) = \
 3417:                      self._parse_example(m, name, lineno)
                   # Create an Example, and add it to the list.
 3403:             if not self._IS_BLANK_OR_COMMENT(source):
 3316:                 output.append( Example(source, want, exc_msg,
 3316:                                     lineno=lineno,
 3316:                                     indent=min_indent+len(m.group('indent')),
 3316:                                     options=options) )
                   # Update lineno (lines inside this example)
 3403:             lineno += string.count('\n', m.start(), m.end())
                   # Update charno.
 3403:             charno = m.end()
               # Add any remaining post-example text to `output`.
 1836:         output.append(string[charno:])
 1836:         return output
       
    1:     def get_doctest(self, string, globs, name, filename, lineno):
               """
               Extract all doctest examples from the given string, and
               collect them into a `DocTest` object.
       
               `globs`, `name`, `filename`, and `lineno` are attributes for
               the new `DocTest` object.  See the documentation for `DocTest`
               for more information.
               """
 1843:         return DocTest(self.get_examples(string, name), globs,
 1829:                        name, filename, lineno, string)
       
    1:     def get_examples(self, string, name='<string>'):
               """
               Extract all doctest examples from the given string, and return
               them as a list of `Example` objects.  Line numbers are
               0-based, because it's most common in doctests that nothing
               interesting appears on the same line as opening triple-quote,
               and so the first interesting line is called \"line 1\" then.
       
               The optional argument `name` is a name identifying this
               string, and is only used for error messages.
               """
10369:         return [x for x in self.parse(string, name)
 8524:                 if isinstance(x, Example)]
       
    1:     def _parse_example(self, m, name, lineno):
               """
               Given a regular expression match from `_EXAMPLE_RE` (`m`),
               return a pair `(source, want)`, where `source` is the matched
               example's source code (with prompts and indentation stripped);
               and `want` is the example's expected output (with indentation
               stripped).
       
               `name` is the string's name, and `lineno` is the line number
               where the example starts; both are used for error messages.
               """
               # Get the example's indentation level.
 3417:         indent = len(m.group('indent'))
       
               # Divide source into lines; check that they're properly
               # indented; and then strip their indentation & prompts.
 3417:         source_lines = m.group('source').split('\n')
 3417:         self._check_prompt_blank(source_lines, indent, name, lineno)
 3413:         self._check_prefix(source_lines[1:], ' '*indent + '.', name, lineno)
 8808:         source = '\n'.join([sl[indent+4:] for sl in source_lines])
       
               # Divide want into lines; check that it's properly indented; and
               # then strip the indentation.  Spaces before the last newline should
               # be preserved, so plain rstrip() isn't good enough.
 3411:         want = m.group('want')
 3411:         want_lines = want.split('\n')
 3411:         if len(want_lines) > 1 and re.match(r' *$', want_lines[-1]):
 1986:             del want_lines[-1]  # forget final newline & spaces after it
 3411:         self._check_prefix(want_lines, ' '*indent, name,
 3411:                            lineno + len(source_lines))
 8948:         want = '\n'.join([wl[indent:] for wl in want_lines])
       
               # If `want` contains a traceback message, then extract it.
 3409:         m = self._EXCEPTION_RE.match(want)
 3409:         if m:
  197:             exc_msg = m.group('msg')
               else:
 3212:             exc_msg = None
       
               # Extract options from the source.
 3409:         options = self._find_options(source, name, lineno)
       
 3403:         return source, options, want, exc_msg
       
           # This regular expression looks for option directives in the
           # source code of an example.  Option directives are comments
           # starting with "doctest:".  Warning: this may give false
           # positives for string-literals that contain the string
           # "#doctest:".  Eliminating these false positives would require
           # actually parsing the string; but we limit them by ignoring any
           # line containing "#doctest:" that is *followed* by a quote mark.
    1:     _OPTION_DIRECTIVE_RE = re.compile(r'#\s*doctest:\s*([^\n\'"]*)$',
    1:                                       re.MULTILINE)
       
    1:     def _find_options(self, source, name, lineno):
               """
               Return a dictionary containing option overrides extracted from
               option directives in the given source string.
       
               `name` is the string's name, and `lineno` is the line number
               where the example starts; both are used for error messages.
               """
 3409:         options = {}
               # (note: with the current regexp, this will match at most once:)
 3567:         for m in self._OPTION_DIRECTIVE_RE.finditer(source):
  162:             option_strings = m.group(1).replace(',', ' ').split()
  332:             for option in option_strings:
  174:                 if (option[0] not in '+-' or
  172:                     option[1:] not in OPTIONFLAGS_BY_NAME):
    4:                     raise ValueError('line %r of the doctest for %s '
                                            'has an invalid option: %r' %
    4:                                      (lineno+1, name, option))
  170:                 flag = OPTIONFLAGS_BY_NAME[option[1:]]
  170:                 options[flag] = (option[0] == '+')
 3405:         if options and self._IS_BLANK_OR_COMMENT(source):
    2:             raise ValueError('line %r of the doctest for %s has an option '
                                    'directive on a line with no example: %r' %
    2:                              (lineno, name, source))
 3403:         return options
       
           # This regular expression finds the indentation of every non-blank
           # line in a string.
    1:     _INDENT_RE = re.compile('^([ ]*)(?=\S)', re.MULTILINE)
       
    1:     def _min_indent(self, s):
               "Return the minimum indentation of any non-blank line in `s`"
15172:         indents = [len(indent) for indent in self._INDENT_RE.findall(s)]
 1850:         if len(indents) > 0:
  976:             return min(indents)
               else:
  874:             return 0
       
    1:     def _check_prompt_blank(self, lines, indent, name, lineno):
               """
               Given the lines of a source string (including prompts and
               leading indentation), check to make sure that every prompt is
               followed by a space character.  If any line is not followed by
               a space character, then raise ValueError.
               """
 8820:         for i, line in enumerate(lines):
 5407:             if len(line) >= indent+4 and line[indent+3] != ' ':
    4:                 raise ValueError('line %r of the docstring for %s '
                                        'lacks blank after %s: %r' %
    4:                                  (lineno+i+1, name,
    4:                                   line[indent:indent+3], line))
       
    1:     def _check_prefix(self, lines, prefix, name, lineno):
               """
               Check that every line in the given list starts with the given
               prefix; if any line does not, then raise a ValueError.
               """
14351:         for i, line in enumerate(lines):
 7531:             if line and not line.startswith(prefix):
    4:                 raise ValueError('line %r of the docstring for %s has '
                                        'inconsistent leading whitespace: %r' %
    4:                                  (lineno+i+1, name, line))
       
       
       ######################################################################
       ## 4. DocTest Finder
       ######################################################################
       
    2: class DocTestFinder:
           """
           A class used to extract the DocTests that are relevant to a given
           object, from its docstring and the docstrings of its contained
           objects.  Doctests can currently be extracted from the following
           object types: modules, functions, classes, methods, staticmethods,
           classmethods, and properties.
    1:     """
       
    1:     def __init__(self, verbose=False, parser=DocTestParser(),
    1:                  recurse=True, exclude_empty=True):
               """
               Create a new doctest finder.
       
               The optional argument `parser` specifies a class or
               function that should be used to create new DocTest objects (or
               objects that implement the same interface as DocTest).  The
               signature for this factory function should match the signature
               of the DocTest constructor.
       
               If the optional argument `recurse` is false, then `find` will
               only examine the given object, and not any contained objects.
       
               If the optional argument `exclude_empty` is false, then `find`
               will include tests for objects with empty docstrings.
               """
  173:         self._parser = parser
  173:         self._verbose = verbose
  173:         self._recurse = recurse
  173:         self._exclude_empty = exclude_empty
       
    1:     def find(self, obj, name=None, module=None, globs=None, extraglobs=None):
               """
               Return a list of the DocTests that are defined by the given
               object's docstring, or by any of its contained objects'
               docstrings.
       
               The optional parameter `module` is the module that contains
               the given object.  If the module is not specified or is None, then
               the test finder will attempt to automatically determine the
               correct module.  The object's module is used:
       
                   - As a default namespace, if `globs` is not specified.
                   - To prevent the DocTestFinder from extracting DocTests
                     from objects that are imported from other modules.
                   - To find the name of the file containing the object.
                   - To help find the line number of the object within its
                     file.
       
               Contained objects whose module does not match `module` are ignored.
       
               If `module` is False, no attempt to find the module will be made.
               This is obscure, of use mostly in tests:  if `module` is False, or
               is None but cannot be found automatically, then all objects are
               considered to belong to the (non-existent) module, so all contained
               objects will (recursively) be searched for doctests.
       
               The globals for each DocTest is formed by combining `globs`
               and `extraglobs` (bindings in `extraglobs` override bindings
               in `globs`).  A new copy of the globals dictionary is created
               for each DocTest.  If `globs` is not specified, then it
               defaults to the module's `__dict__`, if specified, or {}
               otherwise.  If `extraglobs` is not specified, then it defaults
               to {}.
       
               """
               # If name was not specified, then extract it from the object.
  173:         if name is None:
  114:             name = getattr(obj, '__name__', None)
  114:             if name is None:
>>>>>>                 raise ValueError("DocTestFinder.find: name must be given "
                               "when obj.__name__ doesn't exist: %r" %
>>>>>>                                  (type(obj),))
       
               # Find the module that contains the given object (if obj is
               # a module, then module=obj.).  Note: this may fail, in which
               # case module will be None.
  173:         if module is False:
    2:             module = None
  171:         elif module is None:
  141:             module = inspect.getmodule(obj)
       
               # Read the module's source code.  This is used by
               # DocTestFinder._find_lineno to find the line number for a
               # given object's docstring.
  173:         try:
  173:             file = inspect.getsourcefile(obj) or inspect.getfile(obj)
  164:             if module is not None:
                       # Supply the module globals in case the module was
                       # originally loaded via a PEP 302 loader and
                       # file is not a valid filesystem path
  164:                 source_lines = linecache.getlines(file, module.__dict__)
                   else:
                       # No access to a loader, so assume it's a normal
                       # filesystem path
>>>>>>                 source_lines = linecache.getlines(file)
  164:             if not source_lines:
>>>>>>                 source_lines = None
    9:         except TypeError:
    9:             source_lines = None
       
               # Initialize globals, and merge in extraglobs.
  173:         if globs is None:
  166:             if module is None:
>>>>>>                 globs = {}
                   else:
  166:                 globs = module.__dict__.copy()
               else:
    7:             globs = globs.copy()
  173:         if extraglobs is not None:
    1:             globs.update(extraglobs)
  173:         if '__name__' not in globs:
    7:             globs['__name__'] = '__main__'  # provide a default module name
       
               # Recursively explore `obj`, extracting DocTests.
  173:         tests = []
  173:         self._find(tests, obj, name, module, source_lines, globs, {})
               # Sort the tests by alpha order of names, for consistency in
               # verbose-mode output.  This was a feature of doctest in Pythons
               # <= 2.3 that got lost by accident in 2.4.  It was repaired in
               # 2.4.4 and 2.5.
  173:         tests.sort()
  173:         return tests
       
    1:     def _from_module(self, module, object):
               """
               Return true if the given object is defined in the given
               module.
               """
 1986:         if module is None:
   16:             return True
 1970:         elif inspect.getmodule(object) is not None:
 1901:             return module is inspect.getmodule(object)
   69:         elif inspect.isfunction(object):
   41:             return module.__dict__ is object.func_globals
   28:         elif inspect.isclass(object):
    8:             return module.__name__ == object.__module__
   20:         elif hasattr(object, '__module__'):
>>>>>>             return module.__name__ == object.__module__
   20:         elif isinstance(object, property):
   20:             return True # [XX] no way not be sure.
               else:
>>>>>>             raise ValueError("object must be a class or function")
       
    1:     def _find(self, tests, obj, name, module, source_lines, globs, seen):
               """
               Find tests for the given object and any contained objects, and
               add them to `tests`.
               """
 2008:         if self._verbose:
>>>>>>             print 'Finding tests in %s' % name
       
               # If we've already processed this object, then ignore it.
 2008:         if id(obj) in seen:
   23:             return
 1985:         seen[id(obj)] = 1
       
               # Find a test for this object, and add it to the list of tests.
 1985:         test = self._get_test(obj, name, module, globs, source_lines)
 1985:         if test is not None:
 1776:             tests.append(test)
       
               # Look for tests in a module's contained objects.
 1985:         if inspect.ismodule(obj) and self._recurse:
 1426:             for valname, val in obj.__dict__.items():
 1372:                 valname = '%s.%s' % (name, valname)
                       # Recurse to functions & classes.
 1372:                 if ((inspect.isfunction(val) or inspect.isclass(val)) and
  674:                     self._from_module(module, val)):
  500:                     self._find(tests, val, valname, module, source_lines,
  500:                                globs, seen)
       
               # Look for tests in a module's __test__ dictionary.
 1985:         if inspect.ismodule(obj) and self._recurse:
  105:             for valname, val in getattr(obj, '__test__', {}).items():
   51:                 if not isinstance(valname, basestring):
>>>>>>                     raise ValueError("DocTestFinder.find: __test__ keys "
                                            "must be strings: %r" %
>>>>>>                                      (type(valname),))
   51:                 if not (inspect.isfunction(val) or inspect.isclass(val) or
   49:                         inspect.ismethod(val) or inspect.ismodule(val) or
   49:                         isinstance(val, basestring)):
>>>>>>                     raise ValueError("DocTestFinder.find: __test__ values "
                                            "must be strings, functions, methods, "
                                            "classes, or modules: %r" %
>>>>>>                                      (type(val),))
   51:                 valname = '%s.__test__.%s' % (name, valname)
   51:                 self._find(tests, val, valname, module, source_lines,
   51:                            globs, seen)
       
               # Look for tests in a class's contained objects.
 1985:         if inspect.isclass(obj) and self._recurse:
 2328:             for valname, val in obj.__dict__.items():
                       # Special handling for staticmethod/classmethod.
 2086:                 if isinstance(val, staticmethod):
   12:                     val = getattr(obj, valname)
 2086:                 if isinstance(val, classmethod):
   14:                     val = getattr(obj, valname).im_func
       
                       # Recurse to methods, properties, and nested classes.
 2086:                 if ((inspect.isfunction(val) or inspect.isclass(val) or
  794:                       isinstance(val, property)) and
 1312:                       self._from_module(module, val)):
 1284:                     valname = '%s.%s' % (name, valname)
 1284:                     self._find(tests, val, valname, module, source_lines,
 1284:                                globs, seen)
       
    1:     def _get_test(self, obj, name, module, globs, source_lines):
               """
               Return a DocTest for the given object, if it defines a docstring;
               otherwise, return None.
               """
               # Extract the object's docstring.  If it doesn't have one,
               # then return None (no test for this object).
 1985:         if isinstance(obj, basestring):
   49:             docstring = obj
               else:
 1936:             try:
 1936:                 if obj.__doc__ is None:
 1083:                     docstring = ''
                       else:
  853:                     docstring = obj.__doc__
  853:                     if not isinstance(docstring, basestring):
>>>>>>                         docstring = str(docstring)
>>>>>>             except (TypeError, AttributeError):
>>>>>>                 docstring = ''
       
               # Find the docstring's location in the file.
 1985:         lineno = self._find_lineno(obj, source_lines)
       
               # Don't bother if the docstring is empty.
 1985:         if self._exclude_empty and not docstring:
  209:             return None
       
               # Return a DocTest for this object.
 1776:         if module is None:
   16:             filename = None
               else:
 1760:             filename = getattr(module, '__file__', module.__name__)
 1760:             if filename[-4:] in (".pyc", ".pyo"):
 1674:                 filename = filename[:-1]
 1776:         return self._parser.get_doctest(docstring, globs, name,
 1776:                                         filename, lineno)
       
    1:     def _find_lineno(self, obj, source_lines):
               """
               Return a line number of the given object's docstring.  Note:
               this method assumes that the object has a docstring.
               """
 1985:         lineno = None
       
               # Find the line number for modules.
 1985:         if inspect.ismodule(obj):
   54:             lineno = 0
       
               # Find the line number for classes.
               # Note: this could be fooled if a class is defined multiple
               # times in a single file.
 1985:         if inspect.isclass(obj):
  246:             if source_lines is None:
   10:                 return None
  236:             pat = re.compile(r'^\s*class\s*%s\b' %
  236:                              getattr(obj, '__name__', '-'))
154810:             for i, line in enumerate(source_lines):
154803:                 if pat.match(line):
  229:                     lineno = i
  229:                     break
       
               # Find the line number for functions & methods.
 1975:         if inspect.ismethod(obj): obj = obj.im_func
 1975:         if inspect.isfunction(obj): obj = obj.func_code
 1975:         if inspect.istraceback(obj): obj = obj.tb_frame
 1975:         if inspect.isframe(obj): obj = obj.f_code
 1975:         if inspect.iscode(obj):
 1615:             lineno = getattr(obj, 'co_firstlineno', None)-1
       
               # Find the line number where the docstring starts.  Assume
               # that it's the first line that begins with a quote mark.
               # Note: this could be fooled by a multiline function
               # signature, where a continuation line begins with a quote
               # mark.
 1975:         if lineno is not None:
 1898:             if source_lines is None:
   42:                 return lineno+1
 1856:             pat = re.compile('(^|.*:)\s*\w*("|\')')
111069:             for lineno in range(lineno, len(source_lines)):
111005:                 if pat.match(source_lines[lineno]):
 1792:                     return lineno
       
               # We couldn't find the line number.
  141:         return None
       
       ######################################################################
       ## 5. DocTest Runner
       ######################################################################
       
    2: class DocTestRunner:
           """
           A class used to run DocTest test cases, and accumulate statistics.
           The `run` method is used to process a single DocTest case.  It
           returns a tuple `(f, t)`, where `t` is the number of test cases
           tried, and `f` is the number of test cases that failed.
       
               >>> tests = DocTestFinder().find(_TestClass)
               >>> runner = DocTestRunner(verbose=False)
               >>> tests.sort(key = lambda test: test.name)
               >>> for test in tests:
               ...     print test.name, '->', runner.run(test)
               _TestClass -> TestResults(failed=0, attempted=2)
               _TestClass.__init__ -> TestResults(failed=0, attempted=2)
               _TestClass.get -> TestResults(failed=0, attempted=2)
               _TestClass.square -> TestResults(failed=0, attempted=1)
       
           The `summarize` method prints a summary of all the test cases that
           have been run by the runner, and returns an aggregated `(f, t)`
           tuple:
       
               >>> runner.summarize(verbose=1)
               4 items passed all tests:
                  2 tests in _TestClass
                  2 tests in _TestClass.__init__
                  2 tests in _TestClass.get
                  1 tests in _TestClass.square
               7 tests in 4 items.
               7 passed and 0 failed.
               Test passed.
               TestResults(failed=0, attempted=7)
       
           The aggregated number of tried examples and failed examples is
           also available via the `tries` and `failures` attributes:
       
               >>> runner.tries
               7
               >>> runner.failures
               0
       
           The comparison between expected outputs and actual outputs is done
           by an `OutputChecker`.  This comparison may be customized with a
           number of option flags; see the documentation for `testmod` for
           more information.  If the option flags are insufficient, then the
           comparison may also be customized by passing a subclass of
           `OutputChecker` to the constructor.
       
           The test runner's display output can be controlled in two ways.
           First, an output function (`out) can be passed to
           `TestRunner.run`; this function will be called with strings that
           should be displayed.  It defaults to `sys.stdout.write`.  If
           capturing the output is not sufficient, then the display output
           can be also customized by subclassing DocTestRunner, and
           overriding the methods `report_start`, `report_success`,
           `report_unexpected_exception`, and `report_failure`.
    1:     """
           # This divider string is used to separate failure messages, and to
           # separate sections of the summary.
    1:     DIVIDER = "*" * 70
       
    1:     def __init__(self, checker=None, verbose=None, optionflags=0):
               """
               Create a new test runner.
       
               Optional keyword arg `checker` is the `OutputChecker` that
               should be used to compare the expected outputs and actual
               outputs of doctest examples.
       
               Optional keyword arg 'verbose' prints lots of stuff if true,
               only failures if false; by default, it's true iff '-v' is in
               sys.argv.
       
               Optional argument `optionflags` can be used to control how the
               test runner compares expected output to actual output, and how
               it displays failures.  See the documentation for `testmod` for
               more information.
               """
  295:         self._checker = checker or OutputChecker()
  295:         if verbose is None:
   14:             verbose = '-v' in sys.argv
  295:         self._verbose = verbose
  295:         self.optionflags = optionflags
  295:         self.original_optionflags = optionflags
       
               # Keep track of the examples we've run.
  295:         self.tries = 0
  295:         self.failures = 0
  295:         self._name2ft = {}
       
               # Create a fake output target for capturing doctest output.
  295:         self._fakeout = _SpoofOut()
       
           #/////////////////////////////////////////////////////////////////
           # Reporting methods
           #/////////////////////////////////////////////////////////////////
       
    1:     def report_start(self, out, test, example):
               """
               Report that the test runner is about to process the given
               example.  (Only displays a message if verbose=True)
               """
 3104:         if self._verbose:
   26:             if example.want:
   18:                 out('Trying:\n' + _indent(example.source) +
   18:                     'Expecting:\n' + _indent(example.want))
                   else:
    8:                 out('Trying:\n' + _indent(example.source) +
    8:                     'Expecting nothing\n')
       
    1:     def report_success(self, out, test, example, got):
               """
               Report that the given example ran successfully.  (Only
               displays a message if verbose=True)
               """
 2989:         if self._verbose:
   22:             out("ok\n")
       
    1:     def report_failure(self, out, test, example, got):
               """
               Report that the given example failed.
               """
   74:         out(self._failure_header(test, example) +
   74:             self._checker.output_difference(example, got, self.optionflags))
       
    1:     def report_unexpected_exception(self, out, test, example, exc_info):
               """
               Report that the given example raised an unexpected exception.
               """
   33:         out(self._failure_header(test, example) +
   33:             'Exception raised:\n' + _indent(_exception_traceback(exc_info)))
       
    1:     def _failure_header(self, test, example):
  107:         out = [self.DIVIDER]
  107:         if test.filename:
  105:             if test.lineno is not None and example.lineno is not None:
   97:                 lineno = test.lineno + example.lineno + 1
                   else:
    8:                 lineno = '?'
  105:             out.append('File "%s", line %s, in %s' %
  105:                        (test.filename, lineno, test.name))
               else:
    2:             out.append('Line %s, in %s' % (example.lineno+1, test.name))
  107:         out.append('Failed example:')
  107:         source = example.source
  107:         out.append(_indent(source))
  107:         return '\n'.join(out)
       
           #/////////////////////////////////////////////////////////////////
           # DocTest Running
           #/////////////////////////////////////////////////////////////////
       
    1:     def __run(self, test, compileflags, out):
               """
               Run the examples in `test`.  Write the outcome of each example
               with one of the `DocTestRunner.report_*` methods, using the
               writer function `out`.  `compileflags` is the set of compiler
               flags that should be used to execute examples.  Return a tuple
               `(f, t)`, where `t` is the number of examples tried, and `f`
               is the number of examples that failed.  The examples are run
               in the namespace `test.globs`.
               """
               # Keep track of the number of failures and tries.
 1676:         failures = tries = 0
       
               # Save the option flags (since option directives can be used
               # to modify them).
 1676:         original_optionflags = self.optionflags
       
 1676:         SUCCESS, FAILURE, BOOM = range(3) # `outcome` state
       
 1676:         check = self._checker.check_output
       
               # Process each example.
 4798:         for examplenum, example in enumerate(test.examples):
       
                   # If REPORT_ONLY_FIRST_FAILURE is set, then suppress
                   # reporting after the first failure.
 3130:             quiet = (self.optionflags & REPORT_ONLY_FIRST_FAILURE and
   30:                      failures > 0)
       
                   # Merge in the example's options.
 3130:             self.optionflags = original_optionflags
 3130:             if example.options:
  294:                 for (optionflag, val) in example.options.items():
  156:                     if val:
  152:                         self.optionflags |= optionflag
                           else:
    4:                         self.optionflags &= ~optionflag
       
                   # If 'SKIP' is set, then skip this example.
 3130:             if self.optionflags & SKIP:
    8:                 continue
       
                   # Record that we started this example.
 3122:             tries += 1
 3122:             if not quiet:
 3104:                 self.report_start(out, test, example)
       
                   # Use a special filename for compile(), so we can retrieve
                   # the source code during interactive debugging (see
                   # __patched_linecache_getlines).
 3122:             filename = '<doctest %s[%d]>' % (test.name, examplenum)
       
                   # Run the example in the given context (globs), and record
                   # any exception that gets raised.  (But don't intercept
                   # keyboard interrupts.)
 3122:             try:
                       # Don't blink!  This is where the user's code gets run.
 3122:                 exec compile(example.source, filename, "single",
 3122:                              compileflags, 1) in test.globs
 2889:                 self.debugger.set_continue() # ==== Example Finished ====
 2889:                 exception = None
  230:             except KeyboardInterrupt:
>>>>>>                 raise
  230:             except:
  230:                 exception = sys.exc_info()
  230:                 self.debugger.set_continue() # ==== Example Finished ====
       
 3119:             got = self._fakeout.getvalue()  # the actual output
 3119:             self._fakeout.truncate(0)
 3119:             outcome = FAILURE   # guilty until proved innocent or insane
       
                   # If the example executed without raising any exceptions,
                   # verify its output.
 3119:             if exception is None:
 2889:                 if check(example.want, got, self.optionflags):
 2807:                     outcome = SUCCESS
       
                   # The example raised an exception:  check if it was expected.
                   else:
  230:                 exc_info = sys.exc_info()
  230:                 exc_msg = traceback.format_exception_only(*exc_info[:2])[-1]
  230:                 if not quiet:
  230:                     got += _exception_traceback(exc_info)
       
                       # If `example.exc_msg` is None, then we weren't expecting
                       # an exception.
  230:                 if example.exc_msg is None:
   36:                     outcome = BOOM
       
                       # We expected an exception:  see whether it matches.
  194:                 elif check(example.exc_msg, exc_msg, self.optionflags):
  178:                     outcome = SUCCESS
       
                       # Another chance if they didn't care about the detail.
   16:                 elif self.optionflags & IGNORE_EXCEPTION_DETAIL:
   12:                     if check(_strip_exception_details(example.exc_msg),
   12:                              _strip_exception_details(exc_msg),
   12:                              self.optionflags):
   10:                         outcome = SUCCESS
       
                   # Report the outcome.
 3119:             if outcome is SUCCESS:
 2995:                 if not quiet:
 2989:                     self.report_success(out, test, example, got)
  124:             elif outcome is FAILURE:
   88:                 if not quiet:
   76:                     self.report_failure(out, test, example, got)
   86:                 failures += 1
   36:             elif outcome is BOOM:
   36:                 if not quiet:
   36:                     self.report_unexpected_exception(out, test, example,
   36:                                                      exc_info)
   33:                 failures += 1
                   else:
>>>>>>                 assert False, ("unknown outcome", outcome)
       
               # Restore the option flags (in case they were modified)
 1668:         self.optionflags = original_optionflags
       
               # Record and return the number of failures and tries.
 1668:         self.__record_outcome(test, failures, tries)
 1668:         return TestResults(failures, tries)
       
    1:     def __record_outcome(self, test, f, t):
               """
               Record the fact that the given DocTest (`test`) generated `f`
               failures out of `t` tried examples.
               """
 1668:         f2, t2 = self._name2ft.get(test.name, (0,0))
 1668:         self._name2ft[test.name] = (f+f2, t+t2)
 1668:         self.failures += f
 1668:         self.tries += t
       
    1:     __LINECACHE_FILENAME_RE = re.compile(r'<doctest '
                                                r'(?P<name>.+)'
                                                r'\[(?P<examplenum>\d+)\]>$')
    1:     def __patched_linecache_getlines(self, filename, module_globals=None):
  828:         m = self.__LINECACHE_FILENAME_RE.match(filename)
  828:         if m and m.group('name') == self.test.name:
  300:             example = self.test.examples[int(m.group('examplenum'))]
  300:             source = example.source
  300:             if isinstance(source, unicode):
    4:                 source = source.encode('ascii', 'backslashreplace')
  300:             return source.splitlines(True)
               else:
  528:             return self.save_linecache_getlines(filename, module_globals)
       
    1:     def run(self, test, compileflags=None, out=None, clear_globs=True):
               """
               Run the examples in `test`, and display the results using the
               writer function `out`.
       
               The examples are run in the namespace `test.globs`.  If
               `clear_globs` is true (the default), then this namespace will
               be cleared after the test runs, to help with garbage
               collection.  If you would like to examine the namespace after
               the test completes, then use `clear_globs=False`.
       
               `compileflags` gives the set of flags that should be used by
               the Python compiler when running the examples.  If not
               specified, then it will default to the set of future-import
               flags that apply to `globs`.
       
               The output of each example is checked using
               `DocTestRunner.check_output`, and the results are formatted by
               the `DocTestRunner.report_*` methods.
               """
 1676:         self.test = test
       
 1676:         if compileflags is None:
 1676:             compileflags = _extract_future_flags(test.globs)
       
 1676:         save_stdout = sys.stdout
 1676:         if out is None:
 1537:             out = save_stdout.write
 1676:         sys.stdout = self._fakeout
       
               # Patch pdb.set_trace to restore sys.stdout during interactive
               # debugging (so it's not still redirected to self._fakeout).
               # Note that the interactive output will go to *our*
               # save_stdout, even if that's not the real sys.stdout; this
               # allows us to write test cases for the set_trace behavior.
 1676:         save_set_trace = pdb.set_trace
 1676:         self.debugger = _OutputRedirectingPdb(save_stdout)
 1676:         self.debugger.reset()
 1676:         pdb.set_trace = self.debugger.set_trace
       
               # Patch linecache.getlines, so we can see the example's source
               # when we're inside the debugger.
 1676:         self.save_linecache_getlines = linecache.getlines
 1676:         linecache.getlines = self.__patched_linecache_getlines
       
               # Make sure sys.displayhook just prints the value to stdout
 1676:         save_displayhook = sys.displayhook
 1676:         sys.displayhook = sys.__displayhook__
       
 1676:         try:
 1676:             return self.__run(test, compileflags, out)
               finally:
 1673:             sys.stdout = save_stdout
 1673:             pdb.set_trace = save_set_trace
 1673:             linecache.getlines = self.save_linecache_getlines
 1673:             sys.displayhook = save_displayhook
 1673:             if clear_globs:
 1528:                 test.globs.clear()
       
           #/////////////////////////////////////////////////////////////////
           # Summarization
           #/////////////////////////////////////////////////////////////////
    1:     def summarize(self, verbose=None):
               """
               Print a summary of all the test cases that have been run by
               this DocTestRunner, and return a tuple `(f, t)`, where `f` is
               the total number of failed examples, and `t` is the total
               number of tried examples.
       
               The optional `verbose` argument controls how detailed the
               summary is.  If the verbosity is not specified, then the
               DocTestRunner's verbosity is used.
               """
   33:         if verbose is None:
   30:             verbose = self._verbose
   33:         notests = []
   33:         passed = []
   33:         failed = []
   33:         totalt = totalf = 0
 1375:         for x in self._name2ft.items():
 1342:             name, (f, t) = x
 1342:             assert f <= t
 1342:             totalt += t
 1342:             totalf += f
 1342:             if t == 0:
 1163:                 notests.append(name)
  179:             elif f == 0:
  175:                 passed.append( (name, t) )
                   else:
    4:                 failed.append(x)
   33:         if verbose:
    3:             if notests:
>>>>>>                 print len(notests), "items had no tests:"
>>>>>>                 notests.sort()
>>>>>>                 for thing in notests:
>>>>>>                     print "   ", thing
    3:             if passed:
    3:                 print len(passed), "items passed all tests:"
    3:                 passed.sort()
    9:                 for thing, count in passed:
    6:                     print " %3d tests in %s" % (count, thing)
   33:         if failed:
    4:             print self.DIVIDER
    4:             print len(failed), "items had failures:"
    4:             failed.sort()
    8:             for thing, (f, t) in failed:
    4:                 print " %3d of %3d in %s" % (f, t, thing)
   33:         if verbose:
    3:             print totalt, "tests in", len(self._name2ft), "items."
    3:             print totalt - totalf, "passed and", totalf, "failed."
   33:         if totalf:
    4:             print "***Test Failed***", totalf, "failures."
   29:         elif verbose:
    1:             print "Test passed."
   33:         return TestResults(totalf, totalt)
       
           #/////////////////////////////////////////////////////////////////
           # Backward compatibility cruft to maintain doctest.master.
           #/////////////////////////////////////////////////////////////////
    1:     def merge(self, other):
    2:         d = self._name2ft
  126:         for name, (f, t) in other._name2ft.items():
  124:             if name in d:
                       # Don't print here by default, since doing
                       #     so breaks some of the buildbots
                       #print "*** DocTestRunner.merge: '" + name + "' in both" \
                       #    " testers; summing outcomes."
>>>>>>                 f2, t2 = d[name]
>>>>>>                 f = f + f2
>>>>>>                 t = t + t2
  124:             d[name] = f, t
       
    2: class OutputChecker:
           """
           A class used to check the whether the actual output from a doctest
           example matches the expected output.  `OutputChecker` defines two
           methods: `check_output`, which compares a given pair of outputs,
           and returns true if they match; and `output_difference`, which
           returns a string describing the differences between two outputs.
    1:     """
    1:     def check_output(self, want, got, optionflags):
               """
               Return True iff the actual output from an example (`got`)
               matches the expected output (`want`).  These strings are
               always considered to match if they are identical; but
               depending on what option flags the test runner is using,
               several non-exact match types are also possible.  See the
               documentation for `TestRunner` for more information about
               option flags.
               """
               # Handle the common case first, for efficiency:
               # if they're string-identical, always return true.
 3095:         if got == want:
 2879:             return True
       
               # The values True and False replaced 1 and 0 as the return
               # value for boolean comparisons in Python 2.3.
  216:         if not (optionflags & DONT_ACCEPT_TRUE_FOR_1):
  214:             if (got,want) == ("True\n", "1\n"):
    3:                 return True
  211:             if (got,want) == ("False\n", "0\n"):
    1:                 return True
       
               # <BLANKLINE> can be used as a special sequence to signify a
               # blank line, unless the DONT_ACCEPT_BLANKLINE flag is used.
  212:         if not (optionflags & DONT_ACCEPT_BLANKLINE):
                   # Replace <BLANKLINE> in want with a blank line.
  204:             want = re.sub('(?m)^%s\s*?$' % re.escape(BLANKLINE_MARKER),
  204:                           '', want)
                   # If a line in got contains only spaces, then remove the
                   # spaces.
  204:             got = re.sub('(?m)^\s*?$', '', got)
  204:             if got == want:
   23:                 return True
       
               # This flag causes doctest to ignore any differences in the
               # contents of whitespace strings.  Note that this can be used
               # in conjunction with the ELLIPSIS flag.
  189:         if optionflags & NORMALIZE_WHITESPACE:
   16:             got = ' '.join(got.split())
   16:             want = ' '.join(want.split())
   16:             if got == want:
    6:                 return True
       
               # The ELLIPSIS flag says to let the sequence "..." in `want`
               # match any substring in `got`.
  183:         if optionflags & ELLIPSIS:
   83:             if _ellipsis_match(want, got):
   83:                 return True
       
               # We didn't find any match; return false.
  100:         return False
       
           # Should we do a fancy diff?
    1:     def _do_a_fancy_diff(self, want, got, optionflags):
               # Not unless they asked for a fancy diff.
   74:         if not optionflags & (REPORT_UDIFF |
   74:                               REPORT_CDIFF |
   74:                               REPORT_NDIFF):
   68:             return False
       
               # If expected output uses ellipsis, a meaningful fancy diff is
               # too hard ... or maybe not.  In two real-life failures Tim saw,
               # a diff was a major help anyway, so this is commented out.
               # [todo] _ellipsis_match() knows which pieces do and don't match,
               # and could be the basis for a kick-ass diff in this case.
               ##if optionflags & ELLIPSIS and ELLIPSIS_MARKER in want:
               ##    return False
       
               # ndiff does intraline difference marking, so can be useful even
               # for 1-line differences.
    6:         if optionflags & REPORT_NDIFF:
    2:             return True
       
               # The other diff types need at least a few lines to be helpful.
    4:         return want.count('\n') > 2 and got.count('\n') > 2
       
    1:     def output_difference(self, example, got, optionflags):
               """
               Return a string describing the differences between the
               expected output for a given example (`example`) and the actual
               output (`got`).  `optionflags` is the set of option flags used
               to compare `want` and `got`.
               """
   74:         want = example.want
               # If <BLANKLINE>s are being used, then replace blank lines
               # with <BLANKLINE> in the actual output string.
   74:         if not (optionflags & DONT_ACCEPT_BLANKLINE):
   66:             got = re.sub('(?m)^[ ]*(?=\n)', BLANKLINE_MARKER, got)
       
               # Check if we should use diff.
   74:         if self._do_a_fancy_diff(want, got, optionflags):
                   # Split want & got into lines.
    6:             want_lines = want.splitlines(True)  # True == keep line ends
    6:             got_lines = got.splitlines(True)
                   # Use difflib to find their differences.
    6:             if optionflags & REPORT_UDIFF:
    2:                 diff = difflib.unified_diff(want_lines, got_lines, n=2)
    2:                 diff = list(diff)[2:] # strip the diff header
    2:                 kind = 'unified diff with -expected +actual'
    4:             elif optionflags & REPORT_CDIFF:
    2:                 diff = difflib.context_diff(want_lines, got_lines, n=2)
    2:                 diff = list(diff)[2:] # strip the diff header
    2:                 kind = 'context diff with expected followed by actual'
    2:             elif optionflags & REPORT_NDIFF:
    2:                 engine = difflib.Differ(charjunk=difflib.IS_CHARACTER_JUNK)
    2:                 diff = list(engine.compare(want_lines, got_lines))
    2:                 kind = 'ndiff with -expected +actual'
                   else:
>>>>>>                 assert 0, 'Bad diff option'
                   # Remove trailing whitespace on diff output.
   68:             diff = [line.rstrip() + '\n' for line in diff]
    6:             return 'Differences (%s):\n' % kind + _indent(''.join(diff))
       
               # If we're not using diff, then simply list the expected
               # output followed by the actual output.
   68:         if want and got:
   68:             return 'Expected:\n%sGot:\n%s' % (_indent(want), _indent(got))
>>>>>>         elif want:
>>>>>>             return 'Expected:\n%sGot nothing\n' % _indent(want)
>>>>>>         elif got:
>>>>>>             return 'Expected nothing\nGot:\n%s' % _indent(got)
               else:
>>>>>>             return 'Expected nothing\nGot nothing\n'
       
    2: class DocTestFailure(Exception):
           """A DocTest example has failed in debugging mode.
       
           The exception instance has variables:
       
           - test: the DocTest object being run
       
           - example: the Example object that failed
       
           - got: the actual output
    1:     """
    1:     def __init__(self, test, example, got):
    2:         self.test = test
    2:         self.example = example
    2:         self.got = got
       
    1:     def __str__(self):
>>>>>>         return str(self.test)
       
    2: class UnexpectedException(Exception):
           """A DocTest example has encountered an unexpected exception
       
           The exception instance has variables:
       
           - test: the DocTest object being run
       
           - example: the Example object that failed
       
           - exc_info: the exception info
    1:     """
    1:     def __init__(self, test, example, exc_info):
    3:         self.test = test
    3:         self.example = example
    3:         self.exc_info = exc_info
       
    1:     def __str__(self):
    2:         return str(self.test)
       
    2: class DebugRunner(DocTestRunner):
           r"""Run doc tests but raise an exception as soon as there is a failure.
       
              If an unexpected exception occurs, an UnexpectedException is raised.
              It contains the test, the example, and the original exception:
       
                >>> runner = DebugRunner(verbose=False)
                >>> test = DocTestParser().get_doctest('>>> raise KeyError\n42',
                ...                                    {}, 'foo', 'foo.py', 0)
                >>> try:
                ...     runner.run(test)
                ... except UnexpectedException, failure:
                ...     pass
       
                >>> failure.test is test
                True
       
                >>> failure.example.want
                '42\n'
       
                >>> exc_info = failure.exc_info
                >>> raise exc_info[0], exc_info[1], exc_info[2]
                Traceback (most recent call last):
                ...
                KeyError
       
              We wrap the original exception to give the calling application
              access to the test and example information.
       
              If the output doesn't match, then a DocTestFailure is raised:
       
                >>> test = DocTestParser().get_doctest('''
                ...      >>> x = 1
                ...      >>> x
                ...      2
                ...      ''', {}, 'foo', 'foo.py', 0)
       
                >>> try:
                ...    runner.run(test)
                ... except DocTestFailure, failure:
                ...    pass
       
              DocTestFailure objects provide access to the test:
       
                >>> failure.test is test
                True
       
              As well as to the example:
       
                >>> failure.example.want
                '2\n'
       
              and the actual output:
       
                >>> failure.got
                '1\n'
       
              If a failure or error occurs, the globals are left intact:
       
                >>> del test.globs['__builtins__']
                >>> test.globs
                {'x': 1}
       
                >>> test = DocTestParser().get_doctest('''
                ...      >>> x = 2
                ...      >>> raise KeyError
                ...      ''', {}, 'foo', 'foo.py', 0)
       
                >>> runner.run(test)
                Traceback (most recent call last):
                ...
                UnexpectedException: <DocTest foo from foo.py:0 (2 examples)>
       
                >>> del test.globs['__builtins__']
                >>> test.globs
                {'x': 2}
       
              But the globals are cleared if there is no error:
       
                >>> test = DocTestParser().get_doctest('''
                ...      >>> x = 2
                ...      ''', {}, 'foo', 'foo.py', 0)
       
                >>> runner.run(test)
                TestResults(failed=0, attempted=1)
       
                >>> test.globs
                {}
       
    1:        """
       
    1:     def run(self, test, compileflags=None, out=None, clear_globs=True):
    6:         r = DocTestRunner.run(self, test, compileflags, out, False)
    1:         if clear_globs:
    1:             test.globs.clear()
    1:         return r
       
    1:     def report_unexpected_exception(self, out, test, example, exc_info):
    3:         raise UnexpectedException(test, example, exc_info)
       
    1:     def report_failure(self, out, test, example, got):
    2:         raise DocTestFailure(test, example, got)
       
       ######################################################################
       ## 6. Test Functions
       ######################################################################
       # These should be backwards compatible.
       
       # For backward compatibility, a global instance of a DocTestRunner
       # class, updated by testmod.
    1: master = None
       
    1: def testmod(m=None, name=None, globs=None, verbose=None,
    1:             report=True, optionflags=0, extraglobs=None,
    1:             raise_on_error=False, exclude_empty=False):
           """m=None, name=None, globs=None, verbose=None, report=True,
              optionflags=0, extraglobs=None, raise_on_error=False,
              exclude_empty=False
       
           Test examples in docstrings in functions and classes reachable
           from module m (or the current module if m is not supplied), starting
           with m.__doc__.
       
           Also test examples reachable from dict m.__test__ if it exists and is
           not None.  m.__test__ maps names to functions, classes and strings;
           function and class docstrings are tested even if the name is private;
           strings are tested directly, as if they were docstrings.
       
           Return (#failures, #tests).
       
           See help(doctest) for an overview.
       
           Optional keyword arg "name" gives the name of the module; by default
           use m.__name__.
       
           Optional keyword arg "globs" gives a dict to be used as the globals
           when executing examples; by default, use m.__dict__.  A copy of this
           dict is actually used for each docstring, so that each docstring's
           examples start with a clean slate.
       
           Optional keyword arg "extraglobs" gives a dictionary that should be
           merged into the globals that are used to execute examples.  By
           default, no extra globals are used.  This is new in 2.4.
       
           Optional keyword arg "verbose" prints lots of stuff if true, prints
           only failures if false; by default, it's true iff "-v" is in sys.argv.
       
           Optional keyword arg "report" prints a summary at the end when true,
           else prints nothing at the end.  In verbose mode, the summary is
           detailed, else very brief (in fact, empty if all tests passed).
       
           Optional keyword arg "optionflags" or's together module constants,
           and defaults to 0.  This is new in 2.3.  Possible values (see the
           docs for details):
       
               DONT_ACCEPT_TRUE_FOR_1
               DONT_ACCEPT_BLANKLINE
               NORMALIZE_WHITESPACE
               ELLIPSIS
               SKIP
               IGNORE_EXCEPTION_DETAIL
               REPORT_UDIFF
               REPORT_CDIFF
               REPORT_NDIFF
               REPORT_ONLY_FIRST_FAILURE
       
           Optional keyword arg "raise_on_error" raises an exception on the
           first unexpected exception or failure. This allows failures to be
           post-mortem debugged.
       
           Advanced tomfoolery:  testmod runs methods of a local instance of
           class doctest.Tester, then merges the results into (or creates)
           global Tester instance doctest.master.  Methods of doctest.master
           can be called directly too, if you want to do something unusual.
           Passing report=0 to testmod is especially useful then, to delay
           displaying a summary.  Invoke doctest.master.summarize(verbose)
           when you're done fiddling.
           """
           global master
       
           # If no module was given, then use __main__.
   28:     if m is None:
               # DWA - m will still be None if this wasn't invoked from the command
               # line, in which case the following TypeError is about as good an error
               # as we should expect
>>>>>>         m = sys.modules.get('__main__')
       
           # Check that we were actually given a module.
   28:     if not inspect.ismodule(m):
>>>>>>         raise TypeError("testmod: module required; %r" % (m,))
       
           # If no name was given, then use the module's name.
   28:     if name is None:
   28:         name = m.__name__
       
           # Find, parse, and run all tests in the given module.
   28:     finder = DocTestFinder(exclude_empty=exclude_empty)
       
   28:     if raise_on_error:
>>>>>>         runner = DebugRunner(verbose=verbose, optionflags=optionflags)
           else:
   28:         runner = DocTestRunner(verbose=verbose, optionflags=optionflags)
       
 1407:     for test in finder.find(m, name, globs=globs, extraglobs=extraglobs):
 1381:         runner.run(test)
       
   26:     if report:
   26:         runner.summarize()
       
   26:     if master is None:
   24:         master = runner
           else:
    2:         master.merge(runner)
       
   26:     return TestResults(runner.failures, runner.tries)
       
    1: def testfile(filename, module_relative=True, name=None, package=None,
    1:              globs=None, verbose=None, report=True, optionflags=0,
    1:              extraglobs=None, raise_on_error=False, parser=DocTestParser(),
    1:              encoding=None):
           """
           Test examples in the given file.  Return (#failures, #tests).
       
           Optional keyword arg "module_relative" specifies how filenames
           should be interpreted:
       
             - If "module_relative" is True (the default), then "filename"
                specifies a module-relative path.  By default, this path is
                relative to the calling module's directory; but if the
                "package" argument is specified, then it is relative to that
                package.  To ensure os-independence, "filename" should use
                "/" characters to separate path segments, and should not
                be an absolute path (i.e., it may not begin with "/").
       
             - If "module_relative" is False, then "filename" specifies an
               os-specific path.  The path may be absolute or relative (to
               the current working directory).
       
           Optional keyword arg "name" gives the name of the test; by default
           use the file's basename.
       
           Optional keyword argument "package" is a Python package or the
           name of a Python package whose directory should be used as the
           base directory for a module relative filename.  If no package is
           specified, then the calling module's directory is used as the base
           directory for module relative filenames.  It is an error to
           specify "package" if "module_relative" is False.
       
           Optional keyword arg "globs" gives a dict to be used as the globals
           when executing examples; by default, use {}.  A copy of this dict
           is actually used for each docstring, so that each docstring's
           examples start with a clean slate.
       
           Optional keyword arg "extraglobs" gives a dictionary that should be
           merged into the globals that are used to execute examples.  By
           default, no extra globals are used.
       
           Optional keyword arg "verbose" prints lots of stuff if true, prints
           only failures if false; by default, it's true iff "-v" is in sys.argv.
       
           Optional keyword arg "report" prints a summary at the end when true,
           else prints nothing at the end.  In verbose mode, the summary is
           detailed, else very brief (in fact, empty if all tests passed).
       
           Optional keyword arg "optionflags" or's together module constants,
           and defaults to 0.  Possible values (see the docs for details):
       
               DONT_ACCEPT_TRUE_FOR_1
               DONT_ACCEPT_BLANKLINE
               NORMALIZE_WHITESPACE
               ELLIPSIS
               SKIP
               IGNORE_EXCEPTION_DETAIL
               REPORT_UDIFF
               REPORT_CDIFF
               REPORT_NDIFF
               REPORT_ONLY_FIRST_FAILURE
       
           Optional keyword arg "raise_on_error" raises an exception on the
           first unexpected exception or failure. This allows failures to be
           post-mortem debugged.
       
           Optional keyword arg "parser" specifies a DocTestParser (or
           subclass) that should be used to extract tests from the files.
       
           Optional keyword arg "encoding" specifies an encoding that should
           be used to convert the file to unicode.
       
           Advanced tomfoolery:  testmod runs methods of a local instance of
           class doctest.Tester, then merges the results into (or creates)
           global Tester instance doctest.master.  Methods of doctest.master
           can be called directly too, if you want to do something unusual.
           Passing report=0 to testmod is especially useful then, to delay
           displaying a summary.  Invoke doctest.master.summarize(verbose)
           when you're done fiddling.
           """
           global master
       
    2:     if package and not module_relative:
>>>>>>         raise ValueError("Package may only be specified for module-"
                                "relative paths.")
       
           # Relativize the path
    2:     text, filename = _load_testfile(filename, package, module_relative)
       
           # If no name was given, then use the file's name.
    2:     if name is None:
    2:         name = os.path.basename(filename)
       
           # Assemble the globals.
    2:     if globs is None:
>>>>>>         globs = {}
           else:
    2:         globs = globs.copy()
    2:     if extraglobs is not None:
>>>>>>         globs.update(extraglobs)
    2:     if '__name__' not in globs:
    2:         globs['__name__'] = '__main__'
       
    2:     if raise_on_error:
>>>>>>         runner = DebugRunner(verbose=verbose, optionflags=optionflags)
           else:
    2:         runner = DocTestRunner(verbose=verbose, optionflags=optionflags)
       
    2:     if encoding is not None:
>>>>>>         text = text.decode(encoding)
       
           # Read the file, convert it to a test, and run it.
    2:     test = parser.get_doctest(text, globs, name, filename, 0)
    2:     runner.run(test)
       
    2:     if report:
    2:         runner.summarize()
       
    2:     if master is None:
    2:         master = runner
           else:
>>>>>>         master.merge(runner)
       
    2:     return TestResults(runner.failures, runner.tries)
       
    1: def run_docstring_examples(f, globs, verbose=False, name="NoName",
    1:                            compileflags=None, optionflags=0):
           """
           Test examples in the given object's docstring (`f`), using `globs`
           as globals.  Optional argument `name` is used in failure messages.
           If the optional argument `verbose` is true, then generate output
           even if there are no failures.
       
           `compileflags` gives the set of flags that should be used by the
           Python compiler when running the examples.  If not specified, then
           it will default to the set of future-import flags that apply to
           `globs`.
       
           Optional keyword arg `optionflags` specifies options for the
           testing and output.  See the documentation for `testmod` for more
           information.
           """
           # Find, parse, and run all tests in the given module.
>>>>>>     finder = DocTestFinder(verbose=verbose, recurse=False)
>>>>>>     runner = DocTestRunner(verbose=verbose, optionflags=optionflags)
>>>>>>     for test in finder.find(f, name, globs=globs):
>>>>>>         runner.run(test, compileflags=compileflags)
       
       ######################################################################
       ## 7. Tester
       ######################################################################
       # This is provided only for backwards compatibility.  It's not
       # actually used in any way.
       
    2: class Tester:
    1:     def __init__(self, mod=None, globs=None, verbose=None, optionflags=0):
       
   10:         warnings.warn("class Tester is deprecated; "
                             "use class doctest.DocTestRunner instead",
   10:                       DeprecationWarning, stacklevel=2)
   10:         if mod is None and globs is None:
>>>>>>             raise TypeError("Tester.__init__: must specify mod or globs")
   10:         if mod is not None and not inspect.ismodule(mod):
>>>>>>             raise TypeError("Tester.__init__: mod must be a module; %r" %
>>>>>>                             (mod,))
   10:         if globs is None:
>>>>>>             globs = mod.__dict__
   10:         self.globs = globs
       
   10:         self.verbose = verbose
   10:         self.optionflags = optionflags
   10:         self.testfinder = DocTestFinder()
   10:         self.testrunner = DocTestRunner(verbose=verbose,
   10:                                         optionflags=optionflags)
       
    1:     def runstring(self, s, name):
    6:         test = DocTestParser().get_doctest(s, self.globs, name, None, None)
    6:         if self.verbose:
    2:             print "Running string", name
    6:         (f,t) = self.testrunner.run(test)
    6:         if self.verbose:
    2:             print f, "of", t, "examples failed in string", name
    6:         return TestResults(f,t)
       
    1:     def rundoc(self, object, name=None, module=None):
    6:         f = t = 0
    6:         tests = self.testfinder.find(object, name, module=module,
    6:                                      globs=self.globs)
   32:         for test in tests:
   26:             (f2, t2) = self.testrunner.run(test)
   26:             (f,t) = (f+f2, t+t2)
    6:         return TestResults(f,t)
       
    1:     def rundict(self, d, name, module=None):
    4:         import types
    4:         m = types.ModuleType(name)
    4:         m.__dict__.update(d)
    4:         if module is None:
    2:             module = False
    4:         return self.rundoc(m, name, module)
       
    1:     def run__test__(self, d, name):
>>>>>>         import types
>>>>>>         m = types.ModuleType(name)
>>>>>>         m.__test__ = d
>>>>>>         return self.rundoc(m, name)
       
    1:     def summarize(self, verbose=None):
    4:         return self.testrunner.summarize(verbose)
       
    1:     def merge(self, other):
>>>>>>         self.testrunner.merge(other.testrunner)
       
       ######################################################################
       ## 8. Unittest Support
       ######################################################################
       
    1: _unittest_reportflags = 0
       
    1: def set_unittest_reportflags(flags):
           """Sets the unittest option flags.
       
           The old flag is returned so that a runner could restore the old
           value if it wished to:
       
             >>> import doctest
             >>> old = doctest._unittest_reportflags
             >>> doctest.set_unittest_reportflags(REPORT_NDIFF |
             ...                          REPORT_ONLY_FIRST_FAILURE) == old
             True
       
             >>> doctest._unittest_reportflags == (REPORT_NDIFF |
             ...                                   REPORT_ONLY_FIRST_FAILURE)
             True
       
           Only reporting flags can be set:
       
             >>> doctest.set_unittest_reportflags(ELLIPSIS)
             Traceback (most recent call last):
             ...
             ValueError: ('Only reporting flags allowed', 8)
       
             >>> doctest.set_unittest_reportflags(old) == (REPORT_NDIFF |
             ...                                   REPORT_ONLY_FIRST_FAILURE)
             True
           """
           global _unittest_reportflags
       
    3:     if (flags & REPORTING_FLAGS) != flags:
    1:         raise ValueError("Only reporting flags allowed", flags)
    2:     old = _unittest_reportflags
    2:     _unittest_reportflags = flags
    2:     return old
       
       
    2: class DocTestCase(unittest.TestCase):
       
    1:     def __init__(self, test, optionflags=0, setUp=None, tearDown=None,
    1:                  checker=None):
       
  148:         unittest.TestCase.__init__(self)
  148:         self._dt_optionflags = optionflags
  148:         self._dt_checker = checker
  148:         self._dt_test = test
  148:         self._dt_setUp = setUp
  148:         self._dt_tearDown = tearDown
       
    1:     def setUp(self):
  141:         test = self._dt_test
       
  141:         if self._dt_setUp is not None:
   23:             self._dt_setUp(test)
       
    1:     def tearDown(self):
  139:         test = self._dt_test
       
  139:         if self._dt_tearDown is not None:
   13:             self._dt_tearDown(test)
       
  139:         test.globs.clear()
       
    1:     def runTest(self):
  139:         test = self._dt_test
  139:         old = sys.stdout
  139:         new = StringIO()
  139:         optionflags = self._dt_optionflags
       
  139:         if not (optionflags & REPORTING_FLAGS):
                   # The option flags don't include any reporting flags,
                   # so add the default reporting flags
  139:             optionflags |= _unittest_reportflags
       
  139:         runner = DocTestRunner(optionflags=optionflags,
  139:                                checker=self._dt_checker, verbose=False)
       
  139:         try:
  139:             runner.DIVIDER = "-"*70
  139:             failures, tries = runner.run(
  139:                 test, out=new.write, clear_globs=False)
               finally:
  139:             sys.stdout = old
       
  139:         if failures:
   51:             raise self.failureException(self.format_failure(new.getvalue()))
       
    1:     def format_failure(self, err):
   31:         test = self._dt_test
   31:         if test.lineno is None:
    8:             lineno = 'unknown line number'
               else:
   23:             lineno = '%s' % test.lineno
   31:         lname = '.'.join(test.name.split('.')[-1:])
   31:         return ('Failed doctest test for %s\n'
                       '  File "%s", line %s, in %s\n\n%s'
   31:                 % (test.name, test.filename, lineno, lname, err)
                       )
       
    1:     def debug(self):
               r"""Run the test case without results and without catching exceptions
       
                  The unit test framework includes a debug method on test cases
                  and test suites to support post-mortem debugging.  The test code
                  is run in such a way that errors are not caught.  This way a
                  caller can catch the errors and initiate post-mortem debugging.
       
                  The DocTestCase provides a debug method that raises
                  UnexpectedException errors if there is an unexpected
                  exception:
       
                    >>> test = DocTestParser().get_doctest('>>> raise KeyError\n42',
                    ...                {}, 'foo', 'foo.py', 0)
                    >>> case = DocTestCase(test)
                    >>> try:
                    ...     case.debug()
                    ... except UnexpectedException, failure:
                    ...     pass
       
                  The UnexpectedException contains the test, the example, and
                  the original exception:
       
                    >>> failure.test is test
                    True
       
                    >>> failure.example.want
                    '42\n'
       
                    >>> exc_info = failure.exc_info
                    >>> raise exc_info[0], exc_info[1], exc_info[2]
                    Traceback (most recent call last):
                    ...
                    KeyError
       
                  If the output doesn't match, then a DocTestFailure is raised:
       
                    >>> test = DocTestParser().get_doctest('''
                    ...      >>> x = 1
                    ...      >>> x
                    ...      2
                    ...      ''', {}, 'foo', 'foo.py', 0)
                    >>> case = DocTestCase(test)
       
                    >>> try:
                    ...    case.debug()
                    ... except DocTestFailure, failure:
                    ...    pass
       
                  DocTestFailure objects provide access to the test:
       
                    >>> failure.test is test
                    True
       
                  As well as to the example:
       
                    >>> failure.example.want
                    '2\n'
       
                  and the actual output:
       
                    >>> failure.got
                    '1\n'
       
                  """
       
    2:         self.setUp()
    2:         runner = DebugRunner(optionflags=self._dt_optionflags,
    2:                              checker=self._dt_checker, verbose=False)
    2:         runner.run(self._dt_test, clear_globs=False)
>>>>>>         self.tearDown()
       
    1:     def id(self):
>>>>>>         return self._dt_test.name
       
    1:     def __eq__(self, other):
    8:         if type(self) is not type(other):
    4:             return NotImplemented
       
    4:         return self._dt_test == other._dt_test and \
    4:                self._dt_optionflags == other._dt_optionflags and \
    4:                self._dt_setUp == other._dt_setUp and \
    4:                self._dt_tearDown == other._dt_tearDown and \
    4:                self._dt_checker == other._dt_checker
       
    1:     def __ne__(self, other):
    2:         return not self == other
       
    1:     def __hash__(self):
    4:         return hash((self._dt_optionflags, self._dt_setUp, self._dt_tearDown,
    4:                      self._dt_checker))
       
    1:     def __repr__(self):
>>>>>>         name = self._dt_test.name.split('.')
>>>>>>         return "%s (%s)" % (name[-1], '.'.join(name[:-1]))
       
    1:     __str__ = __repr__
       
    1:     def shortDescription(self):
>>>>>>         return "Doctest: " + self._dt_test.name
       
    2: class SkipDocTestCase(DocTestCase):
    1:     def __init__(self, module):
>>>>>>         self.module = module
>>>>>>         DocTestCase.__init__(self, None)
       
    1:     def setUp(self):
>>>>>>         self.skipTest("DocTestSuite will not work with -O2 and above")
       
    1:     def test_skip(self):
>>>>>>         pass
       
    1:     def shortDescription(self):
>>>>>>         return "Skipping tests from %s" % self.module.__name__
       
    1:     __str__ = shortDescription
       
       
    1: def DocTestSuite(module=None, globs=None, extraglobs=None, test_finder=None,
                        **options):
           """
           Convert doctest tests for a module to a unittest test suite.
       
           This converts each documentation string in a module that
           contains doctest tests to a unittest test case.  If any of the
           tests in a doc string fail, then the test case fails.  An exception
           is raised showing the name of the file containing the test and a
           (sometimes approximate) line number.
       
           The `module` argument provides the module to be tested.  The argument
           can be either a module or a module name.
       
           If no argument is given, the calling module is used.
       
           A number of options may be provided as keyword arguments:
       
           setUp
             A set-up function.  This is called before running the
             tests in each file. The setUp function will be passed a DocTest
             object.  The setUp function can access the test globals as the
             globs attribute of the test passed.
       
           tearDown
             A tear-down function.  This is called after running the
             tests in each file.  The tearDown function will be passed a DocTest
             object.  The tearDown function can access the test globals as the
             globs attribute of the test passed.
       
           globs
             A dictionary containing initial global variables for the tests.
       
           optionflags
              A set of doctest option flags expressed as an integer.
           """
       
   20:     if test_finder is None:
   19:         test_finder = DocTestFinder()
       
   20:     module = _normalize_module(module)
   20:     tests = test_finder.find(module, globs=globs, extraglobs=extraglobs)
       
   20:     if not tests and sys.flags.optimize >=2:
               # Skip doctests when running with -O2
>>>>>>         suite = unittest.TestSuite()
>>>>>>         suite.addTest(SkipDocTestCase(module))
>>>>>>         return suite
   20:     elif not tests:
               # Why do we want to do this? Because it reveals a bug that might
               # otherwise be hidden.
               # It is probably a bug that this exception is not also raised if the
               # number of doctest examples in tests is zero (i.e. if no doctest
               # examples were found).  However, we should probably not be raising
               # an exception at all here, though it is too late to make this change
               # for a maintenance release.  See also issue #14649.
    1:         raise ValueError(module, "has no docstrings")
       
   19:     tests.sort()
   19:     suite = unittest.TestSuite()
       
  213:     for test in tests:
  194:         if len(test.examples) == 0:
   83:             continue
  111:         if not test.filename:
>>>>>>             filename = module.__file__
>>>>>>             if filename[-4:] in (".pyc", ".pyo"):
>>>>>>                 filename = filename[:-1]
>>>>>>             test.filename = filename
  111:         suite.addTest(DocTestCase(test, **options))
       
   19:     return suite
       
    2: class DocFileCase(DocTestCase):
       
    1:     def id(self):
>>>>>>         return '_'.join(self._dt_test.name.split('.'))
       
    1:     def __repr__(self):
>>>>>>         return self._dt_test.filename
    1:     __str__ = __repr__
       
    1:     def format_failure(self, err):
   20:         return ('Failed doctest test for %s\n  File "%s", line 0\n\n%s'
   20:                 % (self._dt_test.name, self._dt_test.filename, err)
                       )
       
    1: def DocFileTest(path, module_relative=True, package=None,
    1:                 globs=None, parser=DocTestParser(),
    1:                 encoding=None, **options):
   30:     if globs is None:
   22:         globs = {}
           else:
    8:         globs = globs.copy()
       
   30:     if package and not module_relative:
    1:         raise ValueError("Package may only be specified for module-"
                                "relative paths.")
       
           # Relativize the path.
   29:     doc, path = _load_testfile(path, package, module_relative)
       
   29:     if "__file__" not in globs:
   29:         globs["__file__"] = path
       
           # Find the file and read it.
   29:     name = os.path.basename(path)
       
           # If an encoding is specified, use it to convert the file to unicode
   29:     if encoding is not None:
    3:         doc = doc.decode(encoding)
       
           # Convert it to a test, and wrap it in a DocFileCase.
   29:     test = parser.get_doctest(doc, globs, name, path, 0)
   29:     return DocFileCase(test, **options)
       
    1: def DocFileSuite(*paths, **kw):
           """A unittest suite for one or more doctest files.
       
           The path to each doctest file is given as a string; the
           interpretation of that string depends on the keyword argument
           "module_relative".
       
           A number of options may be provided as keyword arguments:
       
           module_relative
             If "module_relative" is True, then the given file paths are
             interpreted as os-independent module-relative paths.  By
             default, these paths are relative to the calling module's
             directory; but if the "package" argument is specified, then
             they are relative to that package.  To ensure os-independence,
             "filename" should use "/" characters to separate path
             segments, and may not be an absolute path (i.e., it may not
             begin with "/").
       
             If "module_relative" is False, then the given file paths are
             interpreted as os-specific paths.  These paths may be absolute
             or relative (to the current working directory).
       
           package
             A Python package or the name of a Python package whose directory
             should be used as the base directory for module relative paths.
             If "package" is not specified, then the calling module's
             directory is used as the base directory for module relative
             filenames.  It is an error to specify "package" if
             "module_relative" is False.
       
           setUp
             A set-up function.  This is called before running the
             tests in each file. The setUp function will be passed a DocTest
             object.  The setUp function can access the test globals as the
             globs attribute of the test passed.
       
           tearDown
             A tear-down function.  This is called after running the
             tests in each file.  The tearDown function will be passed a DocTest
             object.  The tearDown function can access the test globals as the
             globs attribute of the test passed.
       
           globs
             A dictionary containing initial global variables for the tests.
       
           optionflags
             A set of doctest option flags expressed as an integer.
       
           parser
             A DocTestParser (or subclass) that should be used to extract
             tests from the files.
       
           encoding
             An encoding that will be used to convert the files to unicode.
           """
   14:     suite = unittest.TestSuite()
       
           # We do this here so that _normalize_module is called at the right
           # level.  If it were called in DocFileTest, then this function
           # would be the caller and we might guess the package incorrectly.
   14:     if kw.get('module_relative', True):
   12:         kw['package'] = _normalize_module(kw.get('package'))
       
   41:     for path in paths:
   28:         suite.addTest(DocFileTest(path, **kw))
       
   13:     return suite
       
       ######################################################################
       ## 9. Debugging Support
       ######################################################################
       
    1: def script_from_examples(s):
           r"""Extract script from text with examples.
       
              Converts text with examples to a Python script.  Example input is
              converted to regular code.  Example output and all other words
              are converted to comments:
       
              >>> text = '''
              ...       Here are examples of simple math.
              ...
              ...           Python has super accurate integer addition
              ...
              ...           >>> 2 + 2
              ...           5
              ...
              ...           And very friendly error messages:
              ...
              ...           >>> 1/0
              ...           To Infinity
              ...           And
              ...           Beyond
              ...
              ...           You can use logic if you want:
              ...
              ...           >>> if 0:
              ...           ...    blah
              ...           ...    blah
              ...           ...
              ...
              ...           Ho hum
              ...           '''
       
              >>> print script_from_examples(text)
              # Here are examples of simple math.
              #
              #     Python has super accurate integer addition
              #
              2 + 2
              # Expected:
              ## 5
              #
              #     And very friendly error messages:
              #
              1/0
              # Expected:
              ## To Infinity
              ## And
              ## Beyond
              #
              #     You can use logic if you want:
              #
              if 0:
                 blah
                 blah
              #
              #     Ho hum
              <BLANKLINE>
              """
    3:     output = []
   20:     for piece in DocTestParser().parse(s):
   17:         if isinstance(piece, Example):
                   # Add the example's source code (strip trailing NL)
    7:             output.append(piece.source[:-1])
                   # Add the expected output:
    7:             want = piece.want
    7:             if want:
    4:                 output.append('# Expected:')
   10:                 output += ['## '+l for l in want.split('\n')[:-1]]
               else:
                   # Add non-example text.
   10:             output += [_comment_line(l)
   25:                        for l in piece.split('\n')[:-1]]
       
           # Trim junk on both ends.
    3:     while output and output[-1] == '#':
>>>>>>         output.pop()
    6:     while output and output[0] == '#':
    3:         output.pop(0)
           # Combine the output, and return it.
           # Add a courtesy newline to prevent exec from choking (see bug #1172785)
    3:     return '\n'.join(output) + '\n'
       
    1: def testsource(module, name):
           """Extract the test sources from a doctest docstring as a script.
       
           Provide the module (or dotted name of the module) containing the
           test to be debugged and the name (within the module) of the object
           with the doc string with tests to be debugged.
           """
>>>>>>     module = _normalize_module(module)
>>>>>>     tests = DocTestFinder().find(module)
>>>>>>     test = [t for t in tests if t.name == name]
>>>>>>     if not test:
>>>>>>         raise ValueError(name, "not found in tests")
>>>>>>     test = test[0]
>>>>>>     testsrc = script_from_examples(test.docstring)
>>>>>>     return testsrc
       
    1: def debug_src(src, pm=False, globs=None):
           """Debug a single doctest docstring, in argument `src`'"""
    2:     testsrc = script_from_examples(src)
    2:     debug_script(testsrc, pm, globs)
       
    1: def debug_script(src, pm=False, globs=None):
           "Debug a test script.  `src` is the script, as a string."
    2:     import pdb
       
           # Note that tempfile.NameTemporaryFile() cannot be used.  As the
           # docs say, a file so created cannot be opened by name a second time
           # on modern Windows boxes, and execfile() needs to open it.
    2:     srcfilename = tempfile.mktemp(".py", "doctestdebug")
    2:     f = open(srcfilename, 'w')
    2:     f.write(src)
    2:     f.close()
       
    2:     try:
    2:         if globs:
>>>>>>             globs = globs.copy()
               else:
    2:             globs = {}
       
    2:         if pm:
>>>>>>             try:
>>>>>>                 execfile(srcfilename, globs, globs)
>>>>>>             except:
>>>>>>                 print sys.exc_info()[1]
>>>>>>                 pdb.post_mortem(sys.exc_info()[2])
               else:
                   # Note that %r is vital here.  '%s' instead can, e.g., cause
                   # backslashes to get treated as metacharacters on Windows.
    2:             pdb.run("execfile(%r)" % srcfilename, globs, globs)
       
           finally:
>>>>>>         os.remove(srcfilename)
       
    1: def debug(module, name, pm=False):
           """Debug a single doctest docstring.
       
           Provide the module (or dotted name of the module) containing the
           test to be debugged and the name (within the module) of the object
           with the docstring with tests to be debugged.
           """
>>>>>>     module = _normalize_module(module)
>>>>>>     testsrc = testsource(module, name)
>>>>>>     debug_script(testsrc, pm, module.__dict__)
       
       ######################################################################
       ## 10. Example Usage
       ######################################################################
    2: class _TestClass:
           """
           A pointless class, for sanity-checking of docstring testing.
       
           Methods:
               square()
               get()
       
           >>> _TestClass(13).get() + _TestClass(-12).get()
           1
           >>> hex(_TestClass(13).square().get())
           '0xa9'
    1:     """
       
    1:     def __init__(self, val):
               """val -> _TestClass object with associated value val.
       
               >>> t = _TestClass(123)
               >>> print t.get()
               123
               """
       
   12:         self.val = val
       
    1:     def square(self):
               """square() -> square TestClass's associated value
       
               >>> _TestClass(13).square().get()
               169
               """
       
    4:         self.val = self.val ** 2
    4:         return self
       
    1:     def get(self):
               """get() -> return TestClass's associated value.
       
               >>> x = _TestClass(-42)
               >>> print x.get()
               -42
               """
       
   12:         return self.val
       
    1: __test__ = {"_TestClass": _TestClass,
                   "string": r"""
                             Example of a string object, searched as-is.
                             >>> x = 1; y = 2
                             >>> x + y, x * y
                             (3, 2)
    1:                       """,
       
                   "bool-int equivalence": r"""
                                           In 2.2, boolean expressions displayed
                                           0 or 1.  By default, we still accept
                                           them.  This can be disabled by passing
                                           DONT_ACCEPT_TRUE_FOR_1 to the new
                                           optionflags argument.
                                           >>> 4 == 4
                                           1
                                           >>> 4 == 4
                                           True
                                           >>> 4 > 4
                                           0
                                           >>> 4 > 4
                                           False
    1:                                     """,
       
                   "blank lines": r"""
                       Blank lines can be marked with <BLANKLINE>:
                           >>> print 'foo\n\nbar\n'
                           foo
                           <BLANKLINE>
                           bar
                           <BLANKLINE>
    1:             """,
       
                   "ellipsis": r"""
                       If the ellipsis flag is used, then '...' can be used to
                       elide substrings in the desired output:
                           >>> print range(1000) #doctest: +ELLIPSIS
                           [0, 1, 2, ..., 999]
    1:             """,
       
                   "whitespace normalization": r"""
                       If the whitespace normalization flag is used, then
                       differences in whitespace are ignored.
                           >>> print range(30) #doctest: +NORMALIZE_WHITESPACE
                           [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
                            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,
                            27, 28, 29]
    1:             """,
                  }
       
       
    1: def _test():
>>>>>>     testfiles = [arg for arg in sys.argv[1:] if arg and arg[0] != '-']
>>>>>>     if not testfiles:
>>>>>>         name = os.path.basename(sys.argv[0])
>>>>>>         if '__loader__' in globals():          # python -m
>>>>>>             name, _ = os.path.splitext(name)
>>>>>>         print("usage: {0} [-v] file ...".format(name))
>>>>>>         return 2
>>>>>>     for filename in testfiles:
>>>>>>         if filename.endswith(".py"):
                   # It is a module -- insert its dir into sys.path and try to
                   # import it. If it is part of a package, that possibly
                   # won't work because of package imports.
>>>>>>             dirname, filename = os.path.split(filename)
>>>>>>             sys.path.insert(0, dirname)
>>>>>>             m = __import__(filename[:-3])
>>>>>>             del sys.path[0]
>>>>>>             failures, _ = testmod(m)
               else:
>>>>>>             failures, _ = testfile(filename, module_relative=False)
>>>>>>         if failures:
>>>>>>             return 1
>>>>>>     return 0
       
       
    1: if __name__ == "__main__":
>>>>>>     sys.exit(_test())
