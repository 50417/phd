       # tempfile.py unit tests.
    1: import tempfile
    1: import errno
    1: import io
    1: import os
    1: import signal
    1: import shutil
    1: import sys
    1: import re
    1: import warnings
    1: import contextlib
       
    1: import unittest
    1: from test import test_support as support
       
    1: warnings.filterwarnings("ignore",
    1:                         category=RuntimeWarning,
    1:                         message="mktemp", module=__name__)
       
    1: if hasattr(os, 'stat'):
    1:     import stat
    1:     has_stat = 1
       else:
>>>>>>     has_stat = 0
       
    1: has_textmode = (tempfile._text_openflags != tempfile._bin_openflags)
    1: has_spawnl = hasattr(os, 'spawnl')
       
       # TEST_FILES may need to be tweaked for systems depending on the maximum
       # number of files that can be opened at one time (see ulimit -n)
    1: if sys.platform in ('openbsd3', 'openbsd4'):
>>>>>>     TEST_FILES = 48
       else:
    1:     TEST_FILES = 100
       
       # This is organized as one test for each chunk of code in tempfile.py,
       # in order of their appearance in the file.  Testing which requires
       # threads is not done here.
       
       # Common functionality.
    2: class TC(unittest.TestCase):
       
    1:     str_check = re.compile(r"[a-zA-Z0-9_-]{6}$")
       
    1:     def failOnException(self, what, ei=None):
>>>>>>         if ei is None:
>>>>>>             ei = sys.exc_info()
>>>>>>         self.fail("%s raised %s: %s" % (what, ei[0], ei[1]))
       
    1:     def nameCheck(self, name, dir, pre, suf):
  433:         (ndir, nbase) = os.path.split(name)
  433:         npre  = nbase[:len(pre)]
  433:         nsuf  = nbase[len(nbase)-len(suf):]
       
               # check for equality of the absolute paths!
  433:         self.assertEqual(os.path.abspath(ndir), os.path.abspath(dir),
  433:                          "file '%s' not in directory '%s'" % (name, dir))
  433:         self.assertEqual(npre, pre,
  433:                          "file '%s' does not begin with '%s'" % (nbase, pre))
  433:         self.assertEqual(nsuf, suf,
  433:                          "file '%s' does not end with '%s'" % (nbase, suf))
       
  433:         nbase = nbase[len(pre):len(nbase)-len(suf)]
  433:         self.assertTrue(self.str_check.match(nbase),
  433:                      "random string '%s' does not match /^[a-zA-Z0-9_-]{6}$/"
  433:                      % nbase)
       
    1: test_classes = []
       
    2: class test_exports(TC):
    1:     def test_exports(self):
               # There are no surprising symbols in the tempfile module
    1:         dict = tempfile.__dict__
       
    1:         expected = {
    1:             "NamedTemporaryFile" : 1,
    1:             "TemporaryFile" : 1,
    1:             "mkstemp" : 1,
    1:             "mkdtemp" : 1,
    1:             "mktemp" : 1,
    1:             "TMP_MAX" : 1,
    1:             "gettempprefix" : 1,
    1:             "gettempdir" : 1,
    1:             "tempdir" : 1,
    1:             "template" : 1,
    1:             "SpooledTemporaryFile" : 1
               }
       
    1:         unexp = []
   39:         for key in dict:
   38:             if key[0] != '_' and key not in expected:
>>>>>>                 unexp.append(key)
    1:         self.assertTrue(len(unexp) == 0,
    1:                         "unexpected keys: %s" % unexp)
       
    1: test_classes.append(test_exports)
       
       
    2: class test__RandomNameSequence(TC):
    1:     """Test the internal iterator object _RandomNameSequence."""
       
    1:     def setUp(self):
    4:         self.r = tempfile._RandomNameSequence()
       
    1:     def test_get_six_char_str(self):
               # _RandomNameSequence returns a six-character string
    1:         s = self.r.next()
    1:         self.nameCheck(s, '', '', '')
       
    1:     def test_many(self):
               # _RandomNameSequence returns no duplicate strings (stochastic)
       
    1:         dict = {}
    1:         r = self.r
  101:         for i in xrange(TEST_FILES):
  100:             s = r.next()
  100:             self.nameCheck(s, '', '', '')
  100:             self.assertNotIn(s, dict)
  100:             dict[s] = 1
       
    1:     def test_supports_iter(self):
               # _RandomNameSequence supports the iterator protocol
       
    1:         i = 0
    1:         r = self.r
    1:         try:
   20:             for s in r:
   20:                 i += 1
   20:                 if i == 20:
    1:                     break
>>>>>>         except:
>>>>>>             self.failOnException("iteration")
       
    1:     @unittest.skipUnless(hasattr(os, 'fork'),
    1:         "os.fork is required for this test")
           def test_process_awareness(self):
               # ensure that the random source differs between
               # child and parent.
    1:         read_fd, write_fd = os.pipe()
    1:         pid = None
    1:         try:
    1:             pid = os.fork()
    1:             if not pid:
                       # child process
>>>>>>                 os.close(read_fd)
>>>>>>                 os.write(write_fd, next(self.r).encode("ascii"))
>>>>>>                 os.close(write_fd)
                       # bypass the normal exit handlers- leave those to
                       # the parent.
>>>>>>                 os._exit(0)
       
                   # parent process
    1:             parent_value = next(self.r)
    1:             child_value = os.read(read_fd, len(parent_value)).decode("ascii")
               finally:
    1:             if pid:
                       # best effort to ensure the process can't bleed out
                       # via any bugs above
    1:                 try:
    1:                     os.kill(pid, signal.SIGKILL)
>>>>>>                 except EnvironmentError:
>>>>>>                     pass
       
                       # Read the process exit status to avoid zombie process
    1:                 os.waitpid(pid, 0)
       
    1:             os.close(read_fd)
    1:             os.close(write_fd)
    1:         self.assertNotEqual(child_value, parent_value)
       
       
    1: test_classes.append(test__RandomNameSequence)
       
       
    2: class test__candidate_tempdir_list(TC):
    1:     """Test the internal function _candidate_tempdir_list."""
       
    1:     def test_nonempty_list(self):
               # _candidate_tempdir_list returns a nonempty list of strings
       
    1:         cand = tempfile._candidate_tempdir_list()
       
    1:         self.assertFalse(len(cand) == 0)
    6:         for c in cand:
    5:             self.assertIsInstance(c, basestring)
       
    1:     def test_wanted_dirs(self):
               # _candidate_tempdir_list contains the expected directories
       
               # Make sure the interesting environment variables are all set.
    1:         with support.EnvironmentVarGuard() as env:
    4:             for envname in 'TMPDIR', 'TEMP', 'TMP':
    3:                 dirname = os.getenv(envname)
    3:                 if not dirname:
    2:                     env[envname] = os.path.abspath(envname)
       
    1:             cand = tempfile._candidate_tempdir_list()
       
    4:             for envname in 'TMPDIR', 'TEMP', 'TMP':
    3:                 dirname = os.getenv(envname)
    3:                 if not dirname: raise ValueError
    3:                 self.assertIn(dirname, cand)
       
    1:             try:
    1:                 dirname = os.getcwd()
>>>>>>             except (AttributeError, os.error):
>>>>>>                 dirname = os.curdir
       
    1:             self.assertIn(dirname, cand)
       
                   # Not practical to try to verify the presence of OS-specific
                   # paths in this list.
       
    1: test_classes.append(test__candidate_tempdir_list)
       
       # We test _get_default_tempdir some more by testing gettempdir.
       
    2: class TestGetDefaultTempdir(TC):
    1:     """Test _get_default_tempdir()."""
       
    1:     def test_no_files_left_behind(self):
               # use a private empty directory
    1:         our_temp_directory = tempfile.mkdtemp()
    1:         try:
                   # force _get_default_tempdir() to consider our empty directory
    1:             def our_candidate_list():
    3:                 return [our_temp_directory]
       
    1:             with support.swap_attr(tempfile, "_candidate_tempdir_list",
    1:                                    our_candidate_list):
                       # verify our directory is empty after _get_default_tempdir()
    1:                 tempfile._get_default_tempdir()
    1:                 self.assertEqual(os.listdir(our_temp_directory), [])
       
    1:                 def raise_OSError(*args, **kwargs):
    2:                     raise OSError(-1)
       
    1:                 with support.swap_attr(io, "open", raise_OSError):
                           # test again with failing io.open()
    1:                     with self.assertRaises(IOError) as cm:
    1:                         tempfile._get_default_tempdir()
    1:                     self.assertEqual(cm.exception.errno, errno.ENOENT)
    1:                     self.assertEqual(os.listdir(our_temp_directory), [])
       
    1:                 def bad_writer(*args, **kwargs):
    1:                     fp = orig_open(*args, **kwargs)
    1:                     fp.write = raise_OSError
    1:                     return fp
       
    1:                 with support.swap_attr(io, "open", bad_writer) as orig_open:
                           # test again with failing write()
    1:                     with self.assertRaises(IOError) as cm:
    1:                         tempfile._get_default_tempdir()
    1:                     self.assertEqual(cm.exception.errno, errno.ENOENT)
    1:                     self.assertEqual(os.listdir(our_temp_directory), [])
               finally:
    1:             shutil.rmtree(our_temp_directory)
       
    1: test_classes.append(TestGetDefaultTempdir)
       
       
    2: class test__get_candidate_names(TC):
    1:     """Test the internal function _get_candidate_names."""
       
    1:     def test_retval(self):
               # _get_candidate_names returns a _RandomNameSequence object
    1:         obj = tempfile._get_candidate_names()
    1:         self.assertIsInstance(obj, tempfile._RandomNameSequence)
       
    1:     def test_same_thing(self):
               # _get_candidate_names always returns the same object
    1:         a = tempfile._get_candidate_names()
    1:         b = tempfile._get_candidate_names()
       
    1:         self.assertTrue(a is b)
       
    1: test_classes.append(test__get_candidate_names)
       
       
    1: @contextlib.contextmanager
       def _inside_empty_temp_dir():
   10:     dir = tempfile.mkdtemp()
   10:     try:
   10:         with support.swap_attr(tempfile, 'tempdir', dir):
   10:             yield
           finally:
   10:         support.rmtree(dir)
       
       
    1: def _mock_candidate_names(*names):
    4:     return support.swap_attr(tempfile,
    4:                              '_get_candidate_names',
   12:                              lambda: iter(names))
       
       
    2: class TestBadTempdir:
       
    1:     def test_read_only_directory(self):
    2:         with _inside_empty_temp_dir():
    2:             oldmode = mode = os.stat(tempfile.tempdir).st_mode
    2:             mode &= ~(stat.S_IWUSR | stat.S_IWGRP | stat.S_IWOTH)
    2:             os.chmod(tempfile.tempdir, mode)
    2:             try:
    2:                 if os.access(tempfile.tempdir, os.W_OK):
>>>>>>                     self.skipTest("can't set the directory read-only")
    2:                 with self.assertRaises(OSError) as cm:
    2:                     self.make_temp()
    2:                 self.assertIn(cm.exception.errno, (errno.EPERM, errno.EACCES))
    2:                 self.assertEqual(os.listdir(tempfile.tempdir), [])
                   finally:
    2:                 os.chmod(tempfile.tempdir, oldmode)
       
    1:     def test_nonexisting_directory(self):
    2:         with _inside_empty_temp_dir():
    2:             tempdir = os.path.join(tempfile.tempdir, 'nonexistent')
    2:             with support.swap_attr(tempfile, 'tempdir', tempdir):
    2:                 with self.assertRaises(OSError) as cm:
    2:                     self.make_temp()
    2:                 self.assertEqual(cm.exception.errno, errno.ENOENT)
       
    1:     def test_non_directory(self):
    2:         with _inside_empty_temp_dir():
    2:             tempdir = os.path.join(tempfile.tempdir, 'file')
    2:             open(tempdir, 'wb').close()
    2:             with support.swap_attr(tempfile, 'tempdir', tempdir):
    2:                 with self.assertRaises(OSError) as cm:
    2:                     self.make_temp()
    2:                 self.assertIn(cm.exception.errno, (errno.ENOTDIR, errno.ENOENT))
       
       
    2: class test__mkstemp_inner(TestBadTempdir, TC):
    1:     """Test the internal function _mkstemp_inner."""
       
    2:     class mkstemped:
    1:         _bflags = tempfile._bin_openflags
    1:         _tflags = tempfile._text_openflags
    1:         _close = os.close
    1:         _unlink = os.unlink
       
    1:         def __init__(self, dir, pre, suf, bin):
  108:             if bin: flags = self._bflags
>>>>>>             else:   flags = self._tflags
       
  108:             (self.fd, self.name) = tempfile._mkstemp_inner(dir, pre, suf, flags)
       
    1:         def write(self, str):
    6:             os.write(self.fd, str)
       
    1:         def __del__(self):
  108:             self._close(self.fd)
  108:             self._unlink(self.name)
       
    1:     def do_create(self, dir=None, pre="", suf="", bin=1):
  108:         if dir is None:
  107:             dir = tempfile.gettempdir()
  108:         try:
  108:             file = self.mkstemped(dir, pre, suf, bin)
>>>>>>         except:
>>>>>>             self.failOnException("_mkstemp_inner")
       
  108:         self.nameCheck(file.name, dir, pre, suf)
  108:         return file
       
    1:     def test_basic(self):
               # _mkstemp_inner can create files
    1:         self.do_create().write("blat")
    1:         self.do_create(pre="a").write("blat")
    1:         self.do_create(suf="b").write("blat")
    1:         self.do_create(pre="a", suf="b").write("blat")
    1:         self.do_create(pre="aa", suf=".txt").write("blat")
       
    1:     def test_basic_many(self):
               # _mkstemp_inner can create many files (stochastic)
    1:         extant = range(TEST_FILES)
  101:         for i in extant:
  100:             extant[i] = self.do_create(pre="aa")
       
    1:     def test_choose_directory(self):
               # _mkstemp_inner can create files in a user-selected directory
    1:         dir = tempfile.mkdtemp()
    1:         try:
    1:             self.do_create(dir=dir).write("blat")
               finally:
    1:             os.rmdir(dir)
       
    1:     @unittest.skipUnless(has_stat, 'os.stat not available')
           def test_file_mode(self):
               # _mkstemp_inner creates files with the proper mode
       
    1:         file = self.do_create()
    1:         mode = stat.S_IMODE(os.stat(file.name).st_mode)
    1:         expected = 0600
    1:         if sys.platform in ('win32', 'os2emx'):
                   # There's no distinction among 'user', 'group' and 'world';
                   # replicate the 'user' bits.
>>>>>>             user = expected >> 6
>>>>>>             expected = user * (1 + 8 + 64)
    1:         self.assertEqual(mode, expected)
       
    1:     @unittest.skipUnless(has_spawnl, 'os.spawnl not available')
           def test_noinherit(self):
               # _mkstemp_inner file handles are not inherited by child processes
       
    1:         if support.verbose:
>>>>>>             v="v"
               else:
    1:             v="q"
       
    1:         file = self.do_create()
    1:         fd = "%d" % file.fd
       
    1:         try:
    1:             me = __file__
>>>>>>         except NameError:
>>>>>>             me = sys.argv[0]
       
               # We have to exec something, so that FD_CLOEXEC will take
               # effect.  The core of this test is therefore in
               # tf_inherit_check.py, which see.
    1:         tester = os.path.join(os.path.dirname(os.path.abspath(me)),
    1:                               "tf_inherit_check.py")
       
               # On Windows a spawn* /path/ with embedded spaces shouldn't be quoted,
               # but an arg with embedded spaces should be decorated with double
               # quotes on each end
    1:         if sys.platform in ('win32',):
>>>>>>             decorated = '"%s"' % sys.executable
>>>>>>             tester = '"%s"' % tester
               else:
    1:             decorated = sys.executable
       
    1:         retval = os.spawnl(os.P_WAIT, sys.executable, decorated, tester, v, fd)
    1:         self.assertFalse(retval < 0,
    1:                     "child process caught fatal signal %d" % -retval)
    1:         self.assertFalse(retval > 0, "child process reports failure %d"%retval)
       
    1:     @unittest.skipUnless(has_textmode, "text mode not available")
           def test_textmode(self):
               # _mkstemp_inner can create files in text mode
       
>>>>>>         self.do_create(bin=0).write("blat\n")
               # XXX should test that the file really is a text file
       
    1:     def make_temp(self):
    6:         return tempfile._mkstemp_inner(tempfile.gettempdir(),
    6:                                        tempfile.template,
    6:                                        '',
    6:                                        tempfile._bin_openflags)
       
    1:     def test_collision_with_existing_file(self):
               # _mkstemp_inner tries another name when a file with
               # the chosen name already exists
    1:         with _inside_empty_temp_dir(), \
    1:              _mock_candidate_names('aaa', 'aaa', 'bbb'):
    1:             (fd1, name1) = self.make_temp()
    1:             os.close(fd1)
    1:             self.assertTrue(name1.endswith('aaa'))
       
    1:             (fd2, name2) = self.make_temp()
    1:             os.close(fd2)
    1:             self.assertTrue(name2.endswith('bbb'))
       
    1:     def test_collision_with_existing_directory(self):
               # _mkstemp_inner tries another name when a directory with
               # the chosen name already exists
    1:         with _inside_empty_temp_dir(), \
    1:              _mock_candidate_names('aaa', 'aaa', 'bbb'):
    1:             dir = tempfile.mkdtemp()
    1:             self.assertTrue(dir.endswith('aaa'))
       
    1:             (fd, name) = self.make_temp()
    1:             os.close(fd)
    1:             self.assertTrue(name.endswith('bbb'))
       
    1: test_classes.append(test__mkstemp_inner)
       
       
    2: class test_gettempprefix(TC):
    1:     """Test gettempprefix()."""
       
    1:     def test_sane_template(self):
               # gettempprefix returns a nonempty prefix string
    1:         p = tempfile.gettempprefix()
       
    1:         self.assertIsInstance(p, basestring)
    1:         self.assertTrue(len(p) > 0)
       
    1:     def test_usable_template(self):
               # gettempprefix returns a usable prefix string
       
               # Create a temp directory, avoiding use of the prefix.
               # Then attempt to create a file whose name is
               # prefix + 'xxxxxx.xxx' in that directory.
    1:         p = tempfile.gettempprefix() + "xxxxxx.xxx"
    1:         d = tempfile.mkdtemp(prefix="")
    1:         try:
    1:             p = os.path.join(d, p)
    1:             try:
    1:                 fd = os.open(p, os.O_RDWR | os.O_CREAT)
>>>>>>             except:
>>>>>>                 self.failOnException("os.open")
    1:             os.close(fd)
    1:             os.unlink(p)
               finally:
    1:             os.rmdir(d)
       
    1: test_classes.append(test_gettempprefix)
       
       
    2: class test_gettempdir(TC):
    1:     """Test gettempdir()."""
       
    1:     def test_directory_exists(self):
               # gettempdir returns a directory which exists
       
    1:         dir = tempfile.gettempdir()
    1:         self.assertTrue(os.path.isabs(dir) or dir == os.curdir,
    1:                      "%s is not an absolute path" % dir)
    1:         self.assertTrue(os.path.isdir(dir),
    1:                      "%s is not a directory" % dir)
       
    1:     def test_directory_writable(self):
               # gettempdir returns a directory writable by the user
       
               # sneaky: just instantiate a NamedTemporaryFile, which
               # defaults to writing into the directory returned by
               # gettempdir.
    1:         try:
    1:             file = tempfile.NamedTemporaryFile()
    1:             file.write("blat")
    1:             file.close()
>>>>>>         except:
>>>>>>             self.failOnException("create file in %s" % tempfile.gettempdir())
       
    1:     def test_same_thing(self):
               # gettempdir always returns the same object
    1:         a = tempfile.gettempdir()
    1:         b = tempfile.gettempdir()
       
    1:         self.assertTrue(a is b)
       
    1: test_classes.append(test_gettempdir)
       
       
    2: class test_mkstemp(TC):
    1:     """Test mkstemp()."""
       
    1:     def do_create(self, dir=None, pre="", suf=""):
    7:         if dir is None:
    5:             dir = tempfile.gettempdir()
    7:         try:
    7:             (fd, name) = tempfile.mkstemp(dir=dir, prefix=pre, suffix=suf)
    7:             (ndir, nbase) = os.path.split(name)
    7:             adir = os.path.abspath(dir)
    7:             self.assertEqual(adir, ndir,
    7:                 "Directory '%s' incorrectly returned as '%s'" % (adir, ndir))
>>>>>>         except:
>>>>>>             self.failOnException("mkstemp")
       
    7:         try:
    7:             self.nameCheck(name, dir, pre, suf)
               finally:
    7:             os.close(fd)
    7:             os.unlink(name)
       
    1:     def test_basic(self):
               # mkstemp can create files
    1:         self.do_create()
    1:         self.do_create(pre="a")
    1:         self.do_create(suf="b")
    1:         self.do_create(pre="a", suf="b")
    1:         self.do_create(pre="aa", suf=".txt")
    1:         self.do_create(dir=".")
       
    1:     def test_choose_directory(self):
               # mkstemp can create directories in a user-selected directory
    1:         dir = tempfile.mkdtemp()
    1:         try:
    1:             self.do_create(dir=dir)
               finally:
    1:             os.rmdir(dir)
       
    1: test_classes.append(test_mkstemp)
       
       
    2: class test_mkdtemp(TestBadTempdir, TC):
    1:     """Test mkdtemp()."""
       
    1:     def make_temp(self):
    3:         return tempfile.mkdtemp()
       
    1:     def do_create(self, dir=None, pre="", suf=""):
  107:         if dir is None:
  106:             dir = tempfile.gettempdir()
  107:         try:
  107:             name = tempfile.mkdtemp(dir=dir, prefix=pre, suffix=suf)
>>>>>>         except:
>>>>>>             self.failOnException("mkdtemp")
       
  107:         try:
  107:             self.nameCheck(name, dir, pre, suf)
  107:             return name
>>>>>>         except:
>>>>>>             os.rmdir(name)
>>>>>>             raise
       
    1:     def test_basic(self):
               # mkdtemp can create directories
    1:         os.rmdir(self.do_create())
    1:         os.rmdir(self.do_create(pre="a"))
    1:         os.rmdir(self.do_create(suf="b"))
    1:         os.rmdir(self.do_create(pre="a", suf="b"))
    1:         os.rmdir(self.do_create(pre="aa", suf=".txt"))
       
    1:     def test_basic_many(self):
               # mkdtemp can create many directories (stochastic)
    1:         extant = range(TEST_FILES)
    1:         try:
  101:             for i in extant:
  100:                 extant[i] = self.do_create(pre="aa")
               finally:
  101:             for i in extant:
  100:                 if(isinstance(i, basestring)):
  100:                     os.rmdir(i)
       
    1:     def test_choose_directory(self):
               # mkdtemp can create directories in a user-selected directory
    1:         dir = tempfile.mkdtemp()
    1:         try:
    1:             os.rmdir(self.do_create(dir=dir))
               finally:
    1:             os.rmdir(dir)
       
    1:     @unittest.skipUnless(has_stat, 'os.stat not available')
           def test_mode(self):
               # mkdtemp creates directories with the proper mode
       
    1:         dir = self.do_create()
    1:         try:
    1:             mode = stat.S_IMODE(os.stat(dir).st_mode)
    1:             mode &= 0777 # Mask off sticky bits inherited from /tmp
    1:             expected = 0700
    1:             if sys.platform in ('win32', 'os2emx'):
                       # There's no distinction among 'user', 'group' and 'world';
                       # replicate the 'user' bits.
>>>>>>                 user = expected >> 6
>>>>>>                 expected = user * (1 + 8 + 64)
    1:             self.assertEqual(mode, expected)
               finally:
    1:             os.rmdir(dir)
       
    1:     def test_collision_with_existing_file(self):
               # mkdtemp tries another name when a file with
               # the chosen name already exists
    1:         with _inside_empty_temp_dir(), \
    1:              _mock_candidate_names('aaa', 'aaa', 'bbb'):
    1:             file = tempfile.NamedTemporaryFile(delete=False)
    1:             file.close()
    1:             self.assertTrue(file.name.endswith('aaa'))
    1:             dir = tempfile.mkdtemp()
    1:             self.assertTrue(dir.endswith('bbb'))
       
    1:     def test_collision_with_existing_directory(self):
               # mkdtemp tries another name when a directory with
               # the chosen name already exists
    1:         with _inside_empty_temp_dir(), \
    1:              _mock_candidate_names('aaa', 'aaa', 'bbb'):
    1:             dir1 = tempfile.mkdtemp()
    1:             self.assertTrue(dir1.endswith('aaa'))
    1:             dir2 = tempfile.mkdtemp()
    1:             self.assertTrue(dir2.endswith('bbb'))
       
    1: test_classes.append(test_mkdtemp)
       
       
    2: class test_mktemp(TC):
    1:     """Test mktemp()."""
       
           # For safety, all use of mktemp must occur in a private directory.
           # We must also suppress the RuntimeWarning it generates.
    1:     def setUp(self):
    2:         self.dir = tempfile.mkdtemp()
       
    1:     def tearDown(self):
    2:         if self.dir:
    2:             os.rmdir(self.dir)
    2:             self.dir = None
       
    2:     class mktemped:
    1:         _unlink = os.unlink
    1:         _bflags = tempfile._bin_openflags
       
    1:         def __init__(self, dir, pre, suf):
  105:             self.name = tempfile.mktemp(dir=dir, prefix=pre, suffix=suf)
                   # Create the file.  This will raise an exception if it's
                   # mysteriously appeared in the meanwhile.
  105:             os.close(os.open(self.name, self._bflags, 0600))
       
    1:         def __del__(self):
  105:             self._unlink(self.name)
       
    1:     def do_create(self, pre="", suf=""):
  105:         try:
  105:             file = self.mktemped(self.dir, pre, suf)
>>>>>>         except:
>>>>>>             self.failOnException("mktemp")
       
  105:         self.nameCheck(file.name, self.dir, pre, suf)
  105:         return file
       
    1:     def test_basic(self):
               # mktemp can choose usable file names
    1:         self.do_create()
    1:         self.do_create(pre="a")
    1:         self.do_create(suf="b")
    1:         self.do_create(pre="a", suf="b")
    1:         self.do_create(pre="aa", suf=".txt")
       
    1:     def test_many(self):
               # mktemp can choose many usable file names (stochastic)
    1:         extant = range(TEST_FILES)
  101:         for i in extant:
  100:             extant[i] = self.do_create(pre="aa")
       
       ##     def test_warning(self):
       ##         # mktemp issues a warning when used
       ##         warnings.filterwarnings("error",
       ##                                 category=RuntimeWarning,
       ##                                 message="mktemp")
       ##         self.assertRaises(RuntimeWarning,
       ##                           tempfile.mktemp, dir=self.dir)
       
    1: test_classes.append(test_mktemp)
       
       
       # We test _TemporaryFileWrapper by testing NamedTemporaryFile.
       
       
    2: class test_NamedTemporaryFile(TC):
    1:     """Test NamedTemporaryFile()."""
       
    1:     def do_create(self, dir=None, pre="", suf="", delete=True):
    5:         if dir is None:
    5:             dir = tempfile.gettempdir()
    5:         try:
    5:             file = tempfile.NamedTemporaryFile(dir=dir, prefix=pre, suffix=suf,
    5:                                                delete=delete)
>>>>>>         except:
>>>>>>             self.failOnException("NamedTemporaryFile")
       
    5:         self.nameCheck(file.name, dir, pre, suf)
    5:         return file
       
       
    1:     def test_basic(self):
               # NamedTemporaryFile can create files
    1:         self.do_create()
    1:         self.do_create(pre="a")
    1:         self.do_create(suf="b")
    1:         self.do_create(pre="a", suf="b")
    1:         self.do_create(pre="aa", suf=".txt")
       
    1:     def test_creates_named(self):
               # NamedTemporaryFile creates files with names
    1:         f = tempfile.NamedTemporaryFile()
    1:         self.assertTrue(os.path.exists(f.name),
    1:                         "NamedTemporaryFile %s does not exist" % f.name)
       
    1:     def test_del_on_close(self):
               # A NamedTemporaryFile is deleted when closed
    1:         dir = tempfile.mkdtemp()
    1:         try:
    1:             f = tempfile.NamedTemporaryFile(dir=dir)
    1:             f.write('blat')
    1:             f.close()
    1:             self.assertFalse(os.path.exists(f.name),
    1:                         "NamedTemporaryFile %s exists after close" % f.name)
               finally:
    1:             os.rmdir(dir)
       
    1:     def test_dis_del_on_close(self):
               # Tests that delete-on-close can be disabled
    1:         dir = tempfile.mkdtemp()
    1:         tmp = None
    1:         try:
    1:             f = tempfile.NamedTemporaryFile(dir=dir, delete=False)
    1:             tmp = f.name
    1:             f.write('blat')
    1:             f.close()
    1:             self.assertTrue(os.path.exists(f.name),
    1:                         "NamedTemporaryFile %s missing after close" % f.name)
               finally:
    1:             if tmp is not None:
    1:                 os.unlink(tmp)
    1:             os.rmdir(dir)
       
    1:     def test_multiple_close(self):
               # A NamedTemporaryFile can be closed many times without error
    1:         f = tempfile.NamedTemporaryFile()
    1:         f.write('abc\n')
    1:         f.close()
    1:         try:
    1:             f.close()
    1:             f.close()
>>>>>>         except:
>>>>>>             self.failOnException("close")
       
    1:     def test_context_manager(self):
               # A NamedTemporaryFile can be used as a context manager
    1:         with tempfile.NamedTemporaryFile() as f:
    1:             self.assertTrue(os.path.exists(f.name))
    1:         self.assertFalse(os.path.exists(f.name))
    1:         def use_closed():
    1:             with f:
>>>>>>                 pass
    1:         self.assertRaises(ValueError, use_closed)
       
    1:     def test_no_leak_fd(self):
               # Issue #21058: don't leak file descriptor when fdopen() fails
    1:         old_close = os.close
    1:         old_fdopen = os.fdopen
    1:         closed = []
    1:         def close(fd):
    1:             closed.append(fd)
    1:         def fdopen(*args):
    1:             raise ValueError()
    1:         os.close = close
    1:         os.fdopen = fdopen
    1:         try:
    1:             self.assertRaises(ValueError, tempfile.NamedTemporaryFile)
    1:             self.assertEqual(len(closed), 1)
               finally:
    1:             os.close = old_close
    1:             os.fdopen = old_fdopen
       
    1:     def test_bad_mode(self):
    1:         dir = tempfile.mkdtemp()
    1:         self.addCleanup(support.rmtree, dir)
    1:         with self.assertRaises(TypeError):
    1:             tempfile.NamedTemporaryFile(mode=(), dir=dir)
    1:         self.assertEqual(os.listdir(dir), [])
       
           # How to test the mode and bufsize parameters?
       
    1: test_classes.append(test_NamedTemporaryFile)
       
    2: class test_SpooledTemporaryFile(TC):
    1:     """Test SpooledTemporaryFile()."""
       
    1:     def do_create(self, max_size=0, dir=None, pre="", suf=""):
   10:         if dir is None:
   10:             dir = tempfile.gettempdir()
   10:         try:
   10:             file = tempfile.SpooledTemporaryFile(max_size=max_size, dir=dir, prefix=pre, suffix=suf)
>>>>>>         except:
>>>>>>             self.failOnException("SpooledTemporaryFile")
       
   10:         return file
       
       
    1:     def test_basic(self):
               # SpooledTemporaryFile can create files
    1:         f = self.do_create()
    1:         self.assertFalse(f._rolled)
    1:         f = self.do_create(max_size=100, pre="a", suf=".txt")
    1:         self.assertFalse(f._rolled)
       
    1:     def test_del_on_close(self):
               # A SpooledTemporaryFile is deleted when closed
    1:         dir = tempfile.mkdtemp()
    1:         try:
    1:             f = tempfile.SpooledTemporaryFile(max_size=10, dir=dir)
    1:             self.assertFalse(f._rolled)
    1:             f.write('blat ' * 5)
    1:             self.assertTrue(f._rolled)
    1:             filename = f.name
    1:             f.close()
    1:             self.assertFalse(os.path.exists(filename),
    1:                         "SpooledTemporaryFile %s exists after close" % filename)
               finally:
    1:             os.rmdir(dir)
       
    1:     def test_rewrite_small(self):
               # A SpooledTemporaryFile can be written to multiple within the max_size
    1:         f = self.do_create(max_size=30)
    1:         self.assertFalse(f._rolled)
    6:         for i in range(5):
    5:             f.seek(0, 0)
    5:             f.write('x' * 20)
    1:         self.assertFalse(f._rolled)
       
    1:     def test_write_sequential(self):
               # A SpooledTemporaryFile should hold exactly max_size bytes, and roll
               # over afterward
    1:         f = self.do_create(max_size=30)
    1:         self.assertFalse(f._rolled)
    1:         f.write('x' * 20)
    1:         self.assertFalse(f._rolled)
    1:         f.write('x' * 10)
    1:         self.assertFalse(f._rolled)
    1:         f.write('x')
    1:         self.assertTrue(f._rolled)
       
    1:     def test_writelines(self):
               # Verify writelines with a SpooledTemporaryFile
    1:         f = self.do_create()
    1:         f.writelines((b'x', b'y', b'z'))
    1:         f.seek(0)
    1:         buf = f.read()
    1:         self.assertEqual(buf, b'xyz')
       
    1:     def test_writelines_sequential(self):
               # A SpooledTemporaryFile should hold exactly max_size bytes, and roll
               # over afterward
    1:         f = self.do_create(max_size=35)
    1:         f.writelines((b'x' * 20, b'x' * 10, b'x' * 5))
    1:         self.assertFalse(f._rolled)
    1:         f.write(b'x')
    1:         self.assertTrue(f._rolled)
       
    1:     def test_xreadlines(self):
    1:         f = self.do_create(max_size=20)
    1:         f.write(b'abc\n' * 5)
    1:         f.seek(0)
    1:         self.assertFalse(f._rolled)
    1:         self.assertEqual(list(f.xreadlines()), [b'abc\n'] * 5)
    1:         f.write(b'x\ny')
    1:         self.assertTrue(f._rolled)
    1:         f.seek(0)
    1:         self.assertEqual(list(f.xreadlines()), [b'abc\n'] * 5 + [b'x\n', b'y'])
       
    1:     def test_sparse(self):
               # A SpooledTemporaryFile that is written late in the file will extend
               # when that occurs
    1:         f = self.do_create(max_size=30)
    1:         self.assertFalse(f._rolled)
    1:         f.seek(100, 0)
    1:         self.assertFalse(f._rolled)
    1:         f.write('x')
    1:         self.assertTrue(f._rolled)
       
    1:     def test_fileno(self):
               # A SpooledTemporaryFile should roll over to a real file on fileno()
    1:         f = self.do_create(max_size=30)
    1:         self.assertFalse(f._rolled)
    1:         self.assertTrue(f.fileno() > 0)
    1:         self.assertTrue(f._rolled)
       
    1:     def test_multiple_close_before_rollover(self):
               # A SpooledTemporaryFile can be closed many times without error
    1:         f = tempfile.SpooledTemporaryFile()
    1:         f.write('abc\n')
    1:         self.assertFalse(f._rolled)
    1:         f.close()
    1:         try:
    1:             f.close()
    1:             f.close()
>>>>>>         except:
>>>>>>             self.failOnException("close")
       
    1:     def test_multiple_close_after_rollover(self):
               # A SpooledTemporaryFile can be closed many times without error
    1:         f = tempfile.SpooledTemporaryFile(max_size=1)
    1:         f.write('abc\n')
    1:         self.assertTrue(f._rolled)
    1:         f.close()
    1:         try:
    1:             f.close()
    1:             f.close()
>>>>>>         except:
>>>>>>             self.failOnException("close")
       
    1:     def test_bound_methods(self):
               # It should be OK to steal a bound method from a SpooledTemporaryFile
               # and use it independently; when the file rolls over, those bound
               # methods should continue to function
    1:         f = self.do_create(max_size=30)
    1:         read = f.read
    1:         write = f.write
    1:         seek = f.seek
       
    1:         write("a" * 35)
    1:         write("b" * 35)
    1:         seek(0, 0)
    1:         self.assertTrue(read(70) == 'a'*35 + 'b'*35)
       
    1:     def test_properties(self):
    1:         f = tempfile.SpooledTemporaryFile(max_size=10)
    1:         f.write(b'x' * 10)
    1:         self.assertFalse(f._rolled)
    1:         self.assertEqual(f.mode, 'w+b')
    1:         self.assertIsNone(f.name)
    1:         with self.assertRaises(AttributeError):
    1:             f.newlines
    1:         with self.assertRaises(AttributeError):
    1:             f.encoding
       
    1:         f.write(b'x')
    1:         self.assertTrue(f._rolled)
    1:         self.assertEqual(f.mode, 'w+b')
    1:         self.assertIsNotNone(f.name)
    1:         with self.assertRaises(AttributeError):
    1:             f.newlines
    1:         with self.assertRaises(AttributeError):
    1:             f.encoding
       
    1:     def test_context_manager_before_rollover(self):
               # A SpooledTemporaryFile can be used as a context manager
    1:         with tempfile.SpooledTemporaryFile(max_size=1) as f:
    1:             self.assertFalse(f._rolled)
    1:             self.assertFalse(f.closed)
    1:         self.assertTrue(f.closed)
    1:         def use_closed():
    1:             with f:
>>>>>>                 pass
    1:         self.assertRaises(ValueError, use_closed)
       
    1:     def test_context_manager_during_rollover(self):
               # A SpooledTemporaryFile can be used as a context manager
    1:         with tempfile.SpooledTemporaryFile(max_size=1) as f:
    1:             self.assertFalse(f._rolled)
    1:             f.write('abc\n')
    1:             f.flush()
    1:             self.assertTrue(f._rolled)
    1:             self.assertFalse(f.closed)
    1:         self.assertTrue(f.closed)
    1:         def use_closed():
    1:             with f:
>>>>>>                 pass
    1:         self.assertRaises(ValueError, use_closed)
       
    1:     def test_context_manager_after_rollover(self):
               # A SpooledTemporaryFile can be used as a context manager
    1:         f = tempfile.SpooledTemporaryFile(max_size=1)
    1:         f.write('abc\n')
    1:         f.flush()
    1:         self.assertTrue(f._rolled)
    1:         with f:
    1:             self.assertFalse(f.closed)
    1:         self.assertTrue(f.closed)
    1:         def use_closed():
    1:             with f:
>>>>>>                 pass
    1:         self.assertRaises(ValueError, use_closed)
       
       
    1: test_classes.append(test_SpooledTemporaryFile)
       
       
    2: class test_TemporaryFile(TC):
    1:     """Test TemporaryFile()."""
       
    1:     def test_basic(self):
               # TemporaryFile can create files
               # No point in testing the name params - the file has no name.
    1:         try:
    1:             tempfile.TemporaryFile()
>>>>>>         except:
>>>>>>             self.failOnException("TemporaryFile")
       
    1:     def test_has_no_name(self):
               # TemporaryFile creates files with no names (on this system)
    1:         dir = tempfile.mkdtemp()
    1:         f = tempfile.TemporaryFile(dir=dir)
    1:         f.write('blat')
       
               # Sneaky: because this file has no name, it should not prevent
               # us from removing the directory it was created in.
    1:         try:
    1:             os.rmdir(dir)
>>>>>>         except:
>>>>>>             ei = sys.exc_info()
                   # cleanup
>>>>>>             f.close()
>>>>>>             os.rmdir(dir)
>>>>>>             self.failOnException("rmdir", ei)
       
    1:     def test_multiple_close(self):
               # A TemporaryFile can be closed many times without error
    1:         f = tempfile.TemporaryFile()
    1:         f.write('abc\n')
    1:         f.close()
    1:         try:
    1:             f.close()
    1:             f.close()
>>>>>>         except:
>>>>>>             self.failOnException("close")
       
           # How to test the mode and bufsize parameters?
       
       
    1: if tempfile.NamedTemporaryFile is not tempfile.TemporaryFile:
    1:     test_classes.append(test_TemporaryFile)
       
    1: def test_main():
    1:     support.run_unittest(*test_classes)
       
    1: if __name__ == "__main__":
>>>>>>     test_main()
