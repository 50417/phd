       # Copyright 2001-2013 by Vinay Sajip. All Rights Reserved.
       #
       # Permission to use, copy, modify, and distribute this software and its
       # documentation for any purpose and without fee is hereby granted,
       # provided that the above copyright notice appear in all copies and that
       # both that copyright notice and this permission notice appear in
       # supporting documentation, and that the name of Vinay Sajip
       # not be used in advertising or publicity pertaining to distribution
       # of the software without specific, written prior permission.
       # VINAY SAJIP DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
       # ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
       # VINAY SAJIP BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
       # ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
       # IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
       # OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
       
       """Test harness for the logging module. Run all tests.
       
       Copyright (C) 2001-2013 Vinay Sajip. All Rights Reserved.
    1: """
       
    1: import logging
    1: import logging.handlers
    1: import logging.config
       
    1: import codecs
    1: import cPickle
    1: import cStringIO
    1: import gc
    1: import json
    1: import os
    1: import random
    1: import re
    1: import select
    1: import socket
    1: from SocketServer import ThreadingTCPServer, StreamRequestHandler
    1: import struct
    1: import sys
    1: import tempfile
    1: from test.test_support import captured_stdout, run_with_locale, run_unittest
    1: import textwrap
    1: import time
    1: import unittest
    1: import warnings
    1: import weakref
    1: try:
    1:     import threading
>>>>>> except ImportError:
>>>>>>     threading = None
       
    2: class BaseTest(unittest.TestCase):
       
    1:     """Base class for logging tests."""
       
    1:     log_format = "%(name)s -> %(levelname)s: %(message)s"
    1:     expected_log_pat = r"^([\w.]+) -> ([\w]+): ([\d]+)$"
    1:     message_num = 0
       
    1:     def setUp(self):
               """Setup the default logging stream to an internal StringIO instance,
               so that we can examine log output as we want."""
   48:         logger_dict = logging.getLogger().manager.loggerDict
   48:         logging._acquireLock()
   48:         try:
   48:             self.saved_handlers = logging._handlers.copy()
   48:             self.saved_handler_list = logging._handlerList[:]
   48:             self.saved_loggers = logger_dict.copy()
   48:             self.saved_level_names = logging._levelNames.copy()
               finally:
   48:             logging._releaseLock()
       
               # Set two unused loggers: one non-ASCII and one Unicode.
               # This is to test correct operation when sorting existing
               # loggers in the configuration code. See issue 8201.
   48:         logging.getLogger("\xab\xd7\xbb")
   48:         logging.getLogger(u"\u013f\u00d6\u0047")
       
   48:         self.root_logger = logging.getLogger("")
   48:         self.original_logging_level = self.root_logger.getEffectiveLevel()
       
   48:         self.stream = cStringIO.StringIO()
   48:         self.root_logger.setLevel(logging.DEBUG)
   48:         self.root_hdlr = logging.StreamHandler(self.stream)
   48:         self.root_formatter = logging.Formatter(self.log_format)
   48:         self.root_hdlr.setFormatter(self.root_formatter)
   48:         self.root_logger.addHandler(self.root_hdlr)
       
    1:     def tearDown(self):
               """Remove our logging stream, and restore the original logging
               level."""
   48:         self.stream.close()
   48:         self.root_logger.removeHandler(self.root_hdlr)
   57:         while self.root_logger.handlers:
    9:             h = self.root_logger.handlers[0]
    9:             self.root_logger.removeHandler(h)
    9:             h.close()
   48:         self.root_logger.setLevel(self.original_logging_level)
   48:         logging._acquireLock()
   48:         try:
   48:             logging._levelNames.clear()
   48:             logging._levelNames.update(self.saved_level_names)
   48:             logging._handlers.clear()
   48:             logging._handlers.update(self.saved_handlers)
   48:             logging._handlerList[:] = self.saved_handler_list
   48:             loggerDict = logging.getLogger().manager.loggerDict
   48:             loggerDict.clear()
   48:             loggerDict.update(self.saved_loggers)
               finally:
   48:             logging._releaseLock()
       
    1:     def assert_log_lines(self, expected_values, stream=None):
               """Match the collected log lines against the regular expression
               self.expected_log_pat, and compare the extracted group values to
               the expected_values list of tuples."""
   57:         stream = stream or self.stream
   57:         pat = re.compile(self.expected_log_pat)
   57:         try:
   57:             stream.reset()
   37:             actual_lines = stream.readlines()
   20:         except AttributeError:
                   # StringIO.StringIO lacks a reset() method.
   20:             actual_lines = stream.getvalue().splitlines()
   57:         self.assertEqual(len(actual_lines), len(expected_values))
  237:         for actual, expected in zip(actual_lines, expected_values):
  180:             match = pat.search(actual)
  180:             if not match:
>>>>>>                 self.fail("Log line does not match expected pattern:\n" +
>>>>>>                             actual)
  180:             self.assertEqual(tuple(match.groups()), expected)
   57:         s = stream.read()
   57:         if s:
>>>>>>             self.fail("Remaining output at end of log stream:\n" + s)
       
    1:     def next_message(self):
               """Generate a message consisting solely of an auto-incrementing
               integer."""
  154:         self.message_num += 1
  154:         return "%d" % self.message_num
       
       
    2: class BuiltinLevelsTest(BaseTest):
    1:     """Test builtin levels and their inheritance."""
       
    1:     def test_flat(self):
               #Logging levels in a flat logger namespace.
    1:         m = self.next_message
       
    1:         ERR = logging.getLogger("ERR")
    1:         ERR.setLevel(logging.ERROR)
    1:         INF = logging.getLogger("INF")
    1:         INF.setLevel(logging.INFO)
    1:         DEB = logging.getLogger("DEB")
    1:         DEB.setLevel(logging.DEBUG)
       
               # These should log.
    1:         ERR.log(logging.CRITICAL, m())
    1:         ERR.error(m())
       
    1:         INF.log(logging.CRITICAL, m())
    1:         INF.error(m())
    1:         INF.warn(m())
    1:         INF.info(m())
       
    1:         DEB.log(logging.CRITICAL, m())
    1:         DEB.error(m())
    1:         DEB.warn (m())
    1:         DEB.info (m())
    1:         DEB.debug(m())
       
               # These should not log.
    1:         ERR.warn(m())
    1:         ERR.info(m())
    1:         ERR.debug(m())
       
    1:         INF.debug(m())
       
    1:         self.assert_log_lines([
    1:             ('ERR', 'CRITICAL', '1'),
    1:             ('ERR', 'ERROR', '2'),
    1:             ('INF', 'CRITICAL', '3'),
    1:             ('INF', 'ERROR', '4'),
    1:             ('INF', 'WARNING', '5'),
    1:             ('INF', 'INFO', '6'),
    1:             ('DEB', 'CRITICAL', '7'),
    1:             ('DEB', 'ERROR', '8'),
    1:             ('DEB', 'WARNING', '9'),
    1:             ('DEB', 'INFO', '10'),
    1:             ('DEB', 'DEBUG', '11'),
               ])
       
    1:     def test_nested_explicit(self):
               # Logging levels in a nested namespace, all explicitly set.
    1:         m = self.next_message
       
    1:         INF = logging.getLogger("INF")
    1:         INF.setLevel(logging.INFO)
    1:         INF_ERR  = logging.getLogger("INF.ERR")
    1:         INF_ERR.setLevel(logging.ERROR)
       
               # These should log.
    1:         INF_ERR.log(logging.CRITICAL, m())
    1:         INF_ERR.error(m())
       
               # These should not log.
    1:         INF_ERR.warn(m())
    1:         INF_ERR.info(m())
    1:         INF_ERR.debug(m())
       
    1:         self.assert_log_lines([
    1:             ('INF.ERR', 'CRITICAL', '1'),
    1:             ('INF.ERR', 'ERROR', '2'),
               ])
       
    1:     def test_nested_inherited(self):
               #Logging levels in a nested namespace, inherited from parent loggers.
    1:         m = self.next_message
       
    1:         INF = logging.getLogger("INF")
    1:         INF.setLevel(logging.INFO)
    1:         INF_ERR  = logging.getLogger("INF.ERR")
    1:         INF_ERR.setLevel(logging.ERROR)
    1:         INF_UNDEF = logging.getLogger("INF.UNDEF")
    1:         INF_ERR_UNDEF = logging.getLogger("INF.ERR.UNDEF")
    1:         UNDEF = logging.getLogger("UNDEF")
       
               # These should log.
    1:         INF_UNDEF.log(logging.CRITICAL, m())
    1:         INF_UNDEF.error(m())
    1:         INF_UNDEF.warn(m())
    1:         INF_UNDEF.info(m())
    1:         INF_ERR_UNDEF.log(logging.CRITICAL, m())
    1:         INF_ERR_UNDEF.error(m())
       
               # These should not log.
    1:         INF_UNDEF.debug(m())
    1:         INF_ERR_UNDEF.warn(m())
    1:         INF_ERR_UNDEF.info(m())
    1:         INF_ERR_UNDEF.debug(m())
       
    1:         self.assert_log_lines([
    1:             ('INF.UNDEF', 'CRITICAL', '1'),
    1:             ('INF.UNDEF', 'ERROR', '2'),
    1:             ('INF.UNDEF', 'WARNING', '3'),
    1:             ('INF.UNDEF', 'INFO', '4'),
    1:             ('INF.ERR.UNDEF', 'CRITICAL', '5'),
    1:             ('INF.ERR.UNDEF', 'ERROR', '6'),
               ])
       
    1:     def test_nested_with_virtual_parent(self):
               # Logging levels when some parent does not exist yet.
    1:         m = self.next_message
       
    1:         INF = logging.getLogger("INF")
    1:         GRANDCHILD = logging.getLogger("INF.BADPARENT.UNDEF")
    1:         CHILD = logging.getLogger("INF.BADPARENT")
    1:         INF.setLevel(logging.INFO)
       
               # These should log.
    1:         GRANDCHILD.log(logging.FATAL, m())
    1:         GRANDCHILD.info(m())
    1:         CHILD.log(logging.FATAL, m())
    1:         CHILD.info(m())
       
               # These should not log.
    1:         GRANDCHILD.debug(m())
    1:         CHILD.debug(m())
       
    1:         self.assert_log_lines([
    1:             ('INF.BADPARENT.UNDEF', 'CRITICAL', '1'),
    1:             ('INF.BADPARENT.UNDEF', 'INFO', '2'),
    1:             ('INF.BADPARENT', 'CRITICAL', '3'),
    1:             ('INF.BADPARENT', 'INFO', '4'),
               ])
       
    1:     def test_invalid_name(self):
    1:         self.assertRaises(TypeError, logging.getLogger, any)
       
    2: class BasicFilterTest(BaseTest):
       
    1:     """Test the bundled Filter class."""
       
    1:     def test_filter(self):
               # Only messages satisfying the specified criteria pass through the
               #  filter.
    1:         filter_ = logging.Filter("spam.eggs")
    1:         handler = self.root_logger.handlers[0]
    1:         try:
    1:             handler.addFilter(filter_)
    1:             spam = logging.getLogger("spam")
    1:             spam_eggs = logging.getLogger("spam.eggs")
    1:             spam_eggs_fish = logging.getLogger("spam.eggs.fish")
    1:             spam_bakedbeans = logging.getLogger("spam.bakedbeans")
       
    1:             spam.info(self.next_message())
    1:             spam_eggs.info(self.next_message())  # Good.
    1:             spam_eggs_fish.info(self.next_message())  # Good.
    1:             spam_bakedbeans.info(self.next_message())
       
    1:             self.assert_log_lines([
    1:                 ('spam.eggs', 'INFO', '2'),
    1:                 ('spam.eggs.fish', 'INFO', '3'),
                   ])
               finally:
    1:             handler.removeFilter(filter_)
       
       
       #
       #   First, we define our levels. There can be as many as you want - the only
       #     limitations are that they should be integers, the lowest should be > 0 and
       #   larger values mean less information being logged. If you need specific
       #   level values which do not fit into these limitations, you can use a
       #   mapping dictionary to convert between your application levels and the
       #   logging system.
       #
    1: SILENT      = 120
    1: TACITURN    = 119
    1: TERSE       = 118
    1: EFFUSIVE    = 117
    1: SOCIABLE    = 116
    1: VERBOSE     = 115
    1: TALKATIVE   = 114
    1: GARRULOUS   = 113
    1: CHATTERBOX  = 112
    1: BORING      = 111
       
    1: LEVEL_RANGE = range(BORING, SILENT + 1)
       
       #
       #   Next, we define names for our levels. You don't need to do this - in which
       #   case the system will use "Level n" to denote the text for the level.
       #
    1: my_logging_levels = {
    1:     SILENT      : 'Silent',
    1:     TACITURN    : 'Taciturn',
    1:     TERSE       : 'Terse',
    1:     EFFUSIVE    : 'Effusive',
    1:     SOCIABLE    : 'Sociable',
    1:     VERBOSE     : 'Verbose',
    1:     TALKATIVE   : 'Talkative',
    1:     GARRULOUS   : 'Garrulous',
    1:     CHATTERBOX  : 'Chatterbox',
    1:     BORING      : 'Boring',
       }
       
    2: class GarrulousFilter(logging.Filter):
       
    1:     """A filter which blocks garrulous messages."""
       
    1:     def filter(self, record):
   18:         return record.levelno != GARRULOUS
       
    2: class VerySpecificFilter(logging.Filter):
       
    1:     """A filter which blocks sociable and taciturn messages."""
       
    1:     def filter(self, record):
   10:         return record.levelno not in [SOCIABLE, TACITURN]
       
       
    2: class CustomLevelsAndFiltersTest(BaseTest):
       
    1:     """Test various filtering possibilities with custom logging levels."""
       
           # Skip the logger name group.
    1:     expected_log_pat = r"^[\w.]+ -> ([\w]+): ([\d]+)$"
       
    1:     def setUp(self):
    3:         BaseTest.setUp(self)
   33:         for k, v in my_logging_levels.items():
   30:             logging.addLevelName(k, v)
       
    1:     def log_at_all_levels(self, logger):
   44:         for lvl in LEVEL_RANGE:
   40:             logger.log(lvl, self.next_message())
       
    1:     def test_logger_filter(self):
               # Filter at logger level.
    1:         self.root_logger.setLevel(VERBOSE)
               # Levels >= 'Verbose' are good.
    1:         self.log_at_all_levels(self.root_logger)
    1:         self.assert_log_lines([
    1:             ('Verbose', '5'),
    1:             ('Sociable', '6'),
    1:             ('Effusive', '7'),
    1:             ('Terse', '8'),
    1:             ('Taciturn', '9'),
    1:             ('Silent', '10'),
               ])
       
    1:     def test_handler_filter(self):
               # Filter at handler level.
    1:         self.root_logger.handlers[0].setLevel(SOCIABLE)
    1:         try:
                   # Levels >= 'Sociable' are good.
    1:             self.log_at_all_levels(self.root_logger)
    1:             self.assert_log_lines([
    1:                 ('Sociable', '6'),
    1:                 ('Effusive', '7'),
    1:                 ('Terse', '8'),
    1:                 ('Taciturn', '9'),
    1:                 ('Silent', '10'),
                   ])
               finally:
    1:             self.root_logger.handlers[0].setLevel(logging.NOTSET)
       
    1:     def test_specific_filters(self):
               # Set a specific filter object on the handler, and then add another
               #  filter object on the logger itself.
    1:         handler = self.root_logger.handlers[0]
    1:         specific_filter = None
    1:         garr = GarrulousFilter()
    1:         handler.addFilter(garr)
    1:         try:
    1:             self.log_at_all_levels(self.root_logger)
                   first_lines = [
                       # Notice how 'Garrulous' is missing
    1:                 ('Boring', '1'),
    1:                 ('Chatterbox', '2'),
    1:                 ('Talkative', '4'),
    1:                 ('Verbose', '5'),
    1:                 ('Sociable', '6'),
    1:                 ('Effusive', '7'),
    1:                 ('Terse', '8'),
    1:                 ('Taciturn', '9'),
    1:                 ('Silent', '10'),
                   ]
    1:             self.assert_log_lines(first_lines)
       
    1:             specific_filter = VerySpecificFilter()
    1:             self.root_logger.addFilter(specific_filter)
    1:             self.log_at_all_levels(self.root_logger)
    1:             self.assert_log_lines(first_lines + [
                       # Not only 'Garrulous' is still missing, but also 'Sociable'
                       # and 'Taciturn'
    1:                 ('Boring', '11'),
    1:                 ('Chatterbox', '12'),
    1:                 ('Talkative', '14'),
    1:                 ('Verbose', '15'),
    1:                 ('Effusive', '17'),
    1:                 ('Terse', '18'),
    1:                 ('Silent', '20'),
               ])
               finally:
    1:             if specific_filter:
    1:                 self.root_logger.removeFilter(specific_filter)
    1:             handler.removeFilter(garr)
       
       
    2: class MemoryHandlerTest(BaseTest):
       
    1:     """Tests for the MemoryHandler."""
       
           # Do not bother with a logger name group.
    1:     expected_log_pat = r"^[\w.]+ -> ([\w]+): ([\d]+)$"
       
    1:     def setUp(self):
    1:         BaseTest.setUp(self)
    1:         self.mem_hdlr = logging.handlers.MemoryHandler(10, logging.WARNING,
    1:                                                         self.root_hdlr)
    1:         self.mem_logger = logging.getLogger('mem')
    1:         self.mem_logger.propagate = 0
    1:         self.mem_logger.addHandler(self.mem_hdlr)
       
    1:     def tearDown(self):
    1:         self.mem_hdlr.close()
    1:         BaseTest.tearDown(self)
       
    1:     def test_flush(self):
               # The memory handler flushes to its target handler based on specific
               #  criteria (message count and message level).
    1:         self.mem_logger.debug(self.next_message())
    1:         self.assert_log_lines([])
    1:         self.mem_logger.info(self.next_message())
    1:         self.assert_log_lines([])
               # This will flush because the level is >= logging.WARNING
    1:         self.mem_logger.warn(self.next_message())
               lines = [
    1:             ('DEBUG', '1'),
    1:             ('INFO', '2'),
    1:             ('WARNING', '3'),
               ]
    1:         self.assert_log_lines(lines)
    3:         for n in (4, 14):
   20:             for i in range(9):
   18:                 self.mem_logger.debug(self.next_message())
    2:             self.assert_log_lines(lines)
                   # This will flush because it's the 10th message since the last
                   #  flush.
    2:             self.mem_logger.debug(self.next_message())
   22:             lines = lines + [('DEBUG', str(i)) for i in range(n, n + 10)]
    2:             self.assert_log_lines(lines)
       
    1:         self.mem_logger.debug(self.next_message())
    1:         self.assert_log_lines(lines)
       
       
    2: class ExceptionFormatter(logging.Formatter):
    1:     """A special exception formatter."""
    1:     def formatException(self, ei):
    3:         return "Got a [%s]" % ei[0].__name__
       
       
    2: class ConfigFileTest(BaseTest):
       
    1:     """Reading logging config from a .ini-style config file."""
       
    1:     expected_log_pat = r"^([\w]+) \+\+ ([\w]+)$"
       
           # config0 is a standard configuration.
           config0 = """
           [loggers]
           keys=root
       
           [handlers]
           keys=hand1
       
           [formatters]
           keys=form1
       
           [logger_root]
           level=WARNING
           handlers=hand1
       
           [handler_hand1]
           class=StreamHandler
           level=NOTSET
           formatter=form1
           args=(sys.stdout,)
       
           [formatter_form1]
           format=%(levelname)s ++ %(message)s
           datefmt=
    1:     """
       
           # config1 adds a little to the standard configuration.
           config1 = """
           [loggers]
           keys=root,parser
       
           [handlers]
           keys=hand1
       
           [formatters]
           keys=form1
       
           [logger_root]
           level=WARNING
           handlers=
       
           [logger_parser]
           level=DEBUG
           handlers=hand1
           propagate=1
           qualname=compiler.parser
       
           [handler_hand1]
           class=StreamHandler
           level=NOTSET
           formatter=form1
           args=(sys.stdout,)
       
           [formatter_form1]
           format=%(levelname)s ++ %(message)s
           datefmt=
    1:     """
       
           # config1a moves the handler to the root.
           config1a = """
           [loggers]
           keys=root,parser
       
           [handlers]
           keys=hand1
       
           [formatters]
           keys=form1
       
           [logger_root]
           level=WARNING
           handlers=hand1
       
           [logger_parser]
           level=DEBUG
           handlers=
           propagate=1
           qualname=compiler.parser
       
           [handler_hand1]
           class=StreamHandler
           level=NOTSET
           formatter=form1
           args=(sys.stdout,)
       
           [formatter_form1]
           format=%(levelname)s ++ %(message)s
           datefmt=
    1:     """
       
           # config2 has a subtle configuration error that should be reported
    1:     config2 = config1.replace("sys.stdout", "sys.stbout")
       
           # config3 has a less subtle configuration error
    1:     config3 = config1.replace("formatter=form1", "formatter=misspelled_name")
       
           # config4 specifies a custom formatter class to be loaded
           config4 = """
           [loggers]
           keys=root
       
           [handlers]
           keys=hand1
       
           [formatters]
           keys=form1
       
           [logger_root]
           level=NOTSET
           handlers=hand1
       
           [handler_hand1]
           class=StreamHandler
           level=NOTSET
           formatter=form1
           args=(sys.stdout,)
       
           [formatter_form1]
    1:     class=""" + __name__ + """.ExceptionFormatter
           format=%(levelname)s:%(name)s:%(message)s
           datefmt=
    1:     """
       
           # config5 specifies a custom handler class to be loaded
    1:     config5 = config1.replace('class=StreamHandler', 'class=logging.StreamHandler')
       
           # config6 uses ', ' delimiters in the handlers and formatters sections
           config6 = """
           [loggers]
           keys=root,parser
       
           [handlers]
           keys=hand1, hand2
       
           [formatters]
           keys=form1, form2
       
           [logger_root]
           level=WARNING
           handlers=
       
           [logger_parser]
           level=DEBUG
           handlers=hand1
           propagate=1
           qualname=compiler.parser
       
           [handler_hand1]
           class=StreamHandler
           level=NOTSET
           formatter=form1
           args=(sys.stdout,)
       
           [handler_hand2]
           class=StreamHandler
           level=NOTSET
           formatter=form1
           args=(sys.stderr,)
       
           [formatter_form1]
           format=%(levelname)s ++ %(message)s
           datefmt=
       
           [formatter_form2]
           format=%(message)s
           datefmt=
    1:     """
       
           # config7 adds a compiler logger.
           config7 = """
           [loggers]
           keys=root,parser,compiler
       
           [handlers]
           keys=hand1
       
           [formatters]
           keys=form1
       
           [logger_root]
           level=WARNING
           handlers=hand1
       
           [logger_compiler]
           level=DEBUG
           handlers=
           propagate=1
           qualname=compiler
       
           [logger_parser]
           level=DEBUG
           handlers=
           propagate=1
           qualname=compiler.parser
       
           [handler_hand1]
           class=StreamHandler
           level=NOTSET
           formatter=form1
           args=(sys.stdout,)
       
           [formatter_form1]
           format=%(levelname)s ++ %(message)s
           datefmt=
    1:     """
       
           disable_test = """
           [loggers]
           keys=root
       
           [handlers]
           keys=screen
       
           [formatters]
           keys=
       
           [logger_root]
           level=DEBUG
           handlers=screen
       
           [handler_screen]
           level=DEBUG
           class=StreamHandler
           args=(sys.stdout,)
           formatter=
    1:     """
       
    1:     def apply_config(self, conf, **kwargs):
   12:         file = cStringIO.StringIO(textwrap.dedent(conf))
   12:         logging.config.fileConfig(file, **kwargs)
       
    1:     def test_config0_ok(self):
               # A simple config file which overrides the default settings.
    1:         with captured_stdout() as output:
    1:             self.apply_config(self.config0)
    1:             logger = logging.getLogger()
                   # Won't output anything
    1:             logger.info(self.next_message())
                   # Outputs a message
    1:             logger.error(self.next_message())
    1:             self.assert_log_lines([
    1:                 ('ERROR', '2'),
    1:             ], stream=output)
                   # Original logger output is empty.
    1:             self.assert_log_lines([])
       
    1:     def test_config1_ok(self, config=config1):
               # A config file defining a sub-parser as well.
    3:         with captured_stdout() as output:
    3:             self.apply_config(config)
    3:             logger = logging.getLogger("compiler.parser")
                   # Both will output a message
    3:             logger.info(self.next_message())
    3:             logger.error(self.next_message())
    3:             self.assert_log_lines([
    3:                 ('INFO', '1'),
    3:                 ('ERROR', '2'),
    3:             ], stream=output)
                   # Original logger output is empty.
    3:             self.assert_log_lines([])
       
    1:     def test_config2_failure(self):
               # A simple config file which overrides the default settings.
    1:         self.assertRaises(StandardError, self.apply_config, self.config2)
       
    1:     def test_config3_failure(self):
               # A simple config file which overrides the default settings.
    1:         self.assertRaises(StandardError, self.apply_config, self.config3)
       
    1:     def test_config4_ok(self):
               # A config file specifying a custom formatter class.
    1:         with captured_stdout() as output:
    1:             self.apply_config(self.config4)
    1:             logger = logging.getLogger()
    1:             try:
    1:                 raise RuntimeError()
    1:             except RuntimeError:
    1:                 logging.exception("just testing")
    1:             sys.stdout.seek(0)
    1:             self.assertEqual(output.getvalue(),
    1:                 "ERROR:root:just testing\nGot a [RuntimeError]\n")
                   # Original logger output is empty
    1:             self.assert_log_lines([])
       
    1:     def test_config5_ok(self):
    1:         self.test_config1_ok(config=self.config5)
       
    1:     def test_config6_ok(self):
    1:         self.test_config1_ok(config=self.config6)
       
    1:     def test_config7_ok(self):
    1:         with captured_stdout() as output:
    1:             self.apply_config(self.config1a)
    1:             logger = logging.getLogger("compiler.parser")
                   # See issue #11424. compiler-hyphenated sorts
                   # between compiler and compiler.xyz and this
                   # was preventing compiler.xyz from being included
                   # in the child loggers of compiler because of an
                   # overzealous loop termination condition.
    1:             hyphenated = logging.getLogger('compiler-hyphenated')
                   # All will output a message
    1:             logger.info(self.next_message())
    1:             logger.error(self.next_message())
    1:             hyphenated.critical(self.next_message())
    1:             self.assert_log_lines([
    1:                 ('INFO', '1'),
    1:                 ('ERROR', '2'),
    1:                 ('CRITICAL', '3'),
    1:             ], stream=output)
                   # Original logger output is empty.
    1:             self.assert_log_lines([])
    1:         with captured_stdout() as output:
    1:             self.apply_config(self.config7)
    1:             logger = logging.getLogger("compiler.parser")
    1:             self.assertFalse(logger.disabled)
                   # Both will output a message
    1:             logger.info(self.next_message())
    1:             logger.error(self.next_message())
    1:             logger = logging.getLogger("compiler.lexer")
                   # Both will output a message
    1:             logger.info(self.next_message())
    1:             logger.error(self.next_message())
                   # Will not appear
    1:             hyphenated.critical(self.next_message())
    1:             self.assert_log_lines([
    1:                 ('INFO', '4'),
    1:                 ('ERROR', '5'),
    1:                 ('INFO', '6'),
    1:                 ('ERROR', '7'),
    1:             ], stream=output)
                   # Original logger output is empty.
    1:             self.assert_log_lines([])
       
    1:     def test_logger_disabling(self):
    1:         self.apply_config(self.disable_test)
    1:         logger = logging.getLogger('foo')
    1:         self.assertFalse(logger.disabled)
    1:         self.apply_config(self.disable_test)
    1:         self.assertTrue(logger.disabled)
    1:         self.apply_config(self.disable_test, disable_existing_loggers=False)
    1:         self.assertFalse(logger.disabled)
       
    2: class LogRecordStreamHandler(StreamRequestHandler):
       
           """Handler for a streaming logging request. It saves the log message in the
    1:     TCP server's 'log_output' attribute."""
       
    1:     TCP_LOG_END = "!!!END!!!"
       
    1:     def handle(self):
               """Handle multiple requests - each expected to be of 4-byte length,
               followed by the LogRecord in pickle format. Logs the record
               according to whatever policy is configured locally."""
    4:         while True:
    4:             chunk = self.connection.recv(4)
    4:             if len(chunk) < 4:
    1:                 break
    3:             slen = struct.unpack(">L", chunk)[0]
    3:             chunk = self.connection.recv(slen)
    3:             while len(chunk) < slen:
>>>>>>                 chunk = chunk + self.connection.recv(slen - len(chunk))
    3:             obj = self.unpickle(chunk)
    3:             record = logging.makeLogRecord(obj)
    3:             self.handle_log_record(record)
       
    1:     def unpickle(self, data):
    3:         return cPickle.loads(data)
       
    1:     def handle_log_record(self, record):
               # If the end-of-messages sentinel is seen, tell the server to
               #  terminate.
    3:         if self.TCP_LOG_END in record.msg:
    1:             self.server.abort = 1
    1:             return
    2:         self.server.log_output += record.msg + "\n"
       
       
    2: class LogRecordSocketReceiver(ThreadingTCPServer):
       
           """A simple-minded TCP socket-based logging receiver suitable for test
    1:     purposes."""
       
    1:     allow_reuse_address = 1
    1:     log_output = ""
       
    1:     def __init__(self, host='localhost',
    1:                              port=logging.handlers.DEFAULT_TCP_LOGGING_PORT,
    1:                      handler=LogRecordStreamHandler):
    1:         ThreadingTCPServer.__init__(self, (host, port), handler)
    1:         self.abort = False
    1:         self.timeout = 0.1
    1:         self.finished = threading.Event()
       
    1:     def serve_until_stopped(self):
    3:         while not self.abort:
    2:             rd, wr, ex = select.select([self.socket.fileno()], [], [],
    2:                                        self.timeout)
    2:             if rd:
    1:                 self.handle_request()
               # Notify the main thread that we're about to exit
    1:         self.finished.set()
               # close the listen socket
    1:         self.server_close()
       
       
    2: @unittest.skipUnless(threading, 'Threading required for this test.')
    1: class SocketHandlerTest(BaseTest):
       
    1:     """Test for SocketHandler objects."""
       
    1:     def setUp(self):
               """Set up a TCP server to receive log messages, and a SocketHandler
               pointing to that server's address and port."""
    1:         BaseTest.setUp(self)
    1:         self.tcpserver = LogRecordSocketReceiver(port=0)
    1:         self.port = self.tcpserver.socket.getsockname()[1]
               self.threads = [
    1:                 threading.Thread(target=self.tcpserver.serve_until_stopped)]
    2:         for thread in self.threads:
    1:             thread.start()
       
    1:         self.sock_hdlr = logging.handlers.SocketHandler('localhost', self.port)
    1:         self.sock_hdlr.setFormatter(self.root_formatter)
    1:         self.root_logger.removeHandler(self.root_logger.handlers[0])
    1:         self.root_logger.addHandler(self.sock_hdlr)
       
    1:     def tearDown(self):
               """Shutdown the TCP server."""
    1:         try:
    1:             self.tcpserver.abort = True
    1:             del self.tcpserver
    1:             self.root_logger.removeHandler(self.sock_hdlr)
    1:             self.sock_hdlr.close()
    2:             for thread in self.threads:
    1:                 thread.join(2.0)
               finally:
    1:             BaseTest.tearDown(self)
       
    1:     def get_output(self):
               """Get the log output as received by the TCP server."""
               # Signal the TCP receiver and wait for it to terminate.
    1:         self.root_logger.critical(LogRecordStreamHandler.TCP_LOG_END)
    1:         self.tcpserver.finished.wait(2.0)
    1:         return self.tcpserver.log_output
       
    1:     def test_output(self):
               # The log message sent to the SocketHandler is properly received.
    1:         logger = logging.getLogger("tcp")
    1:         logger.error("spam")
    1:         logger.debug("eggs")
    1:         self.assertEqual(self.get_output(), "spam\neggs\n")
       
       
    2: class MemoryTest(BaseTest):
       
    1:     """Test memory persistence of logger objects."""
       
    1:     def setUp(self):
               """Create a dict to remember potentially destroyed objects."""
    1:         BaseTest.setUp(self)
    1:         self._survivors = {}
       
    1:     def _watch_for_survival(self, *args):
               """Watch the given objects for survival, by creating weakrefs to
               them."""
    2:         for obj in args:
    1:             key = id(obj), repr(obj)
    1:             self._survivors[key] = weakref.ref(obj)
       
    1:     def _assertTruesurvival(self):
               """Assert that all objects watched for survival have survived."""
               # Trigger cycle breaking.
    1:         gc.collect()
    1:         dead = []
    2:         for (id_, repr_), ref in self._survivors.items():
    1:             if ref() is None:
>>>>>>                 dead.append(repr_)
    1:         if dead:
>>>>>>             self.fail("%d objects should have survived "
>>>>>>                 "but have been destroyed: %s" % (len(dead), ", ".join(dead)))
       
    1:     def test_persistent_loggers(self):
               # Logger objects are persistent and retain their configuration, even
               #  if visible references are destroyed.
    1:         self.root_logger.setLevel(logging.INFO)
    1:         foo = logging.getLogger("foo")
    1:         self._watch_for_survival(foo)
    1:         foo.setLevel(logging.DEBUG)
    1:         self.root_logger.debug(self.next_message())
    1:         foo.debug(self.next_message())
    1:         self.assert_log_lines([
    1:             ('foo', 'DEBUG', '2'),
               ])
    1:         del foo
               # foo has survived.
    1:         self._assertTruesurvival()
               # foo has retained its settings.
    1:         bar = logging.getLogger("foo")
    1:         bar.debug(self.next_message())
    1:         self.assert_log_lines([
    1:             ('foo', 'DEBUG', '2'),
    1:             ('foo', 'DEBUG', '3'),
               ])
       
       
    2: class EncodingTest(BaseTest):
    1:     def test_encoding_plain_file(self):
               # In Python 2.x, a plain file object is treated as having no encoding.
    1:         log = logging.getLogger("test")
    1:         fn = tempfile.mktemp(".log")
               # the non-ascii data we write to the log.
    1:         data = "foo\x80"
    1:         try:
    1:             handler = logging.FileHandler(fn)
    1:             log.addHandler(handler)
    1:             try:
                       # write non-ascii data to the log.
    1:                 log.warning(data)
                   finally:
    1:                 log.removeHandler(handler)
    1:                 handler.close()
                   # check we wrote exactly those bytes, ignoring trailing \n etc
    1:             f = open(fn)
    1:             try:
    1:                 self.assertEqual(f.read().rstrip(), data)
                   finally:
    1:                 f.close()
               finally:
    1:             if os.path.isfile(fn):
    1:                 os.remove(fn)
       
    1:     def test_encoding_cyrillic_unicode(self):
    1:         log = logging.getLogger("test")
               #Get a message in Unicode: Do svidanya in Cyrillic (meaning goodbye)
    1:         message = u'\u0434\u043e \u0441\u0432\u0438\u0434\u0430\u043d\u0438\u044f'
               #Ensure it's written in a Cyrillic encoding
    1:         writer_class = codecs.getwriter('cp1251')
    1:         writer_class.encoding = 'cp1251'
    1:         stream = cStringIO.StringIO()
    1:         writer = writer_class(stream, 'strict')
    1:         handler = logging.StreamHandler(writer)
    1:         log.addHandler(handler)
    1:         try:
    1:             log.warning(message)
               finally:
    1:             log.removeHandler(handler)
    1:             handler.close()
               # check we wrote exactly those bytes, ignoring trailing \n etc
    1:         s = stream.getvalue()
               #Compare against what the data should be when encoded in CP-1251
    1:         self.assertEqual(s, '\xe4\xee \xf1\xe2\xe8\xe4\xe0\xed\xe8\xff\n')
       
    1:     def test_encoding_utf16_unicode(self):
               # Issue #19267
    1:         log = logging.getLogger("test")
    1:         message = u'b\u0142\u0105d'
    1:         writer_class = codecs.getwriter('utf-16-le')
    1:         writer_class.encoding = 'utf-16-le'
    1:         stream = cStringIO.StringIO()
    1:         writer = writer_class(stream, 'strict')
    1:         handler = logging.StreamHandler(writer)
    1:         log.addHandler(handler)
    1:         try:
    1:             log.warning(message)
               finally:
    1:             log.removeHandler(handler)
    1:             handler.close()
    1:         s = stream.getvalue()
    1:         self.assertEqual(s, 'b\x00B\x01\x05\x01d\x00\n\x00')
       
       
    2: class WarningsTest(BaseTest):
       
    1:     def test_warnings(self):
    1:         with warnings.catch_warnings():
    1:             logging.captureWarnings(True)
    1:             try:
    1:                 warnings.filterwarnings("always", category=UserWarning)
    1:                 file = cStringIO.StringIO()
    1:                 h = logging.StreamHandler(file)
    1:                 logger = logging.getLogger("py.warnings")
    1:                 logger.addHandler(h)
    1:                 warnings.warn("I'm warning you...")
    1:                 logger.removeHandler(h)
    1:                 s = file.getvalue()
    1:                 h.close()
    1:                 self.assertTrue(s.find("UserWarning: I'm warning you...\n") > 0)
       
                       #See if an explicit file uses the original implementation
    1:                 file = cStringIO.StringIO()
    1:                 warnings.showwarning("Explicit", UserWarning, "dummy.py", 42,
    1:                                         file, "Dummy line")
    1:                 s = file.getvalue()
    1:                 file.close()
    1:                 self.assertEqual(s,
    1:                         "dummy.py:42: UserWarning: Explicit\n  Dummy line\n")
                   finally:
    1:                 logging.captureWarnings(False)
       
       
    1: def formatFunc(format, datefmt=None):
    2:     return logging.Formatter(format, datefmt)
       
    1: def handlerFunc():
    1:     return logging.StreamHandler()
       
    2: class CustomHandler(logging.StreamHandler):
    1:     pass
       
    2: class ConfigDictTest(BaseTest):
       
    1:     """Reading logging config from a dictionary."""
       
    1:     expected_log_pat = r"^([\w]+) \+\+ ([\w]+)$"
       
           # config0 is a standard configuration.
    1:     config0 = {
    1:         'version': 1,
    1:         'formatters': {
    1:             'form1' : {
    1:                 'format' : '%(levelname)s ++ %(message)s',
                   },
               },
    1:         'handlers' : {
    1:             'hand1' : {
    1:                 'class' : 'logging.StreamHandler',
    1:                 'formatter' : 'form1',
    1:                 'level' : 'NOTSET',
    1:                 'stream'  : 'ext://sys.stdout',
                   },
               },
    1:         'root' : {
    1:             'level' : 'WARNING',
    1:             'handlers' : ['hand1'],
               },
           }
       
           # config1 adds a little to the standard configuration.
    1:     config1 = {
    1:         'version': 1,
    1:         'formatters': {
    1:             'form1' : {
    1:                 'format' : '%(levelname)s ++ %(message)s',
                   },
               },
    1:         'handlers' : {
    1:             'hand1' : {
    1:                 'class' : 'logging.StreamHandler',
    1:                 'formatter' : 'form1',
    1:                 'level' : 'NOTSET',
    1:                 'stream'  : 'ext://sys.stdout',
                   },
               },
    1:         'loggers' : {
    1:             'compiler.parser' : {
    1:                 'level' : 'DEBUG',
    1:                 'handlers' : ['hand1'],
                   },
               },
    1:         'root' : {
    1:             'level' : 'WARNING',
               },
           }
       
           # config2 has a subtle configuration error that should be reported
    1:     config2 = {
    1:         'version': 1,
    1:         'formatters': {
    1:             'form1' : {
    1:                 'format' : '%(levelname)s ++ %(message)s',
                   },
               },
    1:         'handlers' : {
    1:             'hand1' : {
    1:                 'class' : 'logging.StreamHandler',
    1:                 'formatter' : 'form1',
    1:                 'level' : 'NOTSET',
    1:                 'stream'  : 'ext://sys.stdbout',
                   },
               },
    1:         'loggers' : {
    1:             'compiler.parser' : {
    1:                 'level' : 'DEBUG',
    1:                 'handlers' : ['hand1'],
                   },
               },
    1:         'root' : {
    1:             'level' : 'WARNING',
               },
           }
       
           #As config1 but with a misspelt level on a handler
    1:     config2a = {
    1:         'version': 1,
    1:         'formatters': {
    1:             'form1' : {
    1:                 'format' : '%(levelname)s ++ %(message)s',
                   },
               },
    1:         'handlers' : {
    1:             'hand1' : {
    1:                 'class' : 'logging.StreamHandler',
    1:                 'formatter' : 'form1',
    1:                 'level' : 'NTOSET',
    1:                 'stream'  : 'ext://sys.stdout',
                   },
               },
    1:         'loggers' : {
    1:             'compiler.parser' : {
    1:                 'level' : 'DEBUG',
    1:                 'handlers' : ['hand1'],
                   },
               },
    1:         'root' : {
    1:             'level' : 'WARNING',
               },
           }
       
       
           #As config1 but with a misspelt level on a logger
    1:     config2b = {
    1:         'version': 1,
    1:         'formatters': {
    1:             'form1' : {
    1:                 'format' : '%(levelname)s ++ %(message)s',
                   },
               },
    1:         'handlers' : {
    1:             'hand1' : {
    1:                 'class' : 'logging.StreamHandler',
    1:                 'formatter' : 'form1',
    1:                 'level' : 'NOTSET',
    1:                 'stream'  : 'ext://sys.stdout',
                   },
               },
    1:         'loggers' : {
    1:             'compiler.parser' : {
    1:                 'level' : 'DEBUG',
    1:                 'handlers' : ['hand1'],
                   },
               },
    1:         'root' : {
    1:             'level' : 'WRANING',
               },
           }
       
           # config3 has a less subtle configuration error
    1:     config3 = {
    1:         'version': 1,
    1:         'formatters': {
    1:             'form1' : {
    1:                 'format' : '%(levelname)s ++ %(message)s',
                   },
               },
    1:         'handlers' : {
    1:             'hand1' : {
    1:                 'class' : 'logging.StreamHandler',
    1:                 'formatter' : 'misspelled_name',
    1:                 'level' : 'NOTSET',
    1:                 'stream'  : 'ext://sys.stdout',
                   },
               },
    1:         'loggers' : {
    1:             'compiler.parser' : {
    1:                 'level' : 'DEBUG',
    1:                 'handlers' : ['hand1'],
                   },
               },
    1:         'root' : {
    1:             'level' : 'WARNING',
               },
           }
       
           # config4 specifies a custom formatter class to be loaded
    1:     config4 = {
    1:         'version': 1,
    1:         'formatters': {
    1:             'form1' : {
    1:                 '()' : __name__ + '.ExceptionFormatter',
    1:                 'format' : '%(levelname)s:%(name)s:%(message)s',
                   },
               },
    1:         'handlers' : {
    1:             'hand1' : {
    1:                 'class' : 'logging.StreamHandler',
    1:                 'formatter' : 'form1',
    1:                 'level' : 'NOTSET',
    1:                 'stream'  : 'ext://sys.stdout',
                   },
               },
    1:         'root' : {
    1:             'level' : 'NOTSET',
    1:                 'handlers' : ['hand1'],
               },
           }
       
           # As config4 but using an actual callable rather than a string
    1:     config4a = {
    1:         'version': 1,
    1:         'formatters': {
    1:             'form1' : {
    1:                 '()' : ExceptionFormatter,
    1:                 'format' : '%(levelname)s:%(name)s:%(message)s',
                   },
    1:             'form2' : {
    1:                 '()' : __name__ + '.formatFunc',
    1:                 'format' : '%(levelname)s:%(name)s:%(message)s',
                   },
    1:             'form3' : {
    1:                 '()' : formatFunc,
    1:                 'format' : '%(levelname)s:%(name)s:%(message)s',
                   },
               },
    1:         'handlers' : {
    1:             'hand1' : {
    1:                 'class' : 'logging.StreamHandler',
    1:                 'formatter' : 'form1',
    1:                 'level' : 'NOTSET',
    1:                 'stream'  : 'ext://sys.stdout',
                   },
    1:             'hand2' : {
    1:                 '()' : handlerFunc,
                   },
               },
    1:         'root' : {
    1:             'level' : 'NOTSET',
    1:                 'handlers' : ['hand1'],
               },
           }
       
           # config5 specifies a custom handler class to be loaded
    1:     config5 = {
    1:         'version': 1,
    1:         'formatters': {
    1:             'form1' : {
    1:                 'format' : '%(levelname)s ++ %(message)s',
                   },
               },
    1:         'handlers' : {
    1:             'hand1' : {
    1:                 'class' : __name__ + '.CustomHandler',
    1:                 'formatter' : 'form1',
    1:                 'level' : 'NOTSET',
    1:                 'stream'  : 'ext://sys.stdout',
                   },
               },
    1:         'loggers' : {
    1:             'compiler.parser' : {
    1:                 'level' : 'DEBUG',
    1:                 'handlers' : ['hand1'],
                   },
               },
    1:         'root' : {
    1:             'level' : 'WARNING',
               },
           }
       
           # config6 specifies a custom handler class to be loaded
           # but has bad arguments
    1:     config6 = {
    1:         'version': 1,
    1:         'formatters': {
    1:             'form1' : {
    1:                 'format' : '%(levelname)s ++ %(message)s',
                   },
               },
    1:         'handlers' : {
    1:             'hand1' : {
    1:                 'class' : __name__ + '.CustomHandler',
    1:                 'formatter' : 'form1',
    1:                 'level' : 'NOTSET',
    1:                 'stream'  : 'ext://sys.stdout',
    1:                 '9' : 'invalid parameter name',
                   },
               },
    1:         'loggers' : {
    1:             'compiler.parser' : {
    1:                 'level' : 'DEBUG',
    1:                 'handlers' : ['hand1'],
                   },
               },
    1:         'root' : {
    1:             'level' : 'WARNING',
               },
           }
       
           #config 7 does not define compiler.parser but defines compiler.lexer
           #so compiler.parser should be disabled after applying it
    1:     config7 = {
    1:         'version': 1,
    1:         'formatters': {
    1:             'form1' : {
    1:                 'format' : '%(levelname)s ++ %(message)s',
                   },
               },
    1:         'handlers' : {
    1:             'hand1' : {
    1:                 'class' : 'logging.StreamHandler',
    1:                 'formatter' : 'form1',
    1:                 'level' : 'NOTSET',
    1:                 'stream'  : 'ext://sys.stdout',
                   },
               },
    1:         'loggers' : {
    1:             'compiler.lexer' : {
    1:                 'level' : 'DEBUG',
    1:                 'handlers' : ['hand1'],
                   },
               },
    1:         'root' : {
    1:             'level' : 'WARNING',
               },
           }
       
    1:     config8 = {
    1:         'version': 1,
    1:         'disable_existing_loggers' : False,
    1:         'formatters': {
    1:             'form1' : {
    1:                 'format' : '%(levelname)s ++ %(message)s',
                   },
               },
    1:         'handlers' : {
    1:             'hand1' : {
    1:                 'class' : 'logging.StreamHandler',
    1:                 'formatter' : 'form1',
    1:                 'level' : 'NOTSET',
    1:                 'stream'  : 'ext://sys.stdout',
                   },
               },
    1:         'loggers' : {
    1:             'compiler' : {
    1:                 'level' : 'DEBUG',
    1:                 'handlers' : ['hand1'],
                   },
    1:             'compiler.lexer' : {
                   },
               },
    1:         'root' : {
    1:             'level' : 'WARNING',
               },
           }
       
    1:     config9 = {
    1:         'version': 1,
    1:         'formatters': {
    1:             'form1' : {
    1:                 'format' : '%(levelname)s ++ %(message)s',
                   },
               },
    1:         'handlers' : {
    1:             'hand1' : {
    1:                 'class' : 'logging.StreamHandler',
    1:                 'formatter' : 'form1',
    1:                 'level' : 'WARNING',
    1:                 'stream'  : 'ext://sys.stdout',
                   },
               },
    1:         'loggers' : {
    1:             'compiler.parser' : {
    1:                 'level' : 'WARNING',
    1:                 'handlers' : ['hand1'],
                   },
               },
    1:         'root' : {
    1:             'level' : 'NOTSET',
               },
           }
       
    1:     config9a = {
    1:         'version': 1,
    1:         'incremental' : True,
    1:         'handlers' : {
    1:             'hand1' : {
    1:                 'level' : 'WARNING',
                   },
               },
    1:         'loggers' : {
    1:             'compiler.parser' : {
    1:                 'level' : 'INFO',
                   },
               },
           }
       
    1:     config9b = {
    1:         'version': 1,
    1:         'incremental' : True,
    1:         'handlers' : {
    1:             'hand1' : {
    1:                 'level' : 'INFO',
                   },
               },
    1:         'loggers' : {
    1:             'compiler.parser' : {
    1:                 'level' : 'INFO',
                   },
               },
           }
       
           #As config1 but with a filter added
    1:     config10 = {
    1:         'version': 1,
    1:         'formatters': {
    1:             'form1' : {
    1:                 'format' : '%(levelname)s ++ %(message)s',
                   },
               },
    1:         'filters' : {
    1:             'filt1' : {
    1:                 'name' : 'compiler.parser',
                   },
               },
    1:         'handlers' : {
    1:             'hand1' : {
    1:                 'class' : 'logging.StreamHandler',
    1:                 'formatter' : 'form1',
    1:                 'level' : 'NOTSET',
    1:                 'stream'  : 'ext://sys.stdout',
    1:                 'filters' : ['filt1'],
                   },
               },
    1:         'loggers' : {
    1:             'compiler.parser' : {
    1:                 'level' : 'DEBUG',
    1:                 'filters' : ['filt1'],
                   },
               },
    1:         'root' : {
    1:             'level' : 'WARNING',
    1:             'handlers' : ['hand1'],
               },
           }
       
           #As config1 but using cfg:// references
    1:     config11 = {
    1:         'version': 1,
    1:         'true_formatters': {
    1:             'form1' : {
    1:                 'format' : '%(levelname)s ++ %(message)s',
                   },
               },
    1:         'handler_configs': {
    1:             'hand1' : {
    1:                 'class' : 'logging.StreamHandler',
    1:                 'formatter' : 'form1',
    1:                 'level' : 'NOTSET',
    1:                 'stream'  : 'ext://sys.stdout',
                   },
               },
    1:         'formatters' : 'cfg://true_formatters',
    1:         'handlers' : {
    1:             'hand1' : 'cfg://handler_configs[hand1]',
               },
    1:         'loggers' : {
    1:             'compiler.parser' : {
    1:                 'level' : 'DEBUG',
    1:                 'handlers' : ['hand1'],
                   },
               },
    1:         'root' : {
    1:             'level' : 'WARNING',
               },
           }
       
           #As config11 but missing the version key
    1:     config12 = {
    1:         'true_formatters': {
    1:             'form1' : {
    1:                 'format' : '%(levelname)s ++ %(message)s',
                   },
               },
    1:         'handler_configs': {
    1:             'hand1' : {
    1:                 'class' : 'logging.StreamHandler',
    1:                 'formatter' : 'form1',
    1:                 'level' : 'NOTSET',
    1:                 'stream'  : 'ext://sys.stdout',
                   },
               },
    1:         'formatters' : 'cfg://true_formatters',
    1:         'handlers' : {
    1:             'hand1' : 'cfg://handler_configs[hand1]',
               },
    1:         'loggers' : {
    1:             'compiler.parser' : {
    1:                 'level' : 'DEBUG',
    1:                 'handlers' : ['hand1'],
                   },
               },
    1:         'root' : {
    1:             'level' : 'WARNING',
               },
           }
       
           #As config11 but using an unsupported version
    1:     config13 = {
    1:         'version': 2,
    1:         'true_formatters': {
    1:             'form1' : {
    1:                 'format' : '%(levelname)s ++ %(message)s',
                   },
               },
    1:         'handler_configs': {
    1:             'hand1' : {
    1:                 'class' : 'logging.StreamHandler',
    1:                 'formatter' : 'form1',
    1:                 'level' : 'NOTSET',
    1:                 'stream'  : 'ext://sys.stdout',
                   },
               },
    1:         'formatters' : 'cfg://true_formatters',
    1:         'handlers' : {
    1:             'hand1' : 'cfg://handler_configs[hand1]',
               },
    1:         'loggers' : {
    1:             'compiler.parser' : {
    1:                 'level' : 'DEBUG',
    1:                 'handlers' : ['hand1'],
                   },
               },
    1:         'root' : {
    1:             'level' : 'WARNING',
               },
           }
       
    1:     out_of_order = {
    1:         "version": 1,
    1:         "formatters": {
    1:             "mySimpleFormatter": {
    1:                 "format": "%(asctime)s (%(name)s) %(levelname)s: %(message)s"
                   }
               },
    1:         "handlers": {
    1:             "fileGlobal": {
    1:                 "class": "logging.StreamHandler",
    1:                 "level": "DEBUG",
    1:                 "formatter": "mySimpleFormatter"
                   },
    1:             "bufferGlobal": {
    1:                 "class": "logging.handlers.MemoryHandler",
    1:                 "capacity": 5,
    1:                 "formatter": "mySimpleFormatter",
    1:                 "target": "fileGlobal",
    1:                 "level": "DEBUG"
                       }
               },
    1:         "loggers": {
    1:             "mymodule": {
    1:                 "level": "DEBUG",
    1:                 "handlers": ["bufferGlobal"],
    1:                 "propagate": "true"
                   }
               }
           }
       
    1:     def apply_config(self, conf):
   22:         logging.config.dictConfig(conf)
       
    1:     def test_config0_ok(self):
               # A simple config which overrides the default settings.
    1:         with captured_stdout() as output:
    1:             self.apply_config(self.config0)
    1:             logger = logging.getLogger()
                   # Won't output anything
    1:             logger.info(self.next_message())
                   # Outputs a message
    1:             logger.error(self.next_message())
    1:             self.assert_log_lines([
    1:                 ('ERROR', '2'),
    1:             ], stream=output)
                   # Original logger output is empty.
    1:             self.assert_log_lines([])
       
    1:     def test_config1_ok(self, config=config1):
               # A config defining a sub-parser as well.
    3:         with captured_stdout() as output:
    3:             self.apply_config(config)
    3:             logger = logging.getLogger("compiler.parser")
                   # Both will output a message
    3:             logger.info(self.next_message())
    3:             logger.error(self.next_message())
    3:             self.assert_log_lines([
    3:                 ('INFO', '1'),
    3:                 ('ERROR', '2'),
    3:             ], stream=output)
                   # Original logger output is empty.
    3:             self.assert_log_lines([])
       
    1:     def test_config2_failure(self):
               # A simple config which overrides the default settings.
    1:         self.assertRaises(StandardError, self.apply_config, self.config2)
       
    1:     def test_config2a_failure(self):
               # A simple config which overrides the default settings.
    1:         self.assertRaises(StandardError, self.apply_config, self.config2a)
       
    1:     def test_config2b_failure(self):
               # A simple config which overrides the default settings.
    1:         self.assertRaises(StandardError, self.apply_config, self.config2b)
       
    1:     def test_config3_failure(self):
               # A simple config which overrides the default settings.
    1:         self.assertRaises(StandardError, self.apply_config, self.config3)
       
    1:     def test_config4_ok(self):
               # A config specifying a custom formatter class.
    1:         with captured_stdout() as output:
    1:             self.apply_config(self.config4)
                   #logger = logging.getLogger()
    1:             try:
    1:                 raise RuntimeError()
    1:             except RuntimeError:
    1:                 logging.exception("just testing")
    1:             sys.stdout.seek(0)
    1:             self.assertEqual(output.getvalue(),
    1:                 "ERROR:root:just testing\nGot a [RuntimeError]\n")
                   # Original logger output is empty
    1:             self.assert_log_lines([])
       
    1:     def test_config4a_ok(self):
               # A config specifying a custom formatter class.
    1:         with captured_stdout() as output:
    1:             self.apply_config(self.config4a)
                   #logger = logging.getLogger()
    1:             try:
    1:                 raise RuntimeError()
    1:             except RuntimeError:
    1:                 logging.exception("just testing")
    1:             sys.stdout.seek(0)
    1:             self.assertEqual(output.getvalue(),
    1:                 "ERROR:root:just testing\nGot a [RuntimeError]\n")
                   # Original logger output is empty
    1:             self.assert_log_lines([])
       
    1:     def test_config5_ok(self):
    1:         self.test_config1_ok(config=self.config5)
       
    1:     def test_config6_failure(self):
    1:         self.assertRaises(StandardError, self.apply_config, self.config6)
       
    1:     def test_config7_ok(self):
    1:         with captured_stdout() as output:
    1:             self.apply_config(self.config1)
    1:             logger = logging.getLogger("compiler.parser")
                   # Both will output a message
    1:             logger.info(self.next_message())
    1:             logger.error(self.next_message())
    1:             self.assert_log_lines([
    1:                 ('INFO', '1'),
    1:                 ('ERROR', '2'),
    1:             ], stream=output)
                   # Original logger output is empty.
    1:             self.assert_log_lines([])
    1:         with captured_stdout() as output:
    1:             self.apply_config(self.config7)
    1:             logger = logging.getLogger("compiler.parser")
    1:             self.assertTrue(logger.disabled)
    1:             logger = logging.getLogger("compiler.lexer")
                   # Both will output a message
    1:             logger.info(self.next_message())
    1:             logger.error(self.next_message())
    1:             self.assert_log_lines([
    1:                 ('INFO', '3'),
    1:                 ('ERROR', '4'),
    1:             ], stream=output)
                   # Original logger output is empty.
    1:             self.assert_log_lines([])
       
           #Same as test_config_7_ok but don't disable old loggers.
    1:     def test_config_8_ok(self):
    1:         with captured_stdout() as output:
    1:             self.apply_config(self.config1)
    1:             logger = logging.getLogger("compiler.parser")
                   # Both will output a message
    1:             logger.info(self.next_message())
    1:             logger.error(self.next_message())
    1:             self.assert_log_lines([
    1:                 ('INFO', '1'),
    1:                 ('ERROR', '2'),
    1:             ], stream=output)
                   # Original logger output is empty.
    1:             self.assert_log_lines([])
    1:         with captured_stdout() as output:
    1:             self.apply_config(self.config8)
    1:             logger = logging.getLogger("compiler.parser")
    1:             self.assertFalse(logger.disabled)
                   # Both will output a message
    1:             logger.info(self.next_message())
    1:             logger.error(self.next_message())
    1:             logger = logging.getLogger("compiler.lexer")
                   # Both will output a message
    1:             logger.info(self.next_message())
    1:             logger.error(self.next_message())
    1:             self.assert_log_lines([
    1:                 ('INFO', '3'),
    1:                 ('ERROR', '4'),
    1:                 ('INFO', '5'),
    1:                 ('ERROR', '6'),
    1:             ], stream=output)
                   # Original logger output is empty.
    1:             self.assert_log_lines([])
       
    1:     def test_config_9_ok(self):
    1:         with captured_stdout() as output:
    1:             self.apply_config(self.config9)
    1:             logger = logging.getLogger("compiler.parser")
                   #Nothing will be output since both handler and logger are set to WARNING
    1:             logger.info(self.next_message())
    1:             self.assert_log_lines([], stream=output)
    1:             self.apply_config(self.config9a)
                   #Nothing will be output since both handler is still set to WARNING
    1:             logger.info(self.next_message())
    1:             self.assert_log_lines([], stream=output)
    1:             self.apply_config(self.config9b)
                   #Message should now be output
    1:             logger.info(self.next_message())
    1:             self.assert_log_lines([
    1:                 ('INFO', '3'),
    1:             ], stream=output)
       
    1:     def test_config_10_ok(self):
    1:         with captured_stdout() as output:
    1:             self.apply_config(self.config10)
    1:             logger = logging.getLogger("compiler.parser")
    1:             logger.warning(self.next_message())
    1:             logger = logging.getLogger('compiler')
                   #Not output, because filtered
    1:             logger.warning(self.next_message())
    1:             logger = logging.getLogger('compiler.lexer')
                   #Not output, because filtered
    1:             logger.warning(self.next_message())
    1:             logger = logging.getLogger("compiler.parser.codegen")
                   #Output, as not filtered
    1:             logger.error(self.next_message())
    1:             self.assert_log_lines([
    1:                 ('WARNING', '1'),
    1:                 ('ERROR', '4'),
    1:             ], stream=output)
       
    1:     def test_config11_ok(self):
    1:         self.test_config1_ok(self.config11)
       
    1:     def test_config12_failure(self):
    1:         self.assertRaises(StandardError, self.apply_config, self.config12)
       
    1:     def test_config13_failure(self):
    1:         self.assertRaises(StandardError, self.apply_config, self.config13)
       
    1:     @unittest.skipUnless(threading, 'listen() needs threading to work')
           def setup_via_listener(self, text):
               # Ask for a randomly assigned port (by using port 0)
    2:         t = logging.config.listen(0)
    2:         t.start()
    2:         t.ready.wait()
               # Now get the port allocated
    2:         port = t.port
    2:         t.ready.clear()
    2:         try:
    2:             sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    2:             sock.settimeout(2.0)
    2:             sock.connect(('localhost', port))
       
    2:             slen = struct.pack('>L', len(text))
    2:             s = slen + text
    2:             sentsofar = 0
    2:             left = len(s)
    4:             while left > 0:
    2:                 sent = sock.send(s[sentsofar:])
    2:                 sentsofar += sent
    2:                 left -= sent
    2:             sock.close()
               finally:
    2:             t.ready.wait(2.0)
    2:             logging.config.stopListening()
    2:             t.join(2.0)
       
    1:     def test_listen_config_10_ok(self):
    1:         with captured_stdout() as output:
    1:             self.setup_via_listener(json.dumps(self.config10))
    1:             logger = logging.getLogger("compiler.parser")
    1:             logger.warning(self.next_message())
    1:             logger = logging.getLogger('compiler')
                   #Not output, because filtered
    1:             logger.warning(self.next_message())
    1:             logger = logging.getLogger('compiler.lexer')
                   #Not output, because filtered
    1:             logger.warning(self.next_message())
    1:             logger = logging.getLogger("compiler.parser.codegen")
                   #Output, as not filtered
    1:             logger.error(self.next_message())
    1:             self.assert_log_lines([
    1:                 ('WARNING', '1'),
    1:                 ('ERROR', '4'),
    1:             ], stream=output)
       
    1:     def test_listen_config_1_ok(self):
    1:         with captured_stdout() as output:
    1:             self.setup_via_listener(textwrap.dedent(ConfigFileTest.config1))
    1:             logger = logging.getLogger("compiler.parser")
                   # Both will output a message
    1:             logger.info(self.next_message())
    1:             logger.error(self.next_message())
    1:             self.assert_log_lines([
    1:                 ('INFO', '1'),
    1:                 ('ERROR', '2'),
    1:             ], stream=output)
                   # Original logger output is empty.
    1:             self.assert_log_lines([])
       
    1:     def test_out_of_order(self):
    1:         self.apply_config(self.out_of_order)
    1:         handler = logging.getLogger('mymodule').handlers[0]
    1:         self.assertIsInstance(handler.target, logging.Handler)
       
    2: class ManagerTest(BaseTest):
    1:     def test_manager_loggerclass(self):
    1:         logged = []
       
    2:         class MyLogger(logging.Logger):
    1:             def _log(self, level, msg, args, exc_info=None, extra=None):
    1:                 logged.append(msg)
       
    1:         man = logging.Manager(None)
    1:         self.assertRaises(TypeError, man.setLoggerClass, int)
    1:         man.setLoggerClass(MyLogger)
    1:         logger = man.getLogger('test')
    1:         logger.warning('should appear in logged')
    1:         logging.warning('should not appear in logged')
       
    1:         self.assertEqual(logged, ['should appear in logged'])
       
       
    2: class ChildLoggerTest(BaseTest):
    1:     def test_child_loggers(self):
    1:         r = logging.getLogger()
    1:         l1 = logging.getLogger('abc')
    1:         l2 = logging.getLogger('def.ghi')
    1:         c1 = r.getChild('xyz')
    1:         c2 = r.getChild('uvw.xyz')
    1:         self.assertTrue(c1 is logging.getLogger('xyz'))
    1:         self.assertTrue(c2 is logging.getLogger('uvw.xyz'))
    1:         c1 = l1.getChild('def')
    1:         c2 = c1.getChild('ghi')
    1:         c3 = l1.getChild('def.ghi')
    1:         self.assertTrue(c1 is logging.getLogger('abc.def'))
    1:         self.assertTrue(c2 is logging.getLogger('abc.def.ghi'))
    1:         self.assertTrue(c2 is c3)
       
       
    2: class HandlerTest(BaseTest):
       
    1:     @unittest.skipIf(os.name == 'nt', 'WatchedFileHandler not appropriate for Windows.')
    1:     @unittest.skipUnless(threading, 'Threading required for this test.')
           def test_race(self):
               # Issue #14632 refers.
    1:         def remove_loop(fname, tries):
 1002:             for _ in range(tries):
 1000:                 try:
 1000:                     os.unlink(fname)
  459:                 except OSError:
  459:                     pass
 1000:                 time.sleep(0.004 * random.randint(0, 4))
       
    1:         del_count = 500
    1:         log_count = 500
       
    3:         for delay in (False, True):
    2:             fd, fn = tempfile.mkstemp('.log', 'test_logging-3-')
    2:             os.close(fd)
    2:             remover = threading.Thread(target=remove_loop, args=(fn, del_count))
    2:             remover.daemon = True
    2:             remover.start()
    2:             h = logging.handlers.WatchedFileHandler(fn, delay=delay)
    2:             f = logging.Formatter('%(asctime)s: %(levelname)s: %(message)s')
    2:             h.setFormatter(f)
    2:             try:
 1002:                 for _ in range(log_count):
 1000:                     time.sleep(0.005)
 1000:                     r = logging.makeLogRecord({'msg': 'testing' })
 1000:                     h.handle(r)
                   finally:
    2:                 remover.join()
    2:                 try:
    2:                     h.close()
>>>>>>                 except ValueError:
>>>>>>                     pass
    2:                 if os.path.exists(fn):
>>>>>>                     os.unlink(fn)
       
       
       # Set the locale to the platform-dependent default.  I have no idea
       # why the test does this, but in any case we save the current locale
       # first and restore it at the end.
    1: @run_with_locale('LC_ALL', '')
       def test_main():
    1:     run_unittest(BuiltinLevelsTest, BasicFilterTest,
    1:                  CustomLevelsAndFiltersTest, MemoryHandlerTest,
    1:                  ConfigFileTest, SocketHandlerTest, MemoryTest,
    1:                  EncodingTest, WarningsTest, ConfigDictTest, ManagerTest,
    1:                  ChildLoggerTest, HandlerTest)
       
    1: if __name__ == "__main__":
>>>>>>     test_main()
