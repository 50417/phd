    1: """Read/write support for Maildir, mbox, MH, Babyl, and MMDF mailboxes."""
       
       # Notes for authors of new mailbox subclasses:
       #
       # Remember to fsync() changes to disk before closing a modified file
       # or returning from a flush() method.  See functions _sync_flush() and
       # _sync_close().
       
    1: import sys
    1: import os
    1: import time
    1: import calendar
    1: import socket
    1: import errno
    1: import copy
    1: import email
    1: import email.message
    1: import email.generator
    1: import StringIO
    1: try:
    1:     if sys.platform == 'os2emx':
               # OS/2 EMX fcntl() not adequate
>>>>>>         raise ImportError
    1:     import fcntl
>>>>>> except ImportError:
>>>>>>     fcntl = None
       
    1: import warnings
    1: with warnings.catch_warnings():
    1:     if sys.py3kwarning:
>>>>>>         warnings.filterwarnings("ignore", ".*rfc822 has been removed",
>>>>>>                                 DeprecationWarning)
    1:     import rfc822
       
    1: __all__ = [ 'Mailbox', 'Maildir', 'mbox', 'MH', 'Babyl', 'MMDF',
    1:             'Message', 'MaildirMessage', 'mboxMessage', 'MHMessage',
    1:             'BabylMessage', 'MMDFMessage', 'UnixMailbox',
    1:             'PortableUnixMailbox', 'MmdfMailbox', 'MHMailbox', 'BabylMailbox' ]
       
    2: class Mailbox:
    1:     """A group of messages in a particular place."""
       
    1:     def __init__(self, path, factory=None, create=True):
               """Initialize a Mailbox instance."""
  271:         self._path = os.path.abspath(os.path.expanduser(path))
  271:         self._factory = factory
       
    1:     def add(self, message):
               """Add message and return assigned key."""
    1:         raise NotImplementedError('Method must be implemented by subclass')
       
    1:     def remove(self, key):
               """Remove the keyed message; raise KeyError if it doesn't exist."""
    3:         raise NotImplementedError('Method must be implemented by subclass')
       
    1:     def __delitem__(self, key):
   31:         self.remove(key)
       
    1:     def discard(self, key):
               """If the keyed message exists, remove it."""
  113:         try:
  113:             self.remove(key)
    5:         except KeyError:
    4:             pass
       
    1:     def __setitem__(self, key, message):
               """Replace the keyed message; raise KeyError if it doesn't exist."""
    2:         raise NotImplementedError('Method must be implemented by subclass')
       
    1:     def get(self, key, default=None):
               """Return the keyed message, or default if it doesn't exist."""
   22:         try:
   22:             return self.__getitem__(key)
   11:         except KeyError:
   10:             return default
       
    1:     def __getitem__(self, key):
               """Return the keyed message; raise KeyError if it doesn't exist."""
  526:         if not self._factory:
  513:             return self.get_message(key)
               else:
   13:             return self._factory(self.get_file(key))
       
    1:     def get_message(self, key):
               """Return a Message representation or raise a KeyError."""
    4:         raise NotImplementedError('Method must be implemented by subclass')
       
    1:     def get_string(self, key):
               """Return a string representation or raise a KeyError."""
    1:         raise NotImplementedError('Method must be implemented by subclass')
       
    1:     def get_file(self, key):
               """Return a file-like representation or raise a KeyError."""
    1:         raise NotImplementedError('Method must be implemented by subclass')
       
    1:     def iterkeys(self):
               """Return an iterator over keys."""
    9:         raise NotImplementedError('Method must be implemented by subclass')
       
    1:     def keys(self):
               """Return a list of keys."""
  286:         return list(self.iterkeys())
       
    1:     def itervalues(self):
               """Return an iterator over all messages."""
  194:         for key in self.iterkeys():
  160:             try:
  160:                 value = self[key]
>>>>>>             except KeyError:
>>>>>>                 continue
  160:             yield value
       
    1:     def __iter__(self):
   12:         return self.itervalues()
       
    1:     def values(self):
               """Return a list of messages. Memory intensive."""
   11:         return list(self.itervalues())
       
    1:     def iteritems(self):
               """Return an iterator over (key, message) tuples."""
  122:         for key in self.iterkeys():
  100:             try:
  100:                 value = self[key]
>>>>>>             except KeyError:
>>>>>>                 continue
  100:             yield (key, value)
       
    1:     def items(self):
               """Return a list of (key, message) tuples. Memory intensive."""
   11:         return list(self.iteritems())
       
    1:     def has_key(self, key):
               """Return True if the keyed message exists, False otherwise."""
    2:         raise NotImplementedError('Method must be implemented by subclass')
       
    1:     def __contains__(self, key):
  101:         return self.has_key(key)
       
    1:     def __len__(self):
               """Return a count of messages in the mailbox."""
    1:         raise NotImplementedError('Method must be implemented by subclass')
       
    1:     def clear(self):
               """Delete all messages."""
   56:         for key in self.iterkeys():
   50:             self.discard(key)
       
    1:     def pop(self, key, default=None):
               """Delete the keyed message and return it, or default."""
   76:         try:
   76:             result = self[key]
    1:         except KeyError:
>>>>>>             return default
   75:         self.discard(key)
   75:         return result
       
    1:     def popitem(self):
               """Delete an arbitrary (key, message) pair and return it."""
   61:         for key in self.iterkeys():
   60:             return (key, self.pop(key))     # This is only run once.
               else:
>>>>>>             raise KeyError('No messages in mailbox')
       
    1:     def update(self, arg=None):
               """Change the messages that correspond to certain keys."""
   16:         if hasattr(arg, 'iteritems'):
   10:             source = arg.iteritems()
    6:         elif hasattr(arg, 'items'):
>>>>>>             source = arg.items()
               else:
    6:             source = arg
   16:         bad_key = False
   51:         for key, message in source:
   36:             try:
   36:                 self[key] = message
    6:             except KeyError:
    5:                 bad_key = True
   15:         if bad_key:
    5:             raise KeyError('No message with key(s)')
       
    1:     def flush(self):
               """Write any pending changes to the disk."""
    1:         raise NotImplementedError('Method must be implemented by subclass')
       
    1:     def lock(self):
               """Lock the mailbox."""
    1:         raise NotImplementedError('Method must be implemented by subclass')
       
    1:     def unlock(self):
               """Unlock the mailbox if it is locked."""
    1:         raise NotImplementedError('Method must be implemented by subclass')
       
    1:     def close(self):
               """Flush and close the mailbox."""
    1:         raise NotImplementedError('Method must be implemented by subclass')
       
           # Whether each message must end in a newline
    1:     _append_newline = False
       
    1:     def _dump_message(self, message, target, mangle_from_=False):
               # Most files are opened in binary mode to allow predictable seeking.
               # To get native line endings on disk, the user-friendly \n line endings
               # used in strings and by email.Message are translated here.
               """Dump message contents to target file."""
  719:         if isinstance(message, email.message.Message):
   52:             buffer = StringIO.StringIO()
   52:             gen = email.generator.Generator(buffer, mangle_from_, 0)
   52:             gen.flatten(message)
   52:             buffer.seek(0)
   52:             data = buffer.read().replace('\n', os.linesep)
   52:             target.write(data)
   52:             if self._append_newline and not data.endswith(os.linesep):
                       # Make sure the message ends with a newline
    1:                 target.write(os.linesep)
  667:         elif isinstance(message, str):
  645:             if mangle_from_:
  331:                 message = message.replace('\nFrom ', '\n>From ')
  645:             message = message.replace('\n', os.linesep)
  645:             target.write(message)
  645:             if self._append_newline and not message.endswith(os.linesep):
                       # Make sure the message ends with a newline
    2:                 target.write(os.linesep)
   22:         elif hasattr(message, 'read'):
   17:             lastline = None
  601:             while True:
  601:                 line = message.readline()
  601:                 if line == '':
   17:                     break
  584:                 if mangle_from_ and line.startswith('From '):
>>>>>>                     line = '>From ' + line[5:]
  584:                 line = line.replace('\n', os.linesep)
  584:                 target.write(line)
  584:                 lastline = line
   17:             if self._append_newline and lastline and not lastline.endswith(os.linesep):
                       # Make sure the message ends with a newline
>>>>>>                 target.write(os.linesep)
               else:
    5:             raise TypeError('Invalid message type: %s' % type(message))
       
       
    2: class Maildir(Mailbox):
    1:     """A qmail-style Maildir mailbox."""
       
    1:     colon = ':'
       
    1:     def __init__(self, dirname, factory=rfc822.Message, create=True):
               """Initialize a Maildir instance."""
   81:         Mailbox.__init__(self, dirname, factory, create)
   81:         self._paths = {
   81:             'tmp': os.path.join(self._path, 'tmp'),
   81:             'new': os.path.join(self._path, 'new'),
   81:             'cur': os.path.join(self._path, 'cur'),
                   }
   81:         if not os.path.exists(self._path):
   62:             if create:
   62:                 os.mkdir(self._path, 0700)
  248:                 for path in self._paths.values():
  186:                     os.mkdir(path, 0o700)
                   else:
>>>>>>                 raise NoSuchMailboxError(self._path)
   81:         self._toc = {}
   81:         self._toc_mtimes = {'cur': 0, 'new': 0}
   81:         self._last_read = 0         # Records last time we read cur/new
   81:         self._skewfactor = 0.1      # Adjust if os/fs clocks are skewing
       
    1:     def add(self, message):
               """Add message and return assigned key."""
  181:         tmp_file = self._create_tmp()
  181:         try:
  181:             self._dump_message(message, tmp_file)
>>>>>>         except BaseException:
>>>>>>             tmp_file.close()
>>>>>>             os.remove(tmp_file.name)
>>>>>>             raise
  181:         _sync_close(tmp_file)
  181:         if isinstance(message, MaildirMessage):
    8:             subdir = message.get_subdir()
    8:             suffix = self.colon + message.get_info()
    8:             if suffix == self.colon:
    3:                 suffix = ''
               else:
  173:             subdir = 'new'
  173:             suffix = ''
  181:         uniq = os.path.basename(tmp_file.name).split(self.colon)[0]
  181:         dest = os.path.join(self._path, subdir, uniq + suffix)
  181:         if isinstance(message, MaildirMessage):
    8:             os.utime(tmp_file.name,
    8:                      (os.path.getatime(tmp_file.name), message.get_date()))
               # No file modification should be done after the file is moved to its
               # final position in order to prevent race conditions with changes
               # from other programs
  181:         try:
  181:             if hasattr(os, 'link'):
  181:                 os.link(tmp_file.name, dest)
  181:                 os.remove(tmp_file.name)
                   else:
>>>>>>                 os.rename(tmp_file.name, dest)
>>>>>>         except OSError, e:
>>>>>>             os.remove(tmp_file.name)
>>>>>>             if e.errno == errno.EEXIST:
>>>>>>                 raise ExternalClashError('Name clash with existing message: %s'
>>>>>>                                          % dest)
                   else:
>>>>>>                 raise
  181:         return uniq
       
    1:     def remove(self, key):
               """Remove the keyed message; raise KeyError if it doesn't exist."""
   68:         os.remove(os.path.join(self._path, self._lookup(key)))
       
    1:     def discard(self, key):
               """If the keyed message exists, remove it."""
               # This overrides an inapplicable implementation in the superclass.
   42:         try:
   42:             self.remove(key)
    1:         except KeyError:
    1:             pass
>>>>>>         except OSError, e:
>>>>>>             if e.errno != errno.ENOENT:
>>>>>>                 raise
       
    1:     def __setitem__(self, key, message):
               """Replace the keyed message; raise KeyError if it doesn't exist."""
   16:         old_subpath = self._lookup(key)
   14:         temp_key = self.add(message)
   14:         temp_subpath = self._lookup(temp_key)
   14:         if isinstance(message, MaildirMessage):
                   # temp's subdir and suffix were specified by message.
    3:             dominant_subpath = temp_subpath
               else:
                   # temp's subdir and suffix were defaults from add().
   11:             dominant_subpath = old_subpath
   14:         subdir = os.path.dirname(dominant_subpath)
   14:         if self.colon in dominant_subpath:
    2:             suffix = self.colon + dominant_subpath.split(self.colon)[-1]
               else:
   12:             suffix = ''
   14:         self.discard(key)
   14:         tmp_path = os.path.join(self._path, temp_subpath)
   14:         new_path = os.path.join(self._path, subdir, key + suffix)
   14:         if isinstance(message, MaildirMessage):
    3:             os.utime(tmp_path,
    3:                      (os.path.getatime(tmp_path), message.get_date()))
               # No file modification should be done after the file is moved to its
               # final position in order to prevent race conditions with changes
               # from other programs
   14:         os.rename(tmp_path, new_path)
       
    1:     def get_message(self, key):
               """Return a Message representation or raise a KeyError."""
  116:         subpath = self._lookup(key)
   93:         f = open(os.path.join(self._path, subpath), 'r')
   93:         try:
   93:             if self._factory:
    1:                 msg = self._factory(f)
                   else:
   92:                 msg = MaildirMessage(f)
               finally:
   93:             f.close()
   93:         subdir, name = os.path.split(subpath)
   93:         msg.set_subdir(subdir)
   93:         if self.colon in name:
    4:             msg.set_info(name.split(self.colon)[-1])
   93:         msg.set_date(os.path.getmtime(os.path.join(self._path, subpath)))
   93:         return msg
       
    1:     def get_string(self, key):
               """Return a string representation or raise a KeyError."""
   29:         f = open(os.path.join(self._path, self._lookup(key)), 'r')
   29:         try:
   29:             return f.read()
               finally:
   29:             f.close()
       
    1:     def get_file(self, key):
               """Return a file-like representation or raise a KeyError."""
   12:         f = open(os.path.join(self._path, self._lookup(key)), 'rb')
   12:         return _ProxyFile(f)
       
    1:     def iterkeys(self):
               """Return an iterator over keys."""
   39:         self._refresh()
  144:         for key in self._toc:
  117:             try:
  117:                 self._lookup(key)
>>>>>>             except KeyError:
>>>>>>                 continue
  117:             yield key
       
    1:     def has_key(self, key):
               """Return True if the keyed message exists, False otherwise."""
   32:         self._refresh()
   32:         return key in self._toc
       
    1:     def __len__(self):
               """Return a count of messages in the mailbox."""
   69:         self._refresh()
   69:         return len(self._toc)
       
    1:     def flush(self):
               """Write any pending changes to disk."""
               # Maildir changes are always written immediately, so there's nothing
               # to do.
    5:         pass
       
    1:     def lock(self):
               """Lock the mailbox."""
    1:         return
       
    1:     def unlock(self):
               """Unlock the mailbox if it is locked."""
    1:         return
       
    1:     def close(self):
               """Flush and close the mailbox."""
   58:         return
       
    1:     def list_folders(self):
               """Return a list of folder names."""
   12:         result = []
   66:         for entry in os.listdir(self._path):
   54:             if len(entry) > 1 and entry[0] == '.' and \
   18:                os.path.isdir(os.path.join(self._path, entry)):
   18:                 result.append(entry[1:])
   12:         return result
       
    1:     def get_folder(self, folder):
               """Return a Maildir instance for the named folder."""
    3:         return Maildir(os.path.join(self._path, '.' + folder),
    3:                        factory=self._factory,
    3:                        create=False)
       
    1:     def add_folder(self, folder):
               """Create a folder and return a Maildir instance representing it."""
    9:         path = os.path.join(self._path, '.' + folder)
    9:         result = Maildir(path, factory=self._factory)
    9:         maildirfolder_path = os.path.join(path, 'maildirfolder')
    9:         if not os.path.exists(maildirfolder_path):
    9:             os.close(os.open(maildirfolder_path, os.O_CREAT | os.O_WRONLY,
    9:                 0666))
    9:         return result
       
    1:     def remove_folder(self, folder):
               """Delete the named folder, which must be empty."""
    3:         path = os.path.join(self._path, '.' + folder)
    3:         for entry in os.listdir(os.path.join(path, 'new')) + \
    3:                      os.listdir(os.path.join(path, 'cur')):
>>>>>>             if len(entry) < 1 or entry[0] != '.':
>>>>>>                 raise NotEmptyError('Folder contains message(s): %s' % folder)
   15:         for entry in os.listdir(path):
   12:             if entry != 'new' and entry != 'cur' and entry != 'tmp' and \
    3:                os.path.isdir(os.path.join(path, entry)):
>>>>>>                 raise NotEmptyError("Folder contains subdirectory '%s': %s" %
>>>>>>                                     (folder, entry))
   15:         for root, dirs, files in os.walk(path, topdown=False):
   15:             for entry in files:
    3:                 os.remove(os.path.join(root, entry))
   21:             for entry in dirs:
    9:                 os.rmdir(os.path.join(root, entry))
    3:         os.rmdir(path)
       
    1:     def clean(self):
               """Delete old files in "tmp"."""
    2:         now = time.time()
    6:         for entry in os.listdir(os.path.join(self._path, 'tmp')):
    4:             path = os.path.join(self._path, 'tmp', entry)
    4:             if now - os.path.getatime(path) > 129600:   # 60 * 60 * 36
    1:                 os.remove(path)
       
    1:     _count = 1  # This is used to generate unique file names.
       
    1:     def _create_tmp(self):
               """Create a file in the tmp subdirectory and open and return it."""
  191:         now = time.time()
  191:         hostname = socket.gethostname()
  191:         if '/' in hostname:
>>>>>>             hostname = hostname.replace('/', r'\057')
  191:         if ':' in hostname:
>>>>>>             hostname = hostname.replace(':', r'\072')
  191:         uniq = "%s.M%sP%sQ%s.%s" % (int(now), int(now % 1 * 1e6), os.getpid(),
  191:                                     Maildir._count, hostname)
  191:         path = os.path.join(self._path, 'tmp', uniq)
  191:         try:
  191:             os.stat(path)
  191:         except OSError, e:
  191:             if e.errno == errno.ENOENT:
  191:                 Maildir._count += 1
  191:                 try:
  191:                     return _create_carefully(path)
>>>>>>                 except OSError, e:
>>>>>>                     if e.errno != errno.EEXIST:
>>>>>>                         raise
                   else:
>>>>>>                 raise
       
               # Fall through to here if stat succeeded or open raised EEXIST.
>>>>>>         raise ExternalClashError('Name clash prevented file creation: %s' %
>>>>>>                                  path)
       
    1:     def _refresh(self):
               """Update table of contents mapping."""
               # If it has been less than two seconds since the last _refresh() call,
               # we have to unconditionally re-read the mailbox just in case it has
               # been modified, because os.path.mtime() has a 2 sec resolution in the
               # most common worst case (FAT) and a 1 sec resolution typically.  This
               # results in a few unnecessary re-reads when _refresh() is called
               # multiple times in that interval, but once the clock ticks over, we
               # will only re-read as needed.  Because the filesystem might be being
               # served by an independent system with its own clock, we record and
               # compare with the mtimes from the filesystem.  Because the other
               # system's clock might be skewing relative to our clock, we add an
               # extra delta to our wait.  The default is one tenth second, but is an
               # instance variable and so can be adjusted if dealing with a
               # particularly skewed or irregular system.
  213:         if time.time() - self._last_read > 2 + self._skewfactor:
   51:             refresh = False
  153:             for subdir in self._toc_mtimes:
  102:                 mtime = os.path.getmtime(self._paths[subdir])
  102:                 if mtime > self._toc_mtimes[subdir]:
   99:                     refresh = True
  102:                 self._toc_mtimes[subdir] = mtime
   51:             if not refresh:
    1:                 return
               # Refresh toc
  212:         self._toc = {}
  636:         for subdir in self._toc_mtimes:
  424:             path = self._paths[subdir]
  964:             for entry in os.listdir(path):
  540:                 p = os.path.join(path, entry)
  540:                 if os.path.isdir(p):
    1:                     continue
  539:                 uniq = entry.split(self.colon)[0]
  539:                 self._toc[uniq] = os.path.join(subdir, entry)
  212:         self._last_read = time.time()
       
    1:     def _lookup(self, key):
               """Use TOC to return subpath for given key, or raise a KeyError."""
  376:         try:
  376:             if os.path.exists(os.path.join(self._path, self._toc[key])):
  309:                 return self._toc[key]
   63:         except KeyError:
   63:             pass
   67:         self._refresh()
   67:         try:
   67:             return self._toc[key]
   34:         except KeyError:
   34:             raise KeyError('No message with key: %s' % key)
       
           # This method is for backward compatibility only.
    1:     def next(self):
               """Return the next message in a one-time iteration."""
   24:         if not hasattr(self, '_onetime_keys'):
    8:             self._onetime_keys = self.iterkeys()
   24:         while True:
   24:             try:
   24:                 return self[self._onetime_keys.next()]
   16:             except StopIteration:
   16:                 return None
>>>>>>             except KeyError:
>>>>>>                 continue
       
       
    2: class _singlefileMailbox(Mailbox):
    1:     """A single-file mailbox."""
       
    1:     def __init__(self, path, factory=None, create=True):
               """Initialize a single-file mailbox."""
  137:         Mailbox.__init__(self, path, factory, create)
  137:         try:
  137:             f = open(self._path, 'rb+')
  119:         except IOError, e:
  119:             if e.errno == errno.ENOENT:
  119:                 if create:
  119:                     f = open(self._path, 'wb+')
                       else:
>>>>>>                     raise NoSuchMailboxError(self._path)
>>>>>>             elif e.errno in (errno.EACCES, errno.EROFS):
>>>>>>                 f = open(self._path, 'rb')
                   else:
>>>>>>                 raise
  137:         self._file = f
  137:         self._toc = None
  137:         self._next_key = 0
  137:         self._pending = False       # No changes require rewriting the file.
  137:         self._pending_sync = False  # No need to sync the file
  137:         self._locked = False
  137:         self._file_length = None    # Used to record mailbox size
       
    1:     def add(self, message):
               """Add message and return assigned key."""
  476:         self._lookup()
  476:         self._toc[self._next_key] = self._append_message(message)
  476:         self._next_key += 1
               # _append_message appends the message to the mailbox file. We
               # don't need a full rewrite + rename, sync is enough.
  476:         self._pending_sync = True
  476:         return self._next_key - 1
       
    1:     def remove(self, key):
               """Remove the keyed message; raise KeyError if it doesn't exist."""
  166:         self._lookup(key)
  145:         del self._toc[key]
  145:         self._pending = True
       
    1:     def __setitem__(self, key, message):
               """Replace the keyed message; raise KeyError if it doesn't exist."""
   40:         self._lookup(key)
   34:         self._toc[key] = self._append_message(message)
   34:         self._pending = True
       
    1:     def iterkeys(self):
               """Return an iterator over keys."""
   89:         self._lookup()
  353:         for key in self._toc.keys():
  300:             yield key
       
    1:     def has_key(self, key):
               """Return True if the keyed message exists, False otherwise."""
   96:         self._lookup()
   96:         return key in self._toc
       
    1:     def __len__(self):
               """Return a count of messages in the mailbox."""
  200:         self._lookup()
  200:         return len(self._toc)
       
    1:     def lock(self):
               """Lock the mailbox."""
    9:         if not self._locked:
    9:             _lock_file(self._file)
    7:             self._locked = True
       
    1:     def unlock(self):
               """Unlock the mailbox if it is locked."""
    7:         if self._locked:
    7:             _unlock_file(self._file)
    7:             self._locked = False
       
    1:     def flush(self):
               """Write any pending changes to disk."""
  170:         if not self._pending:
  124:             if self._pending_sync:
                       # Messages have only been added, so syncing the file
                       # is enough.
   75:                 _sync_flush(self._file)
   75:                 self._pending_sync = False
  124:             return
       
               # In order to be writing anything out at all, self._toc must
               # already have been generated (and presumably has been modified
               # by adding or deleting an item).
   46:         assert self._toc is not None
       
               # Check length of self._file; if it's changed, some other process
               # has modified the mailbox since we scanned it.
   46:         self._file.seek(0, 2)
   46:         cur_len = self._file.tell()
   46:         if cur_len != self._file_length:
>>>>>>             raise ExternalClashError('Size of mailbox file changed '
                                            '(expected %i, found %i)' %
>>>>>>                                      (self._file_length, cur_len))
       
   46:         new_file = _create_temporary(self._path)
   46:         try:
   46:             new_toc = {}
   46:             self._pre_mailbox_hook(new_file)
   71:             for key in sorted(self._toc.keys()):
   25:                 start, stop = self._toc[key]
   25:                 self._file.seek(start)
   25:                 self._pre_message_hook(new_file)
   25:                 new_start = new_file.tell()
   50:                 while True:
   50:                     buffer = self._file.read(min(4096,
   50:                                                  stop - self._file.tell()))
   50:                     if buffer == '':
   25:                         break
   25:                     new_file.write(buffer)
   25:                 new_toc[key] = (new_start, new_file.tell())
   25:                 self._post_message_hook(new_file)
   46:             self._file_length = new_file.tell()
>>>>>>         except:
>>>>>>             new_file.close()
>>>>>>             os.remove(new_file.name)
>>>>>>             raise
   46:         _sync_close(new_file)
               # self._file is about to get replaced, so no need to sync.
   46:         self._file.close()
               # Make sure the new file's mode is the same as the old file's
   46:         mode = os.stat(self._path).st_mode
   46:         os.chmod(new_file.name, mode)
   46:         try:
   46:             os.rename(new_file.name, self._path)
>>>>>>         except OSError, e:
>>>>>>             if e.errno == errno.EEXIST or \
>>>>>>               (os.name == 'os2' and e.errno == errno.EACCES):
>>>>>>                 os.remove(self._path)
>>>>>>                 os.rename(new_file.name, self._path)
                   else:
>>>>>>                 raise
   46:         self._file = open(self._path, 'rb+')
   46:         self._toc = new_toc
   46:         self._pending = False
   46:         self._pending_sync = False
   46:         if self._locked:
>>>>>>             _lock_file(self._file, dotlock=False)
       
    1:     def _pre_mailbox_hook(self, f):
               """Called before writing the mailbox to file f."""
  107:         return
       
    1:     def _pre_message_hook(self, f):
               """Called before writing each message to file f."""
  184:         return
       
    1:     def _post_message_hook(self, f):
               """Called after writing each message to file f."""
>>>>>>         return
       
    1:     def close(self):
               """Flush and close the mailbox."""
  148:         try:
  148:             self.flush()
               finally:
  148:             try:
  148:                 if self._locked:
    2:                     self.unlock()
                   finally:
  148:                 self._file.close()  # Sync has been done by self.flush() above.
       
    1:     def _lookup(self, key=None):
               """Return (start, stop) or raise KeyError."""
 1531:         if self._toc is None:
  126:             self._generate_toc()
 1531:         if key is not None:
  616:             try:
  616:                 return self._toc[key]
   96:             except KeyError:
   96:                 raise KeyError('No message with key: %s' % key)
       
    1:     def _append_message(self, message):
               """Append message to mailbox and return (start, stop) offsets."""
  510:         self._file.seek(0, 2)
  510:         before = self._file.tell()
  510:         if len(self._toc) == 0 and not self._pending:
                   # This is the first message, and the _pre_mailbox_hook
                   # hasn't yet been called. If self._pending is True,
                   # messages have been removed, so _pre_mailbox_hook must
                   # have been called already.
  110:             self._pre_mailbox_hook(self._file)
  510:         try:
  510:             self._pre_message_hook(self._file)
  510:             offsets = self._install_message(message)
  510:             self._post_message_hook(self._file)
>>>>>>         except BaseException:
>>>>>>             self._file.truncate(before)
>>>>>>             raise
  510:         self._file.flush()
  510:         self._file_length = self._file.tell()  # Record current length of mailbox
  510:         return offsets
       
       
       
    2: class _mboxMMDF(_singlefileMailbox):
    1:     """An mbox or MMDF mailbox."""
       
    1:     _mangle_from_ = True
       
    1:     def get_message(self, key):
               """Return a Message representation or raise a KeyError."""
  207:         start, stop = self._lookup(key)
  161:         self._file.seek(start)
  161:         from_line = self._file.readline().replace(os.linesep, '')
  161:         string = self._file.read(stop - self._file.tell())
  161:         msg = self._message_factory(string.replace(os.linesep, '\n'))
  161:         msg.set_from(from_line[5:])
  161:         return msg
       
    1:     def get_string(self, key, from_=False):
               """Return a string representation or raise a KeyError."""
   62:         start, stop = self._lookup(key)
   62:         self._file.seek(start)
   62:         if not from_:
   62:             self._file.readline()
   62:         string = self._file.read(stop - self._file.tell())
   62:         return string.replace(os.linesep, '\n')
       
    1:     def get_file(self, key, from_=False):
               """Return a file-like representation or raise a KeyError."""
    8:         start, stop = self._lookup(key)
    8:         self._file.seek(start)
    8:         if not from_:
    8:             self._file.readline()
    8:         return _PartialFile(self._file, self._file.tell(), stop)
       
    1:     def _install_message(self, message):
               """Format a message and blindly write to self._file."""
  348:         from_line = None
  348:         if isinstance(message, str) and message.startswith('From '):
    2:             newline = message.find('\n')
    2:             if newline != -1:
    2:                 from_line = message[:newline]
    2:                 message = message[newline + 1:]
                   else:
>>>>>>                 from_line = message
>>>>>>                 message = ''
  346:         elif isinstance(message, _mboxMMDFMessage):
    6:             from_line = 'From ' + message.get_from()
  340:         elif isinstance(message, email.message.Message):
    5:             from_line = message.get_unixfrom()  # May be None.
  348:         if from_line is None:
  340:             from_line = 'From MAILER-DAEMON %s' % time.asctime(time.gmtime())
  348:         start = self._file.tell()
  348:         self._file.write(from_line + os.linesep)
  348:         self._dump_message(message, self._file, self._mangle_from_)
  348:         stop = self._file.tell()
  348:         return (start, stop)
       
       
    2: class mbox(_mboxMMDF):
    1:     """A classic mbox mailbox."""
       
    1:     _mangle_from_ = True
       
           # All messages must end in a newline character, and
           # _post_message_hooks outputs an empty line between messages.
    1:     _append_newline = True
       
    1:     def __init__(self, path, factory=None, create=True):
               """Initialize an mbox mailbox."""
   51:         self._message_factory = mboxMessage
   51:         _mboxMMDF.__init__(self, path, factory, create)
       
    1:     def _post_message_hook(self, f):
               """Called after writing each message to file f."""
  184:         f.write(os.linesep)
       
    1:     def _generate_toc(self):
               """Generate key-to-(start, stop) table of contents."""
   46:         starts, stops = [], []
   46:         last_was_empty = False
   46:         self._file.seek(0)
  106:         while True:
  106:             line_pos = self._file.tell()
  106:             line = self._file.readline()
  106:             if line.startswith('From '):
   12:                 if len(stops) < len(starts):
    6:                     if last_was_empty:
    6:                         stops.append(line_pos - len(os.linesep))
                           else:
                               # The last line before the "From " line wasn't
                               # blank, but we consider it a start of a
                               # message anyway.
>>>>>>                         stops.append(line_pos)
   12:                 starts.append(line_pos)
   12:                 last_was_empty = False
   94:             elif not line:
   46:                 if last_was_empty:
    6:                     stops.append(line_pos - len(os.linesep))
                       else:
   40:                     stops.append(line_pos)
   46:                 break
   48:             elif line == os.linesep:
   24:                 last_was_empty = True
                   else:
   24:                 last_was_empty = False
   46:         self._toc = dict(enumerate(zip(starts, stops)))
   46:         self._next_key = len(self._toc)
   46:         self._file_length = self._file.tell()
       
       
    2: class MMDF(_mboxMMDF):
    1:     """An MMDF mailbox."""
       
    1:     def __init__(self, path, factory=None, create=True):
               """Initialize an MMDF mailbox."""
   47:         self._message_factory = MMDFMessage
   47:         _mboxMMDF.__init__(self, path, factory, create)
       
    1:     def _pre_message_hook(self, f):
               """Called before writing each message to file f."""
  180:         f.write('\001\001\001\001' + os.linesep)
       
    1:     def _post_message_hook(self, f):
               """Called after writing each message to file f."""
  180:         f.write(os.linesep + '\001\001\001\001' + os.linesep)
       
    1:     def _generate_toc(self):
               """Generate key-to-(start, stop) table of contents."""
   43:         starts, stops = [], []
   43:         self._file.seek(0)
   43:         next_pos = 0
   55:         while True:
   55:             line_pos = next_pos
   55:             line = self._file.readline()
   55:             next_pos = self._file.tell()
   55:             if line.startswith('\001\001\001\001' + os.linesep):
   12:                 starts.append(next_pos)
   72:                 while True:
   72:                     line_pos = next_pos
   72:                     line = self._file.readline()
   72:                     next_pos = self._file.tell()
   72:                     if line == '\001\001\001\001' + os.linesep:
   12:                         stops.append(line_pos - len(os.linesep))
   12:                         break
   60:                     elif line == '':
>>>>>>                         stops.append(line_pos)
>>>>>>                         break
   43:             elif line == '':
   43:                 break
   43:         self._toc = dict(enumerate(zip(starts, stops)))
   43:         self._next_key = len(self._toc)
   43:         self._file.seek(0, 2)
   43:         self._file_length = self._file.tell()
       
       
    2: class MH(Mailbox):
    1:     """An MH mailbox."""
       
    1:     def __init__(self, path, factory=None, create=True):
               """Initialize an MH instance."""
   52:         Mailbox.__init__(self, path, factory, create)
   52:         if not os.path.exists(self._path):
   46:             if create:
   46:                 os.mkdir(self._path, 0700)
   46:                 os.close(os.open(os.path.join(self._path, '.mh_sequences'),
   46:                                  os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0600))
                   else:
>>>>>>                 raise NoSuchMailboxError(self._path)
   52:         self._locked = False
       
    1:     def add(self, message):
               """Add message and return assigned key."""
  158:         keys = self.keys()
  158:         if len(keys) == 0:
   35:             new_key = 1
               else:
  123:             new_key = max(keys) + 1
  158:         new_path = os.path.join(self._path, str(new_key))
  158:         f = _create_carefully(new_path)
  158:         closed = False
  158:         try:
  158:             if self._locked:
>>>>>>                 _lock_file(f)
  158:             try:
  158:                 try:
  158:                     self._dump_message(message, f)
>>>>>>                 except BaseException:
                           # Unlock and close so it can be deleted on Windows
>>>>>>                     if self._locked:
>>>>>>                         _unlock_file(f)
>>>>>>                     _sync_close(f)
>>>>>>                     closed = True
>>>>>>                     os.remove(new_path)
>>>>>>                     raise
  158:                 if isinstance(message, MHMessage):
   12:                     self._dump_sequences(message, new_key)
                   finally:
  158:                 if self._locked:
>>>>>>                     _unlock_file(f)
               finally:
  158:             if not closed:
  158:                 _sync_close(f)
  158:         return new_key
       
    1:     def remove(self, key):
               """Remove the keyed message; raise KeyError if it doesn't exist."""
   59:         path = os.path.join(self._path, str(key))
   59:         try:
   59:             f = open(path, 'rb+')
    7:         except IOError, e:
    7:             if e.errno == errno.ENOENT:
    7:                 raise KeyError('No message with key: %s' % key)
                   else:
>>>>>>                 raise
               else:
   52:             f.close()
   52:             os.remove(path)
       
    1:     def __setitem__(self, key, message):
               """Replace the keyed message; raise KeyError if it doesn't exist."""
   14:         path = os.path.join(self._path, str(key))
   14:         try:
   14:             f = open(path, 'rb+')
    2:         except IOError, e:
    2:             if e.errno == errno.ENOENT:
    2:                 raise KeyError('No message with key: %s' % key)
                   else:
>>>>>>                 raise
   12:         try:
   12:             if self._locked:
>>>>>>                 _lock_file(f)
   12:             try:
   12:                 os.close(os.open(path, os.O_WRONLY | os.O_TRUNC))
   12:                 self._dump_message(message, f)
   12:                 if isinstance(message, MHMessage):
    2:                     self._dump_sequences(message, key)
                   finally:
   12:                 if self._locked:
>>>>>>                     _unlock_file(f)
               finally:
   12:             _sync_close(f)
       
    1:     def get_message(self, key):
               """Return a Message representation or raise a KeyError."""
  102:         try:
  102:             if self._locked:
>>>>>>                 f = open(os.path.join(self._path, str(key)), 'r+')
                   else:
  102:                 f = open(os.path.join(self._path, str(key)), 'r')
   23:         except IOError, e:
   23:             if e.errno == errno.ENOENT:
   23:                 raise KeyError('No message with key: %s' % key)
                   else:
>>>>>>                 raise
   79:         try:
   79:             if self._locked:
>>>>>>                 _lock_file(f)
   79:             try:
   79:                 msg = MHMessage(f)
                   finally:
   79:                 if self._locked:
>>>>>>                     _unlock_file(f)
               finally:
   79:             f.close()
   80:         for name, key_list in self.get_sequences().iteritems():
    1:             if key in key_list:
    1:                 msg.add_sequence(name)
   79:         return msg
       
    1:     def get_string(self, key):
               """Return a string representation or raise a KeyError."""
   29:         try:
   29:             if self._locked:
>>>>>>                 f = open(os.path.join(self._path, str(key)), 'r+')
                   else:
   29:                 f = open(os.path.join(self._path, str(key)), 'r')
>>>>>>         except IOError, e:
>>>>>>             if e.errno == errno.ENOENT:
>>>>>>                 raise KeyError('No message with key: %s' % key)
                   else:
>>>>>>                 raise
   29:         try:
   29:             if self._locked:
>>>>>>                 _lock_file(f)
   29:             try:
   29:                 return f.read()
                   finally:
   29:                 if self._locked:
>>>>>>                     _unlock_file(f)
               finally:
   29:             f.close()
       
    1:     def get_file(self, key):
               """Return a file-like representation or raise a KeyError."""
    4:         try:
    4:             f = open(os.path.join(self._path, str(key)), 'rb')
>>>>>>         except IOError, e:
>>>>>>             if e.errno == errno.ENOENT:
>>>>>>                 raise KeyError('No message with key: %s' % key)
                   else:
>>>>>>                 raise
    4:         return _ProxyFile(f)
       
    1:     def iterkeys(self):
               """Return an iterator over keys."""
 2660:         return iter(sorted(int(entry) for entry in os.listdir(self._path)
 1940:                                       if entry.isdigit()))
       
    1:     def has_key(self, key):
               """Return True if the keyed message exists, False otherwise."""
   32:         return os.path.exists(os.path.join(self._path, str(key)))
       
    1:     def __len__(self):
               """Return a count of messages in the mailbox."""
   65:         return len(list(self.iterkeys()))
       
    1:     def lock(self):
               """Lock the mailbox."""
    3:         if not self._locked:
    3:             self._file = open(os.path.join(self._path, '.mh_sequences'), 'rb+')
    3:             _lock_file(self._file)
    3:             self._locked = True
       
    1:     def unlock(self):
               """Unlock the mailbox if it is locked."""
    3:         if self._locked:
    3:             _unlock_file(self._file)
    3:             _sync_close(self._file)
    3:             del self._file
    3:             self._locked = False
       
    1:     def flush(self):
               """Write any pending changes to the disk."""
    4:         return
       
    1:     def close(self):
               """Flush and close the mailbox."""
   44:         if self._locked:
>>>>>>             self.unlock()
       
    1:     def list_folders(self):
               """Return a list of folder names."""
   12:         result = []
   42:         for entry in os.listdir(self._path):
   30:             if os.path.isdir(os.path.join(self._path, entry)):
   18:                 result.append(entry)
   12:         return result
       
    1:     def get_folder(self, folder):
               """Return an MH instance for the named folder."""
    2:         return MH(os.path.join(self._path, folder),
    2:                   factory=self._factory, create=False)
       
    1:     def add_folder(self, folder):
               """Create a folder and return an MH instance representing it."""
    7:         return MH(os.path.join(self._path, folder),
    7:                   factory=self._factory)
       
    1:     def remove_folder(self, folder):
               """Delete the named folder, which must be empty."""
    3:         path = os.path.join(self._path, folder)
    3:         entries = os.listdir(path)
    3:         if entries == ['.mh_sequences']:
    3:             os.remove(os.path.join(path, '.mh_sequences'))
>>>>>>         elif entries == []:
>>>>>>             pass
               else:
>>>>>>             raise NotEmptyError('Folder not empty: %s' % self._path)
    3:         os.rmdir(path)
       
    1:     def get_sequences(self):
               """Return a name-to-key-list dictionary to define each sequence."""
  104:         results = {}
  104:         f = open(os.path.join(self._path, '.mh_sequences'), 'r')
  104:         try:
  104:             all_keys = set(self.keys())
  171:             for line in f:
   67:                 try:
   67:                     name, contents = line.split(':')
   67:                     keys = set()
  134:                     for spec in contents.split():
   67:                         if spec.isdigit():
   53:                             keys.add(int(spec))
                               else:
   56:                             start, stop = (int(x) for x in spec.split('-'))
   14:                             keys.update(range(start, stop + 1))
  174:                     results[name] = [key for key in sorted(keys) \
  107:                                          if key in all_keys]
   67:                     if len(results[name]) == 0:
    5:                         del results[name]
>>>>>>                 except ValueError:
>>>>>>                     raise FormatError('Invalid sequence specification: %s' %
>>>>>>                                       line.rstrip())
               finally:
  104:             f.close()
  104:         return results
       
    1:     def set_sequences(self, sequences):
               """Set sequences using the given name-to-key-list dictionary."""
   16:         f = open(os.path.join(self._path, '.mh_sequences'), 'r+')
   16:         try:
   16:             os.close(os.open(f.name, os.O_WRONLY | os.O_TRUNC))
   61:             for name, keys in sequences.iteritems():
   45:                 if len(keys) == 0:
>>>>>>                     continue
   45:                 f.write('%s:' % name)
   45:                 prev = None
   45:                 completing = False
  121:                 for key in sorted(set(keys)):
   76:                     if key - 1 == prev:
   31:                         if not completing:
   10:                             completing = True
   10:                             f.write('-')
   45:                     elif completing:
>>>>>>                         completing = False
>>>>>>                         f.write('%s %s' % (prev, key))
                           else:
   45:                         f.write(' %s' % key)
   76:                     prev = key
   45:                 if completing:
   10:                     f.write(str(prev) + '\n')
                       else:
   35:                     f.write('\n')
               finally:
   16:             _sync_close(f)
       
    1:     def pack(self):
               """Re-name messages to eliminate numbering gaps. Invalidates keys."""
    2:         sequences = self.get_sequences()
    2:         prev = 0
    2:         changes = []
   10:         for key in self.iterkeys():
    8:             if key - 1 != prev:
    3:                 changes.append((key, prev + 1))
    3:                 if hasattr(os, 'link'):
    3:                     os.link(os.path.join(self._path, str(key)),
    3:                             os.path.join(self._path, str(prev + 1)))
    3:                     os.unlink(os.path.join(self._path, str(key)))
                       else:
>>>>>>                     os.rename(os.path.join(self._path, str(key)),
>>>>>>                               os.path.join(self._path, str(prev + 1)))
    8:             prev += 1
    2:         self._next_key = prev + 1
    2:         if len(changes) == 0:
>>>>>>             return
   10:         for name, key_list in sequences.items():
   20:             for old, new in changes:
   12:                 if old in key_list:
    5:                     key_list[key_list.index(old)] = new
    2:         self.set_sequences(sequences)
       
    1:     def _dump_sequences(self, message, key):
               """Inspect a new MHMessage and update sequences appropriately."""
   14:         pending_sequences = message.get_sequences()
   14:         all_sequences = self.get_sequences()
   41:         for name, key_list in all_sequences.iteritems():
   27:             if name in pending_sequences:
    8:                 key_list.append(key)
   19:             elif key in key_list:
    1:                 del key_list[key_list.index(key)]
   32:         for sequence in pending_sequences:
   18:             if sequence not in all_sequences:
   10:                 all_sequences[sequence] = [key]
   14:         self.set_sequences(all_sequences)
       
       
    2: class Babyl(_singlefileMailbox):
    1:     """An Rmail-style Babyl mailbox."""
       
    1:     _special_labels = frozenset(('unseen', 'deleted', 'filed', 'answered',
    1:                                  'forwarded', 'edited', 'resent'))
       
    1:     def __init__(self, path, factory=None, create=True):
               """Initialize a Babyl mailbox."""
   39:         _singlefileMailbox.__init__(self, path, factory, create)
   39:         self._labels = {}
       
    1:     def add(self, message):
               """Add message and return assigned key."""
  150:         key = _singlefileMailbox.add(self, message)
  150:         if isinstance(message, BabylMessage):
    2:             self._labels[key] = message.get_labels()
  150:         return key
       
    1:     def remove(self, key):
               """Remove the keyed message; raise KeyError if it doesn't exist."""
   56:         _singlefileMailbox.remove(self, key)
   49:         if key in self._labels:
    1:             del self._labels[key]
       
    1:     def __setitem__(self, key, message):
               """Replace the keyed message; raise KeyError if it doesn't exist."""
   14:         _singlefileMailbox.__setitem__(self, key, message)
   12:         if isinstance(message, BabylMessage):
    2:             self._labels[key] = message.get_labels()
       
    1:     def get_message(self, key):
               """Return a Message representation or raise a KeyError."""
  101:         start, stop = self._lookup(key)
   78:         self._file.seek(start)
   78:         self._file.readline()   # Skip '1,' line specifying labels.
   78:         original_headers = StringIO.StringIO()
  464:         while True:
  464:             line = self._file.readline()
  464:             if line == '*** EOOH ***' + os.linesep or line == '':
   78:                 break
  386:             original_headers.write(line.replace(os.linesep, '\n'))
   78:         visible_headers = StringIO.StringIO()
  338:         while True:
  338:             line = self._file.readline()
  338:             if line == os.linesep or line == '':
   78:                 break
  260:             visible_headers.write(line.replace(os.linesep, '\n'))
   78:         body = self._file.read(stop - self._file.tell()).replace(os.linesep,
   78:                                                                  '\n')
   78:         msg = BabylMessage(original_headers.getvalue() + body)
   78:         msg.set_visible(visible_headers.getvalue())
   78:         if key in self._labels:
    2:             msg.set_labels(self._labels[key])
   78:         return msg
       
    1:     def get_string(self, key):
               """Return a string representation or raise a KeyError."""
   32:         start, stop = self._lookup(key)
   32:         self._file.seek(start)
   32:         self._file.readline()   # Skip '1,' line specifying labels.
   32:         original_headers = StringIO.StringIO()
  188:         while True:
  188:             line = self._file.readline()
  188:             if line == '*** EOOH ***' + os.linesep or line == '':
   32:                 break
  156:             original_headers.write(line.replace(os.linesep, '\n'))
  156:         while True:
  156:             line = self._file.readline()
  156:             if line == os.linesep or line == '':
   32:                 break
   32:         return original_headers.getvalue() + \
   32:                self._file.read(stop - self._file.tell()).replace(os.linesep,
   32:                                                                  '\n')
       
    1:     def get_file(self, key):
               """Return a file-like representation or raise a KeyError."""
    4:         return StringIO.StringIO(self.get_string(key).replace('\n',
    4:                                                               os.linesep))
       
    1:     def get_labels(self):
               """Return a list of user-defined labels in the mailbox."""
   54:         self._lookup()
   54:         labels = set()
   62:         for label_list in self._labels.values():
    8:             labels.update(label_list)
   54:         labels.difference_update(self._special_labels)
   54:         return list(labels)
       
    1:     def _generate_toc(self):
               """Generate key-to-(start, stop) table of contents."""
   37:         starts, stops = [], []
   37:         self._file.seek(0)
   37:         next_pos = 0
   37:         label_lists = []
  117:         while True:
  117:             line_pos = next_pos
  117:             line = self._file.readline()
  117:             next_pos = self._file.tell()
  117:             if line == '\037\014' + os.linesep:
    8:                 if len(stops) < len(starts):
    4:                     stops.append(line_pos - len(os.linesep))
    8:                 starts.append(next_pos)
    8:                 labels = [label.strip() for label
   32:                                         in self._file.readline()[1:].split(',')
   24:                                         if label.strip() != '']
    8:                 label_lists.append(labels)
  109:             elif line == '\037' or line == '\037' + os.linesep:
    4:                 if len(stops) < len(starts):
    4:                     stops.append(line_pos - len(os.linesep))
  105:             elif line == '':
   37:                 stops.append(line_pos - len(os.linesep))
   37:                 break
   37:         self._toc = dict(enumerate(zip(starts, stops)))
   37:         self._labels = dict(enumerate(label_lists))
   37:         self._next_key = len(self._toc)
   37:         self._file.seek(0, 2)
   37:         self._file_length = self._file.tell()
       
    1:     def _pre_mailbox_hook(self, f):
               """Called before writing the mailbox to file f."""
   49:         f.write('BABYL OPTIONS:%sVersion: 5%sLabels:%s%s\037' %
   49:                 (os.linesep, os.linesep, ','.join(self.get_labels()),
   49:                  os.linesep))
       
    1:     def _pre_message_hook(self, f):
               """Called before writing each message to file f."""
  171:         f.write('\014' + os.linesep)
       
    1:     def _post_message_hook(self, f):
               """Called after writing each message to file f."""
  171:         f.write(os.linesep + '\037')
       
    1:     def _install_message(self, message):
               """Write message contents and return (start, stop)."""
  162:         start = self._file.tell()
  162:         if isinstance(message, BabylMessage):
    4:             special_labels = []
    4:             labels = []
   10:             for label in message.get_labels():
    6:                 if label in self._special_labels:
    2:                     special_labels.append(label)
                       else:
    4:                     labels.append(label)
    4:             self._file.write('1')
    6:             for label in special_labels:
    2:                 self._file.write(', ' + label)
    4:             self._file.write(',,')
    8:             for label in labels:
    4:                 self._file.write(' ' + label + ',')
    4:             self._file.write(os.linesep)
               else:
  158:             self._file.write('1,,' + os.linesep)
  162:         if isinstance(message, email.message.Message):
    6:             orig_buffer = StringIO.StringIO()
    6:             orig_generator = email.generator.Generator(orig_buffer, False, 0)
    6:             orig_generator.flatten(message)
    6:             orig_buffer.seek(0)
   81:             while True:
   81:                 line = orig_buffer.readline()
   81:                 self._file.write(line.replace('\n', os.linesep))
   81:                 if line == '\n' or line == '':
    6:                     break
    6:             self._file.write('*** EOOH ***' + os.linesep)
    6:             if isinstance(message, BabylMessage):
    4:                 vis_buffer = StringIO.StringIO()
    4:                 vis_generator = email.generator.Generator(vis_buffer, False, 0)
    4:                 vis_generator.flatten(message.get_visible())
    4:                 while True:
    4:                     line = vis_buffer.readline()
    4:                     self._file.write(line.replace('\n', os.linesep))
    4:                     if line == '\n' or line == '':
    4:                         break
                   else:
    2:                 orig_buffer.seek(0)
   50:                 while True:
   50:                     line = orig_buffer.readline()
   50:                     self._file.write(line.replace('\n', os.linesep))
   50:                     if line == '\n' or line == '':
    2:                         break
   12:             while True:
   12:                 buffer = orig_buffer.read(4096) # Buffer size is arbitrary.
   12:                 if buffer == '':
    6:                     break
    6:                 self._file.write(buffer.replace('\n', os.linesep))
  156:         elif isinstance(message, str):
  153:             body_start = message.find('\n\n') + 2
  153:             if body_start - 2 != -1:
  153:                 self._file.write(message[:body_start].replace('\n',
  153:                                                               os.linesep))
  153:                 self._file.write('*** EOOH ***' + os.linesep)
  153:                 self._file.write(message[:body_start].replace('\n',
  153:                                                               os.linesep))
  153:                 self._file.write(message[body_start:].replace('\n',
  153:                                                               os.linesep))
                   else:
>>>>>>                 self._file.write('*** EOOH ***' + os.linesep + os.linesep)
>>>>>>                 self._file.write(message.replace('\n', os.linesep))
    3:         elif hasattr(message, 'readline'):
    3:             original_pos = message.tell()
    3:             first_pass = True
  104:             while True:
  104:                 line = message.readline()
  104:                 self._file.write(line.replace('\n', os.linesep))
  104:                 if line == '\n' or line == '':
    6:                     if first_pass:
    3:                         first_pass = False
    3:                         self._file.write('*** EOOH ***' + os.linesep)
    3:                         message.seek(original_pos)
                           else:
    3:                         break
    6:             while True:
    6:                 buffer = message.read(4096)     # Buffer size is arbitrary.
    6:                 if buffer == '':
    3:                     break
    3:                 self._file.write(buffer.replace('\n', os.linesep))
               else:
>>>>>>             raise TypeError('Invalid message type: %s' % type(message))
  162:         stop = self._file.tell()
  162:         return (start, stop)
       
       
    2: class Message(email.message.Message):
    1:     """Message with mailbox-format-specific properties."""
       
    1:     def __init__(self, message=None):
               """Initialize a Message instance."""
 1020:         if isinstance(message, email.message.Message):
  179:             self._become_message(copy.deepcopy(message))
  179:             if isinstance(message, Message):
  173:                 message._explain_to(self)
  841:         elif isinstance(message, str):
  443:             self._become_message(email.message_from_string(message))
  398:         elif hasattr(message, "read"):
  178:             self._become_message(email.message_from_file(message))
  220:         elif message is None:
  208:             email.message.Message.__init__(self)
               else:
   12:             raise TypeError('Invalid message type: %s' % type(message))
       
    1:     def _become_message(self, message):
               """Assume the non-format-specific state of message."""
  806:         for name in ('_headers', '_unixfrom', '_payload', '_charset',
 7254:                      'preamble', 'epilogue', 'defects', '_default_type'):
 6448:             self.__dict__[name] = message.__dict__[name]
       
    1:     def _explain_to(self, message):
               """Copy format-specific state to message insofar as possible."""
   40:         if isinstance(message, Message):
   39:             return  # There's nothing format-specific to explain.
               else:
    1:             raise TypeError('Cannot convert to specified type')
       
       
    2: class MaildirMessage(Message):
    1:     """Message with Maildir-specific properties."""
       
    1:     def __init__(self, message=None):
               """Initialize a MaildirMessage instance."""
  165:         self._subdir = 'new'
  165:         self._info = ''
  165:         self._date = time.time()
  165:         Message.__init__(self, message)
       
    1:     def get_subdir(self):
               """Return 'new' or 'cur'."""
   55:         return self._subdir
       
    1:     def set_subdir(self, subdir):
               """Set subdir to 'new' or 'cur'."""
  137:         if subdir == 'new' or subdir == 'cur':
  136:             self._subdir = subdir
               else:
    1:             raise ValueError("subdir must be 'new' or 'cur': %s" % subdir)
       
    1:     def get_flags(self):
               """Return as a string the flags that are set."""
  135:         if self._info.startswith('2,'):
   88:             return self._info[2:]
               else:
   47:             return ''
       
    1:     def set_flags(self, flags):
               """Set the given flags and unset all others."""
   96:         self._info = '2,' + ''.join(sorted(flags))
       
    1:     def add_flag(self, flag):
               """Set the given flag(s) without changing others."""
   58:         self.set_flags(''.join(set(self.get_flags()) | set(flag)))
       
    1:     def remove_flag(self, flag):
               """Unset the given string flag(s) without changing others."""
    2:         if self.get_flags() != '':
    1:             self.set_flags(''.join(set(self.get_flags()) - set(flag)))
       
    1:     def get_date(self):
               """Return delivery date of message, in seconds since the epoch."""
   47:         return self._date
       
    1:     def set_date(self, date):
               """Set delivery date of message, in seconds since the epoch."""
  114:         try:
  114:             self._date = float(date)
>>>>>>         except ValueError:
>>>>>>             raise TypeError("can't convert to float: %s" % date)
       
    1:     def get_info(self):
               """Get the message's "info" as a string."""
   15:         return self._info
       
    1:     def set_info(self, info):
               """Set the message's "info" string."""
    9:         if isinstance(info, str):
    8:             self._info = info
               else:
    1:             raise TypeError('info must be a string: %s' % type(info))
       
    1:     def _explain_to(self, message):
               """Copy Maildir-specific state to message insofar as possible."""
   39:         if isinstance(message, MaildirMessage):
    2:             message.set_flags(self.get_flags())
    2:             message.set_subdir(self.get_subdir())
    2:             message.set_date(self.get_date())
   37:         elif isinstance(message, _mboxMMDFMessage):
   18:             flags = set(self.get_flags())
   18:             if 'S' in flags:
    6:                 message.add_flag('R')
   18:             if self.get_subdir() == 'cur':
    2:                 message.add_flag('O')
   18:             if 'T' in flags:
    6:                 message.add_flag('D')
   18:             if 'F' in flags:
    6:                 message.add_flag('F')
   18:             if 'R' in flags:
    6:                 message.add_flag('A')
   18:             message.set_from('MAILER-DAEMON', time.gmtime(self.get_date()))
   19:         elif isinstance(message, MHMessage):
    8:             flags = set(self.get_flags())
    8:             if 'S' not in flags:
    6:                 message.add_sequence('unseen')
    8:             if 'R' in flags:
    2:                 message.add_sequence('replied')
    8:             if 'F' in flags:
    2:                 message.add_sequence('flagged')
   11:         elif isinstance(message, BabylMessage):
    8:             flags = set(self.get_flags())
    8:             if 'S' not in flags:
    6:                 message.add_label('unseen')
    8:             if 'T' in flags:
    2:                 message.add_label('deleted')
    8:             if 'R' in flags:
    2:                 message.add_label('answered')
    8:             if 'P' in flags:
    2:                 message.add_label('forwarded')
    3:         elif isinstance(message, Message):
    2:             pass
               else:
    1:             raise TypeError('Cannot convert to specified type: %s' %
    1:                             type(message))
       
       
    2: class _mboxMMDFMessage(Message):
    1:     """Message with mbox- or MMDF-specific properties."""
       
    1:     def __init__(self, message=None):
               """Initialize an mboxMMDFMessage instance."""
  255:         self.set_from('MAILER-DAEMON', True)
  255:         if isinstance(message, email.message.Message):
   50:             unixfrom = message.get_unixfrom()
   50:             if unixfrom is not None and unixfrom.startswith('From '):
    2:                 self.set_from(unixfrom[5:])
  255:         Message.__init__(self, message)
       
    1:     def get_from(self):
               """Return contents of "From " line."""
   68:         return self._from
       
    1:     def set_from(self, from_, time_=None):
               """Set "From " line, formatting and appending time_ if specified."""
  454:         if time_ is not None:
  279:             if time_ is True:
  257:                 time_ = time.gmtime()
  279:             from_ += ' ' + time.asctime(time_)
  454:         self._from = from_
       
    1:     def get_flags(self):
               """Return as a string the flags that are set."""
  180:         return self.get('Status', '') + self.get('X-Status', '')
       
    1:     def set_flags(self, flags):
               """Set the given flags and unset all others."""
  126:         flags = set(flags)
  126:         status_flags, xstatus_flags = '', ''
  378:         for flag in ('R', 'O'):
  252:             if flag in flags:
  150:                 status_flags += flag
  150:                 flags.remove(flag)
  504:         for flag in ('D', 'F', 'A'):
  378:             if flag in flags:
  114:                 xstatus_flags += flag
  114:                 flags.remove(flag)
  126:         xstatus_flags += ''.join(sorted(flags))
  126:         try:
  126:             self.replace_header('Status', status_flags)
   54:         except KeyError:
   54:             self.add_header('Status', status_flags)
  126:         try:
  126:             self.replace_header('X-Status', xstatus_flags)
   54:         except KeyError:
   54:             self.add_header('X-Status', xstatus_flags)
       
    1:     def add_flag(self, flag):
               """Set the given flag(s) without changing others."""
   72:         self.set_flags(''.join(set(self.get_flags()) | set(flag)))
       
    1:     def remove_flag(self, flag):
               """Unset the given string flag(s) without changing others."""
    2:         if 'Status' in self or 'X-Status' in self:
    2:             self.set_flags(''.join(set(self.get_flags()) - set(flag)))
       
    1:     def _explain_to(self, message):
               """Copy mbox- or MMDF-specific state to message insofar as possible."""
   58:         if isinstance(message, MaildirMessage):
   16:             flags = set(self.get_flags())
   16:             if 'O' in flags:
    6:                 message.set_subdir('cur')
   16:             if 'F' in flags:
    4:                 message.add_flag('F')
   16:             if 'A' in flags:
    4:                 message.add_flag('R')
   16:             if 'R' in flags:
    4:                 message.add_flag('S')
   16:             if 'D' in flags:
    4:                 message.add_flag('T')
   16:             del message['status']
   16:             del message['x-status']
   16:             maybe_date = ' '.join(self.get_from().split()[-5:])
   16:             try:
   16:                 message.set_date(calendar.timegm(time.strptime(maybe_date,
   16:                                                       '%a %b %d %H:%M:%S %Y')))
>>>>>>             except (ValueError, OverflowError):
>>>>>>                 pass
   42:         elif isinstance(message, _mboxMMDFMessage):
    8:             message.set_flags(self.get_flags())
    8:             message.set_from(self.get_from())
   34:         elif isinstance(message, MHMessage):
   14:             flags = set(self.get_flags())
   14:             if 'R' not in flags:
   10:                 message.add_sequence('unseen')
   14:             if 'A' in flags:
    4:                 message.add_sequence('replied')
   14:             if 'F' in flags:
    4:                 message.add_sequence('flagged')
   14:             del message['status']
   14:             del message['x-status']
   20:         elif isinstance(message, BabylMessage):
   14:             flags = set(self.get_flags())
   14:             if 'R' not in flags:
   10:                 message.add_label('unseen')
   14:             if 'D' in flags:
    4:                 message.add_label('deleted')
   14:             if 'A' in flags:
    4:                 message.add_label('answered')
   14:             del message['status']
   14:             del message['x-status']
    6:         elif isinstance(message, Message):
    4:             pass
               else:
    2:             raise TypeError('Cannot convert to specified type: %s' %
    2:                             type(message))
       
       
    2: class mboxMessage(_mboxMMDFMessage):
    1:     """Message with mbox-specific properties."""
       
       
    2: class MHMessage(Message):
    1:     """Message with MH-specific properties."""
       
    1:     def __init__(self, message=None):
               """Initialize an MHMessage instance."""
  145:         self._sequences = []
  145:         Message.__init__(self, message)
       
    1:     def get_sequences(self):
               """Return a list of sequences that include the message."""
   78:         return self._sequences[:]
       
    1:     def set_sequences(self, sequences):
               """Set the list of sequences that include the message."""
    9:         self._sequences = list(sequences)
       
    1:     def add_sequence(self, sequence):
               """Add sequence to list of sequences including the message."""
   63:         if isinstance(sequence, str):
   63:             if not sequence in self._sequences:
   62:                 self._sequences.append(sequence)
               else:
>>>>>>             raise TypeError('sequence must be a string: %s' % type(sequence))
       
    1:     def remove_sequence(self, sequence):
               """Remove sequence from the list of sequences including the message."""
    2:         try:
    2:             self._sequences.remove(sequence)
    1:         except ValueError:
    1:             pass
       
    1:     def _explain_to(self, message):
               """Copy MH-specific state to message insofar as possible."""
   29:         if isinstance(message, MaildirMessage):
    9:             sequences = set(self.get_sequences())
    9:             if 'unseen' in sequences:
    4:                 message.set_subdir('cur')
                   else:
    5:                 message.set_subdir('cur')
    5:                 message.add_flag('S')
    9:             if 'flagged' in sequences:
    4:                 message.add_flag('F')
    9:             if 'replied' in sequences:
    4:                 message.add_flag('R')
   20:         elif isinstance(message, _mboxMMDFMessage):
   10:             sequences = set(self.get_sequences())
   10:             if 'unseen' not in sequences:
    6:                 message.add_flag('RO')
                   else:
    4:                 message.add_flag('O')
   10:             if 'flagged' in sequences:
    4:                 message.add_flag('F')
   10:             if 'replied' in sequences:
    4:                 message.add_flag('A')
   10:         elif isinstance(message, MHMessage):
    5:             for sequence in self.get_sequences():
    3:                 message.add_sequence(sequence)
    8:         elif isinstance(message, BabylMessage):
    5:             sequences = set(self.get_sequences())
    5:             if 'unseen' in sequences:
    2:                 message.add_label('unseen')
    5:             if 'replied' in sequences:
    2:                 message.add_label('answered')
    3:         elif isinstance(message, Message):
    2:             pass
               else:
    1:             raise TypeError('Cannot convert to specified type: %s' %
    1:                             type(message))
       
       
    2: class BabylMessage(Message):
    1:     """Message with Babyl-specific properties."""
       
    1:     def __init__(self, message=None):
               """Initialize a BabylMessage instance."""
  154:         self._labels = []
  154:         self._visible = Message()
  154:         Message.__init__(self, message)
       
    1:     def get_labels(self):
               """Return a list of labels on the message."""
   88:         return self._labels[:]
       
    1:     def set_labels(self, labels):
               """Set the list of labels on the message."""
    7:         self._labels = list(labels)
       
    1:     def add_label(self, label):
               """Add label to list of labels on the message."""
  102:         if isinstance(label, str):
  102:             if label not in self._labels:
  101:                 self._labels.append(label)
               else:
>>>>>>             raise TypeError('label must be a string: %s' % type(label))
       
    1:     def remove_label(self, label):
               """Remove label from the list of labels on the message."""
    2:         try:
    2:             self._labels.remove(label)
    1:         except ValueError:
    1:             pass
       
    1:     def get_visible(self):
               """Return a Message representation of visible headers."""
   21:         return Message(self._visible)
       
    1:     def set_visible(self, visible):
               """Set the Message representation of visible headers."""
   81:         self._visible = Message(visible)
       
    1:     def update_visible(self):
               """Update and/or sensibly generate a set of visible headers."""
    4:         for header in self._visible.keys():
    2:             if header in self:
    1:                 self._visible.replace_header(header, self[header])
                   else:
    1:                 del self._visible[header]
   14:         for header in ('Date', 'From', 'Reply-To', 'To', 'CC', 'Subject'):
   12:             if header in self and header not in self._visible:
    8:                 self._visible[header] = self[header]
       
    1:     def _explain_to(self, message):
               """Copy Babyl-specific state to message insofar as possible."""
   49:         if isinstance(message, MaildirMessage):
   17:             labels = set(self.get_labels())
   17:             if 'unseen' in labels:
    4:                 message.set_subdir('cur')
                   else:
   13:                 message.set_subdir('cur')
   13:                 message.add_flag('S')
   17:             if 'forwarded' in labels or 'resent' in labels:
    6:                 message.add_flag('P')
   17:             if 'answered' in labels:
    4:                 message.add_flag('R')
   17:             if 'deleted' in labels:
    4:                 message.add_flag('T')
   32:         elif isinstance(message, _mboxMMDFMessage):
   18:             labels = set(self.get_labels())
   18:             if 'unseen' not in labels:
   14:                 message.add_flag('RO')
                   else:
    4:                 message.add_flag('O')
   18:             if 'deleted' in labels:
    4:                 message.add_flag('D')
   18:             if 'answered' in labels:
    4:                 message.add_flag('A')
   14:         elif isinstance(message, MHMessage):
    9:             labels = set(self.get_labels())
    9:             if 'unseen' in labels:
    2:                 message.add_sequence('unseen')
    9:             if 'answered' in labels:
    2:                 message.add_sequence('replied')
    5:         elif isinstance(message, BabylMessage):
    2:             message.set_visible(self.get_visible())
    9:             for label in self.get_labels():
    7:                 message.add_label(label)
    3:         elif isinstance(message, Message):
    2:             pass
               else:
    1:             raise TypeError('Cannot convert to specified type: %s' %
    1:                             type(message))
       
       
    2: class MMDFMessage(_mboxMMDFMessage):
    1:     """Message with MMDF-specific properties."""
       
       
    2: class _ProxyFile:
    1:     """A read-only wrapper of a file."""
       
    1:     def __init__(self, f, pos=None):
               """Initialize a _ProxyFile."""
   45:         self._file = f
   45:         if pos is None:
   23:             self._pos = f.tell()
               else:
   22:             self._pos = pos
       
    1:     def read(self, size=None):
               """Read bytes."""
   36:         return self._read(size, self._file.read)
       
    1:     def readline(self, size=None):
               """Read a line."""
  104:         return self._read(size, self._file.readline)
       
    1:     def readlines(self, sizehint=None):
               """Read multiple lines."""
    8:         result = []
   26:         for line in self:
   22:             result.append(line)
   22:             if sizehint is not None:
   14:                 sizehint -= len(line)
   14:                 if sizehint <= 0:
    4:                     break
    8:         return result
       
    1:     def __iter__(self):
               """Iterate over lines."""
   10:         return iter(self.readline, "")
       
    1:     def tell(self):
               """Return the position."""
  105:         return self._pos
       
    1:     def seek(self, offset, whence=0):
               """Change position."""
   38:         if whence == 1:
   20:             self._file.seek(self._pos)
   38:         self._file.seek(offset, whence)
   38:         self._pos = self._file.tell()
       
    1:     def close(self):
               """Close the file."""
   20:         if hasattr(self, '_file'):
   17:             if hasattr(self._file, 'close'):
   17:                 self._file.close()
   17:             del self._file
       
    1:     def _read(self, size, read_method):
               """Read size bytes using read_method."""
  134:         if size is None:
   70:             size = -1
  134:         self._file.seek(self._pos)
  134:         result = read_method(size)
  134:         self._pos = self._file.tell()
  134:         return result
       
       
    2: class _PartialFile(_ProxyFile):
    1:     """A read-only wrapper of part of a file."""
       
    1:     def __init__(self, f, start=None, stop=None):
               """Initialize a _PartialFile."""
   21:         _ProxyFile.__init__(self, f, start)
   21:         self._start = start
   21:         self._stop = stop
       
    1:     def tell(self):
               """Return the position with respect to start."""
   36:         return _ProxyFile.tell(self) - self._start
       
    1:     def seek(self, offset, whence=0):
               """Change position, possibly with respect to start or stop."""
   19:         if whence == 0:
   17:             self._pos = self._start
   17:             whence = 1
    2:         elif whence == 2:
    1:             self._pos = self._stop
    1:             whence = 1
   19:         _ProxyFile.seek(self, offset, whence)
       
    1:     def _read(self, size, read_method):
               """Read size bytes using read_method, honoring start and stop."""
   62:         remaining = self._stop - self._pos
   62:         if remaining <= 0:
    6:             return ''
   56:         if size is None or size < 0 or size > remaining:
   51:             size = remaining
   56:         return _ProxyFile._read(self, size, read_method)
       
    1:     def close(self):
               # do *not* close the underlying file object for partial files,
               # since it's global to the mailbox object
   12:         if hasattr(self, '_file'):
    9:             del self._file
       
       
    1: def _lock_file(f, dotlock=True):
           """Lock file f using lockf and dot locking."""
   12:     dotlock_done = False
   12:     try:
   12:         if fcntl:
   12:             try:
   12:                 fcntl.lockf(f, fcntl.LOCK_EX | fcntl.LOCK_NB)
    2:             except IOError, e:
    2:                 if e.errno in (errno.EAGAIN, errno.EACCES, errno.EROFS):
    2:                     raise ExternalClashError('lockf: lock unavailable: %s' %
    2:                                              f.name)
                       else:
>>>>>>                     raise
   10:         if dotlock:
   10:             try:
   10:                 pre_lock = _create_temporary(f.name + '.lock')
   10:                 pre_lock.close()
>>>>>>             except IOError, e:
>>>>>>                 if e.errno in (errno.EACCES, errno.EROFS):
>>>>>>                     return  # Without write access, just skip dotlocking.
                       else:
>>>>>>                     raise
   10:             try:
   10:                 if hasattr(os, 'link'):
   10:                     os.link(pre_lock.name, f.name + '.lock')
   10:                     dotlock_done = True
   10:                     os.unlink(pre_lock.name)
                       else:
>>>>>>                     os.rename(pre_lock.name, f.name + '.lock')
>>>>>>                     dotlock_done = True
>>>>>>             except OSError, e:
>>>>>>                 if e.errno == errno.EEXIST or \
>>>>>>                   (os.name == 'os2' and e.errno == errno.EACCES):
>>>>>>                     os.remove(pre_lock.name)
>>>>>>                     raise ExternalClashError('dot lock unavailable: %s' %
>>>>>>                                              f.name)
                       else:
>>>>>>                     raise
    2:     except:
    2:         if fcntl:
    2:             fcntl.lockf(f, fcntl.LOCK_UN)
    2:         if dotlock_done:
>>>>>>             os.remove(f.name + '.lock')
    2:         raise
       
    1: def _unlock_file(f):
           """Unlock file f using lockf and dot locking."""
   10:     if fcntl:
   10:         fcntl.lockf(f, fcntl.LOCK_UN)
   10:     if os.path.exists(f.name + '.lock'):
   10:         os.remove(f.name + '.lock')
       
    1: def _create_carefully(path):
           """Create a file if it doesn't exist and open for reading and writing."""
  405:     fd = os.open(path, os.O_CREAT | os.O_EXCL | os.O_RDWR, 0666)
  405:     try:
  405:         return open(path, 'rb+')
           finally:
  405:         os.close(fd)
       
    1: def _create_temporary(path):
           """Create a temp file based on path and open for reading and writing."""
   56:     return _create_carefully('%s.%s.%s.%s' % (path, int(time.time()),
   56:                                               socket.gethostname(),
   56:                                               os.getpid()))
       
    1: def _sync_flush(f):
           """Ensure changes to file f are physically on disk."""
  491:     f.flush()
  491:     if hasattr(os, 'fsync'):
  491:         os.fsync(f.fileno())
       
    1: def _sync_close(f):
           """Close file f, ensuring all changes are physically on disk."""
  416:     _sync_flush(f)
  416:     f.close()
       
       ## Start: classes from the original module (for backward compatibility).
       
       # Note that the Maildir class, whose name is unchanged, itself offers a next()
       # method for backward compatibility.
       
    2: class _Mailbox:
       
    1:     def __init__(self, fp, factory=rfc822.Message):
    3:         self.fp = fp
    3:         self.seekp = 0
    3:         self.factory = factory
       
    1:     def __iter__(self):
    3:         return iter(self.next, None)
       
    1:     def next(self):
    9:         while 1:
    9:             self.fp.seek(self.seekp)
    9:             try:
    9:                 self._search_start()
    3:             except EOFError:
    3:                 self.seekp = self.fp.tell()
    3:                 return None
    6:             start = self.fp.tell()
    6:             self._search_end()
    6:             self.seekp = stop = self.fp.tell()
    6:             if start != stop:
    6:                 break
    6:         return self.factory(_PartialFile(self.fp, start, stop))
       
       # Recommended to use PortableUnixMailbox instead!
    2: class UnixMailbox(_Mailbox):
       
    1:     def _search_start(self):
    9:         while 1:
    9:             pos = self.fp.tell()
    9:             line = self.fp.readline()
    9:             if not line:
    3:                 raise EOFError
    6:             if line[:5] == 'From ' and self._isrealfromline(line):
    6:                 self.fp.seek(pos)
    6:                 return
       
    1:     def _search_end(self):
    6:         self.fp.readline()      # Throw away header line
    6:         while 1:
   28:             pos = self.fp.tell()
   28:             line = self.fp.readline()
   28:             if not line:
    3:                 return
   25:             if line[:5] == 'From ' and self._isrealfromline(line):
    3:                 self.fp.seek(pos)
    3:                 return
       
           # An overridable mechanism to test for From-line-ness.  You can either
           # specify a different regular expression or define a whole new
           # _isrealfromline() method.  Note that this only gets called for lines
           # starting with the 5 characters "From ".
           #
           # BAW: According to
           #http://home.netscape.com/eng/mozilla/2.0/relnotes/demo/content-length.html
           # the only portable, reliable way to find message delimiters in a BSD (i.e
           # Unix mailbox) style folder is to search for "\n\nFrom .*\n", or at the
           # beginning of the file, "^From .*\n".  While _fromlinepattern below seems
           # like a good idea, in practice, there are too many variations for more
           # strict parsing of the line to be completely accurate.
           #
           # _strict_isrealfromline() is the old version which tries to do stricter
           # parsing of the From_ line.  _portable_isrealfromline() simply returns
           # true, since it's never called if the line doesn't already start with
           # "From ".
           #
           # This algorithm, and the way it interacts with _search_start() and
           # _search_end() may not be completely correct, because it doesn't check
           # that the two characters preceding "From " are \n\n or the beginning of
           # the file.  Fixing this would require a more extensive rewrite than is
           # necessary.  For convenience, we've added a PortableUnixMailbox class
           # which does no checking of the format of the 'From' line.
       
    1:     _fromlinepattern = (r"From \s*[^\s]+\s+\w\w\w\s+\w\w\w\s+\d?\d\s+"
                               r"\d?\d:\d\d(:\d\d)?(\s+[^\s]+)?\s+\d\d\d\d\s*"
                               r"[^\s]*\s*"
                               "$")
    1:     _regexp = None
       
    1:     def _strict_isrealfromline(self, line):
    7:         if not self._regexp:
    1:             import re
    1:             self._regexp = re.compile(self._fromlinepattern)
    7:         return self._regexp.match(line)
       
    1:     def _portable_isrealfromline(self, line):
    2:         return True
       
    1:     _isrealfromline = _strict_isrealfromline
       
       
    2: class PortableUnixMailbox(UnixMailbox):
    1:     _isrealfromline = UnixMailbox._portable_isrealfromline
       
       
    2: class MmdfMailbox(_Mailbox):
       
    1:     def _search_start(self):
>>>>>>         while 1:
>>>>>>             line = self.fp.readline()
>>>>>>             if not line:
>>>>>>                 raise EOFError
>>>>>>             if line[:5] == '\001\001\001\001\n':
>>>>>>                 return
       
    1:     def _search_end(self):
>>>>>>         while 1:
>>>>>>             pos = self.fp.tell()
>>>>>>             line = self.fp.readline()
>>>>>>             if not line:
>>>>>>                 return
>>>>>>             if line == '\001\001\001\001\n':
>>>>>>                 self.fp.seek(pos)
>>>>>>                 return
       
       
    2: class MHMailbox:
       
    1:     def __init__(self, dirname, factory=rfc822.Message):
>>>>>>         import re
>>>>>>         pat = re.compile('^[1-9][0-9]*$')
>>>>>>         self.dirname = dirname
               # the three following lines could be combined into:
               # list = map(long, filter(pat.match, os.listdir(self.dirname)))
>>>>>>         list = os.listdir(self.dirname)
>>>>>>         list = filter(pat.match, list)
>>>>>>         list = map(long, list)
>>>>>>         list.sort()
               # This only works in Python 1.6 or later;
               # before that str() added 'L':
>>>>>>         self.boxes = map(str, list)
>>>>>>         self.boxes.reverse()
>>>>>>         self.factory = factory
       
    1:     def __iter__(self):
>>>>>>         return iter(self.next, None)
       
    1:     def next(self):
>>>>>>         if not self.boxes:
>>>>>>             return None
>>>>>>         fn = self.boxes.pop()
>>>>>>         fp = open(os.path.join(self.dirname, fn))
>>>>>>         msg = self.factory(fp)
>>>>>>         try:
>>>>>>             msg._mh_msgno = fn
>>>>>>         except (AttributeError, TypeError):
>>>>>>             pass
>>>>>>         return msg
       
       
    2: class BabylMailbox(_Mailbox):
       
    1:     def _search_start(self):
>>>>>>         while 1:
>>>>>>             line = self.fp.readline()
>>>>>>             if not line:
>>>>>>                 raise EOFError
>>>>>>             if line == '*** EOOH ***\n':
>>>>>>                 return
       
    1:     def _search_end(self):
>>>>>>         while 1:
>>>>>>             pos = self.fp.tell()
>>>>>>             line = self.fp.readline()
>>>>>>             if not line:
>>>>>>                 return
>>>>>>             if line == '\037\014\n' or line == '\037':
>>>>>>                 self.fp.seek(pos)
>>>>>>                 return
       
       ## End: classes from the original module (for backward compatibility).
       
       
    2: class Error(Exception):
    1:     """Raised for module-specific errors."""
       
    2: class NoSuchMailboxError(Error):
    1:     """The specified mailbox does not exist and won't be created."""
       
    2: class NotEmptyError(Error):
    1:     """The specified mailbox is not empty and deletion was requested."""
       
    2: class ExternalClashError(Error):
    1:     """Another process caused an action to fail."""
       
    2: class FormatError(Error):
    1:     """A file appears to have an invalid format."""
