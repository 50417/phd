       # Copyright (C) 2003 Python Software Foundation
       
    1: import unittest
    1: import shutil
    1: import tempfile
    1: import sys
    1: import stat
    1: import os
    1: import os.path
    1: import errno
    1: import subprocess
    1: from distutils.spawn import find_executable
    1: from shutil import (make_archive,
                           register_archive_format, unregister_archive_format,
                           get_archive_formats)
    1: import tarfile
    1: import warnings
       
    1: from test import test_support as support
    1: from test.test_support import TESTFN, check_warnings, captured_stdout
       
    1: TESTFN2 = TESTFN + "2"
       
    1: try:
    1:     import grp
    1:     import pwd
    1:     UID_GID_SUPPORT = True
>>>>>> except ImportError:
>>>>>>     UID_GID_SUPPORT = False
       
    1: try:
    1:     import zlib
>>>>>> except ImportError:
>>>>>>     zlib = None
       
    1: try:
    1:     import zipfile
    1:     import zlib
    1:     ZIP_SUPPORT = True
>>>>>> except ImportError:
>>>>>>     ZIP_SUPPORT = find_executable('zip')
       
    2: class TestShutil(unittest.TestCase):
       
    1:     def setUp(self):
   22:         super(TestShutil, self).setUp()
   22:         self.tempdirs = []
       
    1:     def tearDown(self):
   22:         super(TestShutil, self).tearDown()
   41:         while self.tempdirs:
   19:             d = self.tempdirs.pop()
   19:             shutil.rmtree(d, os.name in ('nt', 'cygwin'))
       
    1:     def write_file(self, path, content='xxx'):
               """Writes a file in the given path.
       
       
               path can be a string or a sequence.
               """
   29:         if isinstance(path, (list, tuple)):
   27:             path = os.path.join(*path)
   29:         f = open(path, 'w')
   29:         try:
   29:             f.write(content)
               finally:
   29:             f.close()
       
    1:     def mkdtemp(self):
               """Create a temporary directory that will be cleaned up.
       
               Returns the path of the directory.
               """
   19:         d = tempfile.mkdtemp()
   19:         self.tempdirs.append(d)
   19:         return d
    1:     def test_rmtree_errors(self):
               # filename is guaranteed not to exist
    1:         filename = tempfile.mktemp()
    1:         self.assertRaises(OSError, shutil.rmtree, filename)
       
    1:     @unittest.skipUnless(hasattr(os, 'chmod'), 'requires os.chmod()')
    1:     @unittest.skipIf(sys.platform[:6] == 'cygwin',
    1:                      "This test can't be run on Cygwin (issue #1071513).")
    1:     @unittest.skipIf(hasattr(os, 'geteuid') and os.geteuid() == 0,
    1:                      "This test can't be run reliably as root (issue #1076467).")
           def test_on_error(self):
    1:         self.errorState = 0
    1:         os.mkdir(TESTFN)
    1:         self.childpath = os.path.join(TESTFN, 'a')
    1:         f = open(self.childpath, 'w')
    1:         f.close()
    1:         old_dir_mode = os.stat(TESTFN).st_mode
    1:         old_child_mode = os.stat(self.childpath).st_mode
               # Make unwritable.
    1:         os.chmod(self.childpath, stat.S_IREAD)
    1:         os.chmod(TESTFN, stat.S_IREAD)
       
    1:         shutil.rmtree(TESTFN, onerror=self.check_args_to_onerror)
               # Test whether onerror has actually been called.
    1:         self.assertEqual(self.errorState, 2,
    1:                             "Expected call to onerror function did not happen.")
       
               # Make writable again.
    1:         os.chmod(TESTFN, old_dir_mode)
    1:         os.chmod(self.childpath, old_child_mode)
       
               # Clean up.
    1:         shutil.rmtree(TESTFN)
       
    1:     def check_args_to_onerror(self, func, arg, exc):
               # test_rmtree_errors deliberately runs rmtree
               # on a directory that is chmod 400, which will fail.
               # This function is run when shutil.rmtree fails.
               # 99.9% of the time it initially fails to remove
               # a file in the directory, so the first time through
               # func is os.remove.
               # However, some Linux machines running ZFS on
               # FUSE experienced a failure earlier in the process
               # at os.listdir.  The first failure may legally
               # be either.
    2:         if self.errorState == 0:
    1:             if func is os.remove:
    1:                 self.assertEqual(arg, self.childpath)
                   else:
>>>>>>                 self.assertIs(func, os.listdir,
>>>>>>                               "func must be either os.remove or os.listdir")
>>>>>>                 self.assertEqual(arg, TESTFN)
    1:             self.assertTrue(issubclass(exc[0], OSError))
    1:             self.errorState = 1
               else:
    1:             self.assertEqual(func, os.rmdir)
    1:             self.assertEqual(arg, TESTFN)
    1:             self.assertTrue(issubclass(exc[0], OSError))
    1:             self.errorState = 2
       
    1:     def test_rmtree_dont_delete_file(self):
               # When called on a file instead of a directory, don't delete it.
    1:         handle, path = tempfile.mkstemp()
    1:         os.fdopen(handle).close()
    1:         self.assertRaises(OSError, shutil.rmtree, path)
    1:         os.remove(path)
       
    1:     def test_copytree_simple(self):
    1:         def write_data(path, data):
    2:             f = open(path, "w")
    2:             f.write(data)
    2:             f.close()
       
    1:         def read_data(path):
    2:             f = open(path)
    2:             data = f.read()
    2:             f.close()
    2:             return data
       
    1:         src_dir = tempfile.mkdtemp()
    1:         dst_dir = os.path.join(tempfile.mkdtemp(), 'destination')
       
    1:         write_data(os.path.join(src_dir, 'test.txt'), '123')
       
    1:         os.mkdir(os.path.join(src_dir, 'test_dir'))
    1:         write_data(os.path.join(src_dir, 'test_dir', 'test.txt'), '456')
       
    1:         try:
    1:             shutil.copytree(src_dir, dst_dir)
    1:             self.assertTrue(os.path.isfile(os.path.join(dst_dir, 'test.txt')))
    1:             self.assertTrue(os.path.isdir(os.path.join(dst_dir, 'test_dir')))
    1:             self.assertTrue(os.path.isfile(os.path.join(dst_dir, 'test_dir',
    1:                                                         'test.txt')))
    1:             actual = read_data(os.path.join(dst_dir, 'test.txt'))
    1:             self.assertEqual(actual, '123')
    1:             actual = read_data(os.path.join(dst_dir, 'test_dir', 'test.txt'))
    1:             self.assertEqual(actual, '456')
               finally:
    1:             for path in (
    1:                     os.path.join(src_dir, 'test.txt'),
    1:                     os.path.join(dst_dir, 'test.txt'),
    1:                     os.path.join(src_dir, 'test_dir', 'test.txt'),
    5:                     os.path.join(dst_dir, 'test_dir', 'test.txt'),
                       ):
    4:                 if os.path.exists(path):
    4:                     os.remove(path)
    1:             for path in (src_dir,
    3:                     os.path.dirname(dst_dir)
                       ):
    2:                 if os.path.exists(path):
    2:                     shutil.rmtree(path)
       
    1:     def test_copytree_with_exclude(self):
       
    1:         def write_data(path, data):
    6:             f = open(path, "w")
    6:             f.write(data)
    6:             f.close()
       
    1:         def read_data(path):
>>>>>>             f = open(path)
>>>>>>             data = f.read()
>>>>>>             f.close()
>>>>>>             return data
       
               # creating data
    1:         join = os.path.join
    1:         exists = os.path.exists
    1:         src_dir = tempfile.mkdtemp()
    1:         try:
    1:             dst_dir = join(tempfile.mkdtemp(), 'destination')
    1:             write_data(join(src_dir, 'test.txt'), '123')
    1:             write_data(join(src_dir, 'test.tmp'), '123')
    1:             os.mkdir(join(src_dir, 'test_dir'))
    1:             write_data(join(src_dir, 'test_dir', 'test.txt'), '456')
    1:             os.mkdir(join(src_dir, 'test_dir2'))
    1:             write_data(join(src_dir, 'test_dir2', 'test.txt'), '456')
    1:             os.mkdir(join(src_dir, 'test_dir2', 'subdir'))
    1:             os.mkdir(join(src_dir, 'test_dir2', 'subdir2'))
    1:             write_data(join(src_dir, 'test_dir2', 'subdir', 'test.txt'), '456')
    1:             write_data(join(src_dir, 'test_dir2', 'subdir2', 'test.py'), '456')
       
       
                   # testing glob-like patterns
    1:             try:
    1:                 patterns = shutil.ignore_patterns('*.tmp', 'test_dir2')
    1:                 shutil.copytree(src_dir, dst_dir, ignore=patterns)
                       # checking the result: some elements should not be copied
    1:                 self.assertTrue(exists(join(dst_dir, 'test.txt')))
    1:                 self.assertTrue(not exists(join(dst_dir, 'test.tmp')))
    1:                 self.assertTrue(not exists(join(dst_dir, 'test_dir2')))
                   finally:
    1:                 if os.path.exists(dst_dir):
    1:                     shutil.rmtree(dst_dir)
    1:             try:
    1:                 patterns = shutil.ignore_patterns('*.tmp', 'subdir*')
    1:                 shutil.copytree(src_dir, dst_dir, ignore=patterns)
                       # checking the result: some elements should not be copied
    1:                 self.assertTrue(not exists(join(dst_dir, 'test.tmp')))
    1:                 self.assertTrue(not exists(join(dst_dir, 'test_dir2', 'subdir2')))
    1:                 self.assertTrue(not exists(join(dst_dir, 'test_dir2', 'subdir')))
                   finally:
    1:                 if os.path.exists(dst_dir):
    1:                     shutil.rmtree(dst_dir)
       
                   # testing callable-style
    1:             try:
    1:                 def _filter(src, names):
    1:                     res = []
    5:                     for name in names:
    4:                         path = os.path.join(src, name)
       
    4:                         if (os.path.isdir(path) and
    2:                             path.split()[-1] == 'subdir'):
>>>>>>                             res.append(name)
    4:                         elif os.path.splitext(path)[-1] in ('.py'):
    2:                             res.append(name)
    1:                     return res
       
    1:                 shutil.copytree(src_dir, dst_dir, ignore=_filter)
       
                       # checking the result: some elements should not be copied
    1:                 self.assertTrue(not exists(join(dst_dir, 'test_dir2', 'subdir2',
    1:                                         'test.py')))
    1:                 self.assertTrue(not exists(join(dst_dir, 'test_dir2', 'subdir')))
       
                   finally:
    1:                 if os.path.exists(dst_dir):
    1:                     shutil.rmtree(dst_dir)
               finally:
    1:             shutil.rmtree(src_dir)
    1:             shutil.rmtree(os.path.dirname(dst_dir))
       
    1:     if hasattr(os, "symlink"):
    1:         def test_dont_copy_file_onto_link_to_itself(self):
                   # bug 851123.
    1:             os.mkdir(TESTFN)
    1:             src = os.path.join(TESTFN, 'cheese')
    1:             dst = os.path.join(TESTFN, 'shop')
    1:             try:
    1:                 f = open(src, 'w')
    1:                 f.write('cheddar')
    1:                 f.close()
       
    1:                 os.link(src, dst)
    1:                 self.assertRaises(shutil.Error, shutil.copyfile, src, dst)
    1:                 with open(src, 'r') as f:
    1:                     self.assertEqual(f.read(), 'cheddar')
    1:                 os.remove(dst)
       
                       # Using `src` here would mean we end up with a symlink pointing
                       # to TESTFN/TESTFN/cheese, while it should point at
                       # TESTFN/cheese.
    1:                 os.symlink('cheese', dst)
    1:                 self.assertRaises(shutil.Error, shutil.copyfile, src, dst)
    1:                 with open(src, 'r') as f:
    1:                     self.assertEqual(f.read(), 'cheddar')
    1:                 os.remove(dst)
                   finally:
    1:                 try:
    1:                     shutil.rmtree(TESTFN)
>>>>>>                 except OSError:
>>>>>>                     pass
       
    1:         def test_rmtree_on_symlink(self):
                   # bug 1669.
    1:             os.mkdir(TESTFN)
    1:             try:
    1:                 src = os.path.join(TESTFN, 'cheese')
    1:                 dst = os.path.join(TESTFN, 'shop')
    1:                 os.mkdir(src)
    1:                 os.symlink(src, dst)
    1:                 self.assertRaises(OSError, shutil.rmtree, dst)
                   finally:
    1:                 shutil.rmtree(TESTFN, ignore_errors=True)
       
           # Issue #3002: copyfile and copytree block indefinitely on named pipes
    1:     @unittest.skipUnless(hasattr(os, "mkfifo"), 'requires os.mkfifo()')
           def test_copyfile_named_pipe(self):
    1:         os.mkfifo(TESTFN)
    1:         try:
    1:             self.assertRaises(shutil.SpecialFileError,
    1:                               shutil.copyfile, TESTFN, TESTFN2)
    1:             self.assertRaises(shutil.SpecialFileError,
    1:                               shutil.copyfile, __file__, TESTFN)
               finally:
    1:             os.remove(TESTFN)
       
    1:     @unittest.skipUnless(hasattr(os, "mkfifo"), 'requires os.mkfifo()')
           def test_copytree_named_pipe(self):
    1:         os.mkdir(TESTFN)
    1:         try:
    1:             subdir = os.path.join(TESTFN, "subdir")
    1:             os.mkdir(subdir)
    1:             pipe = os.path.join(subdir, "mypipe")
    1:             os.mkfifo(pipe)
    1:             try:
    1:                 shutil.copytree(TESTFN, TESTFN2)
    1:             except shutil.Error as e:
    1:                 errors = e.args[0]
    1:                 self.assertEqual(len(errors), 1)
    1:                 src, dst, error_msg = errors[0]
    1:                 self.assertEqual("`%s` is a named pipe" % pipe, error_msg)
                   else:
>>>>>>                 self.fail("shutil.Error should have been raised")
               finally:
    1:             shutil.rmtree(TESTFN, ignore_errors=True)
    1:             shutil.rmtree(TESTFN2, ignore_errors=True)
       
    1:     @unittest.skipUnless(hasattr(os, 'chflags') and
    1:                          hasattr(errno, 'EOPNOTSUPP') and
    1:                          hasattr(errno, 'ENOTSUP'),
    1:                          "requires os.chflags, EOPNOTSUPP & ENOTSUP")
           def test_copystat_handles_harmless_chflags_errors(self):
    1:         tmpdir = self.mkdtemp()
    1:         file1 = os.path.join(tmpdir, 'file1')
    1:         file2 = os.path.join(tmpdir, 'file2')
    1:         self.write_file(file1, 'xxx')
    1:         self.write_file(file2, 'xxx')
       
    1:         def make_chflags_raiser(err):
    3:             ex = OSError()
       
    3:             def _chflags_raiser(path, flags):
    3:                 ex.errno = err
    3:                 raise ex
    3:             return _chflags_raiser
    1:         old_chflags = os.chflags
    1:         try:
    3:             for err in errno.EOPNOTSUPP, errno.ENOTSUP:
    2:                 os.chflags = make_chflags_raiser(err)
    2:                 shutil.copystat(file1, file2)
                   # assert others errors break it
    1:             os.chflags = make_chflags_raiser(errno.EOPNOTSUPP + errno.ENOTSUP)
    1:             self.assertRaises(OSError, shutil.copystat, file1, file2)
               finally:
    1:             os.chflags = old_chflags
       
    1:     @unittest.skipUnless(zlib, "requires zlib")
           def test_make_tarball(self):
               # creating something to tar
    1:         root_dir, base_dir = self._create_files('')
       
    1:         tmpdir2 = self.mkdtemp()
               # force shutil to create the directory
    1:         os.rmdir(tmpdir2)
               # working with relative paths
    1:         work_dir = os.path.dirname(tmpdir2)
    1:         rel_base_name = os.path.join(os.path.basename(tmpdir2), 'archive')
       
    1:         with support.change_cwd(work_dir):
    1:             base_name = os.path.abspath(rel_base_name)
    1:             tarball = make_archive(rel_base_name, 'gztar', root_dir, '.')
       
               # check if the compressed tarball was created
    1:         self.assertEqual(tarball, base_name + '.tar.gz')
    1:         self.assertTrue(os.path.isfile(tarball))
    1:         self.assertTrue(tarfile.is_tarfile(tarball))
    1:         with tarfile.open(tarball, 'r:gz') as tf:
    1:             self.assertEqual(sorted(tf.getnames()),
    1:                              ['.', './file1', './file2',
    1:                               './sub', './sub/file3', './sub2'])
       
               # trying an uncompressed one
    1:         with support.change_cwd(work_dir):
    1:             tarball = make_archive(rel_base_name, 'tar', root_dir, '.')
    1:         self.assertEqual(tarball, base_name + '.tar')
    1:         self.assertTrue(os.path.isfile(tarball))
    1:         self.assertTrue(tarfile.is_tarfile(tarball))
    1:         with tarfile.open(tarball, 'r') as tf:
    1:             self.assertEqual(sorted(tf.getnames()),
    1:                              ['.', './file1', './file2',
    1:                               './sub', './sub/file3', './sub2'])
       
    1:     def _tarinfo(self, path):
    2:         with tarfile.open(path) as tar:
    2:             names = tar.getnames()
    2:             names.sort()
    2:             return tuple(names)
       
    1:     def _create_files(self, base_dir='dist'):
               # creating something to tar
    7:         root_dir = self.mkdtemp()
    7:         dist = os.path.join(root_dir, base_dir)
    7:         if not os.path.isdir(dist):
    6:             os.makedirs(dist)
    7:         self.write_file((dist, 'file1'), 'xxx')
    7:         self.write_file((dist, 'file2'), 'xxx')
    7:         os.mkdir(os.path.join(dist, 'sub'))
    7:         self.write_file((dist, 'sub', 'file3'), 'xxx')
    7:         os.mkdir(os.path.join(dist, 'sub2'))
    7:         if base_dir:
    6:             self.write_file((root_dir, 'outer'), 'xxx')
    7:         return root_dir, base_dir
       
    1:     @unittest.skipUnless(zlib, "Requires zlib")
    1:     @unittest.skipUnless(find_executable('tar'),
    1:                          'Need the tar command to run')
           def test_tarfile_vs_tar(self):
    1:         root_dir, base_dir = self._create_files()
    1:         base_name = os.path.join(self.mkdtemp(), 'archive')
    1:         tarball = make_archive(base_name, 'gztar', root_dir, base_dir)
       
               # check if the compressed tarball was created
    1:         self.assertEqual(tarball, base_name + '.tar.gz')
    1:         self.assertTrue(os.path.isfile(tarball))
       
               # now create another tarball using `tar`
    1:         tarball2 = os.path.join(root_dir, 'archive2.tar')
    1:         tar_cmd = ['tar', '-cf', 'archive2.tar', base_dir]
    1:         subprocess.check_call(tar_cmd, cwd=root_dir)
       
    1:         self.assertTrue(os.path.isfile(tarball2))
               # let's compare both tarballs
    1:         self.assertEqual(self._tarinfo(tarball), self._tarinfo(tarball2))
       
               # trying an uncompressed one
    1:         tarball = make_archive(base_name, 'tar', root_dir, base_dir)
    1:         self.assertEqual(tarball, base_name + '.tar')
    1:         self.assertTrue(os.path.isfile(tarball))
       
               # now for a dry_run
    1:         tarball = make_archive(base_name, 'tar', root_dir, base_dir,
    1:                                dry_run=True)
    1:         self.assertEqual(tarball, base_name + '.tar')
    1:         self.assertTrue(os.path.isfile(tarball))
       
    1:     @unittest.skipUnless(ZIP_SUPPORT, 'Need zip support to run')
           def test_make_zipfile(self):
               # creating something to zip
    1:         root_dir, base_dir = self._create_files()
       
    1:         tmpdir2 = self.mkdtemp()
               # force shutil to create the directory
    1:         os.rmdir(tmpdir2)
               # working with relative paths
    1:         work_dir = os.path.dirname(tmpdir2)
    1:         rel_base_name = os.path.join(os.path.basename(tmpdir2), 'archive')
       
    1:         with support.change_cwd(work_dir):
    1:             base_name = os.path.abspath(rel_base_name)
    1:             res = make_archive(rel_base_name, 'zip', root_dir)
       
    1:         self.assertEqual(res, base_name + '.zip')
    1:         self.assertTrue(os.path.isfile(res))
    1:         self.assertTrue(zipfile.is_zipfile(res))
    1:         with zipfile.ZipFile(res) as zf:
    1:             self.assertEqual(sorted(zf.namelist()),
    1:                     ['dist/', 'dist/file1', 'dist/file2',
    1:                      'dist/sub/', 'dist/sub/file3', 'dist/sub2/',
    1:                      'outer'])
    1:         support.unlink(res)
       
    1:         with support.change_cwd(work_dir):
    1:             base_name = os.path.abspath(rel_base_name)
    1:             res = make_archive(rel_base_name, 'zip', root_dir, base_dir)
       
    1:         self.assertEqual(res, base_name + '.zip')
    1:         self.assertTrue(os.path.isfile(res))
    1:         self.assertTrue(zipfile.is_zipfile(res))
    1:         with zipfile.ZipFile(res) as zf:
    1:             self.assertEqual(sorted(zf.namelist()),
    1:                     ['dist/', 'dist/file1', 'dist/file2',
    1:                      'dist/sub/', 'dist/sub/file3', 'dist/sub2/'])
       
    1:     @unittest.skipUnless(ZIP_SUPPORT, 'Need zip support to run')
    1:     @unittest.skipUnless(find_executable('zip'),
    1:                          'Need the zip command to run')
           def test_zipfile_vs_zip(self):
    1:         root_dir, base_dir = self._create_files()
    1:         base_name = os.path.join(self.mkdtemp(), 'archive')
    1:         archive = make_archive(base_name, 'zip', root_dir, base_dir)
       
               # check if ZIP file  was created
    1:         self.assertEqual(archive, base_name + '.zip')
    1:         self.assertTrue(os.path.isfile(archive))
       
               # now create another ZIP file using `zip`
    1:         archive2 = os.path.join(root_dir, 'archive2.zip')
    1:         zip_cmd = ['zip', '-q', '-r', 'archive2.zip', base_dir]
    1:         subprocess.check_call(zip_cmd, cwd=root_dir)
       
    1:         self.assertTrue(os.path.isfile(archive2))
               # let's compare both ZIP files
    1:         with zipfile.ZipFile(archive) as zf:
    1:             names = zf.namelist()
    1:         with zipfile.ZipFile(archive2) as zf:
    1:             names2 = zf.namelist()
    1:         self.assertEqual(sorted(names), sorted(names2))
       
    1:     @unittest.skipUnless(ZIP_SUPPORT, 'Need zip support to run')
    1:     @unittest.skipUnless(find_executable('unzip'),
    1:                          'Need the unzip command to run')
           def test_unzip_zipfile(self):
    1:         root_dir, base_dir = self._create_files()
    1:         base_name = os.path.join(self.mkdtemp(), 'archive')
    1:         archive = make_archive(base_name, 'zip', root_dir, base_dir)
       
               # check if ZIP file  was created
    1:         self.assertEqual(archive, base_name + '.zip')
    1:         self.assertTrue(os.path.isfile(archive))
       
               # now check the ZIP file using `unzip -t`
    1:         zip_cmd = ['unzip', '-t', archive]
    1:         with support.change_cwd(root_dir):
    1:             try:
    1:                 subprocess.check_output(zip_cmd, stderr=subprocess.STDOUT)
>>>>>>             except subprocess.CalledProcessError as exc:
>>>>>>                 details = exc.output
>>>>>>                 msg = "{}\n\n**Unzip Output**\n{}"
>>>>>>                 self.fail(msg.format(exc, details))
       
    1:     def test_make_archive(self):
    1:         tmpdir = self.mkdtemp()
    1:         base_name = os.path.join(tmpdir, 'archive')
    1:         self.assertRaises(ValueError, make_archive, base_name, 'xxx')
       
    1:     @unittest.skipUnless(zlib, "Requires zlib")
           def test_make_archive_owner_group(self):
               # testing make_archive with owner and group, with various combinations
               # this works even if there's not gid/uid support
    1:         if UID_GID_SUPPORT:
    1:             group = grp.getgrgid(0)[0]
    1:             owner = pwd.getpwuid(0)[0]
               else:
>>>>>>             group = owner = 'root'
       
    1:         root_dir, base_dir = self._create_files()
    1:         base_name = os.path.join(self.mkdtemp(), 'archive')
    1:         res = make_archive(base_name, 'zip', root_dir, base_dir, owner=owner,
    1:                            group=group)
    1:         self.assertTrue(os.path.isfile(res))
       
    1:         res = make_archive(base_name, 'zip', root_dir, base_dir)
    1:         self.assertTrue(os.path.isfile(res))
       
    1:         res = make_archive(base_name, 'tar', root_dir, base_dir,
    1:                            owner=owner, group=group)
    1:         self.assertTrue(os.path.isfile(res))
       
    1:         res = make_archive(base_name, 'tar', root_dir, base_dir,
    1:                            owner='kjhkjhkjg', group='oihohoh')
    1:         self.assertTrue(os.path.isfile(res))
       
    1:     @unittest.skipUnless(zlib, "Requires zlib")
    1:     @unittest.skipUnless(UID_GID_SUPPORT, "Requires grp and pwd support")
           def test_tarfile_root_owner(self):
    1:         root_dir, base_dir = self._create_files()
    1:         base_name = os.path.join(self.mkdtemp(), 'archive')
    1:         group = grp.getgrgid(0)[0]
    1:         owner = pwd.getpwuid(0)[0]
    1:         with support.change_cwd(root_dir):
    1:             archive_name = make_archive(base_name, 'gztar', root_dir, 'dist',
    1:                                         owner=owner, group=group)
       
               # check if the compressed tarball was created
    1:         self.assertTrue(os.path.isfile(archive_name))
       
               # now checks the rights
    1:         archive = tarfile.open(archive_name)
    1:         try:
    7:             for member in archive.getmembers():
    6:                 self.assertEqual(member.uid, 0)
    6:                 self.assertEqual(member.gid, 0)
               finally:
    1:             archive.close()
       
    1:     def test_make_archive_cwd(self):
    1:         current_dir = os.getcwd()
    1:         def _breaks(*args, **kw):
    1:             raise RuntimeError()
       
    1:         register_archive_format('xxx', _breaks, [], 'xxx file')
    1:         try:
    1:             try:
    1:                 make_archive('xxx', 'xxx', root_dir=self.mkdtemp())
    1:             except Exception:
    1:                 pass
    1:             self.assertEqual(os.getcwd(), current_dir)
               finally:
    1:             unregister_archive_format('xxx')
       
    1:     def test_make_tarfile_in_curdir(self):
               # Issue #21280
    1:         root_dir = self.mkdtemp()
    1:         saved_dir = os.getcwd()
    1:         try:
    1:             os.chdir(root_dir)
    1:             self.assertEqual(make_archive('test', 'tar'), 'test.tar')
    1:             self.assertTrue(os.path.isfile('test.tar'))
               finally:
    1:             os.chdir(saved_dir)
       
    1:     @unittest.skipUnless(zlib, "Requires zlib")
           def test_make_zipfile_in_curdir(self):
               # Issue #21280
    1:         root_dir = self.mkdtemp()
    1:         saved_dir = os.getcwd()
    1:         try:
    1:             os.chdir(root_dir)
    1:             self.assertEqual(make_archive('test', 'zip'), 'test.zip')
    1:             self.assertTrue(os.path.isfile('test.zip'))
               finally:
    1:             os.chdir(saved_dir)
       
    1:     def test_register_archive_format(self):
       
    1:         self.assertRaises(TypeError, register_archive_format, 'xxx', 1)
    1:         self.assertRaises(TypeError, register_archive_format, 'xxx', lambda: x,
    1:                           1)
    1:         self.assertRaises(TypeError, register_archive_format, 'xxx', lambda: x,
    1:                           [(1, 2), (1, 2, 3)])
       
    1:         register_archive_format('xxx', lambda: x, [(1, 2)], 'xxx file')
    6:         formats = [name for name, params in get_archive_formats()]
    1:         self.assertIn('xxx', formats)
       
    1:         unregister_archive_format('xxx')
    5:         formats = [name for name, params in get_archive_formats()]
    1:         self.assertNotIn('xxx', formats)
       
       
    2: class TestMove(unittest.TestCase):
       
    1:     def setUp(self):
   13:         filename = "foo"
   13:         self.src_dir = tempfile.mkdtemp()
   13:         self.dst_dir = tempfile.mkdtemp()
   13:         self.src_file = os.path.join(self.src_dir, filename)
   13:         self.dst_file = os.path.join(self.dst_dir, filename)
               # Try to create a dir in the current directory, hoping that it is
               # not located on the same filesystem as the system tmp dir.
   13:         try:
   13:             self.dir_other_fs = tempfile.mkdtemp(
   13:                 dir=os.path.dirname(__file__))
   13:             self.file_other_fs = os.path.join(self.dir_other_fs,
   13:                 filename)
>>>>>>         except OSError:
>>>>>>             self.dir_other_fs = None
   13:         with open(self.src_file, "wb") as f:
   13:             f.write("spam")
       
    1:     def tearDown(self):
   52:         for d in (self.src_dir, self.dst_dir, self.dir_other_fs):
   39:             try:
   39:                 if d:
   39:                     shutil.rmtree(d)
    5:             except:
    5:                 pass
       
    1:     def _check_move_file(self, src, dst, real_dst):
    4:         with open(src, "rb") as f:
    4:             contents = f.read()
    4:         shutil.move(src, dst)
    4:         with open(real_dst, "rb") as f:
    4:             self.assertEqual(contents, f.read())
    4:         self.assertFalse(os.path.exists(src))
       
    1:     def _check_move_dir(self, src, dst, real_dst):
    5:         contents = sorted(os.listdir(src))
    5:         shutil.move(src, dst)
    5:         self.assertEqual(contents, sorted(os.listdir(real_dst)))
    5:         self.assertFalse(os.path.exists(src))
       
    1:     def test_move_file(self):
               # Move a file to another location on the same filesystem.
    1:         self._check_move_file(self.src_file, self.dst_file, self.dst_file)
       
    1:     def test_move_file_to_dir(self):
               # Move a file inside an existing dir on the same filesystem.
    1:         self._check_move_file(self.src_file, self.dst_dir, self.dst_file)
       
    1:     def test_move_file_other_fs(self):
               # Move a file to an existing dir on another filesystem.
    1:         if not self.dir_other_fs:
>>>>>>             self.skipTest('dir on other filesystem not available')
    1:         self._check_move_file(self.src_file, self.file_other_fs,
    1:             self.file_other_fs)
       
    1:     def test_move_file_to_dir_other_fs(self):
               # Move a file to another location on another filesystem.
    1:         if not self.dir_other_fs:
>>>>>>             self.skipTest('dir on other filesystem not available')
    1:         self._check_move_file(self.src_file, self.dir_other_fs,
    1:             self.file_other_fs)
       
    1:     def test_move_dir(self):
               # Move a dir to another location on the same filesystem.
    1:         dst_dir = tempfile.mktemp()
    1:         try:
    1:             self._check_move_dir(self.src_dir, dst_dir, dst_dir)
               finally:
    1:             try:
    1:                 shutil.rmtree(dst_dir)
>>>>>>             except:
>>>>>>                 pass
       
    1:     def test_move_dir_other_fs(self):
               # Move a dir to another location on another filesystem.
    1:         if not self.dir_other_fs:
>>>>>>             self.skipTest('dir on other filesystem not available')
    1:         dst_dir = tempfile.mktemp(dir=self.dir_other_fs)
    1:         try:
    1:             self._check_move_dir(self.src_dir, dst_dir, dst_dir)
               finally:
    1:             try:
    1:                 shutil.rmtree(dst_dir)
>>>>>>             except:
>>>>>>                 pass
       
    1:     def test_move_dir_to_dir(self):
               # Move a dir inside an existing dir on the same filesystem.
    1:         self._check_move_dir(self.src_dir, self.dst_dir,
    1:             os.path.join(self.dst_dir, os.path.basename(self.src_dir)))
       
    1:     def test_move_dir_to_dir_other_fs(self):
               # Move a dir inside an existing dir on another filesystem.
    1:         if not self.dir_other_fs:
>>>>>>             self.skipTest('dir on other filesystem not available')
    1:         self._check_move_dir(self.src_dir, self.dir_other_fs,
    1:             os.path.join(self.dir_other_fs, os.path.basename(self.src_dir)))
       
    1:     def test_move_dir_sep_to_dir(self):
    1:         self._check_move_dir(self.src_dir + os.path.sep, self.dst_dir,
    1:             os.path.join(self.dst_dir, os.path.basename(self.src_dir)))
       
    1:     @unittest.skipUnless(os.path.altsep, 'requires os.path.altsep')
           def test_move_dir_altsep_to_dir(self):
>>>>>>         self._check_move_dir(self.src_dir + os.path.altsep, self.dst_dir,
>>>>>>             os.path.join(self.dst_dir, os.path.basename(self.src_dir)))
       
    1:     def test_existing_file_inside_dest_dir(self):
               # A file with the same name inside the destination dir already exists.
    1:         with open(self.dst_file, "wb"):
    1:             pass
    1:         self.assertRaises(shutil.Error, shutil.move, self.src_file, self.dst_dir)
       
    1:     def test_dont_move_dir_in_itself(self):
               # Moving a dir inside itself raises an Error.
    1:         dst = os.path.join(self.src_dir, "bar")
    1:         self.assertRaises(shutil.Error, shutil.move, self.src_dir, dst)
       
    1:     def test_destinsrc_false_negative(self):
    1:         os.mkdir(TESTFN)
    1:         try:
    2:             for src, dst in [('srcdir', 'srcdir/dest')]:
    1:                 src = os.path.join(TESTFN, src)
    1:                 dst = os.path.join(TESTFN, dst)
    1:                 self.assertTrue(shutil._destinsrc(src, dst),
    1:                              msg='_destinsrc() wrongly concluded that '
    1:                              'dst (%s) is not in src (%s)' % (dst, src))
               finally:
    1:             shutil.rmtree(TESTFN, ignore_errors=True)
       
    1:     def test_destinsrc_false_positive(self):
    1:         os.mkdir(TESTFN)
    1:         try:
    3:             for src, dst in [('srcdir', 'src/dest'), ('srcdir', 'srcdir.new')]:
    2:                 src = os.path.join(TESTFN, src)
    2:                 dst = os.path.join(TESTFN, dst)
    2:                 self.assertFalse(shutil._destinsrc(src, dst),
    2:                             msg='_destinsrc() wrongly concluded that '
    2:                             'dst (%s) is in src (%s)' % (dst, src))
               finally:
    1:             shutil.rmtree(TESTFN, ignore_errors=True)
       
       
    2: class TestCopyFile(unittest.TestCase):
       
    1:     _delete = False
       
    2:     class Faux(object):
    1:         _entered = False
    1:         _exited_with = None
    1:         _raised = False
    1:         def __init__(self, raise_in_exit=False, suppress_at_exit=True):
    5:             self._raise_in_exit = raise_in_exit
    5:             self._suppress_at_exit = suppress_at_exit
    1:         def read(self, *args):
>>>>>>             return ''
    1:         def __enter__(self):
    5:             self._entered = True
    1:         def __exit__(self, exc_type, exc_val, exc_tb):
    5:             self._exited_with = exc_type, exc_val, exc_tb
    5:             if self._raise_in_exit:
    2:                 self._raised = True
    2:                 raise IOError("Cannot close")
    3:             return self._suppress_at_exit
       
    1:     def tearDown(self):
    5:         if self._delete:
    4:             del shutil.open
       
    1:     def _set_shutil_open(self, func):
    4:         shutil.open = func
    4:         self._delete = True
       
    1:     def test_w_source_open_fails(self):
    1:         def _open(filename, mode='r'):
    1:             if filename == 'srcfile':
    1:                 raise IOError('Cannot open "srcfile"')
>>>>>>             assert 0  # shouldn't reach here.
       
    1:         self._set_shutil_open(_open)
       
    1:         self.assertRaises(IOError, shutil.copyfile, 'srcfile', 'destfile')
       
    1:     def test_w_dest_open_fails(self):
       
    1:         srcfile = self.Faux()
       
    1:         def _open(filename, mode='r'):
    2:             if filename == 'srcfile':
    1:                 return srcfile
    1:             if filename == 'destfile':
    1:                 raise IOError('Cannot open "destfile"')
>>>>>>             assert 0  # shouldn't reach here.
       
    1:         self._set_shutil_open(_open)
       
    1:         shutil.copyfile('srcfile', 'destfile')
    1:         self.assertTrue(srcfile._entered)
    1:         self.assertTrue(srcfile._exited_with[0] is IOError)
    1:         self.assertEqual(srcfile._exited_with[1].args,
    1:                          ('Cannot open "destfile"',))
       
    1:     def test_w_dest_close_fails(self):
       
    1:         srcfile = self.Faux()
    1:         destfile = self.Faux(True)
       
    1:         def _open(filename, mode='r'):
    2:             if filename == 'srcfile':
    1:                 return srcfile
    1:             if filename == 'destfile':
    1:                 return destfile
>>>>>>             assert 0  # shouldn't reach here.
       
    1:         self._set_shutil_open(_open)
       
    1:         shutil.copyfile('srcfile', 'destfile')
    1:         self.assertTrue(srcfile._entered)
    1:         self.assertTrue(destfile._entered)
    1:         self.assertTrue(destfile._raised)
    1:         self.assertTrue(srcfile._exited_with[0] is IOError)
    1:         self.assertEqual(srcfile._exited_with[1].args,
    1:                          ('Cannot close',))
       
    1:     def test_w_source_close_fails(self):
       
    1:         srcfile = self.Faux(True)
    1:         destfile = self.Faux()
       
    1:         def _open(filename, mode='r'):
    2:             if filename == 'srcfile':
    1:                 return srcfile
    1:             if filename == 'destfile':
    1:                 return destfile
>>>>>>             assert 0  # shouldn't reach here.
       
    1:         self._set_shutil_open(_open)
       
    1:         self.assertRaises(IOError,
    1:                           shutil.copyfile, 'srcfile', 'destfile')
    1:         self.assertTrue(srcfile._entered)
    1:         self.assertTrue(destfile._entered)
    1:         self.assertFalse(destfile._raised)
    1:         self.assertTrue(srcfile._exited_with[0] is None)
    1:         self.assertTrue(srcfile._raised)
       
    1:     def test_move_dir_caseinsensitive(self):
               # Renames a folder to the same name
               # but a different case.
       
    1:         self.src_dir = tempfile.mkdtemp()
    1:         dst_dir = os.path.join(
    1:                 os.path.dirname(self.src_dir),
    1:                 os.path.basename(self.src_dir).upper())
    1:         self.assertNotEqual(self.src_dir, dst_dir)
       
    1:         try:
    1:             shutil.move(self.src_dir, dst_dir)
    1:             self.assertTrue(os.path.isdir(dst_dir))
               finally:
    1:             if os.path.exists(dst_dir):
    1:                 os.rmdir(dst_dir)
       
       
       
    1: def test_main():
    1:     support.run_unittest(TestShutil, TestMove, TestCopyFile)
       
    1: if __name__ == '__main__':
>>>>>>     test_main()
