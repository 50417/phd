       """An FTP client class and some helper functions.
       
       Based on RFC 959: File Transfer Protocol (FTP), by J. Postel and J. Reynolds
       
       Example:
       
       >>> from ftplib import FTP
       >>> ftp = FTP('ftp.python.org') # connect to host, default port
       >>> ftp.login() # default, i.e.: user anonymous, passwd anonymous@
       '230 Guest login ok, access restrictions apply.'
       >>> ftp.retrlines('LIST') # list directory contents
       total 9
       drwxr-xr-x   8 root     wheel        1024 Jan  3  1994 .
       drwxr-xr-x   8 root     wheel        1024 Jan  3  1994 ..
       drwxr-xr-x   2 root     wheel        1024 Jan  3  1994 bin
       drwxr-xr-x   2 root     wheel        1024 Jan  3  1994 etc
       d-wxrwxr-x   2 ftp      wheel        1024 Sep  5 13:43 incoming
       drwxr-xr-x   2 root     wheel        1024 Nov 17  1993 lib
       drwxr-xr-x   6 1094     wheel        1024 Sep 13 19:07 pub
       drwxr-xr-x   3 root     wheel        1024 Jan  3  1994 usr
       -rw-r--r--   1 root     root          312 Aug  1  1994 welcome.msg
       '226 Transfer complete.'
       >>> ftp.quit()
       '221 Goodbye.'
       >>>
       
       A nice test that reveals some of the network dialogue would be:
       python ftplib.py -d localhost -l -p -l
    2: """
       
       #
       # Changes and improvements suggested by Steve Majewski.
       # Modified by Jack to work on the mac.
       # Modified by Siebren to support docstrings and PASV.
       # Modified by Phil Schwartz to add storbinary and storlines callbacks.
       # Modified by Giampaolo Rodola' to add TLS support.
       #
       
    2: import os
    2: import sys
       
       # Import SOCKS module if it exists, else standard socket module socket
    2: try:
    2:     import SOCKS; socket = SOCKS; del SOCKS # import SOCKS as socket
>>>>>>     from socket import getfqdn; socket.getfqdn = getfqdn; del getfqdn
    2: except ImportError:
    2:     import socket
    2: from socket import _GLOBAL_DEFAULT_TIMEOUT
       
    2: __all__ = ["FTP","Netrc"]
       
       # Magic number from <socket.h>
    2: MSG_OOB = 0x1                           # Process data out of band
       
       
       # The standard FTP server control port
    2: FTP_PORT = 21
       # The sizehint parameter passed to readline() calls
    2: MAXLINE = 8192
       
       
       # Exception raised when an error or invalid response is received
    4: class Error(Exception): pass
    4: class error_reply(Error): pass          # unexpected [123]xx reply
    4: class error_temp(Error): pass           # 4xx errors
    4: class error_perm(Error): pass           # 5xx errors
    4: class error_proto(Error): pass          # response does not begin with [1-5]
       
       
       # All exceptions (hopefully) that may be raised here and that aren't
       # (always) programming errors on our side
    2: all_errors = (Error, IOError, EOFError)
       
       
       # Line terminators (we always output CRLF, but accept any of CRLF, CR, LF)
    2: CRLF = '\r\n'
       
       # The class itself
    4: class FTP:
       
           '''An FTP client class.
       
           To create a connection, call the class using these arguments:
                   host, user, passwd, acct, timeout
       
           The first four arguments are all strings, and have default value ''.
           timeout must be numeric and defaults to None if not passed,
           meaning that no timeout will be set on any ftp socket(s)
           If a timeout is passed, then this is now the default timeout for all ftp
           socket operations for this instance.
       
           Then use self.connect() with optional host and port argument.
       
           To download a file, use ftp.retrlines('RETR ' + filename),
           or ftp.retrbinary() with slightly different arguments.
           To upload a file, use ftp.storlines() or ftp.storbinary(),
           which have an open file as argument (see their definitions
           below for details).
           The download/upload functions first issue appropriate TYPE
           and PORT or PASV commands.
    2: '''
       
    2:     debugging = 0
    2:     host = ''
    2:     port = FTP_PORT
    2:     maxline = MAXLINE
    2:     sock = None
    2:     file = None
    2:     welcome = None
    2:     passiveserver = 1
       
           # Initialization method (called by class instantiation).
           # Initialize host to localhost, port to standard ftp port
           # Optional arguments are host (for connect()),
           # and user, passwd, acct (for login())
    2:     def __init__(self, host='', user='', passwd='', acct='',
    2:                  timeout=_GLOBAL_DEFAULT_TIMEOUT):
   74:         self.timeout = timeout
   74:         if host:
    3:             self.connect(host)
    3:             if user:
>>>>>>                 self.login(user, passwd, acct)
       
    2:     def connect(self, host='', port=0, timeout=-999):
               '''Connect to host.  Arguments are:
                - host: hostname to connect to (string, default previous host)
                - port: port to connect to (integer, default previous port)
               '''
   77:         if host != '':
   77:             self.host = host
   77:         if port > 0:
   71:             self.port = port
   77:         if timeout != -999:
    2:             self.timeout = timeout
   77:         self.sock = socket.create_connection((self.host, self.port), self.timeout)
   76:         self.af = self.sock.family
   76:         self.file = self.sock.makefile('rb')
   76:         self.welcome = self.getresp()
   76:         return self.welcome
       
    2:     def getwelcome(self):
               '''Get the welcome message from the server.
               (this is read and squirreled away by connect())'''
    2:         if self.debugging:
>>>>>>             print '*welcome*', self.sanitize(self.welcome)
    2:         return self.welcome
       
    2:     def set_debuglevel(self, level):
               '''Set the debugging level.
               The required argument level means:
               0: no debugging output (default)
               1: print commands and responses but not body text etc.
               2: also print raw lines read and sent before stripping CR/LF'''
>>>>>>         self.debugging = level
    2:     debug = set_debuglevel
       
    2:     def set_pasv(self, val):
               '''Use passive or active mode for data transfers.
               With a false argument, use the normal PORT mode,
               With a true argument, use the PASV command.'''
    4:         self.passiveserver = val
       
           # Internal: "sanitize" a string for printing
    2:     def sanitize(self, s):
    6:         if s[:5] == 'pass ' or s[:5] == 'PASS ':
    4:             i = len(s)
    4:             while i > 5 and s[i-1] in '\r\n':
>>>>>>                 i = i-1
    4:             s = s[:5] + '*'*(i-5) + s[i:]
    6:         return repr(s)
       
           # Internal: send one line to the server, appending CRLF
    2:     def putline(self, line):
  289:         if '\r' in line or '\n' in line:
    6:             raise ValueError('an illegal newline character should not be contained')
  283:         line = line + CRLF
  283:         if self.debugging > 1: print '*put*', self.sanitize(line)
  283:         self.sock.sendall(line)
       
           # Internal: send one command to the server (through putline())
    2:     def putcmd(self, line):
  289:         if self.debugging: print '*cmd*', self.sanitize(line)
  289:         self.putline(line)
       
           # Internal: return one line from the server, stripping CRLF.
           # Raise EOFError if the connection is closed
    2:     def getline(self):
  390:         line = self.file.readline(self.maxline + 1)
  390:         if len(line) > self.maxline:
    2:             raise Error("got more than %d bytes" % self.maxline)
  388:         if self.debugging > 1:
>>>>>>             print '*get*', self.sanitize(line)
  388:         if not line: raise EOFError
  388:         if line[-2:] == CRLF: line = line[:-2]
    6:         elif line[-1:] in CRLF: line = line[:-1]
  388:         return line
       
           # Internal: get a response from the server, which may possibly
           # consist of multiple lines.  Return a single string with no
           # trailing CRLF.  If the response consists of multiple lines,
           # these are separated by '\n' characters in the string
    2:     def getmultiline(self):
  390:         line = self.getline()
  388:         if line[3:4] == '-':
>>>>>>             code = line[:3]
>>>>>>             while 1:
>>>>>>                 nextline = self.getline()
>>>>>>                 line = line + ('\n' + nextline)
>>>>>>                 if nextline[:3] == code and \
>>>>>>                         nextline[3:4] != '-':
>>>>>>                     break
  388:         return line
       
           # Internal: get a response from the server.
           # Raise various errors if the response indicates an error
    2:     def getresp(self):
  390:         resp = self.getmultiline()
  388:         if self.debugging: print '*resp*', self.sanitize(resp)
  388:         self.lastresp = resp[:3]
  388:         c = resp[:1]
  388:         if c in ('1', '2', '3'):
  378:             return resp
   10:         if c == '4':
    4:             raise error_temp, resp
    6:         if c == '5':
    4:             raise error_perm, resp
    2:         raise error_proto, resp
       
    2:     def voidresp(self):
               """Expect a response beginning with '2'."""
  180:         resp = self.getresp()
  180:         if resp[:1] != '2':
    4:             raise error_reply, resp
  176:         return resp
       
    2:     def abort(self):
               '''Abort a file transfer.  Uses out-of-band data.
               This does not follow the procedure from the RFC to send Telnet
               IP and Synch; that doesn't seem to work with the servers I've
               tried.  Instead, just send the ABOR command as OOB data.'''
>>>>>>         line = 'ABOR' + CRLF
>>>>>>         if self.debugging > 1: print '*put urgent*', self.sanitize(line)
>>>>>>         self.sock.sendall(line, MSG_OOB)
>>>>>>         resp = self.getmultiline()
>>>>>>         if resp[:3] not in ('426', '225', '226'):
>>>>>>             raise error_proto, resp
       
    2:     def sendcmd(self, cmd):
               '''Send a command and return the response.'''
  140:         self.putcmd(cmd)
  134:         return self.getresp()
       
    2:     def voidcmd(self, cmd):
               """Send a command and expect a response beginning with '2'."""
  149:         self.putcmd(cmd)
  149:         return self.voidresp()
       
    2:     def sendport(self, host, port):
               '''Send a PORT command with the current host and the given
               port number.
               '''
    2:         hbytes = host.split('.')
    2:         pbytes = [repr(port//256), repr(port%256)]
    2:         bytes = hbytes + pbytes
    2:         cmd = 'PORT ' + ','.join(bytes)
    2:         return self.voidcmd(cmd)
       
    2:     def sendeprt(self, host, port):
               '''Send an EPRT command with the current host and the given port number.'''
>>>>>>         af = 0
>>>>>>         if self.af == socket.AF_INET:
>>>>>>             af = 1
>>>>>>         if self.af == socket.AF_INET6:
>>>>>>             af = 2
>>>>>>         if af == 0:
>>>>>>             raise error_proto, 'unsupported address family'
>>>>>>         fields = ['', repr(af), host, repr(port), '']
>>>>>>         cmd = 'EPRT ' + '|'.join(fields)
>>>>>>         return self.voidcmd(cmd)
       
    2:     def makeport(self):
               '''Create a new socket and send a PORT command for it.'''
    2:         err = None
    2:         sock = None
    2:         for res in socket.getaddrinfo(None, 0, self.af, socket.SOCK_STREAM, 0, socket.AI_PASSIVE):
    2:             af, socktype, proto, canonname, sa = res
    2:             try:
    2:                 sock = socket.socket(af, socktype, proto)
    2:                 sock.bind(sa)
>>>>>>             except socket.error, err:
>>>>>>                 if sock:
>>>>>>                     sock.close()
>>>>>>                 sock = None
>>>>>>                 continue
    2:             break
    2:         if sock is None:
>>>>>>             if err is not None:
>>>>>>                 raise err
                   else:
>>>>>>                 raise socket.error("getaddrinfo returns an empty list")
    2:         sock.listen(1)
    2:         port = sock.getsockname()[1] # Get proper port
    2:         host = self.sock.getsockname()[0] # Get proper host
    2:         if self.af == socket.AF_INET:
    2:             resp = self.sendport(host, port)
               else:
>>>>>>             resp = self.sendeprt(host, port)
    2:         if self.timeout is not _GLOBAL_DEFAULT_TIMEOUT:
    2:             sock.settimeout(self.timeout)
    2:         return sock
       
    2:     def makepasv(self):
   40:         if self.af == socket.AF_INET:
   40:             host, port = parse227(self.sendcmd('PASV'))
               else:
>>>>>>             host, port = parse229(self.sendcmd('EPSV'), self.sock.getpeername())
   40:         return host, port
       
    2:     def ntransfercmd(self, cmd, rest=None):
               """Initiate a transfer over the data connection.
       
               If the transfer is active, send a port command and the
               transfer command, and accept the connection.  If the server is
               passive, send a pasv command, connect to it, and start the
               transfer command.  Either way, return the socket for the
               connection and the expected size of the transfer.  The
               expected size may be None if it could not be determined.
       
               Optional `rest' argument can be a string that is sent as the
               argument to a REST command.  This is essentially a server
               marker used to tell the server to skip over any data up to the
               given marker.
               """
   38:         size = None
   38:         if self.passiveserver:
   38:             host, port = self.makepasv()
   38:             conn = socket.create_connection((host, port), self.timeout)
   38:             try:
   38:                 if rest is not None:
   10:                     self.sendcmd("REST %s" % rest)
   38:                 resp = self.sendcmd(cmd)
                       # Some servers apparently send a 200 reply to
                       # a LIST or STOR command, before the 150 reply
                       # (and way before the 226 reply). This seems to
                       # be in violation of the protocol (which only allows
                       # 1xx or error messages for LIST), so we just discard
                       # this response.
   38:                 if resp[0] == '2':
>>>>>>                     resp = self.getresp()
   38:                 if resp[0] != '1':
>>>>>>                     raise error_reply, resp
>>>>>>             except:
>>>>>>                 conn.close()
>>>>>>                 raise
               else:
>>>>>>             sock = self.makeport()
>>>>>>             try:
>>>>>>                 if rest is not None:
>>>>>>                     self.sendcmd("REST %s" % rest)
>>>>>>                 resp = self.sendcmd(cmd)
                       # See above.
>>>>>>                 if resp[0] == '2':
>>>>>>                     resp = self.getresp()
>>>>>>                 if resp[0] != '1':
>>>>>>                     raise error_reply, resp
>>>>>>                 conn, sockaddr = sock.accept()
>>>>>>                 if self.timeout is not _GLOBAL_DEFAULT_TIMEOUT:
>>>>>>                     conn.settimeout(self.timeout)
                   finally:
>>>>>>                 sock.close()
   38:         if resp[:3] == '150':
                   # this is conditional in case we received a 125
>>>>>>             size = parse150(resp)
   38:         return conn, size
       
    2:     def transfercmd(self, cmd, rest=None):
               """Like ntransfercmd() but returns only the socket."""
   38:         return self.ntransfercmd(cmd, rest)[0]
       
    2:     def login(self, user = '', passwd = '', acct = ''):
               '''Login, default anonymous.'''
    4:         if not user: user = 'anonymous'
    4:         if not passwd: passwd = ''
    4:         if not acct: acct = ''
    4:         if user == 'anonymous' and passwd in ('', '-'):
                   # If there is no anonymous ftp password specified
                   # then we'll just use anonymous@
                   # We don't send any other thing because:
                   # - We want to remain anonymous
                   # - We want to stop SPAM
                   # - We don't want to let ftp sites to discriminate by the user,
                   #   host or country.
    4:             passwd = passwd + 'anonymous@'
    4:         resp = self.sendcmd('USER ' + user)
    4:         if resp[0] == '3': resp = self.sendcmd('PASS ' + passwd)
    4:         if resp[0] == '3': resp = self.sendcmd('ACCT ' + acct)
    4:         if resp[0] != '2':
>>>>>>             raise error_reply, resp
    4:         return resp
       
    2:     def retrbinary(self, cmd, callback, blocksize=8192, rest=None):
               """Retrieve data in binary mode.  A new port is created for you.
       
               Args:
                 cmd: A RETR command.
                 callback: A single parameter callable to be called on each
                           block of data read.
                 blocksize: The maximum number of bytes to read from the
                            socket at one time.  [default: 8192]
                 rest: Passed to transfercmd().  [default: None]
       
               Returns:
                 The response code.
               """
    4:         self.voidcmd('TYPE I')
    4:         conn = self.transfercmd(cmd, rest)
    4:         try:
    4:             while 1:
   16:                 data = conn.recv(blocksize)
   16:                 if not data:
    4:                     break
   12:                 callback(data)
               finally:
    4:             conn.close()
    4:         return self.voidresp()
       
    2:     def retrlines(self, cmd, callback = None):
               """Retrieve data in line mode.  A new port is created for you.
       
               Args:
                 cmd: A RETR, LIST, NLST, or MLSD command.
                 callback: An optional single parameter callable that is called
                           for each line with the trailing CRLF stripped.
                           [default: print_line()]
       
               Returns:
                 The response code.
               """
    5:         if callback is None: callback = print_line
    5:         resp = self.sendcmd('TYPE A')
    5:         conn = self.transfercmd(cmd)
    5:         fp = None
    5:         try:
    5:             fp = conn.makefile('rb')
    5:             while 1:
 1011:                 line = fp.readline(self.maxline + 1)
 1011:                 if len(line) > self.maxline:
    1:                     raise Error("got more than %d bytes" % self.maxline)
 1010:                 if self.debugging > 2: print '*retr*', repr(line)
 1010:                 if not line:
    4:                     break
 1006:                 if line[-2:] == CRLF:
 1006:                     line = line[:-2]
>>>>>>                 elif line[-1:] == '\n':
>>>>>>                     line = line[:-1]
 1006:                 callback(line)
               finally:
    5:             if fp:
    5:                 fp.close()
    5:             conn.close()
    4:         return self.voidresp()
       
    2:     def storbinary(self, cmd, fp, blocksize=8192, callback=None, rest=None):
               """Store a file in binary mode.  A new port is created for you.
       
               Args:
                 cmd: A STOR command.
                 fp: A file-like object with a read(num_bytes) method.
                 blocksize: The maximum data size to read from fp and send over
                            the connection at once.  [default: 8192]
                 callback: An optional single parameter callable that is called on
                           each block of data after it is sent.  [default: None]
                 rest: Passed to transfercmd().  [default: None]
       
               Returns:
                 The response code.
               """
    4:         self.voidcmd('TYPE I')
    4:         conn = self.transfercmd(cmd, rest)
    4:         try:
    4:             while 1:
   12:                 buf = fp.read(blocksize)
   12:                 if not buf: break
    8:                 conn.sendall(buf)
    8:                 if callback: callback(buf)
               finally:
    4:             conn.close()
    4:         return self.voidresp()
       
    2:     def storlines(self, cmd, fp, callback=None):
               """Store a file in line mode.  A new port is created for you.
       
               Args:
                 cmd: A STOR command.
                 fp: A file-like object with a readline() method.
                 callback: An optional single parameter callable that is called on
                           each line after it is sent.  [default: None]
       
               Returns:
                 The response code.
               """
    3:         self.voidcmd('TYPE A')
    3:         conn = self.transfercmd(cmd)
    3:         try:
    3:             while 1:
 2003:                 buf = fp.readline(self.maxline + 1)
 2003:                 if len(buf) > self.maxline:
    1:                     raise Error("got more than %d bytes" % self.maxline)
 2002:                 if not buf: break
 2000:                 if buf[-2:] != CRLF:
 2000:                     if buf[-1] in CRLF: buf = buf[:-1]
 2000:                     buf = buf + CRLF
 2000:                 conn.sendall(buf)
 2000:                 if callback: callback(buf)
               finally:
    3:             conn.close()
    2:         return self.voidresp()
       
    2:     def acct(self, password):
               '''Send new account name.'''
    2:         cmd = 'ACCT ' + password
    2:         return self.voidcmd(cmd)
       
    2:     def nlst(self, *args):
               '''Return a list of files in a given directory (default the current).'''
    4:         cmd = 'NLST'
    4:         for arg in args:
>>>>>>             cmd = cmd + (' ' + arg)
    4:         files = []
    4:         self.retrlines(cmd, files.append)
    4:         return files
       
    2:     def dir(self, *args):
               '''List a directory in long form.
               By default list current directory to stdout.
               Optional last argument is callback function; all
               non-empty arguments before it are concatenated to the
               LIST command.  (This *should* only be used for a pathname.)'''
    2:         cmd = 'LIST'
    2:         func = None
    2:         if args[-1:] and type(args[-1]) != type(''):
    2:             args, func = args[:-1], args[-1]
    2:         for arg in args:
>>>>>>             if arg:
>>>>>>                 cmd = cmd + (' ' + arg)
    2:         self.retrlines(cmd, func)
       
    2:     def rename(self, fromname, toname):
               '''Rename a file.'''
    4:         resp = self.sendcmd('RNFR ' + fromname)
    4:         if resp[0] != '3':
    2:             raise error_reply, resp
    2:         return self.voidcmd('RNTO ' + toname)
       
    2:     def delete(self, filename):
               '''Delete a file.'''
    4:         resp = self.sendcmd('DELE ' + filename)
    4:         if resp[:3] in ('250', '200'):
    2:             return resp
               else:
    2:             raise error_reply, resp
       
    2:     def cwd(self, dirname):
               '''Change to a directory.'''
    2:         if dirname == '..':
>>>>>>             try:
>>>>>>                 return self.voidcmd('CDUP')
>>>>>>             except error_perm, msg:
>>>>>>                 if msg.args[0][:3] != '500':
>>>>>>                     raise
    2:         elif dirname == '':
>>>>>>             dirname = '.'  # does nothing, but could return error
    2:         cmd = 'CWD ' + dirname
    2:         return self.voidcmd(cmd)
       
    2:     def size(self, filename):
               '''Retrieve the size of a file.'''
               # The SIZE command is defined in RFC-3659
    2:         resp = self.sendcmd('SIZE ' + filename)
    2:         if resp[:3] == '213':
>>>>>>             s = resp[3:].strip()
>>>>>>             try:
>>>>>>                 return int(s)
>>>>>>             except (OverflowError, ValueError):
>>>>>>                 return long(s)
       
    2:     def mkd(self, dirname):
               '''Make a directory, return its full pathname.'''
    2:         resp = self.sendcmd('MKD ' + dirname)
    2:         return parse257(resp)
       
    2:     def rmd(self, dirname):
               '''Remove a directory.'''
    2:         return self.voidcmd('RMD ' + dirname)
       
    2:     def pwd(self):
               '''Return current working directory.'''
    2:         resp = self.sendcmd('PWD')
    2:         return parse257(resp)
       
    2:     def quit(self):
               '''Quit, and close the connection.'''
    6:         resp = self.voidcmd('QUIT')
    6:         self.close()
    6:         return resp
       
    2:     def close(self):
               '''Close the connection without assuming anything about it.'''
   78:         try:
   78:             file = self.file
   78:             self.file = None
   78:             if file is not None:
   75:                 file.close()
               finally:
   78:             sock = self.sock
   78:             self.sock = None
   78:             if sock is not None:
   75:                 sock.close()
       
    2: try:
    2:     import ssl
>>>>>> except ImportError:
>>>>>>     pass
       else:
    4:     class FTP_TLS(FTP):
               '''A FTP subclass which adds TLS support to FTP as described
               in RFC-4217.
       
               Connect as usual to port 21 implicitly securing the FTP control
               connection before authenticating.
       
               Securing the data connection requires user to explicitly ask
               for it by calling prot_p() method.
       
               Usage example:
               >>> from ftplib import FTP_TLS
               >>> ftps = FTP_TLS('ftp.python.org')
               >>> ftps.login()  # login anonymously previously securing control channel
               '230 Guest login ok, access restrictions apply.'
               >>> ftps.prot_p()  # switch to secure data connection
               '200 Protection level set to P'
               >>> ftps.retrlines('LIST')  # list directory content securely
               total 9
               drwxr-xr-x   8 root     wheel        1024 Jan  3  1994 .
               drwxr-xr-x   8 root     wheel        1024 Jan  3  1994 ..
               drwxr-xr-x   2 root     wheel        1024 Jan  3  1994 bin
               drwxr-xr-x   2 root     wheel        1024 Jan  3  1994 etc
               d-wxrwxr-x   2 ftp      wheel        1024 Sep  5 13:43 incoming
               drwxr-xr-x   2 root     wheel        1024 Nov 17  1993 lib
               drwxr-xr-x   6 1094     wheel        1024 Sep 13 19:07 pub
               drwxr-xr-x   3 root     wheel        1024 Jan  3  1994 usr
               -rw-r--r--   1 root     root          312 Aug  1  1994 welcome.msg
               '226 Transfer complete.'
               >>> ftps.quit()
               '221 Goodbye.'
               >>>
    2:         '''
    2:         ssl_version = ssl.PROTOCOL_SSLv23
       
    2:         def __init__(self, host='', user='', passwd='', acct='', keyfile=None,
    2:                      certfile=None, context=None,
    2:                      timeout=_GLOBAL_DEFAULT_TIMEOUT, source_address=None):
   41:             if context is not None and keyfile is not None:
    2:                 raise ValueError("context and keyfile arguments are mutually "
                                        "exclusive")
   39:             if context is not None and certfile is not None:
    1:                 raise ValueError("context and certfile arguments are mutually "
                                        "exclusive")
   38:             self.keyfile = keyfile
   38:             self.certfile = certfile
   38:             if context is None:
   36:                 context = ssl._create_stdlib_context(self.ssl_version,
   36:                                                      certfile=certfile,
   36:                                                      keyfile=keyfile)
   38:             self.context = context
   38:             self._prot_p = False
   38:             FTP.__init__(self, host, user, passwd, acct, timeout)
       
    2:         def login(self, user='', passwd='', acct='', secure=True):
    3:             if secure and not isinstance(self.sock, ssl.SSLSocket):
    1:                 self.auth()
    3:             return FTP.login(self, user, passwd, acct)
       
    2:         def auth(self):
                   '''Set up secure control connection by using TLS/SSL.'''
   38:             if isinstance(self.sock, ssl.SSLSocket):
    2:                 raise ValueError("Already using TLS")
   36:             if self.ssl_version >= ssl.PROTOCOL_SSLv23:
   36:                 resp = self.voidcmd('AUTH TLS')
                   else:
>>>>>>                 resp = self.voidcmd('AUTH SSL')
   36:             self.sock = self.context.wrap_socket(self.sock,
   36:                                                  server_hostname=self.host)
   35:             self.file = self.sock.makefile(mode='rb')
   35:             return resp
       
    2:         def prot_p(self):
                   '''Set up secure data connection.'''
                   # PROT defines whether or not the data channel is to be protected.
                   # Though RFC-2228 defines four possible protection levels,
                   # RFC-4217 only recommends two, Clear and Private.
                   # Clear (PROT C) means that no security is to be used on the
                   # data-channel, Private (PROT P) means that the data-channel
                   # should be protected by TLS.
                   # PBSZ command MUST still be issued, but must have a parameter of
                   # '0' to indicate that no buffering is taking place and the data
                   # connection should not be encapsulated.
   33:             self.voidcmd('PBSZ 0')
   33:             resp = self.voidcmd('PROT P')
   33:             self._prot_p = True
   33:             return resp
       
    2:         def prot_c(self):
                   '''Set up clear text data connection.'''
    1:             resp = self.voidcmd('PROT C')
    1:             self._prot_p = False
    1:             return resp
       
               # --- Overridden FTP methods
       
    2:         def ntransfercmd(self, cmd, rest=None):
   22:             conn, size = FTP.ntransfercmd(self, cmd, rest)
   22:             if self._prot_p:
   20:                 conn = self.context.wrap_socket(conn,
   20:                                                 server_hostname=self.host)
   21:             return conn, size
       
    2:         def retrbinary(self, cmd, callback, blocksize=8192, rest=None):
    4:             self.voidcmd('TYPE I')
    4:             conn = self.transfercmd(cmd, rest)
    4:             try:
    4:                 while 1:
   16:                     data = conn.recv(blocksize)
   16:                     if not data:
    4:                         break
   12:                     callback(data)
                       # shutdown ssl layer
    4:                 if isinstance(conn, ssl.SSLSocket):
    4:                     conn.unwrap()
                   finally:
    4:                 conn.close()
    4:             return self.voidresp()
       
    2:         def retrlines(self, cmd, callback = None):
    5:             if callback is None: callback = print_line
    5:             resp = self.sendcmd('TYPE A')
    5:             conn = self.transfercmd(cmd)
    5:             fp = conn.makefile('rb')
    5:             try:
    5:                 while 1:
 1011:                     line = fp.readline(self.maxline + 1)
 1011:                     if len(line) > self.maxline:
    1:                         raise Error("got more than %d bytes" % self.maxline)
 1010:                     if self.debugging > 2: print '*retr*', repr(line)
 1010:                     if not line:
    4:                         break
 1006:                     if line[-2:] == CRLF:
 1006:                         line = line[:-2]
>>>>>>                     elif line[-1:] == '\n':
>>>>>>                         line = line[:-1]
 1006:                     callback(line)
                       # shutdown ssl layer
    4:                 if isinstance(conn, ssl.SSLSocket):
    4:                     conn.unwrap()
                   finally:
    5:                 fp.close()
    5:                 conn.close()
    4:             return self.voidresp()
       
    2:         def storbinary(self, cmd, fp, blocksize=8192, callback=None, rest=None):
    4:             self.voidcmd('TYPE I')
    4:             conn = self.transfercmd(cmd, rest)
    4:             try:
    4:                 while 1:
   12:                     buf = fp.read(blocksize)
   12:                     if not buf: break
    8:                     conn.sendall(buf)
    8:                     if callback: callback(buf)
                       # shutdown ssl layer
    4:                 if isinstance(conn, ssl.SSLSocket):
    4:                     conn.unwrap()
                   finally:
    4:                 conn.close()
    4:             return self.voidresp()
       
    2:         def storlines(self, cmd, fp, callback=None):
    3:             self.voidcmd('TYPE A')
    3:             conn = self.transfercmd(cmd)
    3:             try:
    3:                 while 1:
 2003:                     buf = fp.readline(self.maxline + 1)
 2003:                     if len(buf) > self.maxline:
    1:                         raise Error("got more than %d bytes" % self.maxline)
 2002:                     if not buf: break
 2000:                     if buf[-2:] != CRLF:
 2000:                         if buf[-1] in CRLF: buf = buf[:-1]
 2000:                         buf = buf + CRLF
 2000:                     conn.sendall(buf)
 2000:                     if callback: callback(buf)
                       # shutdown ssl layer
    2:                 if isinstance(conn, ssl.SSLSocket):
    2:                     conn.unwrap()
                   finally:
    3:                 conn.close()
    2:             return self.voidresp()
       
    2:     __all__.append('FTP_TLS')
    2:     all_errors = (Error, IOError, EOFError, ssl.SSLError)
       
       
    2: _150_re = None
       
    2: def parse150(resp):
           '''Parse the '150' response for a RETR request.
           Returns the expected transfer size or None; size is not guaranteed to
           be present in the 150 message.
           '''
>>>>>>     if resp[:3] != '150':
>>>>>>         raise error_reply, resp
           global _150_re
>>>>>>     if _150_re is None:
>>>>>>         import re
>>>>>>         _150_re = re.compile("150 .* \((\d+) bytes\)", re.IGNORECASE)
>>>>>>     m = _150_re.match(resp)
>>>>>>     if not m:
>>>>>>         return None
>>>>>>     s = m.group(1)
>>>>>>     try:
>>>>>>         return int(s)
>>>>>>     except (OverflowError, ValueError):
>>>>>>         return long(s)
       
       
    2: _227_re = None
       
    2: def parse227(resp):
           '''Parse the '227' response for a PASV request.
           Raises error_proto if it does not contain '(h1,h2,h3,h4,p1,p2)'
           Return ('host.addr.as.numbers', port#) tuple.'''
       
   40:     if resp[:3] != '227':
>>>>>>         raise error_reply, resp
           global _227_re
   40:     if _227_re is None:
    1:         import re
    1:         _227_re = re.compile(r'(\d+),(\d+),(\d+),(\d+),(\d+),(\d+)')
   40:     m = _227_re.search(resp)
   40:     if not m:
>>>>>>         raise error_proto, resp
   40:     numbers = m.groups()
   40:     host = '.'.join(numbers[:4])
   40:     port = (int(numbers[4]) << 8) + int(numbers[5])
   40:     return host, port
       
       
    2: def parse229(resp, peer):
           '''Parse the '229' response for an EPSV request.
           Raises error_proto if it does not contain '(|||port|)'
           Return ('host.addr.as.numbers', port#) tuple.'''
       
>>>>>>     if resp[:3] != '229':
>>>>>>         raise error_reply, resp
>>>>>>     left = resp.find('(')
>>>>>>     if left < 0: raise error_proto, resp
>>>>>>     right = resp.find(')', left + 1)
>>>>>>     if right < 0:
>>>>>>         raise error_proto, resp # should contain '(|||port|)'
>>>>>>     if resp[left + 1] != resp[right - 1]:
>>>>>>         raise error_proto, resp
>>>>>>     parts = resp[left + 1:right].split(resp[left+1])
>>>>>>     if len(parts) != 5:
>>>>>>         raise error_proto, resp
>>>>>>     host = peer[0]
>>>>>>     port = int(parts[3])
>>>>>>     return host, port
       
       
    2: def parse257(resp):
           '''Parse the '257' response for a MKD or PWD request.
           This is a response to a MKD or PWD request: a directory name.
           Returns the directoryname in the 257 reply.'''
       
    4:     if resp[:3] != '257':
>>>>>>         raise error_reply, resp
    4:     if resp[3:5] != ' "':
>>>>>>         return '' # Not compliant to RFC 959, but UNIX ftpd does this
    4:     dirname = ''
    4:     i = 5
    4:     n = len(resp)
   24:     while i < n:
   24:         c = resp[i]
   24:         i = i+1
   24:         if c == '"':
    4:             if i >= n or resp[i] != '"':
    4:                 break
>>>>>>             i = i+1
   20:         dirname = dirname + c
    4:     return dirname
       
       
    2: def print_line(line):
           '''Default retrlines callback to print a line.'''
>>>>>>     print line
       
       
    2: def ftpcp(source, sourcename, target, targetname = '', type = 'I'):
           '''Copy file from one FTP-instance to another.'''
>>>>>>     if not targetname: targetname = sourcename
>>>>>>     type = 'TYPE ' + type
>>>>>>     source.voidcmd(type)
>>>>>>     target.voidcmd(type)
>>>>>>     sourcehost, sourceport = parse227(source.sendcmd('PASV'))
>>>>>>     target.sendport(sourcehost, sourceport)
           # RFC 959: the user must "listen" [...] BEFORE sending the
           # transfer request.
           # So: STOR before RETR, because here the target is a "user".
>>>>>>     treply = target.sendcmd('STOR ' + targetname)
>>>>>>     if treply[:3] not in ('125', '150'): raise error_proto  # RFC 959
>>>>>>     sreply = source.sendcmd('RETR ' + sourcename)
>>>>>>     if sreply[:3] not in ('125', '150'): raise error_proto  # RFC 959
>>>>>>     source.voidresp()
>>>>>>     target.voidresp()
       
       
    4: class Netrc:
           """Class to parse & provide access to 'netrc' format files.
       
           See the netrc(4) man page for information on the file format.
       
           WARNING: This class is obsolete -- use module netrc instead.
       
    2:     """
    2:     __defuser = None
    2:     __defpasswd = None
    2:     __defacct = None
       
    2:     def __init__(self, filename=None):
>>>>>>         if filename is None:
>>>>>>             if "HOME" in os.environ:
>>>>>>                 filename = os.path.join(os.environ["HOME"],
>>>>>>                                         ".netrc")
                   else:
>>>>>>                 raise IOError, \
>>>>>>                       "specify file to load or set $HOME"
>>>>>>         self.__hosts = {}
>>>>>>         self.__macros = {}
>>>>>>         fp = open(filename, "r")
>>>>>>         in_macro = 0
>>>>>>         while 1:
>>>>>>             line = fp.readline(self.maxline + 1)
>>>>>>             if len(line) > self.maxline:
>>>>>>                 raise Error("got more than %d bytes" % self.maxline)
>>>>>>             if not line: break
>>>>>>             if in_macro and line.strip():
>>>>>>                 macro_lines.append(line)
>>>>>>                 continue
>>>>>>             elif in_macro:
>>>>>>                 self.__macros[macro_name] = tuple(macro_lines)
>>>>>>                 in_macro = 0
>>>>>>             words = line.split()
>>>>>>             host = user = passwd = acct = None
>>>>>>             default = 0
>>>>>>             i = 0
>>>>>>             while i < len(words):
>>>>>>                 w1 = words[i]
>>>>>>                 if i+1 < len(words):
>>>>>>                     w2 = words[i + 1]
                       else:
>>>>>>                     w2 = None
>>>>>>                 if w1 == 'default':
>>>>>>                     default = 1
>>>>>>                 elif w1 == 'machine' and w2:
>>>>>>                     host = w2.lower()
>>>>>>                     i = i + 1
>>>>>>                 elif w1 == 'login' and w2:
>>>>>>                     user = w2
>>>>>>                     i = i + 1
>>>>>>                 elif w1 == 'password' and w2:
>>>>>>                     passwd = w2
>>>>>>                     i = i + 1
>>>>>>                 elif w1 == 'account' and w2:
>>>>>>                     acct = w2
>>>>>>                     i = i + 1
>>>>>>                 elif w1 == 'macdef' and w2:
>>>>>>                     macro_name = w2
>>>>>>                     macro_lines = []
>>>>>>                     in_macro = 1
>>>>>>                     break
>>>>>>                 i = i + 1
>>>>>>             if default:
>>>>>>                 self.__defuser = user or self.__defuser
>>>>>>                 self.__defpasswd = passwd or self.__defpasswd
>>>>>>                 self.__defacct = acct or self.__defacct
>>>>>>             if host:
>>>>>>                 if host in self.__hosts:
                           ouser, opasswd, oacct = \
>>>>>>                            self.__hosts[host]
>>>>>>                     user = user or ouser
>>>>>>                     passwd = passwd or opasswd
>>>>>>                     acct = acct or oacct
>>>>>>                 self.__hosts[host] = user, passwd, acct
>>>>>>         fp.close()
       
    2:     def get_hosts(self):
               """Return a list of hosts mentioned in the .netrc file."""
>>>>>>         return self.__hosts.keys()
       
    2:     def get_account(self, host):
               """Returns login information for the named host.
       
               The return value is a triple containing userid,
               password, and the accounting field.
       
               """
>>>>>>         host = host.lower()
>>>>>>         user = passwd = acct = None
>>>>>>         if host in self.__hosts:
>>>>>>             user, passwd, acct = self.__hosts[host]
>>>>>>         user = user or self.__defuser
>>>>>>         passwd = passwd or self.__defpasswd
>>>>>>         acct = acct or self.__defacct
>>>>>>         return user, passwd, acct
       
    2:     def get_macros(self):
               """Return a list of all defined macro names."""
>>>>>>         return self.__macros.keys()
       
    2:     def get_macro(self, macro):
               """Return a sequence of lines which define a named macro."""
>>>>>>         return self.__macros[macro]
       
       
       
    2: def test():
           '''Test program.
           Usage: ftp [-d] [-r[file]] host [-l[dir]] [-d[dir]] [-p] [file] ...
       
           -d dir
           -l list
           -p password
           '''
       
>>>>>>     if len(sys.argv) < 2:
>>>>>>         print test.__doc__
>>>>>>         sys.exit(0)
       
>>>>>>     debugging = 0
>>>>>>     rcfile = None
>>>>>>     while sys.argv[1] == '-d':
>>>>>>         debugging = debugging+1
>>>>>>         del sys.argv[1]
>>>>>>     if sys.argv[1][:2] == '-r':
               # get name of alternate ~/.netrc file:
>>>>>>         rcfile = sys.argv[1][2:]
>>>>>>         del sys.argv[1]
>>>>>>     host = sys.argv[1]
>>>>>>     ftp = FTP(host)
>>>>>>     ftp.set_debuglevel(debugging)
>>>>>>     userid = passwd = acct = ''
>>>>>>     try:
>>>>>>         netrc = Netrc(rcfile)
>>>>>>     except IOError:
>>>>>>         if rcfile is not None:
>>>>>>             sys.stderr.write("Could not open account file"
                                    " -- using anonymous login.")
           else:
>>>>>>         try:
>>>>>>             userid, passwd, acct = netrc.get_account(host)
>>>>>>         except KeyError:
                   # no account for host
>>>>>>             sys.stderr.write(
>>>>>>                     "No account -- using anonymous login.")
>>>>>>     ftp.login(userid, passwd, acct)
>>>>>>     for file in sys.argv[2:]:
>>>>>>         if file[:2] == '-l':
>>>>>>             ftp.dir(file[2:])
>>>>>>         elif file[:2] == '-d':
>>>>>>             cmd = 'CWD'
>>>>>>             if file[2:]: cmd = cmd + ' ' + file[2:]
>>>>>>             resp = ftp.sendcmd(cmd)
>>>>>>         elif file == '-p':
>>>>>>             ftp.set_pasv(not ftp.passiveserver)
               else:
>>>>>>             ftp.retrbinary('RETR ' + file, \
>>>>>>                            sys.stdout.write, 1024)
>>>>>>     ftp.quit()
       
       
    2: if __name__ == '__main__':
>>>>>>     test()
