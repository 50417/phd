    1: import collections
    1: import copy
    1: import doctest
    1: import keyword
    1: import operator
    1: import pickle
    1: import cPickle
    1: from random import choice, randrange
    1: import re
    1: import string
    1: import sys
    1: from test import test_support
    1: import unittest
       
    1: from collections import namedtuple, Counter, OrderedDict
    1: from collections import Hashable, Iterable, Iterator
    1: from collections import Sized, Container, Callable
    1: from collections import Set, MutableSet
    1: from collections import Mapping, MutableMapping
    1: from collections import Sequence, MutableSequence
       
       # Silence deprecation warning
    1: sets = test_support.import_module('sets', deprecated=True)
       
    1: TestNT = namedtuple('TestNT', 'x y z')    # type used for pickle tests
       
       py273_named_tuple_pickle = '''\
       ccopy_reg
       _reconstructor
       p0
       (ctest.test_collections
       TestNT
       p1
       c__builtin__
       tuple
       p2
       (I10
       I20
       I30
       tp3
       tp4
       Rp5
       ccollections
       OrderedDict
       p6
       ((lp7
       (lp8
       S'x'
       p9
       aI10
       aa(lp10
       S'y'
       p11
       aI20
       aa(lp12
       S'z'
       p13
       aI30
       aatp14
       Rp15
       b.
    1: '''
       
    2: class TestNamedTuple(unittest.TestCase):
       
    1:     def test_factory(self):
    1:         Point = namedtuple('Point', 'x y')
    1:         self.assertEqual(Point.__name__, 'Point')
    1:         self.assertEqual(Point.__slots__, ())
    1:         self.assertEqual(Point.__module__, __name__)
    1:         self.assertEqual(Point.__getitem__, tuple.__getitem__)
    1:         self.assertEqual(Point._fields, ('x', 'y'))
       
    1:         self.assertRaises(ValueError, namedtuple, 'abc%', 'efg ghi')       # type has non-alpha char
    1:         self.assertRaises(ValueError, namedtuple, 'class', 'efg ghi')      # type has keyword
    1:         self.assertRaises(ValueError, namedtuple, '9abc', 'efg ghi')       # type starts with digit
       
    1:         self.assertRaises(ValueError, namedtuple, 'abc', 'efg g%hi')       # field with non-alpha char
    1:         self.assertRaises(ValueError, namedtuple, 'abc', 'abc class')      # field has keyword
    1:         self.assertRaises(ValueError, namedtuple, 'abc', '8efg 9ghi')      # field starts with digit
    1:         self.assertRaises(ValueError, namedtuple, 'abc', '_efg ghi')       # field with leading underscore
    1:         self.assertRaises(ValueError, namedtuple, 'abc', 'efg efg ghi')    # duplicate field
       
    1:         namedtuple('Point0', 'x1 y2')   # Verify that numbers are allowed in names
    1:         namedtuple('_', 'a b c')        # Test leading underscores in a typename
       
    1:         nt = namedtuple('nt', u'the quick brown fox')                       # check unicode input
    1:         self.assertNotIn("u'", repr(nt._fields))
    1:         nt = namedtuple('nt', (u'the', u'quick'))                           # check unicode input
    1:         self.assertNotIn("u'", repr(nt._fields))
       
    1:         self.assertRaises(TypeError, Point._make, [11])                     # catch too few args
    1:         self.assertRaises(TypeError, Point._make, [11, 22, 33])             # catch too many args
       
    1:     @unittest.skipIf(sys.flags.optimize >= 2,
    1:                      "Docstrings are omitted with -O2 and above")
           def test_factory_doc_attr(self):
    1:         Point = namedtuple('Point', 'x y')
    1:         self.assertEqual(Point.__doc__, 'Point(x, y)')
       
    1:     def test_name_fixer(self):
    1:         for spec, renamed in [
    1:             [('efg', 'g%hi'),  ('efg', '_1')],                              # field with non-alpha char
    1:             [('abc', 'class'), ('abc', '_1')],                              # field has keyword
    1:             [('8efg', '9ghi'), ('_0', '_1')],                               # field starts with digit
    1:             [('abc', '_efg'), ('abc', '_1')],                               # field with leading underscore
    1:             [('abc', 'efg', 'efg', 'ghi'), ('abc', 'efg', '_2', 'ghi')],    # duplicate field
    7:             [('abc', '', 'x'), ('abc', '_1', 'x')],                         # fieldname is a space
               ]:
    6:             self.assertEqual(namedtuple('NT', spec, rename=True)._fields, renamed)
       
    1:     def test_instance(self):
    1:         Point = namedtuple('Point', 'x y')
    1:         p = Point(11, 22)
    1:         self.assertEqual(p, Point(x=11, y=22))
    1:         self.assertEqual(p, Point(11, y=22))
    1:         self.assertEqual(p, Point(y=22, x=11))
    1:         self.assertEqual(p, Point(*(11, 22)))
    1:         self.assertEqual(p, Point(**dict(x=11, y=22)))
    1:         self.assertRaises(TypeError, Point, 1)                              # too few args
    1:         self.assertRaises(TypeError, Point, 1, 2, 3)                        # too many args
    1:         self.assertRaises(TypeError, eval, 'Point(XXX=1, y=2)', locals())   # wrong keyword argument
    1:         self.assertRaises(TypeError, eval, 'Point(x=1)', locals())          # missing keyword argument
    1:         self.assertEqual(repr(p), 'Point(x=11, y=22)')
    1:         self.assertNotIn('__weakref__', dir(p))
    1:         self.assertEqual(p, Point._make([11, 22]))                          # test _make classmethod
    1:         self.assertEqual(p._fields, ('x', 'y'))                             # test _fields attribute
    1:         self.assertEqual(p._replace(x=1), (1, 22))                          # test _replace method
    1:         self.assertEqual(p._asdict(), dict(x=11, y=22))                     # test _asdict method
    1:         self.assertEqual(vars(p), p._asdict())                              # verify that vars() works
       
    1:         try:
    1:             p._replace(x=1, error=2)
    1:         except ValueError:
    1:             pass
               else:
>>>>>>             self._fail('Did not detect an incorrect fieldname')
       
               # verify that field string can have commas
    1:         Point = namedtuple('Point', 'x, y')
    1:         p = Point(x=11, y=22)
    1:         self.assertEqual(repr(p), 'Point(x=11, y=22)')
       
               # verify that fieldspec can be a non-string sequence
    1:         Point = namedtuple('Point', ('x', 'y'))
    1:         p = Point(x=11, y=22)
    1:         self.assertEqual(repr(p), 'Point(x=11, y=22)')
       
    1:     def test_tupleness(self):
    1:         Point = namedtuple('Point', 'x y')
    1:         p = Point(11, 22)
       
    1:         self.assertIsInstance(p, tuple)
    1:         self.assertEqual(p, (11, 22))                                       # matches a real tuple
    1:         self.assertEqual(tuple(p), (11, 22))                                # coercable to a real tuple
    1:         self.assertEqual(list(p), [11, 22])                                 # coercable to a list
    1:         self.assertEqual(max(p), 22)                                        # iterable
    1:         self.assertEqual(max(*p), 22)                                       # star-able
    1:         x, y = p
    1:         self.assertEqual(p, (x, y))                                         # unpacks like a tuple
    1:         self.assertEqual((p[0], p[1]), (11, 22))                            # indexable like a tuple
    1:         self.assertRaises(IndexError, p.__getitem__, 3)
       
    1:         self.assertEqual(p.x, x)
    1:         self.assertEqual(p.y, y)
    1:         self.assertRaises(AttributeError, eval, 'p.z', locals())
       
    1:     def test_odd_sizes(self):
    1:         Zero = namedtuple('Zero', '')
    1:         self.assertEqual(Zero(), ())
    1:         self.assertEqual(Zero._make([]), ())
    1:         self.assertEqual(repr(Zero()), 'Zero()')
    1:         self.assertEqual(Zero()._asdict(), {})
    1:         self.assertEqual(Zero()._fields, ())
       
    1:         Dot = namedtuple('Dot', 'd')
    1:         self.assertEqual(Dot(1), (1,))
    1:         self.assertEqual(Dot._make([1]), (1,))
    1:         self.assertEqual(Dot(1).d, 1)
    1:         self.assertEqual(repr(Dot(1)), 'Dot(d=1)')
    1:         self.assertEqual(Dot(1)._asdict(), {'d':1})
    1:         self.assertEqual(Dot(1)._replace(d=999), (999,))
    1:         self.assertEqual(Dot(1)._fields, ('d',))
       
    1:         n = 5000
 5002:         names = list(set(''.join([choice(string.ascii_letters)
55001:                                   for j in range(10)]) for i in range(n)))
    1:         n = len(names)
    1:         Big = namedtuple('Big', names)
    1:         b = Big(*range(n))
    1:         self.assertEqual(b, tuple(range(n)))
    1:         self.assertEqual(Big._make(range(n)), tuple(range(n)))
 5001:         for pos, name in enumerate(names):
 5000:             self.assertEqual(getattr(b, name), pos)
    1:         repr(b)                                 # make sure repr() doesn't blow-up
    1:         d = b._asdict()
    1:         d_expected = dict(zip(names, range(n)))
    1:         self.assertEqual(d, d_expected)
    1:         b2 = b._replace(**dict([(names[1], 999),(names[-5], 42)]))
    1:         b2_expected = range(n)
    1:         b2_expected[1] = 999
    1:         b2_expected[-5] = 42
    1:         self.assertEqual(b2, tuple(b2_expected))
    1:         self.assertEqual(b._fields, tuple(names))
       
    1:     def test_pickle(self):
    1:         p = TestNT(x=10, y=20, z=30)
    3:         for module in pickle, cPickle:
    2:             loads = getattr(module, 'loads')
    2:             dumps = getattr(module, 'dumps')
   10:             for protocol in -1, 0, 1, 2:
    8:                 q = loads(dumps(p, protocol))
    8:                 self.assertEqual(p, q)
    8:                 self.assertEqual(p._fields, q._fields)
       
    1:     def test_copy(self):
    1:         p = TestNT(x=10, y=20, z=30)
    3:         for copier in copy.copy, copy.deepcopy:
    2:             q = copier(p)
    2:             self.assertEqual(p, q)
    2:             self.assertEqual(p._fields, q._fields)
       
    1:     def test_name_conflicts(self):
               # Some names like "self", "cls", "tuple", "itemgetter", and "property"
               # failed when used as field names.  Test to make sure these now work.
    1:         T = namedtuple('T', 'itemgetter property self cls tuple')
    1:         t = T(1, 2, 3, 4, 5)
    1:         self.assertEqual(t, (1,2,3,4,5))
    1:         newt = t._replace(itemgetter=10, property=20, self=30, cls=40, tuple=50)
    1:         self.assertEqual(newt, (10,20,30,40,50))
       
               # Broader test of all interesting names in a template
    1:         with test_support.captured_stdout() as template:
    1:             T = namedtuple('T', 'x', verbose=True)
    1:         words = set(re.findall('[A-Za-z]+', template.getvalue()))
    1:         words -= set(keyword.kwlist)
    1:         T = namedtuple('T', words)
               # test __new__
    1:         values = tuple(range(len(words)))
    1:         t = T(*values)
    1:         self.assertEqual(t, values)
    1:         t = T(**dict(zip(T._fields, values)))
    1:         self.assertEqual(t, values)
               # test _make
    1:         t = T._make(values)
    1:         self.assertEqual(t, values)
               # exercise __repr__
    1:         repr(t)
               # test _asdict
    1:         self.assertEqual(t._asdict(), dict(zip(T._fields, values)))
               # test _replace
    1:         t = T._make(values)
   70:         newvalues = tuple(v*10 for v in values)
    1:         newt = t._replace(**dict(zip(T._fields, newvalues)))
    1:         self.assertEqual(newt, newvalues)
               # test _fields
    1:         self.assertEqual(T._fields, tuple(words))
               # test __getnewargs__
    1:         self.assertEqual(t.__getnewargs__(), values)
       
    1:     def test_pickling_bug_18015(self):
               # http://bugs.python.org/issue18015
    1:         pt = pickle.loads(py273_named_tuple_pickle)
    1:         self.assertEqual(pt.x, 10)
       
    2: class ABCTestCase(unittest.TestCase):
       
    1:     def validate_abstract_methods(self, abc, *names):
   12:         methodstubs = dict.fromkeys(names, lambda s, *args: 0)
       
               # everything should work will all required methods are present
   12:         C = type('C', (abc,), methodstubs)
   12:         C()
       
               # instantiation should fail if a required method is missing
   48:         for name in names:
   36:             stubs = methodstubs.copy()
   36:             del stubs[name]
   36:             C = type('C', (abc,), stubs)
   36:             self.assertRaises(TypeError, C, name)
       
    1:     def validate_isinstance(self, abc, name):
    5:         stub = lambda s, *args: 0
       
               # new-style class
    5:         C = type('C', (object,), {name: stub})
    5:         self.assertIsInstance(C(), abc)
    5:         self.assertTrue(issubclass(C, abc))
               # old-style class
   10:         class C: pass
    5:         setattr(C, name, stub)
    5:         self.assertIsInstance(C(), abc)
    5:         self.assertTrue(issubclass(C, abc))
       
               # new-style class
    5:         C = type('C', (object,), {'__hash__': None})
    5:         self.assertNotIsInstance(C(), abc)
    5:         self.assertFalse(issubclass(C, abc))
               # old-style class
   10:         class C: pass
    5:         self.assertNotIsInstance(C(), abc)
    5:         self.assertFalse(issubclass(C, abc))
       
    1:     def validate_comparison(self, instance):
    2:         ops = ['lt', 'gt', 'le', 'ge', 'ne', 'or', 'and', 'xor', 'sub']
    2:         operators = {}
   20:         for op in ops:
   18:             name = '__' + op + '__'
   18:             operators[name] = getattr(operator, name)
       
    4:         class Other:
    2:             def __init__(self):
   10:                 self.right_side = False
    2:             def __eq__(self, other):
   10:                 self.right_side = True
   10:                 return True
    2:             __lt__ = __eq__
    2:             __gt__ = __eq__
    2:             __le__ = __eq__
    2:             __ge__ = __eq__
    2:             __ne__ = __eq__
    2:             __ror__ = __eq__
    2:             __rand__ = __eq__
    2:             __rxor__ = __eq__
    2:             __rsub__ = __eq__
       
   20:         for name, op in operators.items():
   18:             if not hasattr(instance, name):
    8:                 continue
   10:             other = Other()
   10:             op(instance, other)
   10:             self.assertTrue(other.right_side,'Right side not called for %s.%s'
   10:                             % (type(instance), name))
       
    2: class TestOneTrickPonyABCs(ABCTestCase):
       
    1:     def test_Hashable(self):
               # Check some non-hashables
    1:         non_samples = [list(), set(), dict()]
    4:         for x in non_samples:
    3:             self.assertNotIsInstance(x, Hashable)
    3:             self.assertFalse(issubclass(type(x), Hashable), repr(type(x)))
               # Check some hashables
    1:         samples = [None,
    1:                    int(), float(), complex(),
    1:                    str(),
    1:                    tuple(), frozenset(),
    1:                    int, list, object, type,
                          ]
   12:         for x in samples:
   11:             self.assertIsInstance(x, Hashable)
   11:             self.assertTrue(issubclass(type(x), Hashable), repr(type(x)))
    1:         self.assertRaises(TypeError, Hashable)
               # Check direct subclassing
    2:         class H(Hashable):
    1:             def __hash__(self):
    1:                 return super(H, self).__hash__()
    1:             __eq__ = Hashable.__eq__ # Silence Py3k warning
    1:         self.assertEqual(hash(H()), 0)
    1:         self.assertFalse(issubclass(int, H))
    1:         self.validate_abstract_methods(Hashable, '__hash__')
    1:         self.validate_isinstance(Hashable, '__hash__')
       
    1:     def test_Iterable(self):
               # Check some non-iterables
    1:         non_samples = [None, 42, 3.14, 1j]
    5:         for x in non_samples:
    4:             self.assertNotIsInstance(x, Iterable)
    4:             self.assertFalse(issubclass(type(x), Iterable), repr(type(x)))
               # Check some iterables
    1:         samples = [str(),
    1:                    tuple(), list(), set(), frozenset(), dict(),
    1:                    dict().keys(), dict().items(), dict().values(),
    1:                    (lambda: (yield))(),
    1:                    (x for x in []),
                          ]
   12:         for x in samples:
   11:             self.assertIsInstance(x, Iterable)
   11:             self.assertTrue(issubclass(type(x), Iterable), repr(type(x)))
               # Check direct subclassing
    2:         class I(Iterable):
    1:             def __iter__(self):
    1:                 return super(I, self).__iter__()
    1:         self.assertEqual(list(I()), [])
    1:         self.assertFalse(issubclass(str, I))
    1:         self.validate_abstract_methods(Iterable, '__iter__')
    1:         self.validate_isinstance(Iterable, '__iter__')
       
    1:     def test_Iterator(self):
    1:         non_samples = [None, 42, 3.14, 1j, "".encode('ascii'), "", (), [],
    1:             {}, set()]
   11:         for x in non_samples:
   10:             self.assertNotIsInstance(x, Iterator)
   10:             self.assertFalse(issubclass(type(x), Iterator), repr(type(x)))
    1:         samples = [iter(str()),
    1:                    iter(tuple()), iter(list()), iter(dict()),
    1:                    iter(set()), iter(frozenset()),
    1:                    iter(dict().keys()), iter(dict().items()),
    1:                    iter(dict().values()),
    1:                    (lambda: (yield))(),
    1:                    (x for x in []),
                          ]
   12:         for x in samples:
   11:             self.assertIsInstance(x, Iterator)
   11:             self.assertTrue(issubclass(type(x), Iterator), repr(type(x)))
    1:         self.validate_abstract_methods(Iterator, 'next', '__iter__')
       
               # Issue 10565
    2:         class NextOnly:
    1:             def __next__(self):
>>>>>>                 yield 1
>>>>>>                 raise StopIteration
    1:         self.assertNotIsInstance(NextOnly(), Iterator)
    2:         class NextOnlyNew(object):
    1:             def __next__(self):
>>>>>>                 yield 1
>>>>>>                 raise StopIteration
    1:         self.assertNotIsInstance(NextOnlyNew(), Iterator)
       
    1:     def test_Sized(self):
    1:         non_samples = [None, 42, 3.14, 1j,
    1:                        (lambda: (yield))(),
    1:                        (x for x in []),
                              ]
    7:         for x in non_samples:
    6:             self.assertNotIsInstance(x, Sized)
    6:             self.assertFalse(issubclass(type(x), Sized), repr(type(x)))
    1:         samples = [str(),
    1:                    tuple(), list(), set(), frozenset(), dict(),
    1:                    dict().keys(), dict().items(), dict().values(),
                          ]
   10:         for x in samples:
    9:             self.assertIsInstance(x, Sized)
    9:             self.assertTrue(issubclass(type(x), Sized), repr(type(x)))
    1:         self.validate_abstract_methods(Sized, '__len__')
    1:         self.validate_isinstance(Sized, '__len__')
       
    1:     def test_Container(self):
    1:         non_samples = [None, 42, 3.14, 1j,
    1:                        (lambda: (yield))(),
    1:                        (x for x in []),
                              ]
    7:         for x in non_samples:
    6:             self.assertNotIsInstance(x, Container)
    6:             self.assertFalse(issubclass(type(x), Container), repr(type(x)))
    1:         samples = [str(),
    1:                    tuple(), list(), set(), frozenset(), dict(),
    1:                    dict().keys(), dict().items(),
                          ]
    9:         for x in samples:
    8:             self.assertIsInstance(x, Container)
    8:             self.assertTrue(issubclass(type(x), Container), repr(type(x)))
    1:         self.validate_abstract_methods(Container, '__contains__')
    1:         self.validate_isinstance(Container, '__contains__')
       
    1:     def test_Callable(self):
    1:         non_samples = [None, 42, 3.14, 1j,
    1:                        "", "".encode('ascii'), (), [], {}, set(),
    1:                        (lambda: (yield))(),
    1:                        (x for x in []),
                              ]
   13:         for x in non_samples:
   12:             self.assertNotIsInstance(x, Callable)
   12:             self.assertFalse(issubclass(type(x), Callable), repr(type(x)))
    1:         samples = [lambda: None,
    1:                    type, int, object,
    1:                    len,
    1:                    list.append, [].append,
                          ]
    8:         for x in samples:
    7:             self.assertIsInstance(x, Callable)
    7:             self.assertTrue(issubclass(type(x), Callable), repr(type(x)))
    1:         self.validate_abstract_methods(Callable, '__call__')
    1:         self.validate_isinstance(Callable, '__call__')
       
    1:     def test_direct_subclassing(self):
    7:         for B in Hashable, Iterable, Iterator, Sized, Container, Callable:
   12:             class C(B):
    6:                 pass
    6:             self.assertTrue(issubclass(C, B))
    6:             self.assertFalse(issubclass(int, C))
       
    1:     def test_registration(self):
    7:         for B in Hashable, Iterable, Iterator, Sized, Container, Callable:
   12:             class C:
    6:                 __metaclass__ = type
    6:                 __hash__ = None  # Make sure it isn't hashable by default
    6:             self.assertFalse(issubclass(C, B), B.__name__)
    6:             B.register(C)
    6:             self.assertTrue(issubclass(C, B))
       
    2: class WithSet(MutableSet):
       
    1:     def __init__(self, it=()):
    9:         self.data = set(it)
       
    1:     def __len__(self):
   16:         return len(self.data)
       
    1:     def __iter__(self):
   35:         return iter(self.data)
       
    1:     def __contains__(self, item):
   34:         return item in self.data
       
    1:     def add(self, item):
   10:         self.data.add(item)
       
    1:     def discard(self, item):
   22:         self.data.discard(item)
       
    2: class TestCollectionABCs(ABCTestCase):
       
           # XXX For now, we only test some virtual inheritance properties.
           # We should also test the proper behavior of the collection ABCs
           # as real base classes or mix-in classes.
       
    1:     def test_Set(self):
    3:         for sample in [set, frozenset]:
    2:             self.assertIsInstance(sample(), Set)
    2:             self.assertTrue(issubclass(sample, Set))
    1:         self.validate_abstract_methods(Set, '__contains__', '__iter__', '__len__')
    2:         class MySet(Set):
    1:             def __contains__(self, x):
>>>>>>                 return False
    1:             def __len__(self):
>>>>>>                 return 0
    1:             def __iter__(self):
>>>>>>                 return iter([])
    1:         self.validate_comparison(MySet())
       
    1:     def test_hash_Set(self):
    2:         class OneTwoThreeSet(Set):
    1:             def __init__(self):
    2:                 self.contents = [1, 2, 3]
    1:             def __contains__(self, x):
>>>>>>                 return x in self.contents
    1:             def __len__(self):
    2:                 return len(self.contents)
    1:             def __iter__(self):
    2:                 return iter(self.contents)
    1:             def __hash__(self):
    2:                 return self._hash()
    1:         a, b = OneTwoThreeSet(), OneTwoThreeSet()
    1:         self.assertTrue(hash(a) == hash(b))
       
    1:     def test_MutableSet(self):
    1:         self.assertIsInstance(set(), MutableSet)
    1:         self.assertTrue(issubclass(set, MutableSet))
    1:         self.assertNotIsInstance(frozenset(), MutableSet)
    1:         self.assertFalse(issubclass(frozenset, MutableSet))
    1:         self.validate_abstract_methods(MutableSet, '__contains__', '__iter__', '__len__',
    1:             'add', 'discard')
       
    1:     def test_issue_5647(self):
               # MutableSet.__iand__ mutated the set during iteration
    1:         s = WithSet('abcd')
    1:         s &= WithSet('cdef')            # This used to fail
    1:         self.assertEqual(set(s), set('cd'))
       
    1:     def test_issue_4920(self):
               # MutableSet.pop() method did not work
    2:         class MySet(MutableSet):
    1:             __slots__=['__s']
    1:             def __init__(self,items=None):
    1:                 if items is None:
>>>>>>                     items=[]
    1:                 self.__s=set(items)
    1:             def __contains__(self,v):
>>>>>>                 return v in self.__s
    1:             def __iter__(self):
    1:                 return iter(self.__s)
    1:             def __len__(self):
>>>>>>                 return len(self.__s)
    1:             def add(self,v):
>>>>>>                 result=v not in self.__s
>>>>>>                 self.__s.add(v)
>>>>>>                 return result
    1:             def discard(self,v):
    1:                 result=v in self.__s
    1:                 self.__s.discard(v)
    1:                 return result
    1:             def __repr__(self):
>>>>>>                 return "MySet(%s)" % repr(list(self))
    1:         s = MySet([5,43,2,1])
    1:         self.assertEqual(s.pop(), 1)
       
    1:     def test_issue8750(self):
    1:         empty = WithSet()
    1:         full = WithSet(range(10))
    1:         s = WithSet(full)
    1:         s -= s
    1:         self.assertEqual(s, empty)
    1:         s = WithSet(full)
    1:         s ^= s
    1:         self.assertEqual(s, empty)
    1:         s = WithSet(full)
    1:         s &= s
    1:         self.assertEqual(s, full)
    1:         s |= s
    1:         self.assertEqual(s, full)
       
    1:     def test_issue16373(self):
               # Recursion error comparing comparable and noncomparable
               # Set instances
    2:         class MyComparableSet(Set):
    1:             def __contains__(self, x):
>>>>>>                 return False
    1:             def __len__(self):
    8:                 return 0
    1:             def __iter__(self):
    2:                 return iter([])
    2:         class MyNonComparableSet(Set):
    1:             def __contains__(self, x):
>>>>>>                 return False
    1:             def __len__(self):
    8:                 return 0
    1:             def __iter__(self):
    2:                 return iter([])
    1:             def __le__(self, x):
    1:                 return NotImplemented
    1:             def __lt__(self, x):
    1:                 return NotImplemented
       
    1:         cs = MyComparableSet()
    1:         ncs = MyNonComparableSet()
       
               # Run all the variants to make sure they don't mutually recurse
    1:         ncs < cs
    1:         ncs <= cs
    1:         ncs > cs
    1:         ncs >= cs
    1:         cs < ncs
    1:         cs <= ncs
    1:         cs > ncs
    1:         cs >= ncs
       
    1:     def assertSameSet(self, s1, s2):
               # coerce both to a real set then check equality
   30:         self.assertEqual(set(s1), set(s2))
       
    1:     def test_Set_interoperability_with_real_sets(self):
               # Issue: 8743
    2:         class ListSet(Set):
    1:             def __init__(self, elements=()):
   54:                 self.data = []
  190:                 for elem in elements:
  136:                     if elem not in self.data:
  110:                         self.data.append(elem)
    1:             def __contains__(self, elem):
  121:                 return elem in self.data
    1:             def __iter__(self):
   84:                 return iter(self.data)
    1:             def __len__(self):
   63:                 return len(self.data)
    1:             def __repr__(self):
>>>>>>                 return 'Set({!r})'.format(self.data)
       
    1:         r1 = set('abc')
    1:         r2 = set('bcd')
    1:         r3 = set('abcde')
    1:         f1 = ListSet('abc')
    1:         f2 = ListSet('bcd')
    1:         f3 = ListSet('abcde')
    1:         l1 = list('abccba')
    1:         l2 = list('bcddcb')
    1:         l3 = list('abcdeedcba')
    1:         p1 = sets.Set('abc')
    1:         p2 = sets.Set('bcd')
    1:         p3 = sets.Set('abcde')
       
    1:         target = r1 & r2
    1:         self.assertSameSet(f1 & f2, target)
    1:         self.assertSameSet(f1 & r2, target)
    1:         self.assertSameSet(r2 & f1, target)
    1:         self.assertSameSet(f1 & p2, target)
    1:         self.assertSameSet(p2 & f1, target)
    1:         self.assertSameSet(f1 & l2, target)
       
    1:         target = r1 | r2
    1:         self.assertSameSet(f1 | f2, target)
    1:         self.assertSameSet(f1 | r2, target)
    1:         self.assertSameSet(r2 | f1, target)
    1:         self.assertSameSet(f1 | p2, target)
    1:         self.assertSameSet(p2 | f1, target)
    1:         self.assertSameSet(f1 | l2, target)
       
    1:         fwd_target = r1 - r2
    1:         rev_target = r2 - r1
    1:         self.assertSameSet(f1 - f2, fwd_target)
    1:         self.assertSameSet(f2 - f1, rev_target)
    1:         self.assertSameSet(f1 - r2, fwd_target)
    1:         self.assertSameSet(f2 - r1, rev_target)
    1:         self.assertSameSet(r1 - f2, fwd_target)
    1:         self.assertSameSet(r2 - f1, rev_target)
    1:         self.assertSameSet(f1 - p2, fwd_target)
    1:         self.assertSameSet(f2 - p1, rev_target)
    1:         self.assertSameSet(p1 - f2, fwd_target)
    1:         self.assertSameSet(p2 - f1, rev_target)
    1:         self.assertSameSet(f1 - l2, fwd_target)
    1:         self.assertSameSet(f2 - l1, rev_target)
       
    1:         target = r1 ^ r2
    1:         self.assertSameSet(f1 ^ f2, target)
    1:         self.assertSameSet(f1 ^ r2, target)
    1:         self.assertSameSet(r2 ^ f1, target)
    1:         self.assertSameSet(f1 ^ p2, target)
    1:         self.assertSameSet(p2 ^ f1, target)
    1:         self.assertSameSet(f1 ^ l2, target)
       
               # proper subset
    1:         self.assertTrue(f1 < f3)
    1:         self.assertFalse(f1 < f1)
    1:         self.assertFalse(f1 < f2)
    1:         self.assertTrue(r1 < f3)
    1:         self.assertFalse(r1 < f1)
    1:         self.assertFalse(r1 < f2)
    1:         self.assertTrue(r1 < r3)
    1:         self.assertFalse(r1 < r1)
    1:         self.assertFalse(r1 < r2)
       
    1:         with test_support.check_py3k_warnings():
                   # python 2 only, cross-type compares will succeed
    1:             f1 < l3
    1:             f1 < l1
    1:             f1 < l2
       
               # any subset
    1:         self.assertTrue(f1 <= f3)
    1:         self.assertTrue(f1 <= f1)
    1:         self.assertFalse(f1 <= f2)
    1:         self.assertTrue(r1 <= f3)
    1:         self.assertTrue(r1 <= f1)
    1:         self.assertFalse(r1 <= f2)
    1:         self.assertTrue(r1 <= r3)
    1:         self.assertTrue(r1 <= r1)
    1:         self.assertFalse(r1 <= r2)
       
    1:         with test_support.check_py3k_warnings():
                   # python 2 only, cross-type compares will succeed
    1:             f1 <= l3
    1:             f1 <= l1
    1:             f1 <= l2
       
               # proper superset
    1:         self.assertTrue(f3 > f1)
    1:         self.assertFalse(f1 > f1)
    1:         self.assertFalse(f2 > f1)
    1:         self.assertTrue(r3 > r1)
    1:         self.assertFalse(f1 > r1)
    1:         self.assertFalse(f2 > r1)
    1:         self.assertTrue(r3 > r1)
    1:         self.assertFalse(r1 > r1)
    1:         self.assertFalse(r2 > r1)
       
    1:         with test_support.check_py3k_warnings():
                   # python 2 only, cross-type compares will succeed
    1:             f1 > l3
    1:             f1 > l1
    1:             f1 > l2
       
               # any superset
    1:         self.assertTrue(f3 >= f1)
    1:         self.assertTrue(f1 >= f1)
    1:         self.assertFalse(f2 >= f1)
    1:         self.assertTrue(r3 >= r1)
    1:         self.assertTrue(f1 >= r1)
    1:         self.assertFalse(f2 >= r1)
    1:         self.assertTrue(r3 >= r1)
    1:         self.assertTrue(r1 >= r1)
    1:         self.assertFalse(r2 >= r1)
       
    1:         with test_support.check_py3k_warnings():
                   # python 2 only, cross-type compares will succeed
    1:             f1 >= l3
    1:             f1 >=l1
    1:             f1 >= l2
       
               # equality
    1:         self.assertTrue(f1 == f1)
    1:         self.assertTrue(r1 == f1)
    1:         self.assertTrue(f1 == r1)
    1:         self.assertFalse(f1 == f3)
    1:         self.assertFalse(r1 == f3)
    1:         self.assertFalse(f1 == r3)
               # python 2 only, cross-type compares will succeed
    1:         f1 == l3
    1:         f1 == l1
    1:         f1 == l2
       
               # inequality
    1:         self.assertFalse(f1 != f1)
    1:         self.assertFalse(r1 != f1)
    1:         self.assertFalse(f1 != r1)
    1:         self.assertTrue(f1 != f3)
    1:         self.assertTrue(r1 != f3)
    1:         self.assertTrue(f1 != r3)
               # python 2 only, cross-type compares will succeed
    1:         f1 != l3
    1:         f1 != l1
    1:         f1 != l2
       
    1:     def test_Mapping(self):
    2:         for sample in [dict]:
    1:             self.assertIsInstance(sample(), Mapping)
    1:             self.assertTrue(issubclass(sample, Mapping))
    1:         self.validate_abstract_methods(Mapping, '__contains__', '__iter__', '__len__',
    1:             '__getitem__')
    2:         class MyMapping(Mapping):
    1:             def __len__(self):
>>>>>>                 return 0
    1:             def __getitem__(self, i):
>>>>>>                 raise IndexError
    1:             def __iter__(self):
>>>>>>                 return iter(())
    1:         self.validate_comparison(MyMapping())
       
    1:     def test_MutableMapping(self):
    2:         for sample in [dict]:
    1:             self.assertIsInstance(sample(), MutableMapping)
    1:             self.assertTrue(issubclass(sample, MutableMapping))
    1:         self.validate_abstract_methods(MutableMapping, '__contains__', '__iter__', '__len__',
    1:             '__getitem__', '__setitem__', '__delitem__')
       
    1:     def test_Sequence(self):
    4:         for sample in [tuple, list, str]:
    3:             self.assertIsInstance(sample(), Sequence)
    3:             self.assertTrue(issubclass(sample, Sequence))
    1:         self.assertTrue(issubclass(basestring, Sequence))
    1:         self.assertIsInstance(range(10), Sequence)
    1:         self.assertTrue(issubclass(xrange, Sequence))
    1:         self.assertTrue(issubclass(str, Sequence))
    1:         self.validate_abstract_methods(Sequence, '__contains__', '__iter__', '__len__',
    1:             '__getitem__')
       
    1:     def test_MutableSequence(self):
    3:         for sample in [tuple, str]:
    2:             self.assertNotIsInstance(sample(), MutableSequence)
    2:             self.assertFalse(issubclass(sample, MutableSequence))
    2:         for sample in [list]:
    1:             self.assertIsInstance(sample(), MutableSequence)
    1:             self.assertTrue(issubclass(sample, MutableSequence))
    1:         self.assertFalse(issubclass(basestring, MutableSequence))
    1:         self.validate_abstract_methods(MutableSequence, '__contains__', '__iter__',
    1:             '__len__', '__getitem__', '__setitem__', '__delitem__', 'insert')
       
    2: class TestCounter(unittest.TestCase):
       
    1:     def test_basics(self):
    1:         c = Counter('abcaba')
    1:         self.assertEqual(c, Counter({'a':3 , 'b': 2, 'c': 1}))
    1:         self.assertEqual(c, Counter(a=3, b=2, c=1))
    1:         self.assertIsInstance(c, dict)
    1:         self.assertIsInstance(c, Mapping)
    1:         self.assertTrue(issubclass(Counter, dict))
    1:         self.assertTrue(issubclass(Counter, Mapping))
    1:         self.assertEqual(len(c), 3)
    1:         self.assertEqual(sum(c.values()), 6)
    1:         self.assertEqual(sorted(c.values()), [1, 2, 3])
    1:         self.assertEqual(sorted(c.keys()), ['a', 'b', 'c'])
    1:         self.assertEqual(sorted(c), ['a', 'b', 'c'])
    1:         self.assertEqual(sorted(c.items()),
    1:                          [('a', 3), ('b', 2), ('c', 1)])
    1:         self.assertEqual(c['b'], 2)
    1:         self.assertEqual(c['z'], 0)
    1:         with test_support.check_py3k_warnings():
    1:             self.assertEqual(c.has_key('c'), True)
    1:             self.assertEqual(c.has_key('z'), False)
    1:         self.assertEqual(c.__contains__('c'), True)
    1:         self.assertEqual(c.__contains__('z'), False)
    1:         self.assertEqual(c.get('b', 10), 2)
    1:         self.assertEqual(c.get('z', 10), 10)
    1:         self.assertEqual(c, dict(a=3, b=2, c=1))
    1:         self.assertEqual(repr(c), "Counter({'a': 3, 'b': 2, 'c': 1})")
    1:         self.assertEqual(c.most_common(), [('a', 3), ('b', 2), ('c', 1)])
    6:         for i in range(5):
    5:             self.assertEqual(c.most_common(i),
    5:                              [('a', 3), ('b', 2), ('c', 1)][:i])
    1:         self.assertEqual(''.join(sorted(c.elements())), 'aaabbc')
    1:         c['a'] += 1         # increment an existing value
    1:         c['b'] -= 2         # sub existing value to zero
    1:         del c['c']          # remove an entry
    1:         del c['c']          # make sure that del doesn't raise KeyError
    1:         c['d'] -= 2         # sub from a missing value
    1:         c['e'] = -5         # directly assign a missing value
    1:         c['f'] += 4         # add to a missing value
    1:         self.assertEqual(c, dict(a=4, b=0, d=-2, e=-5, f=4))
    1:         self.assertEqual(''.join(sorted(c.elements())), 'aaaaffff')
    1:         self.assertEqual(c.pop('f'), 4)
    1:         self.assertNotIn('f', c)
    4:         for i in range(3):
    3:             elem, cnt = c.popitem()
    3:             self.assertNotIn(elem, c)
    1:         c.clear()
    1:         self.assertEqual(c, {})
    1:         self.assertEqual(repr(c), 'Counter()')
    1:         self.assertRaises(NotImplementedError, Counter.fromkeys, 'abc')
    1:         self.assertRaises(TypeError, hash, c)
    1:         c.update(dict(a=5, b=3))
    1:         c.update(c=1)
    1:         c.update(Counter('a' * 50 + 'b' * 30))
    1:         c.update()          # test case with no args
    1:         c.__init__('a' * 500 + 'b' * 300)
    1:         c.__init__('cdc')
    1:         c.__init__()
    1:         self.assertEqual(c, dict(a=555, b=333, c=3, d=1))
    1:         self.assertEqual(c.setdefault('d', 5), 1)
    1:         self.assertEqual(c['d'], 1)
    1:         self.assertEqual(c.setdefault('e', 5), 5)
    1:         self.assertEqual(c['e'], 5)
       
    1:     def test_init(self):
    1:         self.assertEqual(list(Counter(self=42).items()), [('self', 42)])
    1:         self.assertEqual(list(Counter(iterable=42).items()), [('iterable', 42)])
    1:         self.assertEqual(list(Counter(iterable=None).items()), [('iterable', None)])
    1:         self.assertRaises(TypeError, Counter, 42)
    1:         self.assertRaises(TypeError, Counter, (), ())
    1:         self.assertRaises(TypeError, Counter.__init__)
       
    1:     def test_update(self):
    1:         c = Counter()
    1:         c.update(self=42)
    1:         self.assertEqual(list(c.items()), [('self', 42)])
    1:         c = Counter()
    1:         c.update(iterable=42)
    1:         self.assertEqual(list(c.items()), [('iterable', 42)])
    1:         c = Counter()
    1:         c.update(iterable=None)
    1:         self.assertEqual(list(c.items()), [('iterable', None)])
    1:         self.assertRaises(TypeError, Counter().update, 42)
    1:         self.assertRaises(TypeError, Counter().update, {}, {})
    1:         self.assertRaises(TypeError, Counter.update)
       
    1:     def test_copying(self):
               # Check that counters are copyable, deepcopyable, picklable, and
               #have a repr/eval round-trip
    1:         words = Counter('which witch had which witches wrist watch'.split())
    1:         update_test = Counter()
    1:         update_test.update(words)
    1:         for i, dup in enumerate([
    1:                     words.copy(),
    1:                     copy.copy(words),
    1:                     copy.deepcopy(words),
    1:                     pickle.loads(pickle.dumps(words, 0)),
    1:                     pickle.loads(pickle.dumps(words, 1)),
    1:                     pickle.loads(pickle.dumps(words, 2)),
    1:                     pickle.loads(pickle.dumps(words, -1)),
    1:                     cPickle.loads(cPickle.dumps(words, 0)),
    1:                     cPickle.loads(cPickle.dumps(words, 1)),
    1:                     cPickle.loads(cPickle.dumps(words, 2)),
    1:                     cPickle.loads(cPickle.dumps(words, -1)),
    1:                     eval(repr(words)),
    1:                     update_test,
   15:                     Counter(words),
                           ]):
   14:             msg = (i, dup, words)
   14:             self.assertTrue(dup is not words)
   14:             self.assertEqual(dup, words)
   14:             self.assertEqual(len(dup), len(words))
   14:             self.assertEqual(type(dup), type(words))
       
    1:     def test_copy_subclass(self):
    2:         class MyCounter(Counter):
    1:             pass
    1:         c = MyCounter('slartibartfast')
    1:         d = c.copy()
    1:         self.assertEqual(d, c)
    1:         self.assertEqual(len(d), len(c))
    1:         self.assertEqual(type(d), type(c))
       
    1:     def test_conversions(self):
               # Convert to: set, list, dict
    1:         s = 'she sells sea shells by the sea shore'
    1:         self.assertEqual(sorted(Counter(s).elements()), sorted(s))
    1:         self.assertEqual(sorted(Counter(s)), sorted(set(s)))
    1:         self.assertEqual(dict(Counter(s)), dict(Counter(s).items()))
    1:         self.assertEqual(set(Counter(s)), set(s))
       
    1:     def test_invariant_for_the_in_operator(self):
    1:         c = Counter(a=10, b=-2, c=0)
    4:         for elem in c:
    3:             self.assertTrue(elem in c)
    3:             self.assertIn(elem, c)
       
    1:     def test_multiset_operations(self):
               # Verify that adding a zero counter will strip zeros and negatives
    1:         c = Counter(a=10, b=-2, c=0) + Counter()
    1:         self.assertEqual(dict(c), dict(a=10))
       
    1:         elements = 'abcd'
 1001:         for i in range(1000):
                   # test random pairs of multisets
 6000:             p = Counter(dict((elem, randrange(-2,4)) for elem in elements))
 1000:             p.update(e=1, f=-1, g=0)
 6000:             q = Counter(dict((elem, randrange(-2,4)) for elem in elements))
 1000:             q.update(h=1, i=-1, j=0)
 1000:             for counterop, numberop in [
 5000:                 (Counter.__add__, lambda x, y: max(0, x+y)),
 5000:                 (Counter.__sub__, lambda x, y: max(0, x-y)),
 5000:                 (Counter.__or__, lambda x, y: max(0,x,y)),
 9000:                 (Counter.__and__, lambda x, y: max(0, min(x,y))),
                   ]:
 4000:                 result = counterop(p, q)
20000:                 for x in elements:
16000:                     self.assertEqual(numberop(p[x], q[x]), result[x],
16000:                                      (counterop, x, p, q))
                       # verify that results exclude non-positive counts
 4000:                 self.assertTrue(x>0 for x in result.values())
       
    1:         elements = 'abcdef'
  101:         for i in range(100):
                   # verify that random multisets with no repeats are exactly like sets
  800:             p = Counter(dict((elem, randrange(0, 2)) for elem in elements))
  800:             q = Counter(dict((elem, randrange(0, 2)) for elem in elements))
  100:             for counterop, setop in [
  100:                 (Counter.__sub__, set.__sub__),
  100:                 (Counter.__or__, set.__or__),
  400:                 (Counter.__and__, set.__and__),
                   ]:
  300:                 counter_result = counterop(p, q)
  300:                 set_result = setop(set(p.elements()), set(q.elements()))
  300:                 self.assertEqual(counter_result, dict.fromkeys(set_result, 1))
       
    1:     def test_subtract(self):
    1:         c = Counter(a=-5, b=0, c=5, d=10, e=15,g=40)
    1:         c.subtract(a=1, b=2, c=-3, d=10, e=20, f=30, h=-50)
    1:         self.assertEqual(c, Counter(a=-6, b=-2, c=8, d=0, e=-5, f=-30, g=40, h=50))
    1:         c = Counter(a=-5, b=0, c=5, d=10, e=15,g=40)
    1:         c.subtract(Counter(a=1, b=2, c=-3, d=10, e=20, f=30, h=-50))
    1:         self.assertEqual(c, Counter(a=-6, b=-2, c=8, d=0, e=-5, f=-30, g=40, h=50))
    1:         c = Counter('aaabbcd')
    1:         c.subtract('aaaabbcce')
    1:         self.assertEqual(c, Counter(a=-1, b=0, c=-1, d=1, e=-1))
       
    1:         c = Counter()
    1:         c.subtract(self=42)
    1:         self.assertEqual(list(c.items()), [('self', -42)])
    1:         c = Counter()
    1:         c.subtract(iterable=42)
    1:         self.assertEqual(list(c.items()), [('iterable', -42)])
    1:         self.assertRaises(TypeError, Counter().subtract, 42)
    1:         self.assertRaises(TypeError, Counter().subtract, {}, {})
    1:         self.assertRaises(TypeError, Counter.subtract)
       
       
    1: def test_main(verbose=None):
    1:     NamedTupleDocs = doctest.DocTestSuite(module=collections)
    1:     test_classes = [TestNamedTuple, NamedTupleDocs, TestOneTrickPonyABCs,
    1:                     TestCollectionABCs, TestCounter]
    1:     test_support.run_unittest(*test_classes)
    1:     test_support.run_doctest(collections, verbose)
       
    1: if __name__ == "__main__":
>>>>>>     test_main(verbose=True)
