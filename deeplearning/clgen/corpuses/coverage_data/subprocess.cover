       # subprocess - Subprocesses with accessible I/O streams
       #
       # For more information about this module, see PEP 324.
       #
       # Copyright (c) 2003-2005 by Peter Astrand <astrand@lysator.liu.se>
       #
       # Licensed to PSF under a Contributor Agreement.
       # See http://www.python.org/2.4/license for licensing details.
       
       r"""Subprocesses with accessible I/O streams
       
       This module allows you to spawn processes, connect to their
       input/output/error pipes, and obtain their return codes.
       
       For a complete description of this module see the Python documentation.
       
       Main API
       ========
       call(...): Runs a command, waits for it to complete, then returns
           the return code.
       check_call(...): Same as call() but raises CalledProcessError()
           if return code is not 0
       check_output(...): Same as check_call() but returns the contents of
           stdout instead of a return code
       Popen(...): A class for flexibly executing a command in a new process
       
       Constants
       ---------
       PIPE:    Special value that indicates a pipe should be created
       STDOUT:  Special value that indicates that stderr should go to stdout
>>>>>> """
       
>>>>>> import sys
>>>>>> mswindows = (sys.platform == "win32")
       
>>>>>> import os
>>>>>> import types
>>>>>> import traceback
>>>>>> import gc
>>>>>> import signal
>>>>>> import errno
       
       # Exception classes used by this module.
>>>>>> class CalledProcessError(Exception):
           """This exception is raised when a process run by check_call() or
           check_output() returns a non-zero exit status.
       
           Attributes:
             cmd, returncode, output
           """
>>>>>>     def __init__(self, returncode, cmd, output=None):
    4:         self.returncode = returncode
    4:         self.cmd = cmd
    4:         self.output = output
>>>>>>     def __str__(self):
>>>>>>         return "Command '%s' returned non-zero exit status %d" % (self.cmd, self.returncode)
       
       
>>>>>> if mswindows:
>>>>>>     import threading
>>>>>>     import msvcrt
>>>>>>     import _subprocess
>>>>>>     class STARTUPINFO:
>>>>>>         dwFlags = 0
>>>>>>         hStdInput = None
>>>>>>         hStdOutput = None
>>>>>>         hStdError = None
>>>>>>         wShowWindow = 0
>>>>>>     class pywintypes:
>>>>>>         error = IOError
       else:
>>>>>>     import select
>>>>>>     _has_poll = hasattr(select, 'poll')
>>>>>>     import fcntl
>>>>>>     import pickle
       
           # When select or poll has indicated that the file is writable,
           # we can write up to _PIPE_BUF bytes without risk of blocking.
           # POSIX defines PIPE_BUF as >= 512.
>>>>>>     _PIPE_BUF = getattr(select, 'PIPE_BUF', 512)
       
       
>>>>>> __all__ = ["Popen", "PIPE", "STDOUT", "call", "check_call",
>>>>>>            "check_output", "CalledProcessError"]
       
>>>>>> if mswindows:
>>>>>>     from _subprocess import (CREATE_NEW_CONSOLE, CREATE_NEW_PROCESS_GROUP,
                                    STD_INPUT_HANDLE, STD_OUTPUT_HANDLE,
                                    STD_ERROR_HANDLE, SW_HIDE,
                                    STARTF_USESTDHANDLES, STARTF_USESHOWWINDOW)
       
>>>>>>     __all__.extend(["CREATE_NEW_CONSOLE", "CREATE_NEW_PROCESS_GROUP",
>>>>>>                     "STD_INPUT_HANDLE", "STD_OUTPUT_HANDLE",
>>>>>>                     "STD_ERROR_HANDLE", "SW_HIDE",
>>>>>>                     "STARTF_USESTDHANDLES", "STARTF_USESHOWWINDOW"])
>>>>>> try:
>>>>>>     MAXFD = os.sysconf("SC_OPEN_MAX")
>>>>>> except:
>>>>>>     MAXFD = 256
       
>>>>>> _active = []
       
>>>>>> def _cleanup():
 2750:     for inst in _active[:]:
    8:         res = inst._internal_poll(_deadstate=sys.maxint)
    8:         if res is not None:
    8:             try:
    8:                 _active.remove(inst)
>>>>>>             except ValueError:
                       # This can happen if two threads create a new Popen instance.
                       # It's harmless that it was already removed, so ignore.
>>>>>>                 pass
       
>>>>>> PIPE = -1
>>>>>> STDOUT = -2
       
       
>>>>>> def _eintr_retry_call(func, *args):
 7034:     while True:
 7034:         try:
 7034:             return func(*args)
    1:         except (OSError, IOError) as e:
    1:             if e.errno == errno.EINTR:
    1:                 continue
>>>>>>             raise
       
       
       # XXX This function is only used by multiprocessing and the test suite,
       # but it's here so that it can be imported when Python is compiled without
       # threads.
       
>>>>>> def _args_from_interpreter_flags():
           """Return a list of command-line arguments reproducing the current
           settings in sys.flags and sys.warnoptions."""
>>>>>>     flag_opt_map = {
>>>>>>         'debug': 'd',
               # 'inspect': 'i',
               # 'interactive': 'i',
>>>>>>         'optimize': 'O',
>>>>>>         'dont_write_bytecode': 'B',
>>>>>>         'no_user_site': 's',
>>>>>>         'no_site': 'S',
>>>>>>         'ignore_environment': 'E',
>>>>>>         'verbose': 'v',
>>>>>>         'bytes_warning': 'b',
>>>>>>         'py3k_warning': '3',
           }
>>>>>>     args = []
>>>>>>     for flag, opt in flag_opt_map.items():
>>>>>>         v = getattr(sys.flags, flag)
>>>>>>         if v > 0:
>>>>>>             args.append('-' + opt * v)
>>>>>>     if getattr(sys.flags, 'hash_randomization') != 0:
>>>>>>         args.append('-R')
>>>>>>     for opt in sys.warnoptions:
>>>>>>         args.append('-W' + opt)
>>>>>>     return args
       
       
>>>>>> def call(*popenargs, **kwargs):
           """Run command with arguments.  Wait for command to complete, then
           return the returncode attribute.
       
           The arguments are the same as for the Popen constructor.  Example:
       
           retcode = call(["ls", "-l"])
           """
   29:     return Popen(*popenargs, **kwargs).wait()
       
       
>>>>>> def check_call(*popenargs, **kwargs):
           """Run command with arguments.  Wait for command to complete.  If
           the exit code was zero then return, otherwise raise
           CalledProcessError.  The CalledProcessError object will have the
           return code in the returncode attribute.
       
           The arguments are the same as for the Popen constructor.  Example:
       
           check_call(["ls", "-l"])
           """
    9:     retcode = call(*popenargs, **kwargs)
    9:     if retcode:
    2:         cmd = kwargs.get("args")
    2:         if cmd is None:
    2:             cmd = popenargs[0]
    2:         raise CalledProcessError(retcode, cmd)
    7:     return 0
       
       
>>>>>> def check_output(*popenargs, **kwargs):
           r"""Run command with arguments and return its output as a byte string.
       
           If the exit code was non-zero it raises a CalledProcessError.  The
           CalledProcessError object will have the return code in the returncode
           attribute and output in the output attribute.
       
           The arguments are the same as for the Popen constructor.  Example:
       
           >>> check_output(["ls", "-l", "/dev/null"])
           'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
       
           The stdout argument is not allowed as it is used internally.
           To capture standard error in the result, use stderr=STDOUT.
       
           >>> check_output(["/bin/sh", "-c",
           ...               "ls -l non_existent_file ; exit 0"],
           ...              stderr=STDOUT)
           'ls: non_existent_file: No such file or directory\n'
           """
   10:     if 'stdout' in kwargs:
    2:         raise ValueError('stdout argument not allowed, it will be overridden.')
    8:     process = Popen(stdout=PIPE, *popenargs, **kwargs)
    8:     output, unused_err = process.communicate()
    8:     retcode = process.poll()
    8:     if retcode:
    2:         cmd = kwargs.get("args")
    2:         if cmd is None:
    2:             cmd = popenargs[0]
    2:         raise CalledProcessError(retcode, cmd, output=output)
    6:     return output
       
       
>>>>>> def list2cmdline(seq):
           """
           Translate a sequence of arguments into a command line
           string, using the same rules as the MS C runtime:
       
           1) Arguments are delimited by white space, which is either a
              space or a tab.
       
           2) A string surrounded by double quotation marks is
              interpreted as a single argument, regardless of white space
              contained within.  A quoted string can be embedded in an
              argument.
       
           3) A double quotation mark preceded by a backslash is
              interpreted as a literal double quotation mark.
       
           4) Backslashes are interpreted literally, unless they
              immediately precede a double quotation mark.
       
           5) If backslashes immediately precede a double quotation mark,
              every pair of backslashes is interpreted as a literal
              backslash.  If the number of backslashes is odd, the last
              backslash escapes the next double quotation mark as
              described in rule 3.
           """
       
           # See
           # http://msdn.microsoft.com/en-us/library/17w5ykft.aspx
           # or search http://msdn.microsoft.com for
           # "Parsing C++ Command-Line Arguments"
   16:     result = []
   16:     needquote = False
   62:     for arg in seq:
   46:         bs_buf = []
       
               # Add a space to separate this argument from the others
   46:         if result:
   30:             result.append(' ')
       
   46:         needquote = (" " in arg) or ("\t" in arg) or not arg
   46:         if needquote:
   12:             result.append('"')
       
  158:         for c in arg:
  112:             if c == '\\':
                       # Don't know if we need to double yet.
   22:                 bs_buf.append(c)
   90:             elif c == '"':
                       # Double backslashes.
    6:                 result.append('\\' * len(bs_buf)*2)
    6:                 bs_buf = []
    6:                 result.append('\\"')
                   else:
                       # Normal char
   84:                 if bs_buf:
    8:                     result.extend(bs_buf)
    8:                     bs_buf = []
   84:                 result.append(c)
       
               # Add remaining backslashes, if any.
   46:         if bs_buf:
    4:             result.extend(bs_buf)
       
   46:         if needquote:
   12:             result.extend(bs_buf)
   12:             result.append('"')
       
   16:     return ''.join(result)
       
       
>>>>>> class Popen(object):
           """ Execute a child program in a new process.
       
           For a complete description of the arguments see the Python documentation.
       
           Arguments:
             args: A string, or a sequence of program arguments.
       
             bufsize: supplied as the buffering argument to the open() function when
                 creating the stdin/stdout/stderr pipe file objects
       
             executable: A replacement program to execute.
       
             stdin, stdout and stderr: These specify the executed programs' standard
                 input, standard output and standard error file handles, respectively.
       
             preexec_fn: (POSIX only) An object to be called in the child process
                 just before the child is executed.
       
             close_fds: Controls closing or inheriting of file descriptors.
       
             shell: If true, the command will be executed through the shell.
       
             cwd: Sets the current directory before the child is executed.
       
             env: Defines the environment variables for the new process.
       
             universal_newlines: If true, use universal line endings for file
                 objects stdin, stdout and stderr.
       
             startupinfo and creationflags (Windows only)
       
           Attributes:
               stdin, stdout, stderr, pid, returncode
           """
>>>>>>     _child_created = False  # Set here since __del__ checks it
       
>>>>>>     def __init__(self, args, bufsize=0, executable=None,
>>>>>>                  stdin=None, stdout=None, stderr=None,
>>>>>>                  preexec_fn=None, close_fds=False, shell=False,
>>>>>>                  cwd=None, env=None, universal_newlines=False,
>>>>>>                  startupinfo=None, creationflags=0):
               """Create new Popen instance."""
 2479:         _cleanup()
       
 2479:         if not isinstance(bufsize, (int, long)):
    2:             raise TypeError("bufsize must be an integer")
       
 2477:         if mswindows:
>>>>>>             if preexec_fn is not None:
>>>>>>                 raise ValueError("preexec_fn is not supported on Windows "
                                        "platforms")
>>>>>>             if close_fds and (stdin is not None or stdout is not None or
>>>>>>                               stderr is not None):
>>>>>>                 raise ValueError("close_fds is not supported on Windows "
                                        "platforms if you redirect stdin/stdout/stderr")
               else:
                   # POSIX
 2477:             if startupinfo is not None:
    1:                 raise ValueError("startupinfo is only supported on Windows "
                                        "platforms")
 2476:             if creationflags != 0:
    1:                 raise ValueError("creationflags is only supported on Windows "
                                        "platforms")
       
 2475:         self.stdin = None
 2475:         self.stdout = None
 2475:         self.stderr = None
 2475:         self.pid = None
 2475:         self.returncode = None
 2475:         self.universal_newlines = universal_newlines
       
               # Input and output objects. The general principle is like
               # this:
               #
               # Parent                   Child
               # ------                   -----
               # p2cwrite   ---stdin--->  p2cread
               # c2pread    <--stdout---  c2pwrite
               # errread    <--stderr---  errwrite
               #
               # On POSIX, the child objects are file descriptors.  On
               # Windows, these are Windows file handles.  The parent objects
               # are file descriptors on both platforms.  The parent objects
               # are None when not using PIPEs. The child objects are None
               # when not redirecting.
       
               (p2cread, p2cwrite,
                c2pread, c2pwrite,
 2475:          errread, errwrite), to_close = self._get_handles(stdin, stdout, stderr)
       
 2475:         try:
 2475:             self._execute_child(args, executable, preexec_fn, close_fds,
 2475:                                 cwd, env, universal_newlines,
 2475:                                 startupinfo, creationflags, shell, to_close,
 2475:                                 p2cread, p2cwrite,
 2475:                                 c2pread, c2pwrite,
 2475:                                 errread, errwrite)
 2066:         except Exception:
                   # Preserve original exception in case os.close raises.
 2066:             exc_type, exc_value, exc_trace = sys.exc_info()
       
 6175:             for fd in to_close:
 4109:                 try:
 4109:                     if mswindows:
>>>>>>                         fd.Close()
                           else:
 4109:                         os.close(fd)
>>>>>>                 except EnvironmentError:
>>>>>>                     pass
       
 2066:             raise exc_type, exc_value, exc_trace
       
  409:         if mswindows:
>>>>>>             if p2cwrite is not None:
>>>>>>                 p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)
>>>>>>             if c2pread is not None:
>>>>>>                 c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)
>>>>>>             if errread is not None:
>>>>>>                 errread = msvcrt.open_osfhandle(errread.Detach(), 0)
       
  409:         if p2cwrite is not None:
  241:             self.stdin = os.fdopen(p2cwrite, 'wb', bufsize)
  409:         if c2pread is not None:
  338:             if universal_newlines:
   32:                 self.stdout = os.fdopen(c2pread, 'rU', bufsize)
                   else:
  306:                 self.stdout = os.fdopen(c2pread, 'rb', bufsize)
  409:         if errread is not None:
  218:             if universal_newlines:
   29:                 self.stderr = os.fdopen(errread, 'rU', bufsize)
                   else:
  189:                 self.stderr = os.fdopen(errread, 'rb', bufsize)
       
       
>>>>>>     def _translate_newlines(self, data):
   33:         data = data.replace("\r\n", "\n")
   33:         data = data.replace("\r", "\n")
   33:         return data
       
       
>>>>>>     def __del__(self, _maxint=sys.maxint):
               # If __init__ hasn't had a chance to execute (e.g. if it
               # was passed an undeclared keyword argument), we don't
               # have a _child_created attribute at all.
 2350:         if not self._child_created:
                   # We didn't get to successfully create a child process.
    8:             return
               # In case the child hasn't been waited on, check if it's done.
 2342:         self._internal_poll(_deadstate=_maxint)
 2342:         if self.returncode is None and _active is not None:
                   # Child is still running, keep us alive until we can wait on it.
    6:             _active.append(self)
       
       
>>>>>>     def communicate(self, input=None):
               """Interact with process: Send data to stdin.  Read data from
               stdout and stderr, until end-of-file is reached.  Wait for
               process to terminate.  The optional input argument should be a
               string to be sent to the child process, or None, if no data
               should be sent to the child.
       
               communicate() returns a tuple (stdout, stderr)."""
       
               # Optimization: If we are only using one pipe, or no pipe at
               # all, using select() or threads is unnecessary.
  277:         if [self.stdin, self.stdout, self.stderr].count(None) >= 2:
   48:             stdout = None
   48:             stderr = None
   48:             if self.stdin:
    4:                 if input:
    4:                     try:
    4:                         self.stdin.write(input)
    2:                     except IOError as e:
    2:                         if e.errno != errno.EPIPE and e.errno != errno.EINVAL:
>>>>>>                             raise
    4:                 self.stdin.close()
   44:             elif self.stdout:
   40:                 stdout = _eintr_retry_call(self.stdout.read)
   40:                 self.stdout.close()
    4:             elif self.stderr:
    2:                 stderr = _eintr_retry_call(self.stderr.read)
    2:                 self.stderr.close()
   48:             self.wait()
   48:             return (stdout, stderr)
       
  229:         return self._communicate(input)
       
       
>>>>>>     def poll(self):
               """Check if child process has terminated. Set and return returncode
               attribute."""
   43:         return self._internal_poll()
       
       
>>>>>>     if mswindows:
               #
               # Windows methods
               #
>>>>>>         def _get_handles(self, stdin, stdout, stderr):
                   """Construct and return tuple with IO objects:
                   p2cread, p2cwrite, c2pread, c2pwrite, errread, errwrite
                   """
>>>>>>             to_close = set()
>>>>>>             if stdin is None and stdout is None and stderr is None:
>>>>>>                 return (None, None, None, None, None, None), to_close
       
>>>>>>             p2cread, p2cwrite = None, None
>>>>>>             c2pread, c2pwrite = None, None
>>>>>>             errread, errwrite = None, None
       
>>>>>>             if stdin is None:
>>>>>>                 p2cread = _subprocess.GetStdHandle(_subprocess.STD_INPUT_HANDLE)
>>>>>>                 if p2cread is None:
>>>>>>                     p2cread, _ = _subprocess.CreatePipe(None, 0)
>>>>>>             elif stdin == PIPE:
>>>>>>                 p2cread, p2cwrite = _subprocess.CreatePipe(None, 0)
>>>>>>             elif isinstance(stdin, (int, long)):
>>>>>>                 p2cread = msvcrt.get_osfhandle(stdin)
                   else:
                       # Assuming file-like object
>>>>>>                 p2cread = msvcrt.get_osfhandle(stdin.fileno())
>>>>>>             p2cread = self._make_inheritable(p2cread)
                   # We just duplicated the handle, it has to be closed at the end
>>>>>>             to_close.add(p2cread)
>>>>>>             if stdin == PIPE:
>>>>>>                 to_close.add(p2cwrite)
       
>>>>>>             if stdout is None:
>>>>>>                 c2pwrite = _subprocess.GetStdHandle(_subprocess.STD_OUTPUT_HANDLE)
>>>>>>                 if c2pwrite is None:
>>>>>>                     _, c2pwrite = _subprocess.CreatePipe(None, 0)
>>>>>>             elif stdout == PIPE:
>>>>>>                 c2pread, c2pwrite = _subprocess.CreatePipe(None, 0)
>>>>>>             elif isinstance(stdout, (int, long)):
>>>>>>                 c2pwrite = msvcrt.get_osfhandle(stdout)
                   else:
                       # Assuming file-like object
>>>>>>                 c2pwrite = msvcrt.get_osfhandle(stdout.fileno())
>>>>>>             c2pwrite = self._make_inheritable(c2pwrite)
                   # We just duplicated the handle, it has to be closed at the end
>>>>>>             to_close.add(c2pwrite)
>>>>>>             if stdout == PIPE:
>>>>>>                 to_close.add(c2pread)
       
>>>>>>             if stderr is None:
>>>>>>                 errwrite = _subprocess.GetStdHandle(_subprocess.STD_ERROR_HANDLE)
>>>>>>                 if errwrite is None:
>>>>>>                     _, errwrite = _subprocess.CreatePipe(None, 0)
>>>>>>             elif stderr == PIPE:
>>>>>>                 errread, errwrite = _subprocess.CreatePipe(None, 0)
>>>>>>             elif stderr == STDOUT:
>>>>>>                 errwrite = c2pwrite
>>>>>>             elif isinstance(stderr, (int, long)):
>>>>>>                 errwrite = msvcrt.get_osfhandle(stderr)
                   else:
                       # Assuming file-like object
>>>>>>                 errwrite = msvcrt.get_osfhandle(stderr.fileno())
>>>>>>             errwrite = self._make_inheritable(errwrite)
                   # We just duplicated the handle, it has to be closed at the end
>>>>>>             to_close.add(errwrite)
>>>>>>             if stderr == PIPE:
>>>>>>                 to_close.add(errread)
       
>>>>>>             return (p2cread, p2cwrite,
>>>>>>                     c2pread, c2pwrite,
>>>>>>                     errread, errwrite), to_close
       
       
>>>>>>         def _make_inheritable(self, handle):
                   """Return a duplicate of handle, which is inheritable"""
>>>>>>             return _subprocess.DuplicateHandle(_subprocess.GetCurrentProcess(),
>>>>>>                                 handle, _subprocess.GetCurrentProcess(), 0, 1,
>>>>>>                                 _subprocess.DUPLICATE_SAME_ACCESS)
       
       
>>>>>>         def _find_w9xpopen(self):
                   """Find and return absolut path to w9xpopen.exe"""
>>>>>>             w9xpopen = os.path.join(
>>>>>>                             os.path.dirname(_subprocess.GetModuleFileName(0)),
>>>>>>                                     "w9xpopen.exe")
>>>>>>             if not os.path.exists(w9xpopen):
                       # Eeek - file-not-found - possibly an embedding
                       # situation - see if we can locate it in sys.exec_prefix
>>>>>>                 w9xpopen = os.path.join(os.path.dirname(sys.exec_prefix),
>>>>>>                                         "w9xpopen.exe")
>>>>>>                 if not os.path.exists(w9xpopen):
>>>>>>                     raise RuntimeError("Cannot locate w9xpopen.exe, which is "
                                              "needed for Popen to work with your "
                                              "shell or platform.")
>>>>>>             return w9xpopen
       
       
>>>>>>         def _execute_child(self, args, executable, preexec_fn, close_fds,
                                  cwd, env, universal_newlines,
                                  startupinfo, creationflags, shell, to_close,
                                  p2cread, p2cwrite,
                                  c2pread, c2pwrite,
                                  errread, errwrite):
                   """Execute program (MS Windows version)"""
       
>>>>>>             if not isinstance(args, types.StringTypes):
>>>>>>                 args = list2cmdline(args)
       
                   # Process startup details
>>>>>>             if startupinfo is None:
>>>>>>                 startupinfo = STARTUPINFO()
>>>>>>             if None not in (p2cread, c2pwrite, errwrite):
>>>>>>                 startupinfo.dwFlags |= _subprocess.STARTF_USESTDHANDLES
>>>>>>                 startupinfo.hStdInput = p2cread
>>>>>>                 startupinfo.hStdOutput = c2pwrite
>>>>>>                 startupinfo.hStdError = errwrite
       
>>>>>>             if shell:
>>>>>>                 startupinfo.dwFlags |= _subprocess.STARTF_USESHOWWINDOW
>>>>>>                 startupinfo.wShowWindow = _subprocess.SW_HIDE
>>>>>>                 comspec = os.environ.get("COMSPEC", "cmd.exe")
>>>>>>                 args = '{} /c "{}"'.format (comspec, args)
>>>>>>                 if (_subprocess.GetVersion() >= 0x80000000 or
>>>>>>                         os.path.basename(comspec).lower() == "command.com"):
                           # Win9x, or using command.com on NT. We need to
                           # use the w9xpopen intermediate program. For more
                           # information, see KB Q150956
                           # (http://web.archive.org/web/20011105084002/http://support.microsoft.com/support/kb/articles/Q150/9/56.asp)
>>>>>>                     w9xpopen = self._find_w9xpopen()
>>>>>>                     args = '"%s" %s' % (w9xpopen, args)
                           # Not passing CREATE_NEW_CONSOLE has been known to
                           # cause random failures on win9x.  Specifically a
                           # dialog: "Your program accessed mem currently in
                           # use at xxx" and a hopeful warning about the
                           # stability of your system.  Cost is Ctrl+C wont
                           # kill children.
>>>>>>                     creationflags |= _subprocess.CREATE_NEW_CONSOLE
       
>>>>>>             def _close_in_parent(fd):
>>>>>>                 fd.Close()
>>>>>>                 to_close.remove(fd)
       
                   # Start the process
>>>>>>             try:
>>>>>>                 hp, ht, pid, tid = _subprocess.CreateProcess(executable, args,
                                                # no special security
>>>>>>                                          None, None,
>>>>>>                                          int(not close_fds),
>>>>>>                                          creationflags,
>>>>>>                                          env,
>>>>>>                                          cwd,
>>>>>>                                          startupinfo)
>>>>>>             except pywintypes.error, e:
                       # Translate pywintypes.error to WindowsError, which is
                       # a subclass of OSError.  FIXME: We should really
                       # translate errno using _sys_errlist (or similar), but
                       # how can this be done from Python?
>>>>>>                 raise WindowsError(*e.args)
                   finally:
                       # Child is launched. Close the parent's copy of those pipe
                       # handles that only the child should have open.  You need
                       # to make sure that no handles to the write end of the
                       # output pipe are maintained in this process or else the
                       # pipe will not close when the child process exits and the
                       # ReadFile will hang.
>>>>>>                 if p2cread is not None:
>>>>>>                     _close_in_parent(p2cread)
>>>>>>                 if c2pwrite is not None:
>>>>>>                     _close_in_parent(c2pwrite)
>>>>>>                 if errwrite is not None:
>>>>>>                     _close_in_parent(errwrite)
       
                   # Retain the process handle, but close the thread handle
>>>>>>             self._child_created = True
>>>>>>             self._handle = hp
>>>>>>             self.pid = pid
>>>>>>             ht.Close()
       
>>>>>>         def _internal_poll(self, _deadstate=None,
>>>>>>                 _WaitForSingleObject=_subprocess.WaitForSingleObject,
>>>>>>                 _WAIT_OBJECT_0=_subprocess.WAIT_OBJECT_0,
>>>>>>                 _GetExitCodeProcess=_subprocess.GetExitCodeProcess):
                   """Check if child process has terminated.  Returns returncode
                   attribute.
       
                   This method is called by __del__, so it can only refer to objects
                   in its local scope.
       
                   """
>>>>>>             if self.returncode is None:
>>>>>>                 if _WaitForSingleObject(self._handle, 0) == _WAIT_OBJECT_0:
>>>>>>                     self.returncode = _GetExitCodeProcess(self._handle)
>>>>>>             return self.returncode
       
       
>>>>>>         def wait(self):
                   """Wait for child process to terminate.  Returns returncode
                   attribute."""
>>>>>>             if self.returncode is None:
>>>>>>                 _subprocess.WaitForSingleObject(self._handle,
>>>>>>                                                 _subprocess.INFINITE)
>>>>>>                 self.returncode = _subprocess.GetExitCodeProcess(self._handle)
>>>>>>             return self.returncode
       
       
>>>>>>         def _readerthread(self, fh, buffer):
>>>>>>             buffer.append(fh.read())
       
       
>>>>>>         def _communicate(self, input):
>>>>>>             stdout = None # Return
>>>>>>             stderr = None # Return
       
>>>>>>             if self.stdout:
>>>>>>                 stdout = []
>>>>>>                 stdout_thread = threading.Thread(target=self._readerthread,
>>>>>>                                                  args=(self.stdout, stdout))
>>>>>>                 stdout_thread.setDaemon(True)
>>>>>>                 stdout_thread.start()
>>>>>>             if self.stderr:
>>>>>>                 stderr = []
>>>>>>                 stderr_thread = threading.Thread(target=self._readerthread,
>>>>>>                                                  args=(self.stderr, stderr))
>>>>>>                 stderr_thread.setDaemon(True)
>>>>>>                 stderr_thread.start()
       
>>>>>>             if self.stdin:
>>>>>>                 if input is not None:
>>>>>>                     try:
>>>>>>                         self.stdin.write(input)
>>>>>>                     except IOError as e:
>>>>>>                         if e.errno == errno.EPIPE:
                                   # communicate() should ignore broken pipe error
>>>>>>                             pass
>>>>>>                         elif e.errno == errno.EINVAL:
                                   # bpo-19612, bpo-30418: On Windows, stdin.write()
                                   # fails with EINVAL if the child process exited or
                                   # if the child process is still running but closed
                                   # the pipe.
>>>>>>                             pass
                               else:
>>>>>>                             raise
>>>>>>                 self.stdin.close()
       
>>>>>>             if self.stdout:
>>>>>>                 stdout_thread.join()
>>>>>>             if self.stderr:
>>>>>>                 stderr_thread.join()
       
                   # All data exchanged.  Translate lists into strings.
>>>>>>             if stdout is not None:
>>>>>>                 stdout = stdout[0]
>>>>>>             if stderr is not None:
>>>>>>                 stderr = stderr[0]
       
                   # Translate newlines, if requested.  We cannot let the file
                   # object do the translation: It is based on stdio, which is
                   # impossible to combine with select (unless forcing no
                   # buffering).
>>>>>>             if self.universal_newlines and hasattr(file, 'newlines'):
>>>>>>                 if stdout:
>>>>>>                     stdout = self._translate_newlines(stdout)
>>>>>>                 if stderr:
>>>>>>                     stderr = self._translate_newlines(stderr)
       
>>>>>>             self.wait()
>>>>>>             return (stdout, stderr)
       
>>>>>>         def send_signal(self, sig):
                   """Send a signal to the process
                   """
>>>>>>             if sig == signal.SIGTERM:
>>>>>>                 self.terminate()
>>>>>>             elif sig == signal.CTRL_C_EVENT:
>>>>>>                 os.kill(self.pid, signal.CTRL_C_EVENT)
>>>>>>             elif sig == signal.CTRL_BREAK_EVENT:
>>>>>>                 os.kill(self.pid, signal.CTRL_BREAK_EVENT)
                   else:
>>>>>>                 raise ValueError("Unsupported signal: {}".format(sig))
       
>>>>>>         def terminate(self):
                   """Terminates the process
                   """
>>>>>>             try:
>>>>>>                 _subprocess.TerminateProcess(self._handle, 1)
>>>>>>             except OSError as e:
                       # ERROR_ACCESS_DENIED (winerror 5) is received when the
                       # process already died.
>>>>>>                 if e.winerror != 5:
>>>>>>                     raise
>>>>>>                 rc = _subprocess.GetExitCodeProcess(self._handle)
>>>>>>                 if rc == _subprocess.STILL_ACTIVE:
>>>>>>                     raise
>>>>>>                 self.returncode = rc
       
>>>>>>         kill = terminate
       
           else:
               #
               # POSIX methods
               #
>>>>>>         def _get_handles(self, stdin, stdout, stderr):
                   """Construct and return tuple with IO objects:
                   p2cread, p2cwrite, c2pread, c2pwrite, errread, errwrite
                   """
 2475:             to_close = set()
 2475:             p2cread, p2cwrite = None, None
 2475:             c2pread, c2pwrite = None, None
 2475:             errread, errwrite = None, None
       
 2475:             if stdin is None:
 2212:                 pass
  263:             elif stdin == PIPE:
  244:                 p2cread, p2cwrite = self.pipe_cloexec()
  244:                 to_close.update((p2cread, p2cwrite))
   19:             elif isinstance(stdin, (int, long)):
   17:                 p2cread = stdin
                   else:
                       # Assuming file-like object
    2:                 p2cread = stdin.fileno()
       
 2475:             if stdout is None:
   61:                 pass
 2414:             elif stdout == PIPE:
 2391:                 c2pread, c2pwrite = self.pipe_cloexec()
 2391:                 to_close.update((c2pread, c2pwrite))
   23:             elif isinstance(stdout, (int, long)):
   10:                 c2pwrite = stdout
                   else:
                       # Assuming file-like object
   13:                 c2pwrite = stdout.fileno()
       
 2475:             if stderr is None:
  109:                 pass
 2366:             elif stderr == PIPE:
 2271:                 errread, errwrite = self.pipe_cloexec()
 2271:                 to_close.update((errread, errwrite))
   95:             elif stderr == STDOUT:
   79:                 if c2pwrite is not None:
   79:                     errwrite = c2pwrite
                       else: # child's stdout is not set, use parent's stdout
>>>>>>                     errwrite = sys.__stdout__.fileno()
   16:             elif isinstance(stderr, (int, long)):
   10:                 errwrite = stderr
                   else:
                       # Assuming file-like object
    6:                 errwrite = stderr.fileno()
       
 2475:             return (p2cread, p2cwrite,
 2475:                     c2pread, c2pwrite,
 2475:                     errread, errwrite), to_close
       
       
>>>>>>         def _set_cloexec_flag(self, fd, cloexec=True):
14762:             try:
14762:                 cloexec_flag = fcntl.FD_CLOEXEC
>>>>>>             except AttributeError:
>>>>>>                 cloexec_flag = 1
       
14762:             old = fcntl.fcntl(fd, fcntl.F_GETFD)
14762:             if cloexec:
14762:                 fcntl.fcntl(fd, fcntl.F_SETFD, old | cloexec_flag)
                   else:
>>>>>>                 fcntl.fcntl(fd, fcntl.F_SETFD, old & ~cloexec_flag)
       
       
>>>>>>         def pipe_cloexec(self):
                   """Create a pipe with FDs set CLOEXEC."""
                   # Pipes' FDs are set CLOEXEC by default because we don't want them
                   # to be inherited by other subprocesses: the CLOEXEC flag is removed
                   # from the child's FDs by _dup2(), between fork() and exec().
                   # This is not atomic: we would need the pipe2() syscall for that.
 7381:             r, w = os.pipe()
 7381:             self._set_cloexec_flag(r)
 7381:             self._set_cloexec_flag(w)
 7381:             return r, w
       
       
>>>>>>         def _close_fds(self, but):
>>>>>>             if hasattr(os, 'closerange'):
>>>>>>                 os.closerange(3, but)
>>>>>>                 os.closerange(but + 1, MAXFD)
                   else:
>>>>>>                 for i in xrange(3, MAXFD):
>>>>>>                     if i == but:
>>>>>>                         continue
>>>>>>                     try:
>>>>>>                         os.close(i)
>>>>>>                     except:
>>>>>>                         pass
       
       
>>>>>>         def _execute_child(self, args, executable, preexec_fn, close_fds,
                                  cwd, env, universal_newlines,
                                  startupinfo, creationflags, shell, to_close,
                                  p2cread, p2cwrite,
                                  c2pread, c2pwrite,
                                  errread, errwrite):
                   """Execute program (POSIX version)"""
       
 2475:             if isinstance(args, types.StringTypes):
   17:                 args = [args]
                   else:
 2458:                 args = list(args)
       
 2475:             if shell:
   16:                 args = ["/bin/sh", "-c"] + args
   16:                 if executable:
    3:                     args[0] = executable
       
 2475:             if executable is None:
 2467:                 executable = args[0]
       
 2475:             def _close_in_parent(fd):
 4906:                 os.close(fd)
 4906:                 to_close.remove(fd)
       
                   # For transferring possible exec failure from child to parent
                   # The first char specifies the exception type: 0 means
                   # OSError, 1 means some other error.
 2475:             errpipe_read, errpipe_write = self.pipe_cloexec()
 2475:             try:
 2475:                 try:
 2475:                     gc_was_enabled = gc.isenabled()
                           # Disable gc to avoid bug where gc -> file_dealloc ->
                           # write to stderr -> hang.  http://bugs.python.org/issue1336
 2475:                     gc.disable()
 2475:                     try:
 2475:                         self.pid = os.fork()
>>>>>>                     except:
>>>>>>                         if gc_was_enabled:
>>>>>>                             gc.enable()
>>>>>>                         raise
 2475:                     self._child_created = True
 2475:                     if self.pid == 0:
                               # Child
>>>>>>                         try:
                                   # Close parent's pipe ends
>>>>>>                             if p2cwrite is not None:
>>>>>>                                 os.close(p2cwrite)
>>>>>>                             if c2pread is not None:
>>>>>>                                 os.close(c2pread)
>>>>>>                             if errread is not None:
>>>>>>                                 os.close(errread)
>>>>>>                             os.close(errpipe_read)
       
                                   # When duping fds, if there arises a situation
                                   # where one of the fds is either 0, 1 or 2, it
                                   # is possible that it is overwritten (#12607).
>>>>>>                             if c2pwrite == 0:
>>>>>>                                 c2pwrite = os.dup(c2pwrite)
>>>>>>                             if errwrite == 0 or errwrite == 1:
>>>>>>                                 errwrite = os.dup(errwrite)
       
                                   # Dup fds for child
>>>>>>                             def _dup2(a, b):
                                       # dup2() removes the CLOEXEC flag but
                                       # we must do it ourselves if dup2()
                                       # would be a no-op (issue #10806).
>>>>>>                                 if a == b:
>>>>>>                                     self._set_cloexec_flag(a, False)
>>>>>>                                 elif a is not None:
>>>>>>                                     os.dup2(a, b)
>>>>>>                             _dup2(p2cread, 0)
>>>>>>                             _dup2(c2pwrite, 1)
>>>>>>                             _dup2(errwrite, 2)
       
                                   # Close pipe fds.  Make sure we don't close the
                                   # same fd more than once, or standard fds.
>>>>>>                             closed = { None }
>>>>>>                             for fd in [p2cread, c2pwrite, errwrite]:
>>>>>>                                 if fd not in closed and fd > 2:
>>>>>>                                     os.close(fd)
>>>>>>                                     closed.add(fd)
       
>>>>>>                             if cwd is not None:
>>>>>>                                 os.chdir(cwd)
       
>>>>>>                             if preexec_fn:
>>>>>>                                 preexec_fn()
       
                                   # Close all other fds, if asked for - after
                                   # preexec_fn(), which may open FDs.
>>>>>>                             if close_fds:
>>>>>>                                 self._close_fds(but=errpipe_write)
       
>>>>>>                             if env is None:
>>>>>>                                 os.execvp(executable, args)
                                   else:
>>>>>>                                 os.execvpe(executable, args, env)
       
>>>>>>                         except:
>>>>>>                             exc_type, exc_value, tb = sys.exc_info()
                                   # Save the traceback and attach it to the exception object
>>>>>>                             exc_lines = traceback.format_exception(exc_type,
>>>>>>                                                                    exc_value,
>>>>>>                                                                    tb)
>>>>>>                             exc_value.child_traceback = ''.join(exc_lines)
>>>>>>                             os.write(errpipe_write, pickle.dumps(exc_value))
       
                               # This exitcode won't be reported to applications, so it
                               # really doesn't matter what we return.
>>>>>>                         os._exit(255)
       
                           # Parent
 2475:                     if gc_was_enabled:
 2475:                         gc.enable()
                       finally:
                           # be sure the FD is closed no matter what
 2475:                     os.close(errpipe_write)
       
                       # Wait for exec to fail or succeed; possibly raising exception
 2475:                 data = _eintr_retry_call(os.read, errpipe_read, 1048576)
 2475:                 pickle_bits = []
 4541:                 while data:
 2066:                     pickle_bits.append(data)
 2066:                     data = _eintr_retry_call(os.read, errpipe_read, 1048576)
 2475:                 data = "".join(pickle_bits)
                   finally:
 2475:                 if p2cread is not None and p2cwrite is not None:
  244:                     _close_in_parent(p2cread)
 2475:                 if c2pwrite is not None and c2pread is not None:
 2391:                     _close_in_parent(c2pwrite)
 2475:                 if errwrite is not None and errread is not None:
 2271:                     _close_in_parent(errwrite)
       
                       # be sure the FD is closed no matter what
 2475:                 os.close(errpipe_read)
       
 2475:             if data != "":
 2066:                 try:
 2066:                     _eintr_retry_call(os.waitpid, self.pid, 0)
>>>>>>                 except OSError as e:
>>>>>>                     if e.errno != errno.ECHILD:
>>>>>>                         raise
 2066:                 child_exception = pickle.loads(data)
 2066:                 raise child_exception
       
       
>>>>>>         def _handle_exitstatus(self, sts, _WIFSIGNALED=os.WIFSIGNALED,
>>>>>>                 _WTERMSIG=os.WTERMSIG, _WIFEXITED=os.WIFEXITED,
>>>>>>                 _WEXITSTATUS=os.WEXITSTATUS, _WIFSTOPPED=os.WIFSTOPPED,
>>>>>>                 _WSTOPSIG=os.WSTOPSIG):
                   # This method is called (indirectly) by __del__, so it cannot
                   # refer to anything outside of its local scope.
  407:             if _WIFSIGNALED(sts):
    4:                 self.returncode = -_WTERMSIG(sts)
  403:             elif _WIFEXITED(sts):
  402:                 self.returncode = _WEXITSTATUS(sts)
    1:             elif _WIFSTOPPED(sts):
    1:                 self.returncode = -_WSTOPSIG(sts)
                   else:
                       # Should never happen
>>>>>>                 raise RuntimeError("Unknown child exit status!")
       
       
>>>>>>         def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
>>>>>>                 _WNOHANG=os.WNOHANG, _os_error=os.error, _ECHILD=errno.ECHILD):
                   """Check if child process has terminated.  Returns returncode
                   attribute.
       
                   This method is called by __del__, so it cannot reference anything
                   outside of the local scope (nor can any methods it calls).
       
                   """
 2393:             if self.returncode is None:
 2012:                 try:
 2012:                     pid, sts = _waitpid(self.pid, _WNOHANG)
   53:                     if pid == self.pid:
   25:                         self._handle_exitstatus(sts)
 1959:                 except _os_error as e:
 1959:                     if _deadstate is not None:
 1959:                         self.returncode = _deadstate
 1959:                     if e.errno == _ECHILD:
                               # This happens if SIGCLD is set to be ignored or
                               # waiting for child processes has otherwise been
                               # disabled for our process.  This child is dead, we
                               # can't get the status.
                               # http://bugs.python.org/issue15756
 1959:                         self.returncode = 0
 2393:             return self.returncode
       
       
>>>>>>         def wait(self):
                   """Wait for child process to terminate.  Returns returncode
                   attribute."""
  800:             while self.returncode is None:
  382:                 try:
  382:                     pid, sts = _eintr_retry_call(os.waitpid, self.pid, 0)
>>>>>>                 except OSError as e:
>>>>>>                     if e.errno != errno.ECHILD:
>>>>>>                         raise
                           # This happens if SIGCLD is set to be ignored or waiting
                           # for child processes has otherwise been disabled for our
                           # process.  This child is dead, we can't get the status.
>>>>>>                     pid = self.pid
>>>>>>                     sts = 0
                       # Check the pid and loop as waitpid has been known to return
                       # 0 even without WNOHANG in odd situations.  issue14396.
  382:                 if pid == self.pid:
  382:                     self._handle_exitstatus(sts)
  418:             return self.returncode
       
       
>>>>>>         def _communicate(self, input):
  229:             if self.stdin:
                       # Flush stdio buffer.  This might block, if the user has
                       # been writing to .stdin in an uncontrolled fashion.
  186:                 self.stdin.flush()
  186:                 if not input:
  129:                     self.stdin.close()
       
  229:             if _has_poll:
  206:                 stdout, stderr = self._communicate_with_poll(input)
                   else:
   23:                 stdout, stderr = self._communicate_with_select(input)
       
                   # All data exchanged.  Translate lists into strings.
  229:             if stdout is not None:
  229:                 stdout = ''.join(stdout)
  229:             if stderr is not None:
  206:                 stderr = ''.join(stderr)
       
                   # Translate newlines, if requested.  We cannot let the file
                   # object do the translation: It is based on stdio, which is
                   # impossible to combine with select (unless forcing no
                   # buffering).
  229:             if self.universal_newlines and hasattr(file, 'newlines'):
   29:                 if stdout:
   29:                     stdout = self._translate_newlines(stdout)
   29:                 if stderr:
    4:                     stderr = self._translate_newlines(stderr)
       
  229:             self.wait()
  229:             return (stdout, stderr)
       
       
>>>>>>         def _communicate_with_poll(self, input):
  206:             stdout = None # Return
  206:             stderr = None # Return
  206:             fd2file = {}
  206:             fd2output = {}
       
  206:             poller = select.poll()
  206:             def register_and_append(file_obj, eventmask):
  427:                 poller.register(file_obj.fileno(), eventmask)
  427:                 fd2file[file_obj.fileno()] = file_obj
       
  206:             def close_unregister_and_remove(fd):
  427:                 poller.unregister(fd)
  427:                 fd2file[fd].close()
  427:                 fd2file.pop(fd)
       
  206:             if self.stdin and input:
   38:                 register_and_append(self.stdin, select.POLLOUT)
       
  206:             select_POLLIN_POLLPRI = select.POLLIN | select.POLLPRI
  206:             if self.stdout:
  206:                 register_and_append(self.stdout, select_POLLIN_POLLPRI)
  206:                 fd2output[self.stdout.fileno()] = stdout = []
  206:             if self.stderr:
  183:                 register_and_append(self.stderr, select_POLLIN_POLLPRI)
  183:                 fd2output[self.stderr.fileno()] = stderr = []
       
  206:             input_offset = 0
  741:             while fd2file:
  535:                 try:
  535:                     ready = poller.poll()
>>>>>>                 except select.error, e:
>>>>>>                     if e.args[0] == errno.EINTR:
>>>>>>                         continue
>>>>>>                     raise
       
 1280:                 for fd, mode in ready:
  745:                     if mode & select.POLLOUT:
   71:                         chunk = input[input_offset : input_offset + _PIPE_BUF]
   71:                         try:
   71:                             input_offset += os.write(fd, chunk)
>>>>>>                         except OSError as e:
>>>>>>                             if e.errno == errno.EPIPE:
>>>>>>                                 close_unregister_and_remove(fd)
                                   else:
>>>>>>                                 raise
                               else:
   71:                             if input_offset >= len(input):
   37:                                 close_unregister_and_remove(fd)
  674:                     elif mode & select_POLLIN_POLLPRI:
  673:                         data = os.read(fd, 4096)
  673:                         if not data:
  389:                             close_unregister_and_remove(fd)
  673:                         fd2output[fd].append(data)
                           else:
                               # Ignore hang up or errors.
    1:                         close_unregister_and_remove(fd)
       
  206:             return (stdout, stderr)
       
       
>>>>>>         def _communicate_with_select(self, input):
   23:             read_set = []
   23:             write_set = []
   23:             stdout = None # Return
   23:             stderr = None # Return
       
   23:             if self.stdin and input:
   19:                 write_set.append(self.stdin)
   23:             if self.stdout:
   23:                 read_set.append(self.stdout)
   23:                 stdout = []
   23:             if self.stderr:
   23:                 read_set.append(self.stderr)
   23:                 stderr = []
       
   23:             input_offset = 0
  125:             while read_set or write_set:
  102:                 try:
  102:                     rlist, wlist, xlist = select.select(read_set, write_set, [])
>>>>>>                 except select.error, e:
>>>>>>                     if e.args[0] == errno.EINTR:
>>>>>>                         continue
>>>>>>                     raise
       
  102:                 if self.stdin in wlist:
   53:                     chunk = input[input_offset : input_offset + _PIPE_BUF]
   53:                     try:
   53:                         bytes_written = os.write(self.stdin.fileno(), chunk)
    1:                     except OSError as e:
    1:                         if e.errno == errno.EPIPE:
    1:                             self.stdin.close()
    1:                             write_set.remove(self.stdin)
                               else:
>>>>>>                             raise
                           else:
   52:                         input_offset += bytes_written
   52:                         if input_offset >= len(input):
   18:                             self.stdin.close()
   18:                             write_set.remove(self.stdin)
       
  102:                 if self.stdout in rlist:
   47:                     data = os.read(self.stdout.fileno(), 1024)
   47:                     if data == "":
   23:                         self.stdout.close()
   23:                         read_set.remove(self.stdout)
   47:                     stdout.append(data)
       
  102:                 if self.stderr in rlist:
   26:                     data = os.read(self.stderr.fileno(), 1024)
   26:                     if data == "":
   23:                         self.stderr.close()
   23:                         read_set.remove(self.stderr)
   26:                     stderr.append(data)
       
   23:             return (stdout, stderr)
       
       
>>>>>>         def send_signal(self, sig):
                   """Send a signal to the process
                   """
   38:             os.kill(self.pid, sig)
       
>>>>>>         def terminate(self):
                   """Terminate the process with SIGTERM
                   """
    2:             self.send_signal(signal.SIGTERM)
       
>>>>>>         def kill(self):
                   """Kill the process with SIGKILL
                   """
    2:             self.send_signal(signal.SIGKILL)
       
       
>>>>>> def _demo_posix():
           #
           # Example 1: Simple redirection: Get process list
           #
>>>>>>     plist = Popen(["ps"], stdout=PIPE).communicate()[0]
>>>>>>     print "Process list:"
>>>>>>     print plist
       
           #
           # Example 2: Change uid before executing child
           #
>>>>>>     if os.getuid() == 0:
>>>>>>         p = Popen(["id"], preexec_fn=lambda: os.setuid(100))
>>>>>>         p.wait()
       
           #
           # Example 3: Connecting several subprocesses
           #
>>>>>>     print "Looking for 'hda'..."
>>>>>>     p1 = Popen(["dmesg"], stdout=PIPE)
>>>>>>     p2 = Popen(["grep", "hda"], stdin=p1.stdout, stdout=PIPE)
>>>>>>     print repr(p2.communicate()[0])
       
           #
           # Example 4: Catch execution error
           #
>>>>>>     print
>>>>>>     print "Trying a weird file..."
>>>>>>     try:
>>>>>>         print Popen(["/this/path/does/not/exist"]).communicate()
>>>>>>     except OSError, e:
>>>>>>         if e.errno == errno.ENOENT:
>>>>>>             print "The file didn't exist.  I thought so..."
>>>>>>             print "Child traceback:"
>>>>>>             print e.child_traceback
               else:
>>>>>>             print "Error", e.errno
           else:
>>>>>>         print >>sys.stderr, "Gosh.  No error."
       
       
>>>>>> def _demo_windows():
           #
           # Example 1: Connecting several subprocesses
           #
>>>>>>     print "Looking for 'PROMPT' in set output..."
>>>>>>     p1 = Popen("set", stdout=PIPE, shell=True)
>>>>>>     p2 = Popen('find "PROMPT"', stdin=p1.stdout, stdout=PIPE)
>>>>>>     print repr(p2.communicate()[0])
       
           #
           # Example 2: Simple execution of program
           #
>>>>>>     print "Executing calc..."
>>>>>>     p = Popen("calc")
>>>>>>     p.wait()
       
       
>>>>>> if __name__ == "__main__":
>>>>>>     if mswindows:
>>>>>>         _demo_windows()
           else:
>>>>>>         _demo_posix()
