       # Copyright (c) 2004 Python Software Foundation.
       # All rights reserved.
       
       # Written by Eric Price <eprice at tjhsst.edu>
       #    and Facundo Batista <facundo at taniquetil.com.ar>
       #    and Raymond Hettinger <python at rcn.com>
       #    and Aahz (aahz at pobox.com)
       #    and Tim Peters
       
       """
       These are the test cases for the Decimal module.
       
       There are two groups of tests, Arithmetic and Behaviour. The former test
       the Decimal arithmetic using the tests provided by Mike Cowlishaw. The latter
       test the pythonic behaviour according to PEP 327.
       
       Cowlishaw's tests can be downloaded from:
       
          http://speleotrove.com/decimal/dectest.zip
       
       This test module can be called from command line with one parameter (Arithmetic
       or Behaviour) to test each part, or without parameter to test both parts. If
       you're working through IDLE, you can import this test module and call test_main()
       with the corresponding argument.
    1: """
       
    1: import math
    1: import os, sys
    1: import operator
    1: import pickle, copy
    1: import unittest
    1: from decimal import *
    1: import numbers
    1: from test.test_support import (run_unittest, run_doctest, requires_unicode, u,
                                      is_resource_enabled, check_py3k_warnings,
                                      run_with_locale)
    1: import random
    1: try:
    1:     import threading
>>>>>> except ImportError:
>>>>>>     threading = None
       
       # Useful Test Constant
    1: Signals = tuple(getcontext().flags.keys())
       
       # Signals ordered with respect to precedence: when an operation
       # produces multiple signals, signals occurring later in the list
       # should be handled before those occurring earlier in the list.
    1: OrderedSignals = (Clamped, Rounded, Inexact, Subnormal,
    1:                   Underflow, Overflow, DivisionByZero, InvalidOperation)
       
       # Tests are built around these assumed context defaults.
       # test_main() restores the original context.
    1: def init():
           global ORIGINAL_CONTEXT
    1:     ORIGINAL_CONTEXT = getcontext().copy()
    1:     DefaultTestContext = Context(
    1:         prec = 9,
    1:         rounding = ROUND_HALF_EVEN,
    1:         traps = dict.fromkeys(Signals, 0)
               )
    1:     setcontext(DefaultTestContext)
       
       # decorator for skipping tests on non-IEEE 754 platforms
    1: requires_IEEE_754 = unittest.skipUnless(
    1:     float.__getformat__("double").startswith("IEEE"),
    1:     "test requires IEEE 754 doubles")
       
    1: TESTDATADIR = 'decimaltestdata'
    1: if __name__ == '__main__':
>>>>>>     file = sys.argv[0]
       else:
    1:     file = __file__
    1: testdir = os.path.dirname(file) or os.curdir
    1: directory = testdir + os.sep + TESTDATADIR + os.sep
       
    1: skip_expected = not os.path.isdir(directory)
       
       # list of individual .decTest test ids that correspond to tests that
       # we're skipping for one reason or another.
    1: skipped_test_ids = set([
           # Skip implementation-specific scaleb tests.
    1:     'scbx164',
    1:     'scbx165',
       
           # For some operations (currently exp, ln, log10, power), the decNumber
           # reference implementation imposes additional restrictions on the context
           # and operands.  These restrictions are not part of the specification;
           # however, the effect of these restrictions does show up in some of the
           # testcases.  We skip testcases that violate these restrictions, since
           # Decimal behaves differently from decNumber for these testcases so these
           # testcases would otherwise fail.
    1:     'expx901',
    1:     'expx902',
    1:     'expx903',
    1:     'expx905',
    1:     'lnx901',
    1:     'lnx902',
    1:     'lnx903',
    1:     'lnx905',
    1:     'logx901',
    1:     'logx902',
    1:     'logx903',
    1:     'logx905',
    1:     'powx1183',
    1:     'powx1184',
    1:     'powx4001',
    1:     'powx4002',
    1:     'powx4003',
    1:     'powx4005',
    1:     'powx4008',
    1:     'powx4010',
    1:     'powx4012',
    1:     'powx4014',
           ])
       
       # Make sure it actually raises errors when not expected and caught in flags
       # Slower, since it runs some things several times.
    1: EXTENDEDERRORTEST = False
       
       #Map the test cases' error names to the actual errors
    1: ErrorNames = {'clamped' : Clamped,
    1:               'conversion_syntax' : InvalidOperation,
    1:               'division_by_zero' : DivisionByZero,
    1:               'division_impossible' : InvalidOperation,
    1:               'division_undefined' : InvalidOperation,
    1:               'inexact' : Inexact,
    1:               'invalid_context' : InvalidOperation,
    1:               'invalid_operation' : InvalidOperation,
    1:               'overflow' : Overflow,
    1:               'rounded' : Rounded,
    1:               'subnormal' : Subnormal,
    1:               'underflow' : Underflow}
       
       
    1: def Nonfunction(*args):
           """Doesn't do anything."""
  427:     return None
       
    1: RoundingDict = {'ceiling' : ROUND_CEILING, #Maps test-case names to roundings.
    1:                 'down' : ROUND_DOWN,
    1:                 'floor' : ROUND_FLOOR,
    1:                 'half_down' : ROUND_HALF_DOWN,
    1:                 'half_even' : ROUND_HALF_EVEN,
    1:                 'half_up' : ROUND_HALF_UP,
    1:                 'up' : ROUND_UP,
    1:                 '05up' : ROUND_05UP}
       
       # Name adapter to be able to change the Decimal and Context
       # interface without changing the test files from Cowlishaw
    1: nameAdapter = {'and':'logical_and',
    1:                'apply':'_apply',
    1:                'class':'number_class',
    1:                'comparesig':'compare_signal',
    1:                'comparetotal':'compare_total',
    1:                'comparetotmag':'compare_total_mag',
    1:                'copy':'copy_decimal',
    1:                'copyabs':'copy_abs',
    1:                'copynegate':'copy_negate',
    1:                'copysign':'copy_sign',
    1:                'divideint':'divide_int',
    1:                'invert':'logical_invert',
    1:                'iscanonical':'is_canonical',
    1:                'isfinite':'is_finite',
    1:                'isinfinite':'is_infinite',
    1:                'isnan':'is_nan',
    1:                'isnormal':'is_normal',
    1:                'isqnan':'is_qnan',
    1:                'issigned':'is_signed',
    1:                'issnan':'is_snan',
    1:                'issubnormal':'is_subnormal',
    1:                'iszero':'is_zero',
    1:                'maxmag':'max_mag',
    1:                'minmag':'min_mag',
    1:                'nextminus':'next_minus',
    1:                'nextplus':'next_plus',
    1:                'nexttoward':'next_toward',
    1:                'or':'logical_or',
    1:                'reduce':'normalize',
    1:                'remaindernear':'remainder_near',
    1:                'samequantum':'same_quantum',
    1:                'squareroot':'sqrt',
    1:                'toeng':'to_eng_string',
    1:                'tointegral':'to_integral_value',
    1:                'tointegralx':'to_integral_exact',
    1:                'tosci':'to_sci_string',
    1:                'xor':'logical_xor',
                     }
       
       # The following functions return True/False rather than a Decimal instance
       
       LOGICAL_FUNCTIONS = (
    1:     'is_canonical',
    1:     'is_finite',
    1:     'is_infinite',
    1:     'is_nan',
    1:     'is_normal',
    1:     'is_qnan',
    1:     'is_signed',
    1:     'is_snan',
    1:     'is_subnormal',
    1:     'is_zero',
    1:     'same_quantum',
           )
       
    2: class DecimalTest(unittest.TestCase):
           """Class which tests the Decimal class against the test cases.
       
           Changed for unittest.
    1:     """
    1:     def setUp(self):
  143:         self.context = Context()
  143:         self.ignore_list = ['#']
               # Basically, a # means return NaN InvalidOperation.
               # Different from a sNaN in trim
       
  143:         self.ChangeDict = {'precision' : self.change_precision,
  143:                       'rounding' : self.change_rounding_method,
  143:                       'maxexponent' : self.change_max_exponent,
  143:                       'minexponent' : self.change_min_exponent,
  143:                       'clamp' : self.change_clamp}
       
    1:     def eval_file(self, file):
               global skip_expected
  143:         if skip_expected:
>>>>>>             raise unittest.SkipTest
  143:         with open(file) as f:
81757:             for line in f:
81614:                 line = line.replace('\r\n', '').replace('\n', '')
                       #print line
81614:                 try:
81614:                     t = self.eval_line(line)
>>>>>>                 except DecimalException as exception:
                           #Exception raised where there shouldn't have been one.
>>>>>>                     self.fail('Exception "'+exception.__class__.__name__ + '" raised on line '+line)
       
       
    1:     def eval_line(self, s):
81614:         if s.find(' -> ') >= 0 and s[:2] != '--' and not s.startswith('  --'):
67060:             s = (s.split('->')[0] + '->' +
67060:                  s.split('->')[1].split('--')[0]).strip()
               else:
14554:             s = s.split('--')[0].strip()
       
161571:         for ignore in self.ignore_list:
81614:             if s.find(ignore) >= 0:
                       #print s.split()[0], 'NotImplemented--', ignore
 1657:                 return
79957:         if not s:
11199:             return
68758:         elif ':' in s:
 3355:             return self.eval_directive(s)
               else:
65403:             return self.eval_equation(s)
       
    1:     def eval_directive(self, s):
10065:         funct, value = map(lambda x: x.strip().lower(), s.split(':'))
 3355:         if funct == 'rounding':
  781:             value = RoundingDict[value]
               else:
 2574:             try:
 2574:                 value = int(value)
  286:             except ValueError:
  286:                 pass
       
 3355:         funct = self.ChangeDict.get(funct, Nonfunction)
 3355:         funct(value)
       
    1:     def eval_equation(self, s):
               #global DEFAULT_PRECISION
               #print DEFAULT_PRECISION
       
65403:         if not TEST_ALL and random.random() < 0.90:
58797:             return
       
 6606:         try:
 6606:             Sides = s.split('->')
 6606:             L = Sides[0].strip().split()
 6606:             id = L[0]
 6606:             if DEBUG:
>>>>>>                 print "Test ", id,
 6606:             funct = L[1].lower()
 6606:             valstemp = L[2:]
 6606:             L = Sides[1].strip().split()
 6606:             ans = L[0]
 6606:             exceptions = L[1:]
>>>>>>         except (TypeError, AttributeError, IndexError):
>>>>>>             raise InvalidOperation
 6606:         def FixQuotes(val):
18772:             val = val.replace("''", 'SingleQuote').replace('""', 'DoubleQuote')
18772:             val = val.replace("'", '').replace('"', '')
18772:             val = val.replace('SingleQuote', "'").replace('DoubleQuote', '"')
18772:             return val
       
 6606:         if id in skipped_test_ids:
    3:             return
       
 6603:         fname = nameAdapter.get(funct, funct)
 6603:         if fname == 'rescale':
   54:             return
 6549:         funct = getattr(self.context, fname)
 6549:         vals = []
 6549:         conglomerate = ''
 6549:         quote = 0
12046:         theirexceptions = [ErrorNames[x.lower()] for x in exceptions]
       
58941:         for exception in Signals:
52392:             self.context.traps[exception] = 1 #Catch these bugs...
12046:         for exception in theirexceptions:
 5497:             self.context.traps[exception] = 0
18777:         for i, val in enumerate(valstemp):
12228:             if val.count("'") % 2 == 1:
    6:                 quote = 1 - quote
12228:             if quote:
    5:                 conglomerate = conglomerate + ' ' + val
    5:                 continue
                   else:
12223:                 val = conglomerate + val
12223:                 conglomerate = ''
12223:             v = FixQuotes(val)
12223:             if fname in ('to_sci_string', 'to_eng_string'):
  395:                 if EXTENDEDERRORTEST:
>>>>>>                     for error in theirexceptions:
>>>>>>                         self.context.traps[error] = 1
>>>>>>                         try:
>>>>>>                             funct(self.context.create_decimal(v))
>>>>>>                         except error:
>>>>>>                             pass
>>>>>>                         except Signals, e:
>>>>>>                             self.fail("Raised %s in %s when %s disabled" % \
>>>>>>                                       (e, s, error))
                               else:
>>>>>>                             self.fail("Did not raise %s in %s" % (error, s))
>>>>>>                         self.context.traps[error] = 0
  395:                 v = self.context.create_decimal(v)
                   else:
11828:                 v = Decimal(v, self.context)
12223:             vals.append(v)
       
 6549:         ans = FixQuotes(ans)
       
 6549:         if EXTENDEDERRORTEST and fname not in ('to_sci_string', 'to_eng_string'):
>>>>>>             for error in theirexceptions:
>>>>>>                 self.context.traps[error] = 1
>>>>>>                 try:
>>>>>>                     funct(*vals)
>>>>>>                 except error:
>>>>>>                     pass
>>>>>>                 except Signals, e:
>>>>>>                     self.fail("Raised %s in %s when %s disabled" % \
>>>>>>                               (e, s, error))
                       else:
>>>>>>                     self.fail("Did not raise %s in %s" % (error, s))
>>>>>>                 self.context.traps[error] = 0
       
                   # as above, but add traps cumulatively, to check precedence
>>>>>>             ordered_errors = [e for e in OrderedSignals if e in theirexceptions]
>>>>>>             for error in ordered_errors:
>>>>>>                 self.context.traps[error] = 1
>>>>>>                 try:
>>>>>>                     funct(*vals)
>>>>>>                 except error:
>>>>>>                     pass
>>>>>>                 except Signals, e:
>>>>>>                     self.fail("Raised %s in %s; expected %s" %
>>>>>>                               (type(e), s, error))
                       else:
>>>>>>                     self.fail("Did not raise %s in %s" % (error, s))
                   # reset traps
>>>>>>             for error in ordered_errors:
>>>>>>                 self.context.traps[error] = 0
       
       
 6549:         if DEBUG:
>>>>>>             print "--", self.context
 6549:         try:
 6549:             result = str(funct(*vals))
 6549:             if fname in LOGICAL_FUNCTIONS:
  299:                 result = str(int(eval(result))) # 'True', 'False' -> '1', '0'
>>>>>>         except Signals, error:
>>>>>>             self.fail("Raised %s in %s" % (error, s))
>>>>>>         except: #Catch any error long enough to state the test case.
>>>>>>             print "ERROR:", s
>>>>>>             raise
       
 6549:         myexceptions = self.getexceptions()
 6549:         self.context.clear_flags()
       
 6549:         self.assertEqual(result, ans,
 6549:                          'Incorrect answer for ' + s + ' -- got ' + result)
 6549:         self.assertItemsEqual(myexceptions, theirexceptions,
 6549:               'Incorrect flags set in ' + s + ' -- got ' + str(myexceptions))
       
    1:     def getexceptions(self):
58941:         return [e for e in Signals if self.context.flags[e]]
       
    1:     def change_precision(self, prec):
 1220:         self.context.prec = prec
    1:     def change_rounding_method(self, rounding):
  781:         self.context.rounding = rounding
    1:     def change_min_exponent(self, exp):
  409:         self.context.Emin = exp
    1:     def change_max_exponent(self, exp):
  413:         self.context.Emax = exp
    1:     def change_clamp(self, clamp):
  105:         self.context._clamp = clamp
       
       
       
       # The following classes test the behaviour of Decimal according to PEP 327
       
    2: class DecimalExplicitConstructionTest(unittest.TestCase):
    1:     '''Unit tests for Explicit Construction cases of Decimal.'''
       
    1:     def test_explicit_empty(self):
    1:         self.assertEqual(Decimal(), Decimal("0"))
       
    1:     def test_explicit_from_None(self):
    1:         self.assertRaises(TypeError, Decimal, None)
       
    1:     def test_explicit_from_int(self):
       
               #positive
    1:         d = Decimal(45)
    1:         self.assertEqual(str(d), '45')
       
               #very large positive
    1:         d = Decimal(500000123)
    1:         self.assertEqual(str(d), '500000123')
       
               #negative
    1:         d = Decimal(-45)
    1:         self.assertEqual(str(d), '-45')
       
               #zero
    1:         d = Decimal(0)
    1:         self.assertEqual(str(d), '0')
       
    1:     def test_explicit_from_string(self):
       
               #empty
    1:         self.assertEqual(str(Decimal('')), 'NaN')
       
               #int
    1:         self.assertEqual(str(Decimal('45')), '45')
       
               #float
    1:         self.assertEqual(str(Decimal('45.34')), '45.34')
       
               #engineer notation
    1:         self.assertEqual(str(Decimal('45e2')), '4.5E+3')
       
               #just not a number
    1:         self.assertEqual(str(Decimal('ugly')), 'NaN')
       
               #leading and trailing whitespace permitted
    1:         self.assertEqual(str(Decimal('1.3E4 \n')), '1.3E+4')
    1:         self.assertEqual(str(Decimal('  -7.89')), '-7.89')
       
               #unicode strings should be permitted
    1:         self.assertEqual(str(Decimal(u'0E-017')), '0E-17')
    1:         self.assertEqual(str(Decimal(u'45')), '45')
    1:         self.assertEqual(str(Decimal(u'-Inf')), '-Infinity')
    1:         self.assertEqual(str(Decimal(u'NaN123')), 'NaN123')
       
    1:     def test_explicit_from_tuples(self):
       
               #zero
    1:         d = Decimal( (0, (0,), 0) )
    1:         self.assertEqual(str(d), '0')
       
               #int
    1:         d = Decimal( (1, (4, 5), 0) )
    1:         self.assertEqual(str(d), '-45')
       
               #float
    1:         d = Decimal( (0, (4, 5, 3, 4), -2) )
    1:         self.assertEqual(str(d), '45.34')
       
               #weird
    1:         d = Decimal( (1, (4, 3, 4, 9, 1, 3, 5, 3, 4), -25) )
    1:         self.assertEqual(str(d), '-4.34913534E-17')
       
               #wrong number of items
    1:         self.assertRaises(ValueError, Decimal, (1, (4, 3, 4, 9, 1)) )
       
               #bad sign
    1:         self.assertRaises(ValueError, Decimal, (8, (4, 3, 4, 9, 1), 2) )
    1:         self.assertRaises(ValueError, Decimal, (0., (4, 3, 4, 9, 1), 2) )
    1:         self.assertRaises(ValueError, Decimal, (Decimal(1), (4, 3, 4, 9, 1), 2))
       
               #bad exp
    1:         self.assertRaises(ValueError, Decimal, (1, (4, 3, 4, 9, 1), 'wrong!') )
    1:         self.assertRaises(ValueError, Decimal, (1, (4, 3, 4, 9, 1), 0.) )
    1:         self.assertRaises(ValueError, Decimal, (1, (4, 3, 4, 9, 1), '1') )
       
               #bad coefficients
    1:         self.assertRaises(ValueError, Decimal, (1, (4, 3, 4, None, 1), 2) )
    1:         self.assertRaises(ValueError, Decimal, (1, (4, -3, 4, 9, 1), 2) )
    1:         self.assertRaises(ValueError, Decimal, (1, (4, 10, 4, 9, 1), 2) )
    1:         self.assertRaises(ValueError, Decimal, (1, (4, 3, 4, 'a', 1), 2) )
       
    1:     def test_explicit_from_bool(self):
    1:         self.assertIs(bool(Decimal(0)), False)
    1:         self.assertIs(bool(Decimal(1)), True)
    1:         self.assertEqual(Decimal(False), Decimal(0))
    1:         self.assertEqual(Decimal(True), Decimal(1))
       
    1:     def test_explicit_from_Decimal(self):
       
               #positive
    1:         d = Decimal(45)
    1:         e = Decimal(d)
    1:         self.assertEqual(str(e), '45')
    1:         self.assertNotEqual(id(d), id(e))
       
               #very large positive
    1:         d = Decimal(500000123)
    1:         e = Decimal(d)
    1:         self.assertEqual(str(e), '500000123')
    1:         self.assertNotEqual(id(d), id(e))
       
               #negative
    1:         d = Decimal(-45)
    1:         e = Decimal(d)
    1:         self.assertEqual(str(e), '-45')
    1:         self.assertNotEqual(id(d), id(e))
       
               #zero
    1:         d = Decimal(0)
    1:         e = Decimal(d)
    1:         self.assertEqual(str(e), '0')
    1:         self.assertNotEqual(id(d), id(e))
       
    1:     @requires_IEEE_754
           def test_explicit_from_float(self):
    1:         r = Decimal(0.1)
    1:         self.assertEqual(type(r), Decimal)
    1:         self.assertEqual(str(r),
    1:                 '0.1000000000000000055511151231257827021181583404541015625')
    1:         self.assertTrue(Decimal(float('nan')).is_qnan())
    1:         self.assertTrue(Decimal(float('inf')).is_infinite())
    1:         self.assertTrue(Decimal(float('-inf')).is_infinite())
    1:         self.assertEqual(str(Decimal(float('nan'))),
    1:                          str(Decimal('NaN')))
    1:         self.assertEqual(str(Decimal(float('inf'))),
    1:                          str(Decimal('Infinity')))
    1:         self.assertEqual(str(Decimal(float('-inf'))),
    1:                          str(Decimal('-Infinity')))
    1:         self.assertEqual(str(Decimal(float('-0.0'))),
    1:                          str(Decimal('-0')))
  201:         for i in range(200):
  200:             x = random.expovariate(0.01) * (random.random() * 2.0 - 1.0)
  200:             self.assertEqual(x, float(Decimal(x))) # roundtrip
       
    1:     def test_explicit_context_create_decimal(self):
       
    1:         nc = copy.copy(getcontext())
    1:         nc.prec = 3
       
               # empty
    1:         d = Decimal()
    1:         self.assertEqual(str(d), '0')
    1:         d = nc.create_decimal()
    1:         self.assertEqual(str(d), '0')
       
               # from None
    1:         self.assertRaises(TypeError, nc.create_decimal, None)
       
               # from int
    1:         d = nc.create_decimal(456)
    1:         self.assertIsInstance(d, Decimal)
    1:         self.assertEqual(nc.create_decimal(45678),
    1:                          nc.create_decimal('457E+2'))
       
               # from string
    1:         d = Decimal('456789')
    1:         self.assertEqual(str(d), '456789')
    1:         d = nc.create_decimal('456789')
    1:         self.assertEqual(str(d), '4.57E+5')
               # leading and trailing whitespace should result in a NaN;
               # spaces are already checked in Cowlishaw's test-suite, so
               # here we just check that a trailing newline results in a NaN
    1:         self.assertEqual(str(nc.create_decimal('3.14\n')), 'NaN')
       
               # from tuples
    1:         d = Decimal( (1, (4, 3, 4, 9, 1, 3, 5, 3, 4), -25) )
    1:         self.assertEqual(str(d), '-4.34913534E-17')
    1:         d = nc.create_decimal( (1, (4, 3, 4, 9, 1, 3, 5, 3, 4), -25) )
    1:         self.assertEqual(str(d), '-4.35E-17')
       
               # from Decimal
    1:         prevdec = Decimal(500000123)
    1:         d = Decimal(prevdec)
    1:         self.assertEqual(str(d), '500000123')
    1:         d = nc.create_decimal(prevdec)
    1:         self.assertEqual(str(d), '5.00E+8')
       
    1:     @requires_unicode
           def test_unicode_digits(self):
    1:         test_values = {
    1:             u(r'\uff11'): '1',
    1:             u(r'\u0660.\u0660\u0663\u0667\u0662e-\u0663') : '0.0000372',
    1:             u(r'-nan\u0c68\u0c6a\u0c66\u0c66') : '-NaN2400',
                   }
    4:         for input, expected in test_values.items():
    3:             self.assertEqual(str(Decimal(input)), expected)
       
       
    2: class DecimalImplicitConstructionTest(unittest.TestCase):
    1:     '''Unit tests for Implicit Construction cases of Decimal.'''
       
    1:     def test_implicit_from_None(self):
    1:         self.assertRaises(TypeError, eval, 'Decimal(5) + None', globals())
       
    1:     def test_implicit_from_int(self):
               #normal
    1:         self.assertEqual(str(Decimal(5) + 45), '50')
               #exceeding precision
    1:         self.assertEqual(Decimal(5) + 123456789000, Decimal(123456789000))
       
    1:     def test_implicit_from_string(self):
    1:         self.assertRaises(TypeError, eval, 'Decimal(5) + "3"', globals())
       
    1:     def test_implicit_from_float(self):
    1:         self.assertRaises(TypeError, eval, 'Decimal(5) + 2.2', globals())
       
    1:     def test_implicit_from_Decimal(self):
    1:         self.assertEqual(Decimal(5) + Decimal(45), Decimal(50))
       
    1:     def test_rop(self):
               # Allow other classes to be trained to interact with Decimals
    2:         class E:
    1:             def __divmod__(self, other):
    1:                 return 'divmod ' + str(other)
    1:             def __rdivmod__(self, other):
    1:                 return str(other) + ' rdivmod'
    1:             def __lt__(self, other):
    1:                 return 'lt ' + str(other)
    1:             def __gt__(self, other):
    1:                 return 'gt ' + str(other)
    1:             def __le__(self, other):
    1:                 return 'le ' + str(other)
    1:             def __ge__(self, other):
    1:                 return 'ge ' + str(other)
    1:             def __eq__(self, other):
    1:                 return 'eq ' + str(other)
    1:             def __ne__(self, other):
    1:                 return 'ne ' + str(other)
       
    1:         self.assertEqual(divmod(E(), Decimal(10)), 'divmod 10')
    1:         self.assertEqual(divmod(Decimal(10), E()), '10 rdivmod')
    1:         self.assertEqual(eval('Decimal(10) < E()'), 'gt 10')
    1:         self.assertEqual(eval('Decimal(10) > E()'), 'lt 10')
    1:         self.assertEqual(eval('Decimal(10) <= E()'), 'ge 10')
    1:         self.assertEqual(eval('Decimal(10) >= E()'), 'le 10')
    1:         self.assertEqual(eval('Decimal(10) == E()'), 'eq 10')
    1:         self.assertEqual(eval('Decimal(10) != E()'), 'ne 10')
       
               # insert operator methods and then exercise them
               oplist = [
    1:             ('+', '__add__', '__radd__'),
    1:             ('-', '__sub__', '__rsub__'),
    1:             ('*', '__mul__', '__rmul__'),
    1:             ('%', '__mod__', '__rmod__'),
    1:             ('//', '__floordiv__', '__rfloordiv__'),
    1:             ('**', '__pow__', '__rpow__')
               ]
    1:         with check_py3k_warnings():
    1:             if 1 / 2 == 0:
                       # testing with classic division, so add __div__
    1:                 oplist.append(('/', '__div__', '__rdiv__'))
                   else:
                       # testing with -Qnew, so add __truediv__
>>>>>>                 oplist.append(('/', '__truediv__', '__rtruediv__'))
       
    8:         for sym, lop, rop in oplist:
   14:             setattr(E, lop, lambda self, other: 'str' + lop + str(other))
   14:             setattr(E, rop, lambda self, other: str(other) + rop + 'str')
    7:             self.assertEqual(eval('E()' + sym + 'Decimal(10)'),
    7:                              'str' + lop + '10')
    7:             self.assertEqual(eval('Decimal(10)' + sym + 'E()'),
    7:                              '10' + rop + 'str')
       
       
    2: class DecimalFormatTest(unittest.TestCase):
    1:     '''Unit tests for the format function.'''
    1:     def test_formatting(self):
               # triples giving a format, a Decimal, and the expected result
               test_values = [
    1:             ('e', '0E-15', '0e-15'),
    1:             ('e', '2.3E-15', '2.3e-15'),
    1:             ('e', '2.30E+2', '2.30e+2'), # preserve significant zeros
    1:             ('e', '2.30000E-15', '2.30000e-15'),
    1:             ('e', '1.23456789123456789e40', '1.23456789123456789e+40'),
    1:             ('e', '1.5', '1.5e+0'),
    1:             ('e', '0.15', '1.5e-1'),
    1:             ('e', '0.015', '1.5e-2'),
    1:             ('e', '0.0000000000015', '1.5e-12'),
    1:             ('e', '15.0', '1.50e+1'),
    1:             ('e', '-15', '-1.5e+1'),
    1:             ('e', '0', '0e+0'),
    1:             ('e', '0E1', '0e+1'),
    1:             ('e', '0.0', '0e-1'),
    1:             ('e', '0.00', '0e-2'),
    1:             ('.6e', '0E-15', '0.000000e-9'),
    1:             ('.6e', '0', '0.000000e+6'),
    1:             ('.6e', '9.999999', '9.999999e+0'),
    1:             ('.6e', '9.9999999', '1.000000e+1'),
    1:             ('.6e', '-1.23e5', '-1.230000e+5'),
    1:             ('.6e', '1.23456789e-3', '1.234568e-3'),
    1:             ('f', '0', '0'),
    1:             ('f', '0.0', '0.0'),
    1:             ('f', '0E-2', '0.00'),
    1:             ('f', '0.00E-8', '0.0000000000'),
    1:             ('f', '0E1', '0'), # loses exponent information
    1:             ('f', '3.2E1', '32'),
    1:             ('f', '3.2E2', '320'),
    1:             ('f', '3.20E2', '320'),
    1:             ('f', '3.200E2', '320.0'),
    1:             ('f', '3.2E-6', '0.0000032'),
    1:             ('.6f', '0E-15', '0.000000'), # all zeros treated equally
    1:             ('.6f', '0E1', '0.000000'),
    1:             ('.6f', '0', '0.000000'),
    1:             ('.0f', '0', '0'), # no decimal point
    1:             ('.0f', '0e-2', '0'),
    1:             ('.0f', '3.14159265', '3'),
    1:             ('.1f', '3.14159265', '3.1'),
    1:             ('.4f', '3.14159265', '3.1416'),
    1:             ('.6f', '3.14159265', '3.141593'),
    1:             ('.7f', '3.14159265', '3.1415926'), # round-half-even!
    1:             ('.8f', '3.14159265', '3.14159265'),
    1:             ('.9f', '3.14159265', '3.141592650'),
       
    1:             ('g', '0', '0'),
    1:             ('g', '0.0', '0.0'),
    1:             ('g', '0E1', '0e+1'),
    1:             ('G', '0E1', '0E+1'),
    1:             ('g', '0E-5', '0.00000'),
    1:             ('g', '0E-6', '0.000000'),
    1:             ('g', '0E-7', '0e-7'),
    1:             ('g', '-0E2', '-0e+2'),
    1:             ('.0g', '3.14159265', '3'),  # 0 sig fig -> 1 sig fig
    1:             ('.1g', '3.14159265', '3'),
    1:             ('.2g', '3.14159265', '3.1'),
    1:             ('.5g', '3.14159265', '3.1416'),
    1:             ('.7g', '3.14159265', '3.141593'),
    1:             ('.8g', '3.14159265', '3.1415926'), # round-half-even!
    1:             ('.9g', '3.14159265', '3.14159265'),
    1:             ('.10g', '3.14159265', '3.14159265'), # don't pad
       
    1:             ('%', '0E1', '0%'),
    1:             ('%', '0E0', '0%'),
    1:             ('%', '0E-1', '0%'),
    1:             ('%', '0E-2', '0%'),
    1:             ('%', '0E-3', '0.0%'),
    1:             ('%', '0E-4', '0.00%'),
       
    1:             ('.3%', '0', '0.000%'), # all zeros treated equally
    1:             ('.3%', '0E10', '0.000%'),
    1:             ('.3%', '0E-10', '0.000%'),
    1:             ('.3%', '2.34', '234.000%'),
    1:             ('.3%', '1.234567', '123.457%'),
    1:             ('.0%', '1.23', '123%'),
       
    1:             ('e', 'NaN', 'NaN'),
    1:             ('f', '-NaN123', '-NaN123'),
    1:             ('+g', 'NaN456', '+NaN456'),
    1:             ('.3e', 'Inf', 'Infinity'),
    1:             ('.16f', '-Inf', '-Infinity'),
    1:             ('.0g', '-sNaN', '-sNaN'),
       
    1:             ('', '1.00', '1.00'),
       
                   # test alignment and padding
    1:             ('6', '123', '   123'),
    1:             ('<6', '123', '123   '),
    1:             ('>6', '123', '   123'),
    1:             ('^6', '123', ' 123  '),
    1:             ('=+6', '123', '+  123'),
    1:             ('#<10', 'NaN', 'NaN#######'),
    1:             ('#<10', '-4.3', '-4.3######'),
    1:             ('#<+10', '0.0130', '+0.0130###'),
    1:             ('#< 10', '0.0130', ' 0.0130###'),
    1:             ('@>10', '-Inf', '@-Infinity'),
    1:             ('#>5', '-Inf', '-Infinity'),
    1:             ('?^5', '123', '?123?'),
    1:             ('%^6', '123', '%123%%'),
    1:             (' ^6', '-45.6', '-45.6 '),
    1:             ('/=10', '-45.6', '-/////45.6'),
    1:             ('/=+10', '45.6', '+/////45.6'),
    1:             ('/= 10', '45.6', ' /////45.6'),
       
                   # thousands separator
    1:             (',', '1234567', '1,234,567'),
    1:             (',', '123456', '123,456'),
    1:             (',', '12345', '12,345'),
    1:             (',', '1234', '1,234'),
    1:             (',', '123', '123'),
    1:             (',', '12', '12'),
    1:             (',', '1', '1'),
    1:             (',', '0', '0'),
    1:             (',', '-1234567', '-1,234,567'),
    1:             (',', '-123456', '-123,456'),
    1:             ('7,', '123456', '123,456'),
    1:             ('8,', '123456', ' 123,456'),
    1:             ('08,', '123456', '0,123,456'), # special case: extra 0 needed
    1:             ('+08,', '123456', '+123,456'), # but not if there's a sign
    1:             (' 08,', '123456', ' 123,456'),
    1:             ('08,', '-123456', '-123,456'),
    1:             ('+09,', '123456', '+0,123,456'),
                   # ... with fractional part...
    1:             ('07,', '1234.56', '1,234.56'),
    1:             ('08,', '1234.56', '1,234.56'),
    1:             ('09,', '1234.56', '01,234.56'),
    1:             ('010,', '1234.56', '001,234.56'),
    1:             ('011,', '1234.56', '0,001,234.56'),
    1:             ('012,', '1234.56', '0,001,234.56'),
    1:             ('08,.1f', '1234.5', '01,234.5'),
                   # no thousands separators in fraction part
    1:             (',', '1.23456789', '1.23456789'),
    1:             (',%', '123.456789', '12,345.6789%'),
    1:             (',e', '123456', '1.23456e+5'),
    1:             (',E', '123456', '1.23456E+5'),
       
                   # issue 6850
    1:             ('a=-7.0', '0.12345', 'aaaa0.1'),
       
                   # issue 22090
    1:             ('<^+15.20%', 'inf', '<<+Infinity%<<<'),
    1:             ('\x07>,%', 'sNaN1234567', 'sNaN1234567%'),
    1:             ('=10.10%', 'NaN123', '   NaN123%'),
                   ]
  128:         for fmt, d, result in test_values:
  127:             self.assertEqual(format(Decimal(d), fmt), result)
       
    1:     def test_n_format(self):
    1:         try:
    1:             from locale import CHAR_MAX
>>>>>>         except ImportError:
>>>>>>             self.skipTest('locale.CHAR_MAX not available')
       
               # Set up some localeconv-like dictionaries
    1:         en_US = {
    1:             'decimal_point' : '.',
    1:             'grouping' : [3, 3, 0],
    1:             'thousands_sep': ','
                   }
       
    1:         fr_FR = {
    1:             'decimal_point' : ',',
    1:             'grouping' : [CHAR_MAX],
    1:             'thousands_sep' : ''
                   }
       
    1:         ru_RU = {
    1:             'decimal_point' : ',',
    1:             'grouping' : [3, 3, 0],
    1:             'thousands_sep' : ' '
                   }
       
    1:         crazy = {
    1:             'decimal_point' : '&',
    1:             'grouping' : [1, 4, 2, CHAR_MAX],
    1:             'thousands_sep' : '-'
                   }
       
       
    1:         def get_fmt(x, locale, fmt='n'):
   30:             return Decimal.__format__(Decimal(x), fmt, _localeconv=locale)
       
    1:         self.assertEqual(get_fmt(Decimal('12.7'), en_US), '12.7')
    1:         self.assertEqual(get_fmt(Decimal('12.7'), fr_FR), '12,7')
    1:         self.assertEqual(get_fmt(Decimal('12.7'), ru_RU), '12,7')
    1:         self.assertEqual(get_fmt(Decimal('12.7'), crazy), '1-2&7')
       
    1:         self.assertEqual(get_fmt(123456789, en_US), '123,456,789')
    1:         self.assertEqual(get_fmt(123456789, fr_FR), '123456789')
    1:         self.assertEqual(get_fmt(123456789, ru_RU), '123 456 789')
    1:         self.assertEqual(get_fmt(1234567890123, crazy), '123456-78-9012-3')
       
    1:         self.assertEqual(get_fmt(123456789, en_US, '.6n'), '1.23457e+8')
    1:         self.assertEqual(get_fmt(123456789, fr_FR, '.6n'), '1,23457e+8')
    1:         self.assertEqual(get_fmt(123456789, ru_RU, '.6n'), '1,23457e+8')
    1:         self.assertEqual(get_fmt(123456789, crazy, '.6n'), '1&23457e+8')
       
               # zero padding
    1:         self.assertEqual(get_fmt(1234, fr_FR, '03n'), '1234')
    1:         self.assertEqual(get_fmt(1234, fr_FR, '04n'), '1234')
    1:         self.assertEqual(get_fmt(1234, fr_FR, '05n'), '01234')
    1:         self.assertEqual(get_fmt(1234, fr_FR, '06n'), '001234')
       
    1:         self.assertEqual(get_fmt(12345, en_US, '05n'), '12,345')
    1:         self.assertEqual(get_fmt(12345, en_US, '06n'), '12,345')
    1:         self.assertEqual(get_fmt(12345, en_US, '07n'), '012,345')
    1:         self.assertEqual(get_fmt(12345, en_US, '08n'), '0,012,345')
    1:         self.assertEqual(get_fmt(12345, en_US, '09n'), '0,012,345')
    1:         self.assertEqual(get_fmt(12345, en_US, '010n'), '00,012,345')
       
    1:         self.assertEqual(get_fmt(123456, crazy, '06n'), '1-2345-6')
    1:         self.assertEqual(get_fmt(123456, crazy, '07n'), '1-2345-6')
    1:         self.assertEqual(get_fmt(123456, crazy, '08n'), '1-2345-6')
    1:         self.assertEqual(get_fmt(123456, crazy, '09n'), '01-2345-6')
    1:         self.assertEqual(get_fmt(123456, crazy, '010n'), '0-01-2345-6')
    1:         self.assertEqual(get_fmt(123456, crazy, '011n'), '0-01-2345-6')
    1:         self.assertEqual(get_fmt(123456, crazy, '012n'), '00-01-2345-6')
    1:         self.assertEqual(get_fmt(123456, crazy, '013n'), '000-01-2345-6')
       
    1:     @run_with_locale('LC_ALL', 'ps_AF.UTF-8')
           def test_wide_char_separator_decimal_point(self):
               # locale with wide char separator and decimal point
    1:         import locale
       
    1:         decimal_point = locale.localeconv()['decimal_point']
    1:         thousands_sep = locale.localeconv()['thousands_sep']
    1:         if decimal_point != '\xd9\xab':
    1:             self.skipTest('inappropriate decimal point separator'
    1:                           '({!r} not {!r})'.format(decimal_point, '\xd9\xab'))
>>>>>>         if thousands_sep != '\xd9\xac':
>>>>>>             self.skipTest('inappropriate thousands separator'
>>>>>>                           '({!r} not {!r})'.format(thousands_sep, '\xd9\xac'))
       
>>>>>>         self.assertEqual(format(Decimal('100000000.123'), 'n'),
>>>>>>                          '100\xd9\xac000\xd9\xac000\xd9\xab123')
       
       
    2: class DecimalArithmeticOperatorsTest(unittest.TestCase):
    1:     '''Unit tests for all arithmetic operators, binary and unary.'''
       
    1:     def test_addition(self):
       
    1:         d1 = Decimal('-11.1')
    1:         d2 = Decimal('22.2')
       
               #two Decimals
    1:         self.assertEqual(d1+d2, Decimal('11.1'))
    1:         self.assertEqual(d2+d1, Decimal('11.1'))
       
               #with other type, left
    1:         c = d1 + 5
    1:         self.assertEqual(c, Decimal('-6.1'))
    1:         self.assertEqual(type(c), type(d1))
       
               #with other type, right
    1:         c = 5 + d1
    1:         self.assertEqual(c, Decimal('-6.1'))
    1:         self.assertEqual(type(c), type(d1))
       
               #inline with decimal
    1:         d1 += d2
    1:         self.assertEqual(d1, Decimal('11.1'))
       
               #inline with other type
    1:         d1 += 5
    1:         self.assertEqual(d1, Decimal('16.1'))
       
    1:     def test_subtraction(self):
       
    1:         d1 = Decimal('-11.1')
    1:         d2 = Decimal('22.2')
       
               #two Decimals
    1:         self.assertEqual(d1-d2, Decimal('-33.3'))
    1:         self.assertEqual(d2-d1, Decimal('33.3'))
       
               #with other type, left
    1:         c = d1 - 5
    1:         self.assertEqual(c, Decimal('-16.1'))
    1:         self.assertEqual(type(c), type(d1))
       
               #with other type, right
    1:         c = 5 - d1
    1:         self.assertEqual(c, Decimal('16.1'))
    1:         self.assertEqual(type(c), type(d1))
       
               #inline with decimal
    1:         d1 -= d2
    1:         self.assertEqual(d1, Decimal('-33.3'))
       
               #inline with other type
    1:         d1 -= 5
    1:         self.assertEqual(d1, Decimal('-38.3'))
       
    1:     def test_multiplication(self):
       
    1:         d1 = Decimal('-5')
    1:         d2 = Decimal('3')
       
               #two Decimals
    1:         self.assertEqual(d1*d2, Decimal('-15'))
    1:         self.assertEqual(d2*d1, Decimal('-15'))
       
               #with other type, left
    1:         c = d1 * 5
    1:         self.assertEqual(c, Decimal('-25'))
    1:         self.assertEqual(type(c), type(d1))
       
               #with other type, right
    1:         c = 5 * d1
    1:         self.assertEqual(c, Decimal('-25'))
    1:         self.assertEqual(type(c), type(d1))
       
               #inline with decimal
    1:         d1 *= d2
    1:         self.assertEqual(d1, Decimal('-15'))
       
               #inline with other type
    1:         d1 *= 5
    1:         self.assertEqual(d1, Decimal('-75'))
       
    1:     def test_division(self):
       
    1:         d1 = Decimal('-5')
    1:         d2 = Decimal('2')
       
               #two Decimals
    1:         self.assertEqual(d1/d2, Decimal('-2.5'))
    1:         self.assertEqual(d2/d1, Decimal('-0.4'))
       
               #with other type, left
    1:         c = d1 / 4
    1:         self.assertEqual(c, Decimal('-1.25'))
    1:         self.assertEqual(type(c), type(d1))
       
               #with other type, right
    1:         c = 4 / d1
    1:         self.assertEqual(c, Decimal('-0.8'))
    1:         self.assertEqual(type(c), type(d1))
       
               #inline with decimal
    1:         d1 /= d2
    1:         self.assertEqual(d1, Decimal('-2.5'))
       
               #inline with other type
    1:         d1 /= 4
    1:         self.assertEqual(d1, Decimal('-0.625'))
       
    1:     def test_floor_division(self):
       
    1:         d1 = Decimal('5')
    1:         d2 = Decimal('2')
       
               #two Decimals
    1:         self.assertEqual(d1//d2, Decimal('2'))
    1:         self.assertEqual(d2//d1, Decimal('0'))
       
               #with other type, left
    1:         c = d1 // 4
    1:         self.assertEqual(c, Decimal('1'))
    1:         self.assertEqual(type(c), type(d1))
       
               #with other type, right
    1:         c = 7 // d1
    1:         self.assertEqual(c, Decimal('1'))
    1:         self.assertEqual(type(c), type(d1))
       
               #inline with decimal
    1:         d1 //= d2
    1:         self.assertEqual(d1, Decimal('2'))
       
               #inline with other type
    1:         d1 //= 2
    1:         self.assertEqual(d1, Decimal('1'))
       
    1:     def test_powering(self):
       
    1:         d1 = Decimal('5')
    1:         d2 = Decimal('2')
       
               #two Decimals
    1:         self.assertEqual(d1**d2, Decimal('25'))
    1:         self.assertEqual(d2**d1, Decimal('32'))
       
               #with other type, left
    1:         c = d1 ** 4
    1:         self.assertEqual(c, Decimal('625'))
    1:         self.assertEqual(type(c), type(d1))
       
               #with other type, right
    1:         c = 7 ** d1
    1:         self.assertEqual(c, Decimal('16807'))
    1:         self.assertEqual(type(c), type(d1))
       
               #inline with decimal
    1:         d1 **= d2
    1:         self.assertEqual(d1, Decimal('25'))
       
               #inline with other type
    1:         d1 **= 4
    1:         self.assertEqual(d1, Decimal('390625'))
       
    1:     def test_module(self):
       
    1:         d1 = Decimal('5')
    1:         d2 = Decimal('2')
       
               #two Decimals
    1:         self.assertEqual(d1%d2, Decimal('1'))
    1:         self.assertEqual(d2%d1, Decimal('2'))
       
               #with other type, left
    1:         c = d1 % 4
    1:         self.assertEqual(c, Decimal('1'))
    1:         self.assertEqual(type(c), type(d1))
       
               #with other type, right
    1:         c = 7 % d1
    1:         self.assertEqual(c, Decimal('2'))
    1:         self.assertEqual(type(c), type(d1))
       
               #inline with decimal
    1:         d1 %= d2
    1:         self.assertEqual(d1, Decimal('1'))
       
               #inline with other type
    1:         d1 %= 4
    1:         self.assertEqual(d1, Decimal('1'))
       
    1:     def test_floor_div_module(self):
       
    1:         d1 = Decimal('5')
    1:         d2 = Decimal('2')
       
               #two Decimals
    1:         (p, q) = divmod(d1, d2)
    1:         self.assertEqual(p, Decimal('2'))
    1:         self.assertEqual(q, Decimal('1'))
    1:         self.assertEqual(type(p), type(d1))
    1:         self.assertEqual(type(q), type(d1))
       
               #with other type, left
    1:         (p, q) = divmod(d1, 4)
    1:         self.assertEqual(p, Decimal('1'))
    1:         self.assertEqual(q, Decimal('1'))
    1:         self.assertEqual(type(p), type(d1))
    1:         self.assertEqual(type(q), type(d1))
       
               #with other type, right
    1:         (p, q) = divmod(7, d1)
    1:         self.assertEqual(p, Decimal('1'))
    1:         self.assertEqual(q, Decimal('2'))
    1:         self.assertEqual(type(p), type(d1))
    1:         self.assertEqual(type(q), type(d1))
       
    1:     def test_unary_operators(self):
    1:         self.assertEqual(+Decimal(45), Decimal(+45))           #  +
    1:         self.assertEqual(-Decimal(45), Decimal(-45))           #  -
    1:         self.assertEqual(abs(Decimal(45)), abs(Decimal(-45)))  # abs
       
    1:     def test_nan_comparisons(self):
               # comparisons involving signaling nans signal InvalidOperation
       
               # order comparisons (<, <=, >, >=) involving only quiet nans
               # also signal InvalidOperation
       
               # equality comparisons (==, !=) involving only quiet nans
               # don't signal, but return False or True respectively.
       
    1:         n = Decimal('NaN')
    1:         s = Decimal('sNaN')
    1:         i = Decimal('Inf')
    1:         f = Decimal('2')
       
    1:         qnan_pairs = (n, n), (n, i), (i, n), (n, f), (f, n)
    1:         snan_pairs = (s, n), (n, s), (s, i), (i, s), (s, f), (f, s), (s, s)
    1:         order_ops = operator.lt, operator.le, operator.gt, operator.ge
    1:         equality_ops = operator.eq, operator.ne
       
               # results when InvalidOperation is not trapped
   13:         for x, y in qnan_pairs + snan_pairs:
   84:             for op in order_ops + equality_ops:
   72:                 got = op(x, y)
   72:                 expected = True if op is operator.ne else False
   72:                 self.assertIs(expected, got,
   72:                               "expected {0!r} for operator.{1}({2!r}, {3!r}); "
                                     "got {4!r}".format(
   72:                         expected, op.__name__, x, y, got))
       
               # repeat the above, but this time trap the InvalidOperation
    1:         with localcontext() as ctx:
    1:             ctx.traps[InvalidOperation] = 1
       
    6:             for x, y in qnan_pairs:
   15:                 for op in equality_ops:
   10:                     got = op(x, y)
   10:                     expected = True if op is operator.ne else False
   10:                     self.assertIs(expected, got,
   10:                                   "expected {0!r} for "
                                         "operator.{1}({2!r}, {3!r}); "
                                         "got {4!r}".format(
   10:                             expected, op.__name__, x, y, got))
       
    8:             for x, y in snan_pairs:
   21:                 for op in equality_ops:
   14:                     self.assertRaises(InvalidOperation, operator.eq, x, y)
   14:                     self.assertRaises(InvalidOperation, operator.ne, x, y)
       
   13:             for x, y in qnan_pairs + snan_pairs:
   60:                 for op in order_ops:
   48:                     self.assertRaises(InvalidOperation, op, x, y)
       
    1:     def test_copy_sign(self):
    1:         d = Decimal(1).copy_sign(Decimal(-2))
       
    1:         self.assertEqual(Decimal(1).copy_sign(-2), d)
    1:         self.assertRaises(TypeError, Decimal(1).copy_sign, '-2')
       
       # The following are two functions used to test threading in the next class
       
    1: def thfunc1(cls):
    1:     d1 = Decimal(1)
    1:     d3 = Decimal(3)
    1:     test1 = d1/d3
    1:     cls.synchro.wait()
    1:     test2 = d1/d3
    1:     cls.finish1.set()
       
    1:     cls.assertEqual(test1, Decimal('0.3333333333333333333333333333'))
    1:     cls.assertEqual(test2, Decimal('0.3333333333333333333333333333'))
       
    1: def thfunc2(cls):
    1:     d1 = Decimal(1)
    1:     d3 = Decimal(3)
    1:     test1 = d1/d3
    1:     thiscontext = getcontext()
    1:     thiscontext.prec = 18
    1:     test2 = d1/d3
    1:     cls.synchro.set()
    1:     cls.finish2.set()
       
    1:     cls.assertEqual(test1, Decimal('0.3333333333333333333333333333'))
    1:     cls.assertEqual(test2, Decimal('0.333333333333333333'))
       
       
    2: @unittest.skipUnless(threading, 'threading required')
    1: class DecimalUseOfContextTest(unittest.TestCase):
    1:     '''Unit tests for Use of Context cases in Decimal.'''
       
           # Take care executing this test from IDLE, there's an issue in threading
           # that hangs IDLE and I couldn't find it
       
    1:     def test_threading(self):
               #Test the "threading isolation" of a Context.
       
    1:         self.synchro = threading.Event()
    1:         self.finish1 = threading.Event()
    1:         self.finish2 = threading.Event()
       
    1:         th1 = threading.Thread(target=thfunc1, args=(self,))
    1:         th2 = threading.Thread(target=thfunc2, args=(self,))
       
    1:         th1.start()
    1:         th2.start()
       
    1:         self.finish1.wait()
    1:         self.finish2.wait()
       
       
    2: class DecimalUsabilityTest(unittest.TestCase):
    1:     '''Unit tests for Usability cases of Decimal.'''
       
    1:     def test_comparison_operators(self):
       
    1:         da = Decimal('23.42')
    1:         db = Decimal('23.42')
    1:         dc = Decimal('45')
       
               #two Decimals
    1:         self.assertGreater(dc, da)
    1:         self.assertGreaterEqual(dc, da)
    1:         self.assertLess(da, dc)
    1:         self.assertLessEqual(da, dc)
    1:         self.assertEqual(da, db)
    1:         self.assertNotEqual(da, dc)
    1:         self.assertLessEqual(da, db)
    1:         self.assertGreaterEqual(da, db)
    1:         self.assertEqual(cmp(dc,da), 1)
    1:         self.assertEqual(cmp(da,dc), -1)
    1:         self.assertEqual(cmp(da,db), 0)
       
               #a Decimal and an int
    1:         self.assertGreater(dc, 23)
    1:         self.assertLess(23, dc)
    1:         self.assertEqual(dc, 45)
    1:         self.assertEqual(cmp(dc,23), 1)
    1:         self.assertEqual(cmp(23,dc), -1)
    1:         self.assertEqual(cmp(dc,45), 0)
       
               #a Decimal and uncomparable
    1:         self.assertNotEqual(da, 'ugly')
    1:         self.assertNotEqual(da, 32.7)
    1:         self.assertNotEqual(da, object())
    1:         self.assertNotEqual(da, object)
       
               # sortable
    1:         a = map(Decimal, xrange(100))
    1:         b =  a[:]
    1:         random.shuffle(a)
    1:         a.sort()
    1:         self.assertEqual(a, b)
       
               # with None
    1:         with check_py3k_warnings():
    1:             self.assertFalse(Decimal(1) < None)
    1:             self.assertTrue(Decimal(1) > None)
       
    1:     def test_decimal_float_comparison(self):
    1:         da = Decimal('0.25')
    1:         db = Decimal('3.0')
    1:         self.assertLess(da, 3.0)
    1:         self.assertLessEqual(da, 3.0)
    1:         self.assertGreater(db, 0.25)
    1:         self.assertGreaterEqual(db, 0.25)
    1:         self.assertNotEqual(da, 1.5)
    1:         self.assertEqual(da, 0.25)
    1:         self.assertGreater(3.0, da)
    1:         self.assertGreaterEqual(3.0, da)
    1:         self.assertLess(0.25, db)
    1:         self.assertLessEqual(0.25, db)
    1:         self.assertNotEqual(0.25, db)
    1:         self.assertEqual(3.0, db)
    1:         self.assertNotEqual(0.1, Decimal('0.1'))
       
    1:     def test_copy_and_deepcopy_methods(self):
    1:         d = Decimal('43.24')
    1:         c = copy.copy(d)
    1:         self.assertEqual(id(c), id(d))
    1:         dc = copy.deepcopy(d)
    1:         self.assertEqual(id(dc), id(d))
       
    1:     def test_hash_method(self):
               #just that it's hashable
    1:         hash(Decimal(23))
    1:         hash(Decimal('Infinity'))
    1:         hash(Decimal('-Infinity'))
    1:         hash(Decimal('nan123'))
    1:         hash(Decimal('-NaN'))
       
    1:         test_values = [Decimal(sign*(2**m + n))
    1:                        for m in [0, 14, 15, 16, 17, 30, 31,
   15:                                  32, 33, 62, 63, 64, 65, 66]
  294:                        for n in range(-10, 10)
  840:                        for sign in [-1, 1]]
    1:         test_values.extend([
    1:                 Decimal("-0"), # zeros
    1:                 Decimal("0.00"),
    1:                 Decimal("-0.000"),
    1:                 Decimal("0E10"),
    1:                 Decimal("-0E12"),
    1:                 Decimal("10.0"), # negative exponent
    1:                 Decimal("-23.00000"),
    1:                 Decimal("1230E100"), # positive exponent
    1:                 Decimal("-4.5678E50"),
                       # a value for which hash(n) != hash(n % (2**64-1))
                       # in Python pre-2.6
    1:                 Decimal(2**64 + 2**32 - 1),
                       # selection of values which fail with the old (before
                       # version 2.6) long.__hash__
    1:                 Decimal("1.634E100"),
    1:                 Decimal("90.697E100"),
    1:                 Decimal("188.83E100"),
    1:                 Decimal("1652.9E100"),
    1:                 Decimal("56531E100"),
                       ])
       
               # check that hash(d) == hash(int(d)) for integral values
  576:         for value in test_values:
  575:             self.assertEqual(hash(value), hash(int(value)))
       
               #the same hash that to an int
    1:         self.assertEqual(hash(Decimal(23)), hash(23))
    1:         self.assertRaises(TypeError, hash, Decimal('sNaN'))
    1:         self.assertTrue(hash(Decimal('Inf')))
    1:         self.assertTrue(hash(Decimal('-Inf')))
       
               # check that the hashes of a Decimal float match when they
               # represent exactly the same values
    1:         test_strings = ['inf', '-Inf', '0.0', '-.0e1',
    1:                         '34.0', '2.5', '112390.625', '-0.515625']
    9:         for s in test_strings:
    8:             f = float(s)
    8:             d = Decimal(s)
    8:             self.assertEqual(hash(f), hash(d))
       
               # check that the value of the hash doesn't depend on the
               # current context (issue #1757)
    1:         c = getcontext()
    1:         old_precision = c.prec
    1:         x = Decimal("123456789.1")
       
    1:         c.prec = 6
    1:         h1 = hash(x)
    1:         c.prec = 10
    1:         h2 = hash(x)
    1:         c.prec = 16
    1:         h3 = hash(x)
       
    1:         self.assertEqual(h1, h2)
    1:         self.assertEqual(h1, h3)
    1:         c.prec = old_precision
       
    1:     def test_min_and_max_methods(self):
       
    1:         d1 = Decimal('15.32')
    1:         d2 = Decimal('28.5')
    1:         l1 = 15
    1:         l2 = 28
       
               #between Decimals
    1:         self.assertIs(min(d1,d2), d1)
    1:         self.assertIs(min(d2,d1), d1)
    1:         self.assertIs(max(d1,d2), d2)
    1:         self.assertIs(max(d2,d1), d2)
       
               #between Decimal and long
    1:         self.assertIs(min(d1,l2), d1)
    1:         self.assertIs(min(l2,d1), d1)
    1:         self.assertIs(max(l1,d2), d2)
    1:         self.assertIs(max(d2,l1), d2)
       
    1:     def test_as_nonzero(self):
               #as false
    1:         self.assertFalse(Decimal(0))
               #as true
    1:         self.assertTrue(Decimal('0.372'))
       
    1:     def test_tostring_methods(self):
               #Test str and repr methods.
       
    1:         d = Decimal('15.32')
    1:         self.assertEqual(str(d), '15.32')               # str
    1:         self.assertEqual(repr(d), "Decimal('15.32')")   # repr
       
               # result type of string methods should be str, not unicode
    1:         unicode_inputs = [u'123.4', u'0.5E2', u'Infinity', u'sNaN',
    1:                           u'-0.0E100', u'-NaN001', u'-Inf']
       
    8:         for u in unicode_inputs:
    7:             d = Decimal(u)
    7:             self.assertEqual(type(str(d)), str)
    7:             self.assertEqual(type(repr(d)), str)
    7:             self.assertEqual(type(d.to_eng_string()), str)
       
    1:     def test_tonum_methods(self):
               #Test float, int and long methods.
       
    1:         d1 = Decimal('66')
    1:         d2 = Decimal('15.32')
       
               #int
    1:         self.assertEqual(int(d1), 66)
    1:         self.assertEqual(int(d2), 15)
       
               #long
    1:         self.assertEqual(long(d1), 66)
    1:         self.assertEqual(long(d2), 15)
       
               #float
    1:         self.assertEqual(float(d1), 66)
    1:         self.assertEqual(float(d2), 15.32)
       
    1:     def test_nan_to_float(self):
               # Test conversions of decimal NANs to float.
               # See http://bugs.python.org/issue15544
    5:         for s in ('nan', 'nan1234', '-nan', '-nan2468'):
    4:             f = float(Decimal(s))
    4:             self.assertTrue(math.isnan(f))
       
    1:     def test_snan_to_float(self):
    5:         for s in ('snan', '-snan', 'snan1357', '-snan1234'):
    4:             d = Decimal(s)
    4:             self.assertRaises(ValueError, float, d)
       
    1:     def test_eval_round_trip(self):
       
               #with zero
    1:         d = Decimal( (0, (0,), 0) )
    1:         self.assertEqual(d, eval(repr(d)))
       
               #int
    1:         d = Decimal( (1, (4, 5), 0) )
    1:         self.assertEqual(d, eval(repr(d)))
       
               #float
    1:         d = Decimal( (0, (4, 5, 3, 4), -2) )
    1:         self.assertEqual(d, eval(repr(d)))
       
               #weird
    1:         d = Decimal( (1, (4, 3, 4, 9, 1, 3, 5, 3, 4), -25) )
    1:         self.assertEqual(d, eval(repr(d)))
       
    1:     def test_as_tuple(self):
       
               #with zero
    1:         d = Decimal(0)
    1:         self.assertEqual(d.as_tuple(), (0, (0,), 0) )
       
               #int
    1:         d = Decimal(-45)
    1:         self.assertEqual(d.as_tuple(), (1, (4, 5), 0) )
       
               #complicated string
    1:         d = Decimal("-4.34913534E-17")
    1:         self.assertEqual(d.as_tuple(), (1, (4, 3, 4, 9, 1, 3, 5, 3, 4), -25) )
       
               #inf
    1:         d = Decimal("Infinity")
    1:         self.assertEqual(d.as_tuple(), (0, (0,), 'F') )
       
               #leading zeros in coefficient should be stripped
    1:         d = Decimal( (0, (0, 0, 4, 0, 5, 3, 4), -2) )
    1:         self.assertEqual(d.as_tuple(), (0, (4, 0, 5, 3, 4), -2) )
    1:         d = Decimal( (1, (0, 0, 0), 37) )
    1:         self.assertEqual(d.as_tuple(), (1, (0,), 37))
    1:         d = Decimal( (1, (), 37) )
    1:         self.assertEqual(d.as_tuple(), (1, (0,), 37))
       
               #leading zeros in NaN diagnostic info should be stripped
    1:         d = Decimal( (0, (0, 0, 4, 0, 5, 3, 4), 'n') )
    1:         self.assertEqual(d.as_tuple(), (0, (4, 0, 5, 3, 4), 'n') )
    1:         d = Decimal( (1, (0, 0, 0), 'N') )
    1:         self.assertEqual(d.as_tuple(), (1, (), 'N') )
    1:         d = Decimal( (1, (), 'n') )
    1:         self.assertEqual(d.as_tuple(), (1, (), 'n') )
       
               #coefficient in infinity should be ignored
    1:         d = Decimal( (0, (4, 5, 3, 4), 'F') )
    1:         self.assertEqual(d.as_tuple(), (0, (0,), 'F'))
    1:         d = Decimal( (1, (0, 2, 7, 1), 'F') )
    1:         self.assertEqual(d.as_tuple(), (1, (0,), 'F'))
       
    1:     def test_immutability_operations(self):
               # Do operations and check that it didn't change change internal objects.
       
    1:         d1 = Decimal('-25e55')
    1:         b1 = Decimal('-25e55')
    1:         d2 = Decimal('33e+33')
    1:         b2 = Decimal('33e+33')
       
    1:         def checkSameDec(operation, useOther=False):
   46:             if useOther:
   29:                 eval("d1." + operation + "(d2)")
   29:                 self.assertEqual(d1._sign, b1._sign)
   29:                 self.assertEqual(d1._int, b1._int)
   29:                 self.assertEqual(d1._exp, b1._exp)
   29:                 self.assertEqual(d2._sign, b2._sign)
   29:                 self.assertEqual(d2._int, b2._int)
   29:                 self.assertEqual(d2._exp, b2._exp)
                   else:
   17:                 eval("d1." + operation + "()")
   17:                 self.assertEqual(d1._sign, b1._sign)
   17:                 self.assertEqual(d1._int, b1._int)
   17:                 self.assertEqual(d1._exp, b1._exp)
       
    1:         Decimal(d1)
    1:         self.assertEqual(d1._sign, b1._sign)
    1:         self.assertEqual(d1._int, b1._int)
    1:         self.assertEqual(d1._exp, b1._exp)
       
    1:         checkSameDec("__abs__")
    1:         checkSameDec("__add__", True)
    1:         checkSameDec("__div__", True)
    1:         checkSameDec("__divmod__", True)
    1:         checkSameDec("__eq__", True)
    1:         checkSameDec("__ne__", True)
    1:         checkSameDec("__le__", True)
    1:         checkSameDec("__lt__", True)
    1:         checkSameDec("__ge__", True)
    1:         checkSameDec("__gt__", True)
    1:         checkSameDec("__float__")
    1:         checkSameDec("__floordiv__", True)
    1:         checkSameDec("__hash__")
    1:         checkSameDec("__int__")
    1:         checkSameDec("__trunc__")
    1:         checkSameDec("__long__")
    1:         checkSameDec("__mod__", True)
    1:         checkSameDec("__mul__", True)
    1:         checkSameDec("__neg__")
    1:         checkSameDec("__nonzero__")
    1:         checkSameDec("__pos__")
    1:         checkSameDec("__pow__", True)
    1:         checkSameDec("__radd__", True)
    1:         checkSameDec("__rdiv__", True)
    1:         checkSameDec("__rdivmod__", True)
    1:         checkSameDec("__repr__")
    1:         checkSameDec("__rfloordiv__", True)
    1:         checkSameDec("__rmod__", True)
    1:         checkSameDec("__rmul__", True)
    1:         checkSameDec("__rpow__", True)
    1:         checkSameDec("__rsub__", True)
    1:         checkSameDec("__str__")
    1:         checkSameDec("__sub__", True)
    1:         checkSameDec("__truediv__", True)
    1:         checkSameDec("adjusted")
    1:         checkSameDec("as_tuple")
    1:         checkSameDec("compare", True)
    1:         checkSameDec("max", True)
    1:         checkSameDec("min", True)
    1:         checkSameDec("normalize")
    1:         checkSameDec("quantize", True)
    1:         checkSameDec("remainder_near", True)
    1:         checkSameDec("same_quantum", True)
    1:         checkSameDec("sqrt")
    1:         checkSameDec("to_eng_string")
    1:         checkSameDec("to_integral")
       
    1:     def test_subclassing(self):
               # Different behaviours when subclassing Decimal
       
    2:         class MyDecimal(Decimal):
    1:             pass
       
    1:         d1 = MyDecimal(1)
    1:         d2 = MyDecimal(2)
    1:         d = d1 + d2
    1:         self.assertIs(type(d), Decimal)
       
    1:         d = d1.max(d2)
    1:         self.assertIs(type(d), Decimal)
       
    1:     def test_implicit_context(self):
               # Check results when context given implicitly.  (Issue 2478)
    1:         c = getcontext()
    1:         self.assertEqual(str(Decimal(0).sqrt()),
    1:                          str(c.sqrt(Decimal(0))))
       
    1:     def test_conversions_from_int(self):
               # Check that methods taking a second Decimal argument will
               # always accept an integer in place of a Decimal.
    1:         self.assertEqual(Decimal(4).compare(3),
    1:                          Decimal(4).compare(Decimal(3)))
    1:         self.assertEqual(Decimal(4).compare_signal(3),
    1:                          Decimal(4).compare_signal(Decimal(3)))
    1:         self.assertEqual(Decimal(4).compare_total(3),
    1:                          Decimal(4).compare_total(Decimal(3)))
    1:         self.assertEqual(Decimal(4).compare_total_mag(3),
    1:                          Decimal(4).compare_total_mag(Decimal(3)))
    1:         self.assertEqual(Decimal(10101).logical_and(1001),
    1:                          Decimal(10101).logical_and(Decimal(1001)))
    1:         self.assertEqual(Decimal(10101).logical_or(1001),
    1:                          Decimal(10101).logical_or(Decimal(1001)))
    1:         self.assertEqual(Decimal(10101).logical_xor(1001),
    1:                          Decimal(10101).logical_xor(Decimal(1001)))
    1:         self.assertEqual(Decimal(567).max(123),
    1:                          Decimal(567).max(Decimal(123)))
    1:         self.assertEqual(Decimal(567).max_mag(123),
    1:                          Decimal(567).max_mag(Decimal(123)))
    1:         self.assertEqual(Decimal(567).min(123),
    1:                          Decimal(567).min(Decimal(123)))
    1:         self.assertEqual(Decimal(567).min_mag(123),
    1:                          Decimal(567).min_mag(Decimal(123)))
    1:         self.assertEqual(Decimal(567).next_toward(123),
    1:                          Decimal(567).next_toward(Decimal(123)))
    1:         self.assertEqual(Decimal(1234).quantize(100),
    1:                          Decimal(1234).quantize(Decimal(100)))
    1:         self.assertEqual(Decimal(768).remainder_near(1234),
    1:                          Decimal(768).remainder_near(Decimal(1234)))
    1:         self.assertEqual(Decimal(123).rotate(1),
    1:                          Decimal(123).rotate(Decimal(1)))
    1:         self.assertEqual(Decimal(1234).same_quantum(1000),
    1:                          Decimal(1234).same_quantum(Decimal(1000)))
    1:         self.assertEqual(Decimal('9.123').scaleb(-100),
    1:                          Decimal('9.123').scaleb(Decimal(-100)))
    1:         self.assertEqual(Decimal(456).shift(-1),
    1:                          Decimal(456).shift(Decimal(-1)))
       
    1:         self.assertEqual(Decimal(-12).fma(Decimal(45), 67),
    1:                          Decimal(-12).fma(Decimal(45), Decimal(67)))
    1:         self.assertEqual(Decimal(-12).fma(45, 67),
    1:                          Decimal(-12).fma(Decimal(45), Decimal(67)))
    1:         self.assertEqual(Decimal(-12).fma(45, Decimal(67)),
    1:                          Decimal(-12).fma(Decimal(45), Decimal(67)))
       
       
    2: class DecimalPythonAPItests(unittest.TestCase):
       
    1:     def test_abc(self):
    1:         self.assertTrue(issubclass(Decimal, numbers.Number))
    1:         self.assertFalse(issubclass(Decimal, numbers.Real))
    1:         self.assertIsInstance(Decimal(0), numbers.Number)
    1:         self.assertNotIsInstance(Decimal(0), numbers.Real)
       
    1:     def test_pickle(self):
    1:         d = Decimal('-3.141590000')
    4:         for proto in range(pickle.HIGHEST_PROTOCOL + 1):
    3:             p = pickle.dumps(d, proto)
    3:             e = pickle.loads(p)
    3:             self.assertEqual(d, e)
       
    1:     def test_int(self):
  501:         for x in range(-250, 250):
  500:             s = '%0.2f' % (x / 100.0)
                   # should work the same as for floats
  500:             self.assertEqual(int(Decimal(s)), int(float(s)))
                   # should work the same as to_integral in the ROUND_DOWN mode
  500:             d = Decimal(s)
  500:             r = d.to_integral(ROUND_DOWN)
  500:             self.assertEqual(Decimal(int(d)), r)
       
    1:         self.assertRaises(ValueError, int, Decimal('-nan'))
    1:         self.assertRaises(ValueError, int, Decimal('snan'))
    1:         self.assertRaises(OverflowError, int, Decimal('inf'))
    1:         self.assertRaises(OverflowError, int, Decimal('-inf'))
       
    1:         self.assertRaises(ValueError, long, Decimal('-nan'))
    1:         self.assertRaises(ValueError, long, Decimal('snan'))
    1:         self.assertRaises(OverflowError, long, Decimal('inf'))
    1:         self.assertRaises(OverflowError, long, Decimal('-inf'))
       
    1:     def test_trunc(self):
  501:         for x in range(-250, 250):
  500:             s = '%0.2f' % (x / 100.0)
                   # should work the same as for floats
  500:             self.assertEqual(int(Decimal(s)), int(float(s)))
                   # should work the same as to_integral in the ROUND_DOWN mode
  500:             d = Decimal(s)
  500:             r = d.to_integral(ROUND_DOWN)
  500:             self.assertEqual(Decimal(math.trunc(d)), r)
       
    1:     def test_from_float(self):
       
    2:         class  MyDecimal(Decimal):
    1:             pass
       
    1:         r = MyDecimal.from_float(0.1)
    1:         self.assertEqual(type(r), MyDecimal)
    1:         self.assertEqual(str(r),
    1:                 '0.1000000000000000055511151231257827021181583404541015625')
    1:         bigint = 12345678901234567890123456789
    1:         self.assertEqual(MyDecimal.from_float(bigint), MyDecimal(bigint))
    1:         self.assertTrue(MyDecimal.from_float(float('nan')).is_qnan())
    1:         self.assertTrue(MyDecimal.from_float(float('inf')).is_infinite())
    1:         self.assertTrue(MyDecimal.from_float(float('-inf')).is_infinite())
    1:         self.assertEqual(str(MyDecimal.from_float(float('nan'))),
    1:                          str(Decimal('NaN')))
    1:         self.assertEqual(str(MyDecimal.from_float(float('inf'))),
    1:                          str(Decimal('Infinity')))
    1:         self.assertEqual(str(MyDecimal.from_float(float('-inf'))),
    1:                          str(Decimal('-Infinity')))
    1:         self.assertRaises(TypeError, MyDecimal.from_float, 'abc')
  201:         for i in range(200):
  200:             x = random.expovariate(0.01) * (random.random() * 2.0 - 1.0)
  200:             self.assertEqual(x, float(MyDecimal.from_float(x))) # roundtrip
       
    1:     def test_create_decimal_from_float(self):
    1:         context = Context(prec=5, rounding=ROUND_DOWN)
    1:         self.assertEqual(
    1:             context.create_decimal_from_float(math.pi),
    1:             Decimal('3.1415')
               )
    1:         context = Context(prec=5, rounding=ROUND_UP)
    1:         self.assertEqual(
    1:             context.create_decimal_from_float(math.pi),
    1:             Decimal('3.1416')
               )
    1:         context = Context(prec=5, traps=[Inexact])
    1:         self.assertRaises(
    1:             Inexact,
    1:             context.create_decimal_from_float,
    1:             math.pi
               )
    1:         self.assertEqual(repr(context.create_decimal_from_float(-0.0)),
    1:                          "Decimal('-0')")
    1:         self.assertEqual(repr(context.create_decimal_from_float(1.0)),
    1:                          "Decimal('1')")
    1:         self.assertEqual(repr(context.create_decimal_from_float(10)),
    1:                          "Decimal('10')")
       
    2: class ContextAPItests(unittest.TestCase):
       
    1:     def test_pickle(self):
    4:         for proto in range(pickle.HIGHEST_PROTOCOL + 1):
    3:             c = Context()
    3:             e = pickle.loads(pickle.dumps(c, proto))
   30:             for k in vars(c):
   27:                 v1 = vars(c)[k]
   27:                 v2 = vars(e)[k]
   27:                 self.assertEqual(v1, v2)
       
    1:     def test_equality_with_other_types(self):
    1:         self.assertIn(Decimal(10), ['a', 1.0, Decimal(10), (1,2), {}])
    1:         self.assertNotIn(Decimal(10), ['a', 1.0, (1,2), {}])
       
    1:     def test_copy(self):
               # All copies should be deep
    1:         c = Context()
    1:         d = c.copy()
    1:         self.assertNotEqual(id(c), id(d))
    1:         self.assertNotEqual(id(c.flags), id(d.flags))
    1:         self.assertNotEqual(id(c.traps), id(d.traps))
       
    1:     def test_abs(self):
    1:         c = Context()
    1:         d = c.abs(Decimal(-1))
    1:         self.assertEqual(c.abs(-1), d)
    1:         self.assertRaises(TypeError, c.abs, '-1')
       
    1:     def test_add(self):
    1:         c = Context()
    1:         d = c.add(Decimal(1), Decimal(1))
    1:         self.assertEqual(c.add(1, 1), d)
    1:         self.assertEqual(c.add(Decimal(1), 1), d)
    1:         self.assertEqual(c.add(1, Decimal(1)), d)
    1:         self.assertRaises(TypeError, c.add, '1', 1)
    1:         self.assertRaises(TypeError, c.add, 1, '1')
       
    1:     def test_compare(self):
    1:         c = Context()
    1:         d = c.compare(Decimal(1), Decimal(1))
    1:         self.assertEqual(c.compare(1, 1), d)
    1:         self.assertEqual(c.compare(Decimal(1), 1), d)
    1:         self.assertEqual(c.compare(1, Decimal(1)), d)
    1:         self.assertRaises(TypeError, c.compare, '1', 1)
    1:         self.assertRaises(TypeError, c.compare, 1, '1')
       
    1:     def test_compare_signal(self):
    1:         c = Context()
    1:         d = c.compare_signal(Decimal(1), Decimal(1))
    1:         self.assertEqual(c.compare_signal(1, 1), d)
    1:         self.assertEqual(c.compare_signal(Decimal(1), 1), d)
    1:         self.assertEqual(c.compare_signal(1, Decimal(1)), d)
    1:         self.assertRaises(TypeError, c.compare_signal, '1', 1)
    1:         self.assertRaises(TypeError, c.compare_signal, 1, '1')
       
    1:     def test_compare_total(self):
    1:         c = Context()
    1:         d = c.compare_total(Decimal(1), Decimal(1))
    1:         self.assertEqual(c.compare_total(1, 1), d)
    1:         self.assertEqual(c.compare_total(Decimal(1), 1), d)
    1:         self.assertEqual(c.compare_total(1, Decimal(1)), d)
    1:         self.assertRaises(TypeError, c.compare_total, '1', 1)
    1:         self.assertRaises(TypeError, c.compare_total, 1, '1')
       
    1:     def test_compare_total_mag(self):
    1:         c = Context()
    1:         d = c.compare_total_mag(Decimal(1), Decimal(1))
    1:         self.assertEqual(c.compare_total_mag(1, 1), d)
    1:         self.assertEqual(c.compare_total_mag(Decimal(1), 1), d)
    1:         self.assertEqual(c.compare_total_mag(1, Decimal(1)), d)
    1:         self.assertRaises(TypeError, c.compare_total_mag, '1', 1)
    1:         self.assertRaises(TypeError, c.compare_total_mag, 1, '1')
       
    1:     def test_copy_abs(self):
    1:         c = Context()
    1:         d = c.copy_abs(Decimal(-1))
    1:         self.assertEqual(c.copy_abs(-1), d)
    1:         self.assertRaises(TypeError, c.copy_abs, '-1')
       
    1:     def test_copy_decimal(self):
    1:         c = Context()
    1:         d = c.copy_decimal(Decimal(-1))
    1:         self.assertEqual(c.copy_decimal(-1), d)
    1:         self.assertRaises(TypeError, c.copy_decimal, '-1')
       
    1:     def test_copy_negate(self):
    1:         c = Context()
    1:         d = c.copy_negate(Decimal(-1))
    1:         self.assertEqual(c.copy_negate(-1), d)
    1:         self.assertRaises(TypeError, c.copy_negate, '-1')
       
    1:     def test_copy_sign(self):
    1:         c = Context()
    1:         d = c.copy_sign(Decimal(1), Decimal(-2))
    1:         self.assertEqual(c.copy_sign(1, -2), d)
    1:         self.assertEqual(c.copy_sign(Decimal(1), -2), d)
    1:         self.assertEqual(c.copy_sign(1, Decimal(-2)), d)
    1:         self.assertRaises(TypeError, c.copy_sign, '1', -2)
    1:         self.assertRaises(TypeError, c.copy_sign, 1, '-2')
       
    1:     def test_divide(self):
    1:         c = Context()
    1:         d = c.divide(Decimal(1), Decimal(2))
    1:         self.assertEqual(c.divide(1, 2), d)
    1:         self.assertEqual(c.divide(Decimal(1), 2), d)
    1:         self.assertEqual(c.divide(1, Decimal(2)), d)
    1:         self.assertRaises(TypeError, c.divide, '1', 2)
    1:         self.assertRaises(TypeError, c.divide, 1, '2')
       
    1:     def test_divide_int(self):
    1:         c = Context()
    1:         d = c.divide_int(Decimal(1), Decimal(2))
    1:         self.assertEqual(c.divide_int(1, 2), d)
    1:         self.assertEqual(c.divide_int(Decimal(1), 2), d)
    1:         self.assertEqual(c.divide_int(1, Decimal(2)), d)
    1:         self.assertRaises(TypeError, c.divide_int, '1', 2)
    1:         self.assertRaises(TypeError, c.divide_int, 1, '2')
       
    1:     def test_divmod(self):
    1:         c = Context()
    1:         d = c.divmod(Decimal(1), Decimal(2))
    1:         self.assertEqual(c.divmod(1, 2), d)
    1:         self.assertEqual(c.divmod(Decimal(1), 2), d)
    1:         self.assertEqual(c.divmod(1, Decimal(2)), d)
    1:         self.assertRaises(TypeError, c.divmod, '1', 2)
    1:         self.assertRaises(TypeError, c.divmod, 1, '2')
       
    1:     def test_exp(self):
    1:         c = Context()
    1:         d = c.exp(Decimal(10))
    1:         self.assertEqual(c.exp(10), d)
    1:         self.assertRaises(TypeError, c.exp, '10')
       
    1:     def test_fma(self):
    1:         c = Context()
    1:         d = c.fma(Decimal(2), Decimal(3), Decimal(4))
    1:         self.assertEqual(c.fma(2, 3, 4), d)
    1:         self.assertEqual(c.fma(Decimal(2), 3, 4), d)
    1:         self.assertEqual(c.fma(2, Decimal(3), 4), d)
    1:         self.assertEqual(c.fma(2, 3, Decimal(4)), d)
    1:         self.assertEqual(c.fma(Decimal(2), Decimal(3), 4), d)
    1:         self.assertRaises(TypeError, c.fma, '2', 3, 4)
    1:         self.assertRaises(TypeError, c.fma, 2, '3', 4)
    1:         self.assertRaises(TypeError, c.fma, 2, 3, '4')
       
    1:     def test_is_finite(self):
    1:         c = Context()
    1:         d = c.is_finite(Decimal(10))
    1:         self.assertEqual(c.is_finite(10), d)
    1:         self.assertRaises(TypeError, c.is_finite, '10')
       
    1:     def test_is_infinite(self):
    1:         c = Context()
    1:         d = c.is_infinite(Decimal(10))
    1:         self.assertEqual(c.is_infinite(10), d)
    1:         self.assertRaises(TypeError, c.is_infinite, '10')
       
    1:     def test_is_nan(self):
    1:         c = Context()
    1:         d = c.is_nan(Decimal(10))
    1:         self.assertEqual(c.is_nan(10), d)
    1:         self.assertRaises(TypeError, c.is_nan, '10')
       
    1:     def test_is_normal(self):
    1:         c = Context()
    1:         d = c.is_normal(Decimal(10))
    1:         self.assertEqual(c.is_normal(10), d)
    1:         self.assertRaises(TypeError, c.is_normal, '10')
       
    1:     def test_is_qnan(self):
    1:         c = Context()
    1:         d = c.is_qnan(Decimal(10))
    1:         self.assertEqual(c.is_qnan(10), d)
    1:         self.assertRaises(TypeError, c.is_qnan, '10')
       
    1:     def test_is_signed(self):
    1:         c = Context()
    1:         d = c.is_signed(Decimal(10))
    1:         self.assertEqual(c.is_signed(10), d)
    1:         self.assertRaises(TypeError, c.is_signed, '10')
       
    1:     def test_is_snan(self):
    1:         c = Context()
    1:         d = c.is_snan(Decimal(10))
    1:         self.assertEqual(c.is_snan(10), d)
    1:         self.assertRaises(TypeError, c.is_snan, '10')
       
    1:     def test_is_subnormal(self):
    1:         c = Context()
    1:         d = c.is_subnormal(Decimal(10))
    1:         self.assertEqual(c.is_subnormal(10), d)
    1:         self.assertRaises(TypeError, c.is_subnormal, '10')
       
    1:     def test_is_zero(self):
    1:         c = Context()
    1:         d = c.is_zero(Decimal(10))
    1:         self.assertEqual(c.is_zero(10), d)
    1:         self.assertRaises(TypeError, c.is_zero, '10')
       
    1:     def test_ln(self):
    1:         c = Context()
    1:         d = c.ln(Decimal(10))
    1:         self.assertEqual(c.ln(10), d)
    1:         self.assertRaises(TypeError, c.ln, '10')
       
    1:     def test_log10(self):
    1:         c = Context()
    1:         d = c.log10(Decimal(10))
    1:         self.assertEqual(c.log10(10), d)
    1:         self.assertRaises(TypeError, c.log10, '10')
       
    1:     def test_logb(self):
    1:         c = Context()
    1:         d = c.logb(Decimal(10))
    1:         self.assertEqual(c.logb(10), d)
    1:         self.assertRaises(TypeError, c.logb, '10')
       
    1:     def test_logical_and(self):
    1:         c = Context()
    1:         d = c.logical_and(Decimal(1), Decimal(1))
    1:         self.assertEqual(c.logical_and(1, 1), d)
    1:         self.assertEqual(c.logical_and(Decimal(1), 1), d)
    1:         self.assertEqual(c.logical_and(1, Decimal(1)), d)
    1:         self.assertRaises(TypeError, c.logical_and, '1', 1)
    1:         self.assertRaises(TypeError, c.logical_and, 1, '1')
       
    1:     def test_logical_invert(self):
    1:         c = Context()
    1:         d = c.logical_invert(Decimal(1000))
    1:         self.assertEqual(c.logical_invert(1000), d)
    1:         self.assertRaises(TypeError, c.logical_invert, '1000')
       
    1:     def test_logical_or(self):
    1:         c = Context()
    1:         d = c.logical_or(Decimal(1), Decimal(1))
    1:         self.assertEqual(c.logical_or(1, 1), d)
    1:         self.assertEqual(c.logical_or(Decimal(1), 1), d)
    1:         self.assertEqual(c.logical_or(1, Decimal(1)), d)
    1:         self.assertRaises(TypeError, c.logical_or, '1', 1)
    1:         self.assertRaises(TypeError, c.logical_or, 1, '1')
       
    1:     def test_logical_xor(self):
    1:         c = Context()
    1:         d = c.logical_xor(Decimal(1), Decimal(1))
    1:         self.assertEqual(c.logical_xor(1, 1), d)
    1:         self.assertEqual(c.logical_xor(Decimal(1), 1), d)
    1:         self.assertEqual(c.logical_xor(1, Decimal(1)), d)
    1:         self.assertRaises(TypeError, c.logical_xor, '1', 1)
    1:         self.assertRaises(TypeError, c.logical_xor, 1, '1')
       
    1:     def test_max(self):
    1:         c = Context()
    1:         d = c.max(Decimal(1), Decimal(2))
    1:         self.assertEqual(c.max(1, 2), d)
    1:         self.assertEqual(c.max(Decimal(1), 2), d)
    1:         self.assertEqual(c.max(1, Decimal(2)), d)
    1:         self.assertRaises(TypeError, c.max, '1', 2)
    1:         self.assertRaises(TypeError, c.max, 1, '2')
       
    1:     def test_max_mag(self):
    1:         c = Context()
    1:         d = c.max_mag(Decimal(1), Decimal(2))
    1:         self.assertEqual(c.max_mag(1, 2), d)
    1:         self.assertEqual(c.max_mag(Decimal(1), 2), d)
    1:         self.assertEqual(c.max_mag(1, Decimal(2)), d)
    1:         self.assertRaises(TypeError, c.max_mag, '1', 2)
    1:         self.assertRaises(TypeError, c.max_mag, 1, '2')
       
    1:     def test_min(self):
    1:         c = Context()
    1:         d = c.min(Decimal(1), Decimal(2))
    1:         self.assertEqual(c.min(1, 2), d)
    1:         self.assertEqual(c.min(Decimal(1), 2), d)
    1:         self.assertEqual(c.min(1, Decimal(2)), d)
    1:         self.assertRaises(TypeError, c.min, '1', 2)
    1:         self.assertRaises(TypeError, c.min, 1, '2')
       
    1:     def test_min_mag(self):
    1:         c = Context()
    1:         d = c.min_mag(Decimal(1), Decimal(2))
    1:         self.assertEqual(c.min_mag(1, 2), d)
    1:         self.assertEqual(c.min_mag(Decimal(1), 2), d)
    1:         self.assertEqual(c.min_mag(1, Decimal(2)), d)
    1:         self.assertRaises(TypeError, c.min_mag, '1', 2)
    1:         self.assertRaises(TypeError, c.min_mag, 1, '2')
       
    1:     def test_minus(self):
    1:         c = Context()
    1:         d = c.minus(Decimal(10))
    1:         self.assertEqual(c.minus(10), d)
    1:         self.assertRaises(TypeError, c.minus, '10')
       
    1:     def test_multiply(self):
    1:         c = Context()
    1:         d = c.multiply(Decimal(1), Decimal(2))
    1:         self.assertEqual(c.multiply(1, 2), d)
    1:         self.assertEqual(c.multiply(Decimal(1), 2), d)
    1:         self.assertEqual(c.multiply(1, Decimal(2)), d)
    1:         self.assertRaises(TypeError, c.multiply, '1', 2)
    1:         self.assertRaises(TypeError, c.multiply, 1, '2')
       
    1:     def test_next_minus(self):
    1:         c = Context()
    1:         d = c.next_minus(Decimal(10))
    1:         self.assertEqual(c.next_minus(10), d)
    1:         self.assertRaises(TypeError, c.next_minus, '10')
       
    1:     def test_next_plus(self):
    1:         c = Context()
    1:         d = c.next_plus(Decimal(10))
    1:         self.assertEqual(c.next_plus(10), d)
    1:         self.assertRaises(TypeError, c.next_plus, '10')
       
    1:     def test_next_toward(self):
    1:         c = Context()
    1:         d = c.next_toward(Decimal(1), Decimal(2))
    1:         self.assertEqual(c.next_toward(1, 2), d)
    1:         self.assertEqual(c.next_toward(Decimal(1), 2), d)
    1:         self.assertEqual(c.next_toward(1, Decimal(2)), d)
    1:         self.assertRaises(TypeError, c.next_toward, '1', 2)
    1:         self.assertRaises(TypeError, c.next_toward, 1, '2')
       
    1:     def test_normalize(self):
    1:         c = Context()
    1:         d = c.normalize(Decimal(10))
    1:         self.assertEqual(c.normalize(10), d)
    1:         self.assertRaises(TypeError, c.normalize, '10')
       
    1:     def test_number_class(self):
    1:         c = Context()
    1:         self.assertEqual(c.number_class(123), c.number_class(Decimal(123)))
    1:         self.assertEqual(c.number_class(0), c.number_class(Decimal(0)))
    1:         self.assertEqual(c.number_class(-45), c.number_class(Decimal(-45)))
       
    1:     def test_power(self):
    1:         c = Context()
    1:         d = c.power(Decimal(1), Decimal(4), Decimal(2))
    1:         self.assertEqual(c.power(1, 4, 2), d)
    1:         self.assertEqual(c.power(Decimal(1), 4, 2), d)
    1:         self.assertEqual(c.power(1, Decimal(4), 2), d)
    1:         self.assertEqual(c.power(1, 4, Decimal(2)), d)
    1:         self.assertEqual(c.power(Decimal(1), Decimal(4), 2), d)
    1:         self.assertRaises(TypeError, c.power, '1', 4, 2)
    1:         self.assertRaises(TypeError, c.power, 1, '4', 2)
    1:         self.assertRaises(TypeError, c.power, 1, 4, '2')
       
    1:     def test_plus(self):
    1:         c = Context()
    1:         d = c.plus(Decimal(10))
    1:         self.assertEqual(c.plus(10), d)
    1:         self.assertRaises(TypeError, c.plus, '10')
       
    1:     def test_quantize(self):
    1:         c = Context()
    1:         d = c.quantize(Decimal(1), Decimal(2))
    1:         self.assertEqual(c.quantize(1, 2), d)
    1:         self.assertEqual(c.quantize(Decimal(1), 2), d)
    1:         self.assertEqual(c.quantize(1, Decimal(2)), d)
    1:         self.assertRaises(TypeError, c.quantize, '1', 2)
    1:         self.assertRaises(TypeError, c.quantize, 1, '2')
       
    1:     def test_remainder(self):
    1:         c = Context()
    1:         d = c.remainder(Decimal(1), Decimal(2))
    1:         self.assertEqual(c.remainder(1, 2), d)
    1:         self.assertEqual(c.remainder(Decimal(1), 2), d)
    1:         self.assertEqual(c.remainder(1, Decimal(2)), d)
    1:         self.assertRaises(TypeError, c.remainder, '1', 2)
    1:         self.assertRaises(TypeError, c.remainder, 1, '2')
       
    1:     def test_remainder_near(self):
    1:         c = Context()
    1:         d = c.remainder_near(Decimal(1), Decimal(2))
    1:         self.assertEqual(c.remainder_near(1, 2), d)
    1:         self.assertEqual(c.remainder_near(Decimal(1), 2), d)
    1:         self.assertEqual(c.remainder_near(1, Decimal(2)), d)
    1:         self.assertRaises(TypeError, c.remainder_near, '1', 2)
    1:         self.assertRaises(TypeError, c.remainder_near, 1, '2')
       
    1:     def test_rotate(self):
    1:         c = Context()
    1:         d = c.rotate(Decimal(1), Decimal(2))
    1:         self.assertEqual(c.rotate(1, 2), d)
    1:         self.assertEqual(c.rotate(Decimal(1), 2), d)
    1:         self.assertEqual(c.rotate(1, Decimal(2)), d)
    1:         self.assertRaises(TypeError, c.rotate, '1', 2)
    1:         self.assertRaises(TypeError, c.rotate, 1, '2')
       
    1:     def test_sqrt(self):
    1:         c = Context()
    1:         d = c.sqrt(Decimal(10))
    1:         self.assertEqual(c.sqrt(10), d)
    1:         self.assertRaises(TypeError, c.sqrt, '10')
       
    1:     def test_same_quantum(self):
    1:         c = Context()
    1:         d = c.same_quantum(Decimal(1), Decimal(2))
    1:         self.assertEqual(c.same_quantum(1, 2), d)
    1:         self.assertEqual(c.same_quantum(Decimal(1), 2), d)
    1:         self.assertEqual(c.same_quantum(1, Decimal(2)), d)
    1:         self.assertRaises(TypeError, c.same_quantum, '1', 2)
    1:         self.assertRaises(TypeError, c.same_quantum, 1, '2')
       
    1:     def test_scaleb(self):
    1:         c = Context()
    1:         d = c.scaleb(Decimal(1), Decimal(2))
    1:         self.assertEqual(c.scaleb(1, 2), d)
    1:         self.assertEqual(c.scaleb(Decimal(1), 2), d)
    1:         self.assertEqual(c.scaleb(1, Decimal(2)), d)
    1:         self.assertRaises(TypeError, c.scaleb, '1', 2)
    1:         self.assertRaises(TypeError, c.scaleb, 1, '2')
       
    1:     def test_shift(self):
    1:         c = Context()
    1:         d = c.shift(Decimal(1), Decimal(2))
    1:         self.assertEqual(c.shift(1, 2), d)
    1:         self.assertEqual(c.shift(Decimal(1), 2), d)
    1:         self.assertEqual(c.shift(1, Decimal(2)), d)
    1:         self.assertRaises(TypeError, c.shift, '1', 2)
    1:         self.assertRaises(TypeError, c.shift, 1, '2')
       
    1:     def test_subtract(self):
    1:         c = Context()
    1:         d = c.subtract(Decimal(1), Decimal(2))
    1:         self.assertEqual(c.subtract(1, 2), d)
    1:         self.assertEqual(c.subtract(Decimal(1), 2), d)
    1:         self.assertEqual(c.subtract(1, Decimal(2)), d)
    1:         self.assertRaises(TypeError, c.subtract, '1', 2)
    1:         self.assertRaises(TypeError, c.subtract, 1, '2')
       
    1:     def test_to_eng_string(self):
    1:         c = Context()
    1:         d = c.to_eng_string(Decimal(10))
    1:         self.assertEqual(c.to_eng_string(10), d)
    1:         self.assertRaises(TypeError, c.to_eng_string, '10')
       
    1:     def test_to_sci_string(self):
    1:         c = Context()
    1:         d = c.to_sci_string(Decimal(10))
    1:         self.assertEqual(c.to_sci_string(10), d)
    1:         self.assertRaises(TypeError, c.to_sci_string, '10')
       
    1:     def test_to_integral_exact(self):
    1:         c = Context()
    1:         d = c.to_integral_exact(Decimal(10))
    1:         self.assertEqual(c.to_integral_exact(10), d)
    1:         self.assertRaises(TypeError, c.to_integral_exact, '10')
       
    1:     def test_to_integral_value(self):
    1:         c = Context()
    1:         d = c.to_integral_value(Decimal(10))
    1:         self.assertEqual(c.to_integral_value(10), d)
    1:         self.assertRaises(TypeError, c.to_integral_value, '10')
       
    2: class WithStatementTest(unittest.TestCase):
           # Can't do these as docstrings until Python 2.6
           # as doctest can't handle __future__ statements
       
    1:     def test_localcontext(self):
               # Use a copy of the current context in the block
    1:         orig_ctx = getcontext()
    1:         with localcontext() as enter_ctx:
    1:             set_ctx = getcontext()
    1:         final_ctx = getcontext()
    1:         self.assertIs(orig_ctx, final_ctx, 'did not restore context correctly')
    1:         self.assertIsNot(orig_ctx, set_ctx, 'did not copy the context')
    1:         self.assertIs(set_ctx, enter_ctx, '__enter__ returned wrong context')
       
    1:     def test_localcontextarg(self):
               # Use a copy of the supplied context in the block
    1:         orig_ctx = getcontext()
    1:         new_ctx = Context(prec=42)
    1:         with localcontext(new_ctx) as enter_ctx:
    1:             set_ctx = getcontext()
    1:         final_ctx = getcontext()
    1:         self.assertIs(orig_ctx, final_ctx, 'did not restore context correctly')
    1:         self.assertEqual(set_ctx.prec, new_ctx.prec, 'did not set correct context')
    1:         self.assertIsNot(new_ctx, set_ctx, 'did not copy the context')
    1:         self.assertIs(set_ctx, enter_ctx, '__enter__ returned wrong context')
       
    2: class ContextFlags(unittest.TestCase):
    1:     def test_flags_irrelevant(self):
               # check that the result (numeric result + flags raised) of an
               # arithmetic operation doesn't depend on the current flags
       
    1:         context = Context(prec=9, Emin = -999999999, Emax = 999999999,
    1:                     rounding=ROUND_HALF_EVEN, traps=[], flags=[])
       
               # operations that raise various flags, in the form (function, arglist)
               operations = [
    1:             (context._apply, [Decimal("100E-1000000009")]),
    1:             (context.sqrt, [Decimal(2)]),
    1:             (context.add, [Decimal("1.23456789"), Decimal("9.87654321")]),
    1:             (context.multiply, [Decimal("1.23456789"), Decimal("9.87654321")]),
    1:             (context.subtract, [Decimal("1.23456789"), Decimal("9.87654321")]),
                   ]
       
               # try various flags individually, then a whole lot at once
    1:         flagsets = [[Inexact], [Rounded], [Underflow], [Clamped], [Subnormal],
    1:                     [Inexact, Rounded, Underflow, Clamped, Subnormal]]
       
    6:         for fn, args in operations:
                   # find answer and flags raised using a clean context
    5:             context.clear_flags()
    5:             ans = fn(*args)
   45:             flags = [k for k, v in context.flags.items() if v]
       
   35:             for extra_flags in flagsets:
                       # set flags, before calling operation
   30:                 context.clear_flags()
   80:                 for flag in extra_flags:
   50:                     context._raise_error(flag)
   30:                 new_ans = fn(*args)
       
                       # flags that we expect to be set after the operation
   30:                 expected_flags = list(flags)
   80:                 for flag in extra_flags:
   50:                     if flag not in expected_flags:
   36:                         expected_flags.append(flag)
       
                       # flags we actually got
  270:                 new_flags = [k for k,v in context.flags.items() if v]
       
   30:                 self.assertEqual(ans, new_ans,
   30:                                  "operation produces different answers depending on flags set: " +
   30:                                  "expected %s, got %s." % (ans, new_ans))
   30:                 self.assertItemsEqual(new_flags, expected_flags,
   30:                                   "operation raises different flags depending on flags set: " +
   30:                                   "expected %s, got %s" % (expected_flags, new_flags))
       
    1: def test_main(arith=None, verbose=None, todo_tests=None, debug=None):
           """ Execute the tests.
       
           Runs all arithmetic tests if arith is True or if the "decimal" resource
           is enabled in regrtest.py
           """
       
    1:     init()
           global TEST_ALL, DEBUG
    1:     TEST_ALL = arith if arith is not None else is_resource_enabled('decimal')
    1:     DEBUG = debug
       
    1:     if todo_tests is None:
               test_classes = [
    1:             DecimalExplicitConstructionTest,
    1:             DecimalImplicitConstructionTest,
    1:             DecimalArithmeticOperatorsTest,
    1:             DecimalFormatTest,
    1:             DecimalUseOfContextTest,
    1:             DecimalUsabilityTest,
    1:             DecimalPythonAPItests,
    1:             ContextAPItests,
    1:             DecimalTest,
    1:             WithStatementTest,
    1:             ContextFlags
               ]
           else:
>>>>>>         test_classes = [DecimalTest]
       
           # Dynamically build custom test definition for each file in the test
           # directory and add the definitions to the DecimalTest class.  This
           # procedure insures that new files do not get skipped.
  144:     for filename in os.listdir(directory):
  143:         if '.decTest' not in filename or filename.startswith("."):
>>>>>>             continue
  143:         head, tail = filename.split('.')
  143:         if todo_tests is not None and head not in todo_tests:
>>>>>>             continue
  286:         tester = lambda self, f=filename: self.eval_file(directory + f)
  143:         setattr(DecimalTest, 'test_' + head, tester)
  143:         del filename, head, tail, tester
       
       
    1:     try:
    1:         run_unittest(*test_classes)
    1:         if todo_tests is None:
    1:             import decimal as DecimalModule
    1:             run_doctest(DecimalModule, verbose)
           finally:
    1:         setcontext(ORIGINAL_CONTEXT)
       
    1: if __name__ == '__main__':
>>>>>>     import optparse
>>>>>>     p = optparse.OptionParser("test_decimal.py [--debug] [{--skip | test1 [test2 [...]]}]")
>>>>>>     p.add_option('--debug', '-d', action='store_true', help='shows the test number and context before each test')
>>>>>>     p.add_option('--skip',  '-s', action='store_true', help='skip over 90% of the arithmetic tests')
>>>>>>     (opt, args) = p.parse_args()
       
>>>>>>     if opt.skip:
>>>>>>         test_main(arith=False, verbose=True)
>>>>>>     elif args:
>>>>>>         test_main(arith=True, verbose=True, todo_tests=args, debug=opt.debug)
           else:
>>>>>>         test_main(arith=True, verbose=True)
