       """
       Module difflib -- helpers for computing deltas between objects.
       
       Function get_close_matches(word, possibilities, n=3, cutoff=0.6):
           Use SequenceMatcher to return list of the best "good enough" matches.
       
       Function context_diff(a, b):
           For two lists of strings, return a delta in context diff format.
       
       Function ndiff(a, b):
           Return a delta: the difference between `a` and `b` (lists of strings).
       
       Function restore(delta, which):
           Return one of the two sequences that generated an ndiff delta.
       
       Function unified_diff(a, b):
           For two lists of strings, return a delta in unified diff format.
       
       Class SequenceMatcher:
           A flexible class for comparing pairs of sequences of any type.
       
       Class Differ:
           For producing human-readable deltas from sequences of lines of text.
       
       Class HtmlDiff:
           For producing HTML side by side comparison with change highlights.
       """
       
>>>>>> __all__ = ['get_close_matches', 'ndiff', 'restore', 'SequenceMatcher',
>>>>>>            'Differ','IS_CHARACTER_JUNK', 'IS_LINE_JUNK', 'context_diff',
>>>>>>            'unified_diff', 'HtmlDiff', 'Match']
       
>>>>>> import heapq
>>>>>> from collections import namedtuple as _namedtuple
>>>>>> from functools import reduce
       
>>>>>> Match = _namedtuple('Match', 'a b size')
       
>>>>>> def _calculate_ratio(matches, length):
 1489:     if length:
 1486:         return 2.0 * matches / length
    3:     return 1.0
       
>>>>>> class SequenceMatcher:
       
           """
           SequenceMatcher is a flexible class for comparing pairs of sequences of
           any type, so long as the sequence elements are hashable.  The basic
           algorithm predates, and is a little fancier than, an algorithm
           published in the late 1980's by Ratcliff and Obershelp under the
           hyperbolic name "gestalt pattern matching".  The basic idea is to find
           the longest contiguous matching subsequence that contains no "junk"
           elements (R-O doesn't address junk).  The same idea is then applied
           recursively to the pieces of the sequences to the left and to the right
           of the matching subsequence.  This does not yield minimal edit
           sequences, but does tend to yield matches that "look right" to people.
       
           SequenceMatcher tries to compute a "human-friendly diff" between two
           sequences.  Unlike e.g. UNIX(tm) diff, the fundamental notion is the
           longest *contiguous* & junk-free matching subsequence.  That's what
           catches peoples' eyes.  The Windows(tm) windiff has another interesting
           notion, pairing up elements that appear uniquely in each sequence.
           That, and the method here, appear to yield more intuitive difference
           reports than does diff.  This method appears to be the least vulnerable
           to synching up on blocks of "junk lines", though (like blank lines in
           ordinary text files, or maybe "<P>" lines in HTML files).  That may be
           because this is the only method of the 3 that has a *concept* of
           "junk" <wink>.
       
           Example, comparing two strings, and considering blanks to be "junk":
       
           >>> s = SequenceMatcher(lambda x: x == " ",
           ...                     "private Thread currentThread;",
           ...                     "private volatile Thread currentThread;")
           >>>
       
           .ratio() returns a float in [0, 1], measuring the "similarity" of the
           sequences.  As a rule of thumb, a .ratio() value over 0.6 means the
           sequences are close matches:
       
           >>> print round(s.ratio(), 3)
           0.866
           >>>
       
           If you're only interested in where the sequences match,
           .get_matching_blocks() is handy:
       
           >>> for block in s.get_matching_blocks():
           ...     print "a[%d] and b[%d] match for %d elements" % block
           a[0] and b[0] match for 8 elements
           a[8] and b[17] match for 21 elements
           a[29] and b[38] match for 0 elements
       
           Note that the last tuple returned by .get_matching_blocks() is always a
           dummy, (len(a), len(b), 0), and this is the only case in which the last
           tuple element (number of elements matched) is 0.
       
           If you want to know how to change the first sequence into the second,
           use .get_opcodes():
       
           >>> for opcode in s.get_opcodes():
           ...     print "%6s a[%d:%d] b[%d:%d]" % opcode
            equal a[0:8] b[0:8]
           insert a[8:8] b[8:17]
            equal a[8:29] b[17:38]
       
           See the Differ class for a fancy human-friendly file differencer, which
           uses SequenceMatcher both to compare sequences of lines, and to compare
           sequences of characters within similar (near-matching) lines.
       
           See also function get_close_matches() in this module, which shows how
           simple code building on SequenceMatcher can be used to do useful work.
       
           Timing:  Basic R-O is cubic time worst case and quadratic time expected
           case.  SequenceMatcher is quadratic time for the worst case and has
           expected-case behavior dependent in a complicated way on how many
           elements the sequences have in common; best case time is linear.
       
           Methods:
       
           __init__(isjunk=None, a='', b='')
               Construct a SequenceMatcher.
       
           set_seqs(a, b)
               Set the two sequences to be compared.
       
           set_seq1(a)
               Set the first sequence to be compared.
       
           set_seq2(b)
               Set the second sequence to be compared.
       
           find_longest_match(alo, ahi, blo, bhi)
               Find longest matching block in a[alo:ahi] and b[blo:bhi].
       
           get_matching_blocks()
               Return list of triples describing matching subsequences.
       
           get_opcodes()
               Return list of 5-tuples describing how to turn a into b.
       
           ratio()
               Return a measure of the sequences' similarity (float in [0,1]).
       
           quick_ratio()
               Return an upper bound on .ratio() relatively quickly.
       
           real_quick_ratio()
               Return an upper bound on ratio() very quickly.
           """
       
>>>>>>     def __init__(self, isjunk=None, a='', b='', autojunk=True):
               """Construct a SequenceMatcher.
       
               Optional arg isjunk is None (the default), or a one-argument
               function that takes a sequence element and returns true iff the
               element is junk.  None is equivalent to passing "lambda x: 0", i.e.
               no elements are considered to be junk.  For example, pass
                   lambda x: x in " \\t"
               if you're comparing lines as sequences of characters, and don't
               want to synch up on blanks or hard tabs.
       
               Optional arg a is the first of two sequences to be compared.  By
               default, an empty string.  The elements of a must be hashable.  See
               also .set_seqs() and .set_seq1().
       
               Optional arg b is the second of two sequences to be compared.  By
               default, an empty string.  The elements of b must be hashable. See
               also .set_seqs() and .set_seq2().
       
               Optional arg autojunk should be set to False to disable the
               "automatic junk heuristic" that treats popular elements as junk
               (see module documentation for more information).
               """
       
               # Members:
               # a
               #      first sequence
               # b
               #      second sequence; differences are computed as "what do
               #      we need to do to 'a' to change it into 'b'?"
               # b2j
               #      for x in b, b2j[x] is a list of the indices (into b)
               #      at which x appears; junk elements do not appear
               # fullbcount
               #      for x in b, fullbcount[x] == the number of times x
               #      appears in b; only materialized if really needed (used
               #      only for computing quick_ratio())
               # matching_blocks
               #      a list of (i, j, k) triples, where a[i:i+k] == b[j:j+k];
               #      ascending & non-overlapping in i and in j; terminated by
               #      a dummy (len(a), len(b), 0) sentinel
               # opcodes
               #      a list of (tag, i1, i2, j1, j2) tuples, where tag is
               #      one of
               #          'replace'   a[i1:i2] should be replaced by b[j1:j2]
               #          'delete'    a[i1:i2] should be deleted
               #          'insert'    b[j1:j2] should be inserted
               #          'equal'     a[i1:i2] == b[j1:j2]
               # isjunk
               #      a user-supplied function taking a sequence element and
               #      returning true iff the element is "junk" -- this has
               #      subtle but helpful effects on the algorithm, which I'll
               #      get around to writing up someday <0.9 wink>.
               #      DON'T USE!  Only __chain_b uses this.  Use isbjunk.
               # isbjunk
               #      for x in b, isbjunk(x) == isjunk(x) but much faster;
               #      it's really the __contains__ method of a hidden dict.
               #      DOES NOT WORK for x in a!
               # isbpopular
               #      for x in b, isbpopular(x) is true iff b is reasonably long
               #      (at least 200 elements) and x accounts for more than 1 + 1% of
               #      its elements (when autojunk is enabled).
               #      DOES NOT WORK for x in a!
       
  203:         self.isjunk = isjunk
  203:         self.a = self.b = None
  203:         self.autojunk = autojunk
  203:         self.set_seqs(a, b)
       
>>>>>>     def set_seqs(self, a, b):
               """Set the two sequences to be compared.
       
               >>> s = SequenceMatcher()
               >>> s.set_seqs("abcd", "bcde")
               >>> s.ratio()
               0.75
               """
       
  282:         self.set_seq1(a)
  282:         self.set_seq2(b)
       
>>>>>>     def set_seq1(self, a):
               """Set the first sequence to be compared.
       
               The second sequence to be compared is not changed.
       
               >>> s = SequenceMatcher(None, "abcd", "bcde")
               >>> s.ratio()
               0.75
               >>> s.set_seq1("bcde")
               >>> s.ratio()
               1.0
               >>>
       
               SequenceMatcher computes and caches detailed information about the
               second sequence, so if you want to compare one sequence S against
               many sequences, use .set_seq2(S) once and call .set_seq1(x)
               repeatedly for each of the other sequences.
       
               See also set_seqs() and set_seq2().
               """
       
  995:         if a is self.a:
   54:             return
  941:         self.a = a
  941:         self.matching_blocks = self.opcodes = None
       
>>>>>>     def set_seq2(self, b):
               """Set the second sequence to be compared.
       
               The first sequence to be compared is not changed.
       
               >>> s = SequenceMatcher(None, "abcd", "bcde")
               >>> s.ratio()
               0.75
               >>> s.set_seq2("abcd")
               >>> s.ratio()
               1.0
               >>>
       
               SequenceMatcher computes and caches detailed information about the
               second sequence, so if you want to compare one sequence S against
               many sequences, use .set_seq2(S) once and call .set_seq1(x)
               repeatedly for each of the other sequences.
       
               See also set_seqs() and set_seq1().
               """
       
  520:         if b is self.b:
   48:             return
  472:         self.b = b
  472:         self.matching_blocks = self.opcodes = None
  472:         self.fullbcount = None
  472:         self.__chain_b()
       
           # For each element x in b, set b2j[x] to a list of the indices in
           # b where x appears; the indices are in increasing order; note that
           # the number of times x appears in b is len(b2j[x]) ...
           # when self.isjunk is defined, junk elements don't show up in this
           # map at all, which stops the central find_longest_match method
           # from starting any matching block at a junk element ...
           # also creates the fast isbjunk function ...
           # b2j also does not contain entries for "popular" elements, meaning
           # elements that account for more than 1 + 1% of the total elements, and
           # when the sequence is reasonably large (>= 200 elements); this can
           # be viewed as an adaptive notion of semi-junk, and yields an enormous
           # speedup when, e.g., comparing program files with hundreds of
           # instances of "return NULL;" ...
           # note that this is only called when b changes; so for cross-product
           # kinds of matches, it's best to call set_seq2 once, then set_seq1
           # repeatedly
       
>>>>>>     def __chain_b(self):
               # Because isjunk is a user-defined (not C) function, and we test
               # for junk a LOT, it's important to minimize the number of calls.
               # Before the tricks described here, __chain_b was by far the most
               # time-consuming routine in the whole module!  If anyone sees
               # Jim Roskind, thank him again for profile.py -- I never would
               # have guessed that.
               # The first trick is to build b2j ignoring the possibility
               # of junk.  I.e., we don't call isjunk at all yet.  Throwing
               # out the junk later is much cheaper than building b2j "right"
               # from the start.
  472:         b = self.b
  472:         self.b2j = b2j = {}
       
37586:         for i, elt in enumerate(b):
37114:             indices = b2j.setdefault(elt, [])
37114:             indices.append(i)
       
               # Purge junk elements
  472:         junk = set()
  472:         isjunk = self.isjunk
  472:         if isjunk:
 4215:             for elt in list(b2j.keys()):  # using list() since b2j is modified
 3853:                 if isjunk(elt):
  225:                     junk.add(elt)
  225:                     del b2j[elt]
       
               # Purge popular elements that are not junk
  472:         popular = set()
  472:         n = len(b)
  472:         if self.autojunk and n >= 200:
    6:             ntest = n // 100 + 1
 2020:             for elt, idxs in list(b2j.items()):
 2014:                 if len(idxs) > ntest:
    5:                     popular.add(elt)
    5:                     del b2j[elt]
       
               # Now for x in b, isjunk(x) == x in junk, but the latter is much faster.
               # Sicne the number of *unique* junk elements is probably small, the
               # memory burden of keeping this set alive is likely trivial compared to
               # the size of b2j.
  472:         self.isbjunk = junk.__contains__
  472:         self.isbpopular = popular.__contains__
       
>>>>>>     def find_longest_match(self, alo, ahi, blo, bhi):
               """Find longest matching block in a[alo:ahi] and b[blo:bhi].
       
               If isjunk is not defined:
       
               Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where
                   alo <= i <= i+k <= ahi
                   blo <= j <= j+k <= bhi
               and for all (i',j',k') meeting those conditions,
                   k >= k'
                   i <= i'
                   and if i == i', j <= j'
       
               In other words, of all maximal matching blocks, return one that
               starts earliest in a, and of all those maximal matching blocks that
               start earliest in a, return the one that starts earliest in b.
       
               >>> s = SequenceMatcher(None, " abcd", "abcd abcd")
               >>> s.find_longest_match(0, 5, 0, 9)
               Match(a=0, b=4, size=5)
       
               If isjunk is defined, first the longest matching block is
               determined as above, but with the additional restriction that no
               junk element appears in the block.  Then that block is extended as
               far as possible by matching (only) junk elements on both sides.  So
               the resulting block never matches on junk except as identical junk
               happens to be adjacent to an "interesting" match.
       
               Here's the same example as before, but considering blanks to be
               junk.  That prevents " abcd" from matching the " abcd" at the tail
               end of the second sequence directly.  Instead only the "abcd" can
               match, and matches the leftmost "abcd" in the second sequence:
       
               >>> s = SequenceMatcher(lambda x: x==" ", " abcd", "abcd abcd")
               >>> s.find_longest_match(0, 5, 0, 9)
               Match(a=1, b=0, size=4)
       
               If no blocks match, return (alo, blo, 0).
       
               >>> s = SequenceMatcher(None, "ab", "c")
               >>> s.find_longest_match(0, 2, 0, 1)
               Match(a=0, b=0, size=0)
               """
       
               # CAUTION:  stripping common prefix or suffix would be incorrect.
               # E.g.,
               #    ab
               #    acab
               # Longest matching block is "ab", but if common prefix is
               # stripped, it's "a" (tied with "b").  UNIX(tm) diff does so
               # strip, so ends up claiming that ab is changed to acab by
               # inserting "ca" in the middle.  That's minimal but unintuitive:
               # "it's obvious" that someone inserted "ac" at the front.
               # Windiff ends up at the same place as diff, but by pairing up
               # the unique 'b's and then matching the first two 'a's.
       
 3537:         a, b, b2j, isbjunk = self.a, self.b, self.b2j, self.isbjunk
 3537:         besti, bestj, bestsize = alo, blo, 0
               # find longest junk-free match
               # during an iteration of the loop, j2len[j] = length of longest
               # junk-free match ending with a[i-1] and b[j]
 3537:         j2len = {}
 3537:         nothing = []
1076462:         for i in xrange(alo, ahi):
                   # look at all instances of a[i] in b; note that because
                   # b2j has no junk keys, the loop is skipped if a[i] is junk
1072925:             j2lenget = j2len.get
1072925:             newj2len = {}
1694758:             for j in b2j.get(a[i], nothing):
                       # a[i] matches b[j]
623858:                 if j < blo:
 7103:                     continue
616755:                 if j >= bhi:
 2025:                     break
614730:                 k = newj2len[j] = j2lenget(j-1, 0) + 1
614730:                 if k > bestsize:
 6616:                     besti, bestj, bestsize = i-k+1, j-k+1, k
1072925:             j2len = newj2len
       
               # Extend the best by non-junk elements on each end.  In particular,
               # "popular" non-junk elements aren't in b2j, which greatly speeds
               # the inner loop above, but also means "the best" match so far
               # doesn't contain any junk *or* popular non-junk elements.
29137:         while besti > alo and bestj > blo and \
27315:               not isbjunk(b[bestj-1]) and \
26820:               a[besti-1] == b[bestj-1]:
25600:             besti, bestj, bestsize = besti-1, bestj-1, bestsize+1
 3537:         while besti+bestsize < ahi and bestj+bestsize < bhi and \
 2908:               not isbjunk(b[bestj+bestsize]) and \
 2439:               a[besti+bestsize] == b[bestj+bestsize]:
>>>>>>             bestsize += 1
       
               # Now that we have a wholly interesting match (albeit possibly
               # empty!), we may as well suck up the matching junk on each
               # side of it too.  Can't think of a good reason not to, and it
               # saves post-processing the (possibly considerable) expense of
               # figuring out what to do with it.  In the case of an empty
               # interesting match, this is clearly the right thing to do,
               # because no other kind of match is possible in the regions.
 4285:         while besti > alo and bestj > blo and \
 2354:               isbjunk(b[bestj-1]) and \
  804:               a[besti-1] == b[bestj-1]:
  748:             besti, bestj, bestsize = besti-1, bestj-1, bestsize+1
 3991:         while besti+bestsize < ahi and bestj+bestsize < bhi and \
 3362:               isbjunk(b[bestj+bestsize]) and \
  531:               a[besti+bestsize] == b[bestj+bestsize]:
  454:             bestsize = bestsize + 1
       
 3537:         return Match(besti, bestj, bestsize)
       
>>>>>>     def get_matching_blocks(self):
               """Return list of triples describing matching subsequences.
       
               Each triple is of the form (i, j, n), and means that
               a[i:i+n] == b[j:j+n].  The triples are monotonically increasing in
               i and in j.  New in Python 2.5, it's also guaranteed that if
               (i, j, n) and (i', j', n') are adjacent triples in the list, and
               the second is not the last triple in the list, then i+n != i' or
               j+n != j'.  IOW, adjacent triples never describe adjacent equal
               blocks.
       
               The last triple is a dummy, (len(a), len(b), 0), and is the only
               triple with n==0.
       
               >>> s = SequenceMatcher(None, "abxcd", "abcd")
               >>> s.get_matching_blocks()
               [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]
               """
       
  451:         if self.matching_blocks is not None:
  154:             return self.matching_blocks
  297:         la, lb = len(self.a), len(self.b)
       
               # This is most naturally expressed as a recursive algorithm, but
               # at least one user bumped into extreme use cases that exceeded
               # the recursion limit on their box.  So, now we maintain a list
               # ('queue`) of blocks we still need to look at, and append partial
               # results to `matching_blocks` in a loop; the matches are sorted
               # at the end.
  297:         queue = [(0, la, 0, lb)]
  297:         matching_blocks = []
 3831:         while queue:
 3534:             alo, ahi, blo, bhi = queue.pop()
 3534:             i, j, k = x = self.find_longest_match(alo, ahi, blo, bhi)
                   # a[alo:i] vs b[blo:j] unknown
                   # a[i:i+k] same as b[j:j+k]
                   # a[i+k:ahi] vs b[j+k:bhi] unknown
 3534:             if k:   # if k is 0, there was no matching block
 2249:                 matching_blocks.append(x)
 2249:                 if alo < i and blo < j:
 1606:                     queue.append((alo, i, blo, j))
 2249:                 if i+k < ahi and j+k < bhi:
 1631:                     queue.append((i+k, ahi, j+k, bhi))
  297:         matching_blocks.sort()
       
               # It's possible that we have adjacent equal blocks in the
               # matching_blocks list now.  Starting with 2.5, this code was added
               # to collapse them.
  297:         i1 = j1 = k1 = 0
  297:         non_adjacent = []
 2546:         for i2, j2, k2 in matching_blocks:
                   # Is this block adjacent to i1, j1, k1?
 2249:             if i1 + k1 == i2 and j1 + k1 == j2:
                       # Yes, so collapse them -- this just increases the length of
                       # the first block by the length of the second, and the first
                       # block so lengthened remains the block to compare against.
  859:                 k1 += k2
                   else:
                       # Not adjacent.  Remember the first block (k1==0 means it's
                       # the dummy we started with), and make the second block the
                       # new block to compare against.
 1390:                 if k1:
 1358:                     non_adjacent.append((i1, j1, k1))
 1390:                 i1, j1, k1 = i2, j2, k2
  297:         if k1:
  258:             non_adjacent.append((i1, j1, k1))
       
  297:         non_adjacent.append( (la, lb, 0) )
  297:         self.matching_blocks = map(Match._make, non_adjacent)
  297:         return self.matching_blocks
       
>>>>>>     def get_opcodes(self):
               """Return list of 5-tuples describing how to turn a into b.
       
               Each tuple is of the form (tag, i1, i2, j1, j2).  The first tuple
               has i1 == j1 == 0, and remaining tuples have i1 == the i2 from the
               tuple preceding it, and likewise for j1 == the previous j2.
       
               The tags are strings, with these meanings:
       
               'replace':  a[i1:i2] should be replaced by b[j1:j2]
               'delete':   a[i1:i2] should be deleted.
                           Note that j1==j2 in this case.
               'insert':   b[j1:j2] should be inserted at a[i1:i1].
                           Note that i1==i2 in this case.
               'equal':    a[i1:i2] == b[j1:j2]
       
               >>> a = "qabxcd"
               >>> b = "abycdf"
               >>> s = SequenceMatcher(None, a, b)
               >>> for tag, i1, i2, j1, j2 in s.get_opcodes():
               ...    print ("%7s a[%d:%d] (%s) b[%d:%d] (%s)" %
               ...           (tag, i1, i2, a[i1:i2], j1, j2, b[j1:j2]))
                delete a[0:1] (q) b[0:0] ()
                 equal a[1:3] (ab) b[0:2] (ab)
               replace a[3:4] (x) b[2:3] (y)
                 equal a[4:6] (cd) b[3:5] (cd)
                insert a[6:6] () b[5:6] (f)
               """
       
  148:         if self.opcodes is not None:
>>>>>>             return self.opcodes
  148:         i = j = 0
  148:         self.opcodes = answer = []
 1539:         for ai, bj, size in self.get_matching_blocks():
                   # invariant:  we've pumped out correct diffs to change
                   # a[:i] into b[:j], and the next matching block is
                   # a[ai:ai+size] == b[bj:bj+size].  So we need to pump
                   # out a diff to change a[i:ai] into b[j:bj], pump out
                   # the matching block, and move (i,j) beyond the match
 1391:             tag = ''
 1391:             if i < ai and j < bj:
 1135:                 tag = 'replace'
  256:             elif i < ai:
   18:                 tag = 'delete'
  238:             elif j < bj:
   44:                 tag = 'insert'
 1391:             if tag:
 1197:                 answer.append( (tag, i, ai, j, bj) )
 1391:             i, j = ai+size, bj+size
                   # the list of matching blocks is terminated by a
                   # sentinel with size 0
 1391:             if size:
 1243:                 answer.append( ('equal', ai, i, bj, j) )
  148:         return answer
       
>>>>>>     def get_grouped_opcodes(self, n=3):
               """ Isolate change clusters by eliminating ranges with no changes.
       
               Return a generator of groups with up to n lines of context.
               Each group is in the same format as returned by get_opcodes().
       
               >>> from pprint import pprint
               >>> a = map(str, range(1,40))
               >>> b = a[:]
               >>> b[8:8] = ['i']     # Make an insertion
               >>> b[20] += 'x'       # Make a replacement
               >>> b[23:28] = []      # Make a deletion
               >>> b[30] += 'y'       # Make another replacement
               >>> pprint(list(SequenceMatcher(None,a,b).get_grouped_opcodes()))
               [[('equal', 5, 8, 5, 8), ('insert', 8, 8, 8, 9), ('equal', 8, 11, 9, 12)],
                [('equal', 16, 19, 17, 20),
                 ('replace', 19, 20, 20, 21),
                 ('equal', 20, 22, 21, 23),
                 ('delete', 22, 27, 23, 23),
                 ('equal', 27, 30, 23, 26)],
                [('equal', 31, 34, 27, 30),
                 ('replace', 34, 35, 30, 31),
                 ('equal', 35, 38, 31, 34)]]
               """
       
   14:         codes = self.get_opcodes()
   14:         if not codes:
    2:             codes = [("equal", 0, 1, 0, 1)]
               # Fixup leading and trailing groups if they show no changes.
   14:         if codes[0][0] == 'equal':
    7:             tag, i1, i2, j1, j2 = codes[0]
    7:             codes[0] = tag, max(i1, i2-n), i2, max(j1, j2-n), j2
   14:         if codes[-1][0] == 'equal':
    5:             tag, i1, i2, j1, j2 = codes[-1]
    5:             codes[-1] = tag, i1, min(i2, i1+n), j1, min(j2, j1+n)
       
   14:         nn = n + n
   14:         group = []
   70:         for tag, i1, i2, j1, j2 in codes:
                   # End the current group and start a new one whenever
                   # there is a large range with no changes.
   56:             if tag == 'equal' and i2-i1 > nn:
    2:                 group.append((tag, i1, min(i2, i1+n), j1, min(j2, j1+n)))
    2:                 yield group
    2:                 group = []
    2:                 i1, j1 = max(i1, i2-n), max(j1, j2-n)
   56:             group.append((tag, i1, i2, j1 ,j2))
   14:         if group and not (len(group)==1 and group[0][0] == 'equal'):
   12:             yield group
       
>>>>>>     def ratio(self):
               """Return a measure of the sequences' similarity (float in [0,1]).
       
               Where T is the total number of elements in both sequences, and
               M is the number of matches, this is 2.0*M / T.
               Note that this is 1 if the sequences are identical, and 0 if
               they have nothing in common.
       
               .ratio() is expensive to compute if you haven't already computed
               .get_matching_blocks() or .get_opcodes(), in which case you may
               want to try .quick_ratio() or .real_quick_ratio() first to get an
               upper bound.
       
               >>> s = SequenceMatcher(None, "abcd", "bcde")
               >>> s.ratio()
               0.75
               >>> s.quick_ratio()
               0.75
               >>> s.real_quick_ratio()
               1.0
               """
       
 1283:         matches = reduce(lambda sum, triple: sum + triple[-1],
  299:                          self.get_matching_blocks(), 0)
  299:         return _calculate_ratio(matches, len(self.a) + len(self.b))
       
>>>>>>     def quick_ratio(self):
               """Return an upper bound on ratio() relatively quickly.
       
               This isn't defined beyond that it is an upper bound on .ratio(), and
               is faster to compute.
               """
       
               # viewing a and b as multisets, set matches to the cardinality
               # of their intersection; this counts the number of matches
               # without regard to order, so is clearly an upper bound
  476:         if self.fullbcount is None:
  204:             self.fullbcount = fullbcount = {}
32311:             for elt in self.b:
32107:                 fullbcount[elt] = fullbcount.get(elt, 0) + 1
  476:         fullbcount = self.fullbcount
               # avail[x] is the number of times x appears in 'b' less the
               # number of times we've seen it in 'a' so far ... kinda
  476:         avail = {}
  476:         availhas, matches = avail.__contains__, 0
39526:         for elt in self.a:
39050:             if availhas(elt):
32429:                 numb = avail[elt]
                   else:
 6621:                 numb = fullbcount.get(elt, 0)
39050:             avail[elt] = numb - 1
39050:             if numb > 0:
36070:                 matches = matches + 1
  476:         return _calculate_ratio(matches, len(self.a) + len(self.b))
       
>>>>>>     def real_quick_ratio(self):
               """Return an upper bound on ratio() very quickly.
       
               This isn't defined beyond that it is an upper bound on .ratio(), and
               is faster to compute than either .ratio() or .quick_ratio().
               """
       
  714:         la, lb = len(self.a), len(self.b)
               # can't have more matches than the number of elements in the
               # shorter sequence
  714:         return _calculate_ratio(min(la, lb), la + lb)
       
>>>>>> def get_close_matches(word, possibilities, n=3, cutoff=0.6):
           """Use SequenceMatcher to return list of the best "good enough" matches.
       
           word is a sequence for which close matches are desired (typically a
           string).
       
           possibilities is a list of sequences against which to match word
           (typically a list of strings).
       
           Optional arg n (default 3) is the maximum number of close matches to
           return.  n must be > 0.
       
           Optional arg cutoff (default 0.6) is a float in [0, 1].  Possibilities
           that don't score at least that similar to word are ignored.
       
           The best (no more than n) matches among the possibilities are returned
           in a list, sorted by similarity score, most similar first.
       
           >>> get_close_matches("appel", ["ape", "apple", "peach", "puppy"])
           ['apple', 'ape']
           >>> import keyword as _keyword
           >>> get_close_matches("wheel", _keyword.kwlist)
           ['while']
           >>> get_close_matches("apple", _keyword.kwlist)
           []
           >>> get_close_matches("accept", _keyword.kwlist)
           ['except']
           """
       
    4:     if not n >  0:
>>>>>>         raise ValueError("n must be > 0: %r" % (n,))
    4:     if not 0.0 <= cutoff <= 1.0:
>>>>>>         raise ValueError("cutoff must be in [0.0, 1.0]: %r" % (cutoff,))
    4:     result = []
    4:     s = SequenceMatcher()
    4:     s.set_seq2(word)
  101:     for x in possibilities:
   97:         s.set_seq1(x)
   97:         if s.real_quick_ratio() >= cutoff and \
   82:            s.quick_ratio() >= cutoff and \
    6:            s.ratio() >= cutoff:
    4:             result.append((s.ratio(), x))
       
           # Move the best scorers to head of list
    4:     result = heapq.nlargest(n, result)
           # Strip scores for the best n matches
    8:     return [x for score, x in result]
       
>>>>>> def _count_leading(line, ch):
           """
           Return number of `ch` characters at the start of `line`.
       
           Example:
       
           >>> _count_leading('   abc', ' ')
           3
           """
       
  317:     i, n = 0, len(line)
  348:     while i < n and line[i] == ch:
   31:         i += 1
  317:     return i
       
>>>>>> class Differ:
           r"""
           Differ is a class for comparing sequences of lines of text, and
           producing human-readable differences or deltas.  Differ uses
           SequenceMatcher both to compare sequences of lines, and to compare
           sequences of characters within similar (near-matching) lines.
       
           Each line of a Differ delta begins with a two-letter code:
       
               '- '    line unique to sequence 1
               '+ '    line unique to sequence 2
               '  '    line common to both sequences
               '? '    line not present in either input sequence
       
           Lines beginning with '? ' attempt to guide the eye to intraline
           differences, and were not present in either input sequence.  These lines
           can be confusing if the sequences contain tab characters.
       
           Note that Differ makes no claim to produce a *minimal* diff.  To the
           contrary, minimal diffs are often counter-intuitive, because they synch
           up anywhere possible, sometimes accidental matches 100 pages apart.
           Restricting synch points to contiguous matches preserves some notion of
           locality, at the occasional cost of producing a longer diff.
       
           Example: Comparing two texts.
       
           First we set up the texts, sequences of individual single-line strings
           ending with newlines (such sequences can also be obtained from the
           `readlines()` method of file-like objects):
       
           >>> text1 = '''  1. Beautiful is better than ugly.
           ...   2. Explicit is better than implicit.
           ...   3. Simple is better than complex.
           ...   4. Complex is better than complicated.
           ... '''.splitlines(1)
           >>> len(text1)
           4
           >>> text1[0][-1]
           '\n'
           >>> text2 = '''  1. Beautiful is better than ugly.
           ...   3.   Simple is better than complex.
           ...   4. Complicated is better than complex.
           ...   5. Flat is better than nested.
           ... '''.splitlines(1)
       
           Next we instantiate a Differ object:
       
           >>> d = Differ()
       
           Note that when instantiating a Differ object we may pass functions to
           filter out line and character 'junk'.  See Differ.__init__ for details.
       
           Finally, we compare the two:
       
           >>> result = list(d.compare(text1, text2))
       
           'result' is a list of strings, so let's pretty-print it:
       
           >>> from pprint import pprint as _pprint
           >>> _pprint(result)
           ['    1. Beautiful is better than ugly.\n',
            '-   2. Explicit is better than implicit.\n',
            '-   3. Simple is better than complex.\n',
            '+   3.   Simple is better than complex.\n',
            '?     ++\n',
            '-   4. Complex is better than complicated.\n',
            '?            ^                     ---- ^\n',
            '+   4. Complicated is better than complex.\n',
            '?           ++++ ^                      ^\n',
            '+   5. Flat is better than nested.\n']
       
           As a single multi-line string it looks like this:
       
           >>> print ''.join(result),
               1. Beautiful is better than ugly.
           -   2. Explicit is better than implicit.
           -   3. Simple is better than complex.
           +   3.   Simple is better than complex.
           ?     ++
           -   4. Complex is better than complicated.
           ?            ^                     ---- ^
           +   4. Complicated is better than complex.
           ?           ++++ ^                      ^
           +   5. Flat is better than nested.
       
           Methods:
       
           __init__(linejunk=None, charjunk=None)
               Construct a text differencer, with optional filters.
       
           compare(a, b)
               Compare two sequences of lines; generate the resulting delta.
           """
       
>>>>>>     def __init__(self, linejunk=None, charjunk=None):
               """
               Construct a text differencer, with optional filters.
       
               The two optional keyword parameters are for filter functions:
       
               - `linejunk`: A function that should accept a single string argument,
                 and return true iff the string is junk. The module-level function
                 `IS_LINE_JUNK` may be used to filter out lines without visible
                 characters, except for at most one splat ('#').  It is recommended
                 to leave linejunk None; as of Python 2.3, the underlying
                 SequenceMatcher class has grown an adaptive notion of "noise" lines
                 that's better than any static definition the author has ever been
                 able to craft.
       
               - `charjunk`: A function that should accept a string of length 1. The
                 module-level function `IS_CHARACTER_JUNK` may be used to filter out
                 whitespace characters (a blank or tab; **note**: bad idea to include
                 newline in this!).  Use of IS_CHARACTER_JUNK is recommended.
               """
       
   52:         self.linejunk = linejunk
   52:         self.charjunk = charjunk
       
>>>>>>     def compare(self, a, b):
               r"""
               Compare two sequences of lines; generate the resulting delta.
       
               Each sequence must contain individual single-line strings ending with
               newlines. Such sequences can be obtained from the `readlines()` method
               of file-like objects.  The delta generated also consists of newline-
               terminated strings, ready to be printed as-is via the writeline()
               method of a file-like object.
       
               Example:
       
               >>> print ''.join(Differ().compare('one\ntwo\nthree\n'.splitlines(1),
               ...                                'ore\ntree\nemu\n'.splitlines(1))),
               - one
               ?  ^
               + ore
               ?  ^
               - two
               - three
               ?  -
               + tree
               + emu
               """
       
   50:         cruncher = SequenceMatcher(self.linejunk, a, b)
  159:         for tag, alo, ahi, blo, bhi in cruncher.get_opcodes():
  109:             if tag == 'replace':
   62:                 g = self._fancy_replace(a, alo, ahi, b, blo, bhi)
   47:             elif tag == 'delete':
>>>>>>                 g = self._dump('-', a, alo, ahi)
   47:             elif tag == 'insert':
    4:                 g = self._dump('+', b, blo, bhi)
   43:             elif tag == 'equal':
   43:                 g = self._dump(' ', a, alo, ahi)
                   else:
>>>>>>                 raise ValueError, 'unknown tag %r' % (tag,)
       
  814:             for line in g:
  705:                 yield line
       
>>>>>>     def _dump(self, tag, x, lo, hi):
               """Generate comparison results for a same-tagged range."""
  570:         for i in xrange(lo, hi):
  420:             yield '%s %s' % (tag, x[i])
       
>>>>>>     def _plain_replace(self, a, alo, ahi, b, blo, bhi):
   39:         assert alo < ahi and blo < bhi
               # dump the shorter block first -- reduces the burden on short-term
               # memory if the blocks are of very different sizes
   39:         if bhi - blo < ahi - alo:
>>>>>>             first  = self._dump('+', b, blo, bhi)
>>>>>>             second = self._dump('-', a, alo, ahi)
               else:
   39:             first  = self._dump('-', a, alo, ahi)
   39:             second = self._dump('+', b, blo, bhi)
       
  117:         for g in first, second:
  177:             for line in g:
   99:                 yield line
       
>>>>>>     def _fancy_replace(self, a, alo, ahi, b, blo, bhi):
               r"""
               When replacing one block of lines with another, search the blocks
               for *similar* lines; the best-matching pair (if any) is used as a
               synch point, and intraline difference marking is done on the
               similar pair. Lots of work, but often worth it.
       
               Example:
       
               >>> d = Differ()
               >>> results = d._fancy_replace(['abcDefghiJkl\n'], 0, 1,
               ...                            ['abcdefGhijkl\n'], 0, 1)
               >>> print ''.join(results),
               - abcDefghiJkl
               ?    ^  ^  ^
               + abcdefGhijkl
               ?    ^  ^  ^
               """
       
               # don't synch up unless the lines have a similarity score of at
               # least cutoff; best_ratio tracks the best score seen so far
  117:         best_ratio, cutoff = 0.74, 0.75
  117:         cruncher = SequenceMatcher(self.charjunk)
  117:         eqi, eqj = None, None   # 1st indices of equal lines (if any)
       
               # search for the pair that matches best without being identical
               # (identical lines must be junk lines, & we don't want to synch up
               # on junk -- unless we have to)
  350:         for j in xrange(blo, bhi):
  233:             bj = b[j]
  233:             cruncher.set_seq2(bj)
  848:             for i in xrange(alo, ahi):
  615:                 ai = a[i]
  615:                 if ai == bj:
>>>>>>                     if eqi is None:
>>>>>>                         eqi, eqj = i, j
>>>>>>                     continue
  615:                 cruncher.set_seq1(ai)
                       # computing similarity is expensive, so use the quick
                       # upper bounds first -- have seen this speed up messy
                       # compares by a factor of 3.
                       # note that ratio() is only expensive to compute the first
                       # time it's called on a sequence pair; the expensive part
                       # of the computation is cached by cruncher
  615:                 if cruncher.real_quick_ratio() > best_ratio and \
  392:                       cruncher.quick_ratio() > best_ratio and \
  162:                       cruncher.ratio() > best_ratio:
  114:                     best_ratio, best_i, best_j = cruncher.ratio(), i, j
  117:         if best_ratio < cutoff:
                   # no non-identical "pretty close" pair
   39:             if eqi is None:
                       # no identical pair either -- treat it as a straight replace
  138:                 for line in self._plain_replace(a, alo, ahi, b, blo, bhi):
   99:                     yield line
   39:                 return
                   # no close pair, but an identical pair -- synch up on that
>>>>>>             best_i, best_j, best_ratio = eqi, eqj, 1.0
               else:
                   # there's a close pair, so forget the identical pair (if any)
   78:             eqi = None
       
               # a[best_i] very similar to b[best_j]; eqi is None iff they're not
               # identical
       
               # pump out diffs from before the synch point
  269:         for line in self._fancy_helper(a, alo, best_i, b, blo, best_j):
  191:             yield line
       
               # do intraline marking on the synch pair
   78:         aelt, belt = a[best_i], b[best_j]
   78:         if eqi is None:
                   # pump out a '-', '?', '+', '?' quad for the synched lines
   78:             atags = btags = ""
   78:             cruncher.set_seqs(aelt, belt)
  339:             for tag, ai1, ai2, bj1, bj2 in cruncher.get_opcodes():
  261:                 la, lb = ai2 - ai1, bj2 - bj1
  261:                 if tag == 'replace':
   63:                     atags += '^' * la
   63:                     btags += '^' * lb
  198:                 elif tag == 'delete':
    7:                     atags += '-' * la
  191:                 elif tag == 'insert':
   25:                     btags += '+' * lb
  166:                 elif tag == 'equal':
  166:                     atags += ' ' * la
  166:                     btags += ' ' * lb
                       else:
>>>>>>                     raise ValueError, 'unknown tag %r' % (tag,)
  367:             for line in self._qformat(aelt, belt, atags, btags):
  289:                 yield line
               else:
                   # the synch pair is identical
>>>>>>             yield '  ' + aelt
       
               # pump out diffs from after the synch point
  196:         for line in self._fancy_helper(a, best_i+1, ahi, b, best_j+1, bhi):
  118:             yield line
       
>>>>>>     def _fancy_helper(self, a, alo, ahi, b, blo, bhi):
  156:         g = []
  156:         if alo < ahi:
   73:             if blo < bhi:
   54:                 g = self._fancy_replace(a, alo, ahi, b, blo, bhi)
                   else:
   19:                 g = self._dump('-', a, alo, ahi)
   83:         elif blo < bhi:
    6:             g = self._dump('+', b, blo, bhi)
       
  465:         for line in g:
  309:             yield line
       
>>>>>>     def _qformat(self, aline, bline, atags, btags):
               r"""
               Format "?" output and deal with leading tabs.
       
               Example:
       
               >>> d = Differ()
               >>> results = d._qformat('\tabcDefghiJkl\n', '\tabcdefGhijkl\n',
               ...                      '  ^ ^  ^      ', '  ^ ^  ^      ')
               >>> for line in results: print repr(line)
               ...
               '- \tabcDefghiJkl\n'
               '? \t ^ ^  ^\n'
               '+ \tabcdefGhijkl\n'
               '? \t ^ ^  ^\n'
               """
       
               # Can hurt, but will probably help most of the time.
   79:         common = min(_count_leading(aline, "\t"),
   79:                      _count_leading(bline, "\t"))
   79:         common = min(common, _count_leading(atags[:common], " "))
   79:         common = min(common, _count_leading(btags[:common], " "))
   79:         atags = atags[common:].rstrip()
   79:         btags = btags[common:].rstrip()
       
   79:         yield "- " + aline
   79:         if atags:
   61:             yield "? %s%s\n" % ("\t" * common, atags)
       
   79:         yield "+ " + bline
   79:         if btags:
   74:             yield "? %s%s\n" % ("\t" * common, btags)
       
       # With respect to junk, an earlier version of ndiff simply refused to
       # *start* a match with a junk element.  The result was cases like this:
       #     before: private Thread currentThread;
       #     after:  private volatile Thread currentThread;
       # If you consider whitespace to be junk, the longest contiguous match
       # not starting with junk is "e Thread currentThread".  So ndiff reported
       # that "e volatil" was inserted between the 't' and the 'e' in "private".
       # While an accurate view, to people that's absurd.  The current version
       # looks for matching blocks that are entirely junk-free, then extends the
       # longest one of those as far as possible but only with matching junk.
       # So now "currentThread" is matched, then extended to suck up the
       # preceding blank; then "private" is matched, and extended to suck up the
       # following blank; then "Thread" is matched; and finally ndiff reports
       # that "volatile " was inserted before "Thread".  The only quibble
       # remaining is that perhaps it was really the case that " volatile"
       # was inserted after "private".  I can live with that <wink>.
       
>>>>>> import re
       
>>>>>> def IS_LINE_JUNK(line, pat=re.compile(r"\s*#?\s*$").match):
           r"""
           Return 1 for ignorable line: iff `line` is blank or contains a single '#'.
       
           Examples:
       
           >>> IS_LINE_JUNK('\n')
           True
           >>> IS_LINE_JUNK('  #   \n')
           True
           >>> IS_LINE_JUNK('hello\n')
           False
           """
       
    3:     return pat(line) is not None
       
>>>>>> def IS_CHARACTER_JUNK(ch, ws=" \t"):
           r"""
           Return 1 for ignorable character: iff `ch` is a space or tab.
       
           Examples:
       
           >>> IS_CHARACTER_JUNK(' ')
           True
           >>> IS_CHARACTER_JUNK('\t')
           True
           >>> IS_CHARACTER_JUNK('\n')
           False
           >>> IS_CHARACTER_JUNK('x')
           False
           """
       
 3835:     return ch in ws
       
       
       ########################################################################
       ###  Unified Diff
       ########################################################################
       
>>>>>> def _format_range_unified(start, stop):
           'Convert range to the "ed" format'
           # Per the diff spec at http://www.unix.org/single_unix_specification/
   17:     beginning = start + 1     # lines start numbering with one
   17:     length = stop - start
   17:     if length == 1:
    1:         return '{}'.format(beginning)
   16:     if not length:
    2:         beginning -= 1        # empty ranges begin at line just before the range
   16:     return '{},{}'.format(beginning, length)
       
>>>>>> def unified_diff(a, b, fromfile='', tofile='', fromfiledate='',
>>>>>>                  tofiledate='', n=3, lineterm='\n'):
           r"""
           Compare two sequences of lines; generate the delta as a unified diff.
       
           Unified diffs are a compact way of showing line changes and a few
           lines of context.  The number of context lines is set by 'n' which
           defaults to three.
       
           By default, the diff control lines (those with ---, +++, or @@) are
           created with a trailing newline.  This is helpful so that inputs
           created from file.readlines() result in diffs that are suitable for
           file.writelines() since both the inputs and outputs have trailing
           newlines.
       
           For inputs that do not have trailing newlines, set the lineterm
           argument to "" so that the output will be uniformly newline free.
       
           The unidiff format normally has a header for filenames and modification
           times.  Any or all of these may be specified using strings for
           'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'.
           The modification times are normally expressed in the ISO 8601 format.
       
           Example:
       
           >>> for line in unified_diff('one two three four'.split(),
           ...             'zero one tree four'.split(), 'Original', 'Current',
           ...             '2005-01-26 23:30:50', '2010-04-02 10:20:52',
           ...             lineterm=''):
           ...     print line                  # doctest: +NORMALIZE_WHITESPACE
           --- Original        2005-01-26 23:30:50
           +++ Current         2010-04-02 10:20:52
           @@ -1,4 +1,4 @@
           +zero
            one
           -two
           -three
           +tree
            four
           """
       
    7:     started = False
   12:     for group in SequenceMatcher(None,a,b).get_grouped_opcodes(n):
    6:         if not started:
    6:             started = True
    6:             fromdate = '\t{}'.format(fromfiledate) if fromfiledate else ''
    6:             todate = '\t{}'.format(tofiledate) if tofiledate else ''
    6:             yield '--- {}{}{}'.format(fromfile, fromdate, lineterm)
    6:             yield '+++ {}{}{}'.format(tofile, todate, lineterm)
       
    6:         first, last = group[0], group[-1]
    6:         file1_range = _format_range_unified(first[1], last[2])
    6:         file2_range = _format_range_unified(first[3], last[4])
    6:         yield '@@ -{} +{} @@{}'.format(file1_range, file2_range, lineterm)
       
   28:         for tag, i1, i2, j1, j2 in group:
   23:             if tag == 'equal':
   24:                 for line in a[i1:i2]:
   14:                     yield ' ' + line
   10:                 continue
   13:             if tag in ('replace', 'delete'):
   19:                 for line in a[i1:i2]:
   12:                     yield '-' + line
   12:             if tag in ('replace', 'insert'):
   18:                 for line in b[j1:j2]:
   10:                     yield '+' + line
       
       
       ########################################################################
       ###  Context Diff
       ########################################################################
       
>>>>>> def _format_range_context(start, stop):
           'Convert range to the "ed" format'
           # Per the diff spec at http://www.unix.org/single_unix_specification/
   15:     beginning = start + 1     # lines start numbering with one
   15:     length = stop - start
   15:     if not length:
    2:         beginning -= 1        # empty ranges begin at line just before the range
   15:     if length <= 1:
    3:         return '{}'.format(beginning)
   12:     return '{},{}'.format(beginning, beginning + length - 1)
       
       # See http://www.unix.org/single_unix_specification/
>>>>>> def context_diff(a, b, fromfile='', tofile='',
>>>>>>                  fromfiledate='', tofiledate='', n=3, lineterm='\n'):
           r"""
           Compare two sequences of lines; generate the delta as a context diff.
       
           Context diffs are a compact way of showing line changes and a few
           lines of context.  The number of context lines is set by 'n' which
           defaults to three.
       
           By default, the diff control lines (those with *** or ---) are
           created with a trailing newline.  This is helpful so that inputs
           created from file.readlines() result in diffs that are suitable for
           file.writelines() since both the inputs and outputs have trailing
           newlines.
       
           For inputs that do not have trailing newlines, set the lineterm
           argument to "" so that the output will be uniformly newline free.
       
           The context diff format normally has a header for filenames and
           modification times.  Any or all of these may be specified using
           strings for 'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'.
           The modification times are normally expressed in the ISO 8601 format.
           If not specified, the strings default to blanks.
       
           Example:
       
           >>> print ''.join(context_diff('one\ntwo\nthree\nfour\n'.splitlines(1),
           ...       'zero\none\ntree\nfour\n'.splitlines(1), 'Original', 'Current')),
           *** Original
           --- Current
           ***************
           *** 1,4 ****
             one
           ! two
           ! three
             four
           --- 1,4 ----
           + zero
             one
           ! tree
             four
           """
       
    5:     prefix = dict(insert='+ ', delete='- ', replace='! ', equal='  ')
    5:     started = False
   10:     for group in SequenceMatcher(None,a,b).get_grouped_opcodes(n):
    5:         if not started:
    5:             started = True
    5:             fromdate = '\t{}'.format(fromfiledate) if fromfiledate else ''
    5:             todate = '\t{}'.format(tofiledate) if tofiledate else ''
    5:             yield '*** {}{}{}'.format(fromfile, fromdate, lineterm)
    5:             yield '--- {}{}{}'.format(tofile, todate, lineterm)
       
    5:         first, last = group[0], group[-1]
    5:         yield '***************' + lineterm
       
    5:         file1_range = _format_range_context(first[1], last[2])
    5:         yield '*** {} ****{}'.format(file1_range, lineterm)
       
   18:         if any(tag in ('replace', 'delete') for tag, _, _, _, _ in group):
   27:             for tag, i1, i2, _, _ in group:
   22:                 if tag != 'insert':
   41:                     for line in a[i1:i2]:
   24:                         yield prefix[tag] + line
       
    5:         file2_range = _format_range_context(first[3], last[4])
    5:         yield '--- {} ----{}'.format(file2_range, lineterm)
       
   12:         if any(tag in ('replace', 'insert') for tag, _, _, _, _ in group):
   27:             for tag, _, _, j1, j2 in group:
   22:                 if tag != 'delete':
   42:                     for line in b[j1:j2]:
   24:                         yield prefix[tag] + line
       
>>>>>> def ndiff(a, b, linejunk=None, charjunk=IS_CHARACTER_JUNK):
           r"""
           Compare `a` and `b` (lists of strings); return a `Differ`-style delta.
       
           Optional keyword parameters `linejunk` and `charjunk` are for filter
           functions (or None):
       
           - linejunk: A function that should accept a single string argument, and
             return true iff the string is junk.  The default is None, and is
             recommended; as of Python 2.3, an adaptive notion of "noise" lines is
             used that does a good job on its own.
       
           - charjunk: A function that should accept a string of length 1. The
             default is module-level function IS_CHARACTER_JUNK, which filters out
             whitespace characters (a blank or tab; note: bad idea to include newline
             in this!).
       
           Tools/scripts/ndiff.py is a command-line front-end to this function.
       
           Example:
       
           >>> diff = ndiff('one\ntwo\nthree\n'.splitlines(1),
           ...              'ore\ntree\nemu\n'.splitlines(1))
           >>> print ''.join(diff),
           - one
           ?  ^
           + ore
           ?  ^
           - two
           - three
           ?  -
           + tree
           + emu
           """
   45:     return Differ(linejunk, charjunk).compare(a, b)
       
>>>>>> def _mdiff(fromlines, tolines, context=None, linejunk=None,
>>>>>>            charjunk=IS_CHARACTER_JUNK):
           r"""Returns generator yielding marked up from/to side by side differences.
       
           Arguments:
           fromlines -- list of text lines to compared to tolines
           tolines -- list of text lines to be compared to fromlines
           context -- number of context lines to display on each side of difference,
                      if None, all from/to text lines will be generated.
           linejunk -- passed on to ndiff (see ndiff documentation)
           charjunk -- passed on to ndiff (see ndiff documentation)
       
           This function returns an iterator which returns a tuple:
           (from line tuple, to line tuple, boolean flag)
       
           from/to line tuple -- (line num, line text)
               line num -- integer or None (to indicate a context separation)
               line text -- original line text with following markers inserted:
                   '\0+' -- marks start of added text
                   '\0-' -- marks start of deleted text
                   '\0^' -- marks start of changed text
                   '\1' -- marks end of added/deleted/changed text
       
           boolean flag -- None indicates context separation, True indicates
               either "from" or "to" line contains a change, otherwise False.
       
           This function/iterator was originally developed to generate side by side
           file difference for making HTML pages (see HtmlDiff class for example
           usage).
       
           Note, this function utilizes the ndiff function to generate the side by
           side difference markup.  Optional ndiff arguments may be passed to this
           function and they in turn will be passed to ndiff.
           """
   14:     import re
       
           # regular expression for finding intraline change indices
   14:     change_re = re.compile('(\++|\-+|\^+)')
       
           # create the difference iterator to generate the differences
   14:     diff_lines_iterator = ndiff(fromlines,tolines,linejunk,charjunk)
       
   14:     def _make_line(lines, format_key, side, num_lines=[0,0]):
               """Returns line of text with user's change markup and line formatting.
       
               lines -- list of lines from the ndiff generator to produce a line of
                        text from.  When producing the line of text to return, the
                        lines used are removed from this list.
               format_key -- '+' return first line in list with "add" markup around
                                 the entire line.
                             '-' return first line in list with "delete" markup around
                                 the entire line.
                             '?' return first line in list with add/delete/change
                                 intraline markup (indices obtained from second line)
                             None return first line in list with no markup
               side -- indice into the num_lines list (0=from,1=to)
               num_lines -- from/to current line number.  This is NOT intended to be a
                            passed parameter.  It is present as a keyword argument to
                            maintain memory of the current line numbers between calls
                            of this function.
       
               Note, this function is purposefully not defined at the module scope so
               that data it needs from its parent function (within whose context it
               is defined) does not need to be of module scope.
               """
  770:         num_lines[side] += 1
               # Handle case where no user markup is to be added, just return line of
               # text with user's line format to allow for usage of the line number.
  770:         if format_key is None:
  593:             return (num_lines[side],lines.pop(0)[2:])
               # Handle case of intraline changes
  177:         if format_key == '?':
   93:             text, markers = lines.pop(0), lines.pop(0)
                   # find intraline changes (store change type and indices in tuples)
   93:             sub_info = []
   93:             def record_sub_info(match_object,sub_info=sub_info):
  105:                 sub_info.append([match_object.group(1)[0],match_object.span()])
  105:                 return match_object.group(1)
   93:             change_re.sub(record_sub_info,markers)
                   # process each tuple inserting our special marks that won't be
                   # noticed by an xml/html escaper.
  198:             for key,(begin,end) in sub_info[::-1]:
  105:                 text = text[0:begin]+'\0'+key+text[begin:end]+'\1'+text[end:]
   93:             text = text[2:]
               # Handle case of add/delete entire line
               else:
   84:             text = lines.pop(0)[2:]
                   # if line of text is just a newline, insert a space so there is
                   # something for the user to highlight and see.
   84:             if not text:
>>>>>>                 text = ' '
                   # insert marks that won't be noticed by an xml/html escaper.
   84:             text = '\0' + format_key + text + '\1'
               # Return line of text, first allow user's line formatter to do its
               # thing (such as adding the line number) then replace the special
               # marks with what the user's change markup.
  177:         return (num_lines[side],text)
       
   14:     def _line_iterator():
               """Yields from/to lines of text with a change indication.
       
               This function is an iterator.  It itself pulls lines from a
               differencing iterator, processes them and yields them.  When it can
               it yields both a "from" and a "to" line, otherwise it will yield one
               or the other.  In addition to yielding the lines of from/to text, a
               boolean flag is yielded to indicate if the text line(s) have
               differences in them.
       
               Note, this function is purposefully not defined at the module scope so
               that data it needs from its parent function (within whose context it
               is defined) does not need to be of module scope.
               """
   14:         lines = []
   14:         num_blanks_pending, num_blanks_to_yield = 0, 0
  441:         while True:
                   # Load up next 4 lines so we can look ahead, create strings which
                   # are a concatenation of the first character of each of the 4 lines
                   # so we can do some very readable comparisons.
 1072:             while len(lines) < 4:
  631:                 try:
  631:                     lines.append(diff_lines_iterator.next())
   56:                 except StopIteration:
   56:                     lines.append('X')
 2205:             s = ''.join([line[0] for line in lines])
  441:             if s.startswith('X'):
                       # When no more lines, pump out any remaining blank lines so the
                       # corresponding add/delete lines get a matching blank line so
                       # all line pairs get yielded at the next level.
   14:                 num_blanks_to_yield = num_blanks_pending
  427:             elif s.startswith('-?+?'):
                       # simple intraline change
   38:                 yield _make_line(lines,'?',0), _make_line(lines,'?',1), True
   38:                 continue
  389:             elif s.startswith('--++'):
                       # in delete block, add block coming: we do NOT want to get
                       # caught up on blank lines yet, just process the delete line
    3:                 num_blanks_pending -= 1
    3:                 yield _make_line(lines,'-',0), None, True
    3:                 continue
  386:             elif s.startswith(('--?+', '--+', '- ')):
                       # in delete block and see an intraline change or unchanged line
                       # coming: yield the delete line and then blanks
   15:                 from_line,to_line = _make_line(lines,'-',0), None
   15:                 num_blanks_to_yield,num_blanks_pending = num_blanks_pending-1,0
  371:             elif s.startswith('-+?'):
                       # intraline change
   15:                 yield _make_line(lines,None,0), _make_line(lines,'?',1), True
   15:                 continue
  356:             elif s.startswith('-?+'):
                       # intraline change
    2:                 yield _make_line(lines,'?',0), _make_line(lines,None,1), True
    2:                 continue
  354:             elif s.startswith('-'):
                       # delete FROM line
   24:                 num_blanks_pending -= 1
   24:                 yield _make_line(lines,'-',0), None, True
   24:                 continue
  330:             elif s.startswith('+--'):
                       # in add block, delete block coming: we do NOT want to get
                       # caught up on blank lines yet, just process the add line
>>>>>>                 num_blanks_pending += 1
>>>>>>                 yield None, _make_line(lines,'+',1), True
>>>>>>                 continue
  330:             elif s.startswith(('+ ', '+-')):
                       # will be leaving an add block: yield blanks then add line
   24:                 from_line, to_line = None, _make_line(lines,'+',1)
   24:                 num_blanks_to_yield,num_blanks_pending = num_blanks_pending+1,0
  306:             elif s.startswith('+'):
                       # inside an add block, yield the add line
   18:                 num_blanks_pending += 1
   18:                 yield None, _make_line(lines,'+',1), True
   18:                 continue
  288:             elif s.startswith(' '):
                       # unchanged text, yield it to both sides
  288:                 yield _make_line(lines[:],None,0),_make_line(lines,None,1),False
  288:                 continue
                   # Catch up on the blank lines so when we yield the next from/to
                   # pair, they are lined up.
   68:             while(num_blanks_to_yield < 0):
   15:                 num_blanks_to_yield += 1
   15:                 yield None,('','\n'),True
   68:             while(num_blanks_to_yield > 0):
   15:                 num_blanks_to_yield -= 1
   15:                 yield ('','\n'),None,True
   53:             if s.startswith('X'):
   14:                 raise StopIteration
                   else:
   39:                 yield from_line,to_line,True
       
   14:     def _line_pair_iterator():
               """Yields from/to lines of text with a change indication.
       
               This function is an iterator.  It itself pulls lines from the line
               iterator.  Its difference from that iterator is that this function
               always yields a pair of from/to text lines (with the change
               indication).  If necessary it will collect single from/to lines
               until it has a matching pair from/to pair to yield.
       
               Note, this function is purposefully not defined at the module scope so
               that data it needs from its parent function (within whose context it
               is defined) does not need to be of module scope.
               """
   14:         line_iterator = _line_iterator()
   14:         fromlines,tolines=[],[]
  414:         while True:
                   # Collecting lines of text until we have a from/to pair
  871:             while (len(fromlines)==0 or len(tolines)==0):
  471:                 from_line, to_line, found_diff =line_iterator.next()
  457:                 if from_line is not None:
  400:                     fromlines.append((from_line,found_diff))
  457:                 if to_line is not None:
  400:                     tolines.append((to_line,found_diff))
                   # Once we have a pair, remove them from the collection and yield it
  400:             from_line, fromDiff = fromlines.pop(0)
  400:             to_line, to_diff = tolines.pop(0)
  400:             yield (from_line,to_line,fromDiff or to_diff)
       
           # Handle case where user does not want context differencing, just yield
           # them up without doing anything else with them.
   14:     line_pair_iterator = _line_pair_iterator()
   14:     if context is None:
  144:         while True:
  144:             yield line_pair_iterator.next()
           # Handle case where user wants context differencing.  We must do some
           # storage of lines until we know for sure that they are to be yielded.
           else:
    7:         context += 1
    7:         lines_to_write = 0
   40:         while True:
                   # Store lines up until we find a difference, note use of a
                   # circular queue because we only need to keep around what
                   # we need for context.
   40:             index, contextLines = 0, [None]*(context)
   40:             found_diff = False
  219:             while(found_diff is False):
  186:                 from_line, to_line, found_diff = line_pair_iterator.next()
  179:                 i = index % context
  179:                 contextLines[i] = (from_line, to_line, found_diff)
  179:                 index += 1
                   # Yield lines that we have collected so far, but first yield
                   # the user's separator.
   33:             if index > context:
   12:                 yield None, None, None
   12:                 lines_to_write = context
                   else:
   21:                 lines_to_write = index
   21:                 index = 0
  103:             while(lines_to_write):
   70:                 i = index % context
   70:                 index += 1
   70:                 yield contextLines[i]
   70:                 lines_to_write -= 1
                   # Now yield the context lines after the change
   33:             lines_to_write = context-1
  117:             while(lines_to_write):
   84:                 from_line, to_line, found_diff = line_pair_iterator.next()
                       # If another change within the context, extend the context
   84:                 if found_diff:
   36:                     lines_to_write = context-1
                       else:
   48:                     lines_to_write -= 1
   84:                 yield from_line, to_line, found_diff
       
       
       _file_template = """
       <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
                 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
       
       <html>
       
       <head>
           <meta http-equiv="Content-Type"
                 content="text/html; charset=ISO-8859-1" />
           <title></title>
           <style type="text/css">%(styles)s
           </style>
       </head>
       
       <body>
           %(table)s%(legend)s
       </body>
       
>>>>>> </html>"""
       
       _styles = """
               table.diff {font-family:Courier; border:medium;}
               .diff_header {background-color:#e0e0e0}
               td.diff_header {text-align:right}
               .diff_next {background-color:#c0c0c0}
               .diff_add {background-color:#aaffaa}
               .diff_chg {background-color:#ffff77}
>>>>>>         .diff_sub {background-color:#ffaaaa}"""
       
       _table_template = """
           <table class="diff" id="difflib_chg_%(prefix)s_top"
                  cellspacing="0" cellpadding="0" rules="groups" >
               <colgroup></colgroup> <colgroup></colgroup> <colgroup></colgroup>
               <colgroup></colgroup> <colgroup></colgroup> <colgroup></colgroup>
               %(header_row)s
               <tbody>
       %(data_rows)s        </tbody>
>>>>>>     </table>"""
       
       _legend = """
           <table class="diff" summary="Legends">
               <tr> <th colspan="2"> Legends </th> </tr>
               <tr> <td> <table border="" summary="Colors">
                             <tr><th> Colors </th> </tr>
                             <tr><td class="diff_add">&nbsp;Added&nbsp;</td></tr>
                             <tr><td class="diff_chg">Changed</td> </tr>
                             <tr><td class="diff_sub">Deleted</td> </tr>
                         </table></td>
                    <td> <table border="" summary="Links">
                             <tr><th colspan="2"> Links </th> </tr>
                             <tr><td>(f)irst change</td> </tr>
                             <tr><td>(n)ext change</td> </tr>
                             <tr><td>(t)op</td> </tr>
                         </table></td> </tr>
>>>>>>     </table>"""
       
>>>>>> class HtmlDiff(object):
           """For producing HTML side by side comparison with change highlights.
       
           This class can be used to create an HTML table (or a complete HTML file
           containing the table) showing a side by side, line by line comparison
           of text with inter-line and intra-line change highlights.  The table can
           be generated in either full or contextual difference mode.
       
           The following methods are provided for HTML generation:
       
           make_table -- generates HTML for a single side by side table
           make_file -- generates complete HTML file with a single side by side table
       
           See tools/scripts/diff.py for an example usage of this class.
           """
       
>>>>>>     _file_template = _file_template
>>>>>>     _styles = _styles
>>>>>>     _table_template = _table_template
>>>>>>     _legend = _legend
>>>>>>     _default_prefix = 0
       
>>>>>>     def __init__(self,tabsize=8,wrapcolumn=None,linejunk=None,
>>>>>>                  charjunk=IS_CHARACTER_JUNK):
               """HtmlDiff instance initializer
       
               Arguments:
               tabsize -- tab stop spacing, defaults to 8.
               wrapcolumn -- column number where lines are broken and wrapped,
                   defaults to None where lines are not wrapped.
               linejunk,charjunk -- keyword arguments passed into ndiff() (used to by
                   HtmlDiff() to generate the side by side HTML differences).  See
                   ndiff() documentation for argument default values and descriptions.
               """
    3:         self._tabsize = tabsize
    3:         self._wrapcolumn = wrapcolumn
    3:         self._linejunk = linejunk
    3:         self._charjunk = charjunk
       
>>>>>>     def make_file(self,fromlines,tolines,fromdesc='',todesc='',context=False,
>>>>>>                   numlines=5):
               """Returns HTML file of side by side comparison with change highlights
       
               Arguments:
               fromlines -- list of "from" lines
               tolines -- list of "to" lines
               fromdesc -- "from" file column header string
               todesc -- "to" file column header string
               context -- set to True for contextual differences (defaults to False
                   which shows full differences).
               numlines -- number of context lines.  When context is set True,
                   controls number of lines displayed before and after the change.
                   When context is False, controls the number of lines to place
                   the "next" link anchors before the next change (so click of
                   "next" link jumps to just before the change).
               """
       
    1:         return self._file_template % dict(
    1:             styles = self._styles,
    1:             legend = self._legend,
    1:             table = self.make_table(fromlines,tolines,fromdesc,todesc,
    1:                                     context=context,numlines=numlines))
       
>>>>>>     def _tab_newline_replace(self,fromlines,tolines):
               """Returns from/to line lists with tabs expanded and newlines removed.
       
               Instead of tab characters being replaced by the number of spaces
               needed to fill in to the next tab stop, this function will fill
               the space with tab characters.  This is done so that the difference
               algorithms can identify changes in a file when tabs are replaced by
               spaces and vice versa.  At the end of the HTML generation, the tab
               characters will be replaced with a nonbreakable space.
               """
   14:         def expand_tabs(line):
                   # hide real spaces
  770:             line = line.replace(' ','\0')
                   # expand tabs into spaces
  770:             line = line.expandtabs(self._tabsize)
                   # replace spaces from expanded tabs back into tab characters
                   # (we'll replace them with markup after we do differencing)
  770:             line = line.replace(' ','\t')
  770:             return line.replace('\0',' ').rstrip('\n')
  399:         fromlines = [expand_tabs(line) for line in fromlines]
  399:         tolines = [expand_tabs(line) for line in tolines]
   14:         return fromlines,tolines
       
>>>>>>     def _split_line(self,data_list,line_num,text):
               """Builds list of text lines by splitting text lines at wrap point
       
               This function will determine if the input text line needs to be
               wrapped (split) into separate lines.  If so, the first wrap point
               will be determined and the first line appended to the output
               text line list.  This function is used recursively to handle
               the second part of the split line to further split it.
               """
               # if blank line or context separator, just add it to the output list
  132:         if not line_num:
>>>>>>             data_list.append((line_num,text))
>>>>>>             return
       
               # if line text doesn't need wrapping, just add it to the output list
  132:         size = len(text)
  132:         max = self._wrapcolumn
  132:         if (size <= max) or ((size -(text.count('\0')*3)) <= max):
   82:             data_list.append((line_num,text))
   82:             return
       
               # scan text looking for the wrap point, keeping track if the wrap
               # point is inside markers
   50:         i = 0
   50:         n = 0
   50:         mark = ''
  804:         while n < max and i < size:
  754:             if text[i] == '\0':
   42:                 i += 1
   42:                 mark = text[i]
   42:                 i += 1
  712:             elif text[i] == '\1':
   12:                 i += 1
   12:                 mark = ''
                   else:
  700:                 i += 1
  700:                 n += 1
       
               # wrap point is inside text, break it up into separate lines
   50:         line1 = text[:i]
   50:         line2 = text[i:]
       
               # if wrap point is inside markers, place end marker at end of first
               # line and start marker at beginning of second line because each
               # line will have its own table tag markup around it.
   50:         if mark:
   30:             line1 = line1 + '\1'
   30:             line2 = '\0' + mark + line2
       
               # tack on first line onto the output list
   50:         data_list.append((line_num,line1))
       
               # use this routine again to wrap the remaining text
   50:         self._split_line(data_list,'>',line2)
       
>>>>>>     def _line_wrapper(self,diffs):
               """Returns iterator that splits (wraps) mdiff text lines"""
       
               # pull from/to data and flags from mdiff iterator
   48:         for fromdata,todata,flag in diffs:
                   # check for context separators and pass them through
   45:             if flag is None:
    4:                 yield fromdata,todata,flag
    4:                 continue
   41:             (fromline,fromtext),(toline,totext) = fromdata,todata
                   # for each from/to line split it at the wrap column to form
                   # list of text lines.
   41:             fromlist,tolist = [],[]
   41:             self._split_line(fromlist,fromline,fromtext)
   41:             self._split_line(tolist,toline,totext)
                   # yield from/to line in pairs inserting blank lines as
                   # necessary when one side has more wrapped lines
  116:             while fromlist or tolist:
   75:                 if fromlist:
   66:                     fromdata = fromlist.pop(0)
                       else:
    9:                     fromdata = ('',' ')
   75:                 if tolist:
   66:                     todata = tolist.pop(0)
                       else:
    9:                     todata = ('',' ')
   75:                 yield fromdata,todata,flag
       
>>>>>>     def _collect_lines(self,diffs):
               """Collects mdiff output into separate lists
       
               Before storing the mdiff from/to data into a list, it is converted
               into a single line of text with HTML markup.
               """
       
   14:         fromlist,tolist,flaglist = [],[],[]
               # pull from/to data and flags from mdiff style iterator
  351:         for fromdata,todata,flag in diffs:
  337:             try:
                       # store HTML markup of the lines into the lists
  337:                 fromlist.append(self._format_line(0,flag,*fromdata))
  325:                 tolist.append(self._format_line(1,flag,*todata))
   12:             except TypeError:
                       # exceptions occur for lines where context separators go
   12:                 fromlist.append(None)
   12:                 tolist.append(None)
  337:             flaglist.append(flag)
   14:         return fromlist,tolist,flaglist
       
>>>>>>     def _format_line(self,side,flag,linenum,text):
               """Returns HTML markup of "from" / "to" text lines
       
               side -- 0 or 1 indicating "from" or "to" text
               flag -- indicates if difference on line
               linenum -- line number (used for line number column)
               text -- line text to be marked up
               """
  650:         try:
  650:             linenum = '%d' % linenum
  552:             id = ' id="%s%s"' % (self._prefix[side],linenum)
   98:         except TypeError:
                   # handle blank lines where linenum is '>' or ''
   98:             id = ''
               # replace those things that would get confused with HTML symbols
  650:         text=text.replace("&","&amp;").replace(">","&gt;").replace("<","&lt;")
       
               # make space non-breakable so they don't get compressed or line wrapped
  650:         text = text.replace(' ','&nbsp;').rstrip()
       
  650:         return '<td class="diff_header"%s>%s</td><td nowrap="nowrap">%s</td>' \
  650:                % (id,linenum,text)
       
>>>>>>     def _make_prefix(self):
               """Create unique anchor prefixes"""
       
               # Generate a unique anchor prefix so multiple tables
               # can exist on the same HTML page without conflicts.
   14:         fromprefix = "from%d_" % HtmlDiff._default_prefix
   14:         toprefix = "to%d_" % HtmlDiff._default_prefix
   14:         HtmlDiff._default_prefix += 1
               # store prefixes so line format method has access
   14:         self._prefix = [fromprefix,toprefix]
       
>>>>>>     def _convert_flags(self,fromlist,tolist,flaglist,context,numlines):
               """Makes list of "next" links"""
       
               # all anchor names will be generated using the unique "to" prefix
   14:         toprefix = self._prefix[1]
       
               # process change flags, generating middle column of next anchors/links
   14:         next_id = ['']*len(flaglist)
   14:         next_href = ['']*len(flaglist)
   14:         num_chg, in_change = 0, False
   14:         last = 0
  351:         for i,flag in enumerate(flaglist):
  337:             if flag:
  142:                 if not in_change:
   29:                     in_change = True
   29:                     last = i
                           # at the beginning of a change, drop an anchor a few lines
                           # (the context lines) before the change for the previous
                           # link
   29:                     i = max([0,i-numlines])
   29:                     next_id[i] = ' id="difflib_chg_%s_%d"' % (toprefix,num_chg)
                           # at the beginning of a change, drop a link to the next
                           # change
   29:                     num_chg += 1
   29:                     next_href[last] = '<a href="#difflib_chg_%s_%d">n</a>' % (
   29:                          toprefix,num_chg)
                   else:
  195:                 in_change = False
               # check for cases where there is no content to avoid exceptions
   14:         if not flaglist:
    3:             flaglist = [False]
    3:             next_id = ['']
    3:             next_href = ['']
    3:             last = 0
    3:             if context:
    2:                 fromlist = ['<td></td><td>&nbsp;No Differences Found&nbsp;</td>']
    2:                 tolist = fromlist
                   else:
    1:                 fromlist = tolist = ['<td></td><td>&nbsp;Empty File&nbsp;</td>']
               # if not a change on first line, drop a link
   14:         if not flaglist[0]:
   14:             next_href[0] = '<a href="#difflib_chg_%s_0">f</a>' % toprefix
               # redo the last link to link to the top
   14:         next_href[last] = '<a href="#difflib_chg_%s_top">t</a>' % (toprefix)
       
   14:         return fromlist,tolist,flaglist,next_href,next_id
       
>>>>>>     def make_table(self,fromlines,tolines,fromdesc='',todesc='',context=False,
>>>>>>                    numlines=5):
               """Returns HTML table of side by side comparison with change highlights
       
               Arguments:
               fromlines -- list of "from" lines
               tolines -- list of "to" lines
               fromdesc -- "from" file column header string
               todesc -- "to" file column header string
               context -- set to True for contextual differences (defaults to False
                   which shows full differences).
               numlines -- number of context lines.  When context is set True,
                   controls number of lines displayed before and after the change.
                   When context is False, controls the number of lines to place
                   the "next" link anchors before the next change (so click of
                   "next" link jumps to just before the change).
               """
       
               # make unique anchor prefixes so that multiple tables may exist
               # on the same page without conflict.
   14:         self._make_prefix()
       
               # change tabs to spaces before it gets more difficult after we insert
               # markup
   14:         fromlines,tolines = self._tab_newline_replace(fromlines,tolines)
       
               # create diffs iterator which generates side by side from/to data
   14:         if context:
    7:             context_lines = numlines
               else:
    7:             context_lines = None
   14:         diffs = _mdiff(fromlines,tolines,context_lines,linejunk=self._linejunk,
   14:                       charjunk=self._charjunk)
       
               # set up iterator to wrap lines that exceed desired width
   14:         if self._wrapcolumn:
    3:             diffs = self._line_wrapper(diffs)
       
               # collect up from/to lines and flags into lists (also format the lines)
   14:         fromlist,tolist,flaglist = self._collect_lines(diffs)
       
               # process change flags, generating middle column of next anchors/links
   14:         fromlist,tolist,flaglist,next_href,next_id = self._convert_flags(
   14:             fromlist,tolist,flaglist,context,numlines)
       
   14:         s = []
   14:         fmt = '            <tr><td class="diff_next"%s>%s</td>%s' + \
   14:               '<td class="diff_next">%s</td>%s</tr>\n'
  354:         for i in range(len(flaglist)):
  340:             if flaglist[i] is None:
                       # mdiff yields None on separator lines skip the bogus ones
                       # generated for the first line
   12:                 if i > 0:
    9:                     s.append('        </tbody>        \n        <tbody>\n')
                   else:
  328:                 s.append( fmt % (next_id[i],next_href[i],fromlist[i],
  328:                                            next_href[i],tolist[i]))
   14:         if fromdesc or todesc:
    9:             header_row = '<thead><tr>%s%s%s%s</tr></thead>' % (
    9:                 '<th class="diff_next"><br /></th>',
    9:                 '<th colspan="2" class="diff_header">%s</th>' % fromdesc,
    9:                 '<th class="diff_next"><br /></th>',
    9:                 '<th colspan="2" class="diff_header">%s</th>' % todesc)
               else:
    5:             header_row = ''
       
   14:         table = self._table_template % dict(
   14:             data_rows=''.join(s),
   14:             header_row=header_row,
   14:             prefix=self._prefix[1])
       
   14:         return table.replace('\0+','<span class="diff_add">'). \
   14:                      replace('\0-','<span class="diff_sub">'). \
   14:                      replace('\0^','<span class="diff_chg">'). \
   14:                      replace('\1','</span>'). \
   14:                      replace('\t','&nbsp;')
       
>>>>>> del re
       
>>>>>> def restore(delta, which):
           r"""
           Generate one of the two sequences that generated a delta.
       
           Given a `delta` produced by `Differ.compare()` or `ndiff()`, extract
           lines originating from file 1 or 2 (parameter `which`), stripping off line
           prefixes.
       
           Examples:
       
           >>> diff = ndiff('one\ntwo\nthree\n'.splitlines(1),
           ...              'ore\ntree\nemu\n'.splitlines(1))
           >>> diff = list(diff)
           >>> print ''.join(restore(diff, 1)),
           one
           two
           three
           >>> print ''.join(restore(diff, 2)),
           ore
           tree
           emu
           """
    2:     try:
    2:         tag = {1: "- ", 2: "+ "}[int(which)]
>>>>>>     except KeyError:
>>>>>>         raise ValueError, ('unknown delta choice (must be 1 or 2): %r'
>>>>>>                            % which)
    2:     prefixes = ("  ", tag)
   20:     for line in delta:
   18:         if line[:2] in prefixes:
    6:             yield line[2:]
       
>>>>>> def _test():
>>>>>>     import doctest, difflib
>>>>>>     return doctest.testmod(difflib)
       
>>>>>> if __name__ == "__main__":
>>>>>>     _test()
