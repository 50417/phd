    1: import sys
    1: import types
       
       
    1: import unittest
       
       
    2: class Test_TestLoader(unittest.TestCase):
       
           ### Tests for TestLoader.loadTestsFromTestCase
           ################################################################
       
           # "Return a suite of all test cases contained in the TestCase-derived
           # class testCaseClass"
    1:     def test_loadTestsFromTestCase(self):
    2:         class Foo(unittest.TestCase):
    1:             def test_1(self): pass
    1:             def test_2(self): pass
    1:             def foo_bar(self): pass
       
    1:         tests = unittest.TestSuite([Foo('test_1'), Foo('test_2')])
       
    1:         loader = unittest.TestLoader()
    1:         self.assertEqual(loader.loadTestsFromTestCase(Foo), tests)
       
           # "Return a suite of all test cases contained in the TestCase-derived
           # class testCaseClass"
           #
           # Make sure it does the right thing even if no tests were found
    1:     def test_loadTestsFromTestCase__no_matches(self):
    2:         class Foo(unittest.TestCase):
    1:             def foo_bar(self): pass
       
    1:         empty_suite = unittest.TestSuite()
       
    1:         loader = unittest.TestLoader()
    1:         self.assertEqual(loader.loadTestsFromTestCase(Foo), empty_suite)
       
           # "Return a suite of all test cases contained in the TestCase-derived
           # class testCaseClass"
           #
           # What happens if loadTestsFromTestCase() is given an object
           # that isn't a subclass of TestCase? Specifically, what happens
           # if testCaseClass is a subclass of TestSuite?
           #
           # This is checked for specifically in the code, so we better add a
           # test for it.
    1:     def test_loadTestsFromTestCase__TestSuite_subclass(self):
    2:         class NotATestCase(unittest.TestSuite):
    1:             pass
       
    1:         loader = unittest.TestLoader()
    1:         try:
    1:             loader.loadTestsFromTestCase(NotATestCase)
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail('Should raise TypeError')
       
           # "Return a suite of all test cases contained in the TestCase-derived
           # class testCaseClass"
           #
           # Make sure loadTestsFromTestCase() picks up the default test method
           # name (as specified by TestCase), even though the method name does
           # not match the default TestLoader.testMethodPrefix string
    1:     def test_loadTestsFromTestCase__default_method_name(self):
    2:         class Foo(unittest.TestCase):
    1:             def runTest(self):
>>>>>>                 pass
       
    1:         loader = unittest.TestLoader()
               # This has to be false for the test to succeed
    1:         self.assertFalse('runTest'.startswith(loader.testMethodPrefix))
       
    1:         suite = loader.loadTestsFromTestCase(Foo)
    1:         self.assertIsInstance(suite, loader.suiteClass)
    1:         self.assertEqual(list(suite), [Foo('runTest')])
       
           ################################################################
           ### /Tests for TestLoader.loadTestsFromTestCase
       
           ### Tests for TestLoader.loadTestsFromModule
           ################################################################
       
           # "This method searches `module` for classes derived from TestCase"
    1:     def test_loadTestsFromModule__TestCase_subclass(self):
    1:         m = types.ModuleType('m')
    2:         class MyTestCase(unittest.TestCase):
    1:             def test(self):
>>>>>>                 pass
    1:         m.testcase_1 = MyTestCase
       
    1:         loader = unittest.TestLoader()
    1:         suite = loader.loadTestsFromModule(m)
    1:         self.assertIsInstance(suite, loader.suiteClass)
       
    1:         expected = [loader.suiteClass([MyTestCase('test')])]
    1:         self.assertEqual(list(suite), expected)
       
           # "This method searches `module` for classes derived from TestCase"
           #
           # What happens if no tests are found (no TestCase instances)?
    1:     def test_loadTestsFromModule__no_TestCase_instances(self):
    1:         m = types.ModuleType('m')
       
    1:         loader = unittest.TestLoader()
    1:         suite = loader.loadTestsFromModule(m)
    1:         self.assertIsInstance(suite, loader.suiteClass)
    1:         self.assertEqual(list(suite), [])
       
           # "This method searches `module` for classes derived from TestCase"
           #
           # What happens if no tests are found (TestCases instances, but no tests)?
    1:     def test_loadTestsFromModule__no_TestCase_tests(self):
    1:         m = types.ModuleType('m')
    2:         class MyTestCase(unittest.TestCase):
    1:             pass
    1:         m.testcase_1 = MyTestCase
       
    1:         loader = unittest.TestLoader()
    1:         suite = loader.loadTestsFromModule(m)
    1:         self.assertIsInstance(suite, loader.suiteClass)
       
    1:         self.assertEqual(list(suite), [loader.suiteClass()])
       
           # "This method searches `module` for classes derived from TestCase"s
           #
           # What happens if loadTestsFromModule() is given something other
           # than a module?
           #
           # XXX Currently, it succeeds anyway. This flexibility
           # should either be documented or loadTestsFromModule() should
           # raise a TypeError
           #
           # XXX Certain people are using this behaviour. We'll add a test for it
    1:     def test_loadTestsFromModule__not_a_module(self):
    2:         class MyTestCase(unittest.TestCase):
    1:             def test(self):
>>>>>>                 pass
       
    2:         class NotAModule(object):
    1:             test_2 = MyTestCase
       
    1:         loader = unittest.TestLoader()
    1:         suite = loader.loadTestsFromModule(NotAModule)
       
    1:         reference = [unittest.TestSuite([MyTestCase('test')])]
    1:         self.assertEqual(list(suite), reference)
       
       
           # Check that loadTestsFromModule honors (or not) a module
           # with a load_tests function.
    1:     def test_loadTestsFromModule__load_tests(self):
    1:         m = types.ModuleType('m')
    2:         class MyTestCase(unittest.TestCase):
    1:             def test(self):
>>>>>>                 pass
    1:         m.testcase_1 = MyTestCase
       
    1:         load_tests_args = []
    1:         def load_tests(loader, tests, pattern):
    1:             self.assertIsInstance(tests, unittest.TestSuite)
    1:             load_tests_args.extend((loader, tests, pattern))
    1:             return tests
    1:         m.load_tests = load_tests
       
    1:         loader = unittest.TestLoader()
    1:         suite = loader.loadTestsFromModule(m)
    1:         self.assertIsInstance(suite, unittest.TestSuite)
    1:         self.assertEqual(load_tests_args, [loader, suite, None])
       
    1:         load_tests_args = []
    1:         suite = loader.loadTestsFromModule(m, use_load_tests=False)
    1:         self.assertEqual(load_tests_args, [])
       
    1:     def test_loadTestsFromModule__faulty_load_tests(self):
    1:         m = types.ModuleType('m')
       
    1:         def load_tests(loader, tests, pattern):
    1:             raise TypeError('some failure')
    1:         m.load_tests = load_tests
       
    1:         loader = unittest.TestLoader()
    1:         suite = loader.loadTestsFromModule(m)
    1:         self.assertIsInstance(suite, unittest.TestSuite)
    1:         self.assertEqual(suite.countTestCases(), 1)
    1:         test = list(suite)[0]
       
    1:         self.assertRaisesRegexp(TypeError, "some failure", test.m)
       
           ################################################################
           ### /Tests for TestLoader.loadTestsFromModule()
       
           ### Tests for TestLoader.loadTestsFromName()
           ################################################################
       
           # "The specifier name is a ``dotted name'' that may resolve either to
           # a module, a test case class, a TestSuite instance, a test method
           # within a test case class, or a callable object which returns a
           # TestCase or TestSuite instance."
           #
           # Is ValueError raised in response to an empty name?
    1:     def test_loadTestsFromName__empty_name(self):
    1:         loader = unittest.TestLoader()
       
    1:         try:
    1:             loader.loadTestsFromName('')
    1:         except ValueError, e:
    1:             self.assertEqual(str(e), "Empty module name")
               else:
>>>>>>             self.fail("TestLoader.loadTestsFromName failed to raise ValueError")
       
           # "The specifier name is a ``dotted name'' that may resolve either to
           # a module, a test case class, a TestSuite instance, a test method
           # within a test case class, or a callable object which returns a
           # TestCase or TestSuite instance."
           #
           # What happens when the name contains invalid characters?
    1:     def test_loadTestsFromName__malformed_name(self):
    1:         loader = unittest.TestLoader()
       
               # XXX Should this raise ValueError or ImportError?
    1:         try:
    1:             loader.loadTestsFromName('abc () //')
    1:         except ValueError:
>>>>>>             pass
    1:         except ImportError:
    1:             pass
               else:
>>>>>>             self.fail("TestLoader.loadTestsFromName failed to raise ValueError")
       
           # "The specifier name is a ``dotted name'' that may resolve ... to a
           # module"
           #
           # What happens when a module by that name can't be found?
    1:     def test_loadTestsFromName__unknown_module_name(self):
    1:         loader = unittest.TestLoader()
       
    1:         try:
    1:             loader.loadTestsFromName('sdasfasfasdf')
    1:         except ImportError, e:
    1:             self.assertEqual(str(e), "No module named sdasfasfasdf")
               else:
>>>>>>             self.fail("TestLoader.loadTestsFromName failed to raise ImportError")
       
           # "The specifier name is a ``dotted name'' that may resolve either to
           # a module, a test case class, a TestSuite instance, a test method
           # within a test case class, or a callable object which returns a
           # TestCase or TestSuite instance."
           #
           # What happens when the module is found, but the attribute can't?
    1:     def test_loadTestsFromName__unknown_attr_name(self):
    1:         loader = unittest.TestLoader()
       
    1:         try:
    1:             loader.loadTestsFromName('unittest.sdasfasfasdf')
    1:         except AttributeError, e:
    1:             self.assertEqual(str(e), "'module' object has no attribute 'sdasfasfasdf'")
               else:
>>>>>>             self.fail("TestLoader.loadTestsFromName failed to raise AttributeError")
       
           # "The specifier name is a ``dotted name'' that may resolve either to
           # a module, a test case class, a TestSuite instance, a test method
           # within a test case class, or a callable object which returns a
           # TestCase or TestSuite instance."
           #
           # What happens when we provide the module, but the attribute can't be
           # found?
    1:     def test_loadTestsFromName__relative_unknown_name(self):
    1:         loader = unittest.TestLoader()
       
    1:         try:
    1:             loader.loadTestsFromName('sdasfasfasdf', unittest)
    1:         except AttributeError, e:
    1:             self.assertEqual(str(e), "'module' object has no attribute 'sdasfasfasdf'")
               else:
>>>>>>             self.fail("TestLoader.loadTestsFromName failed to raise AttributeError")
       
           # "The specifier name is a ``dotted name'' that may resolve either to
           # a module, a test case class, a TestSuite instance, a test method
           # within a test case class, or a callable object which returns a
           # TestCase or TestSuite instance."
           # ...
           # "The method optionally resolves name relative to the given module"
           #
           # Does loadTestsFromName raise ValueError when passed an empty
           # name relative to a provided module?
           #
           # XXX Should probably raise a ValueError instead of an AttributeError
    1:     def test_loadTestsFromName__relative_empty_name(self):
    1:         loader = unittest.TestLoader()
       
    1:         try:
    1:             loader.loadTestsFromName('', unittest)
    1:         except AttributeError:
    1:             pass
               else:
>>>>>>             self.fail("Failed to raise AttributeError")
       
           # "The specifier name is a ``dotted name'' that may resolve either to
           # a module, a test case class, a TestSuite instance, a test method
           # within a test case class, or a callable object which returns a
           # TestCase or TestSuite instance."
           # ...
           # "The method optionally resolves name relative to the given module"
           #
           # What happens when an impossible name is given, relative to the provided
           # `module`?
    1:     def test_loadTestsFromName__relative_malformed_name(self):
    1:         loader = unittest.TestLoader()
       
               # XXX Should this raise AttributeError or ValueError?
    1:         try:
    1:             loader.loadTestsFromName('abc () //', unittest)
    1:         except ValueError:
>>>>>>             pass
    1:         except AttributeError:
    1:             pass
               else:
>>>>>>             self.fail("TestLoader.loadTestsFromName failed to raise ValueError")
       
           # "The method optionally resolves name relative to the given module"
           #
           # Does loadTestsFromName raise TypeError when the `module` argument
           # isn't a module object?
           #
           # XXX Accepts the not-a-module object, ignoring the object's type
           # This should raise an exception or the method name should be changed
           #
           # XXX Some people are relying on this, so keep it for now
    1:     def test_loadTestsFromName__relative_not_a_module(self):
    2:         class MyTestCase(unittest.TestCase):
    1:             def test(self):
>>>>>>                 pass
       
    2:         class NotAModule(object):
    1:             test_2 = MyTestCase
       
    1:         loader = unittest.TestLoader()
    1:         suite = loader.loadTestsFromName('test_2', NotAModule)
       
    1:         reference = [MyTestCase('test')]
    1:         self.assertEqual(list(suite), reference)
       
           # "The specifier name is a ``dotted name'' that may resolve either to
           # a module, a test case class, a TestSuite instance, a test method
           # within a test case class, or a callable object which returns a
           # TestCase or TestSuite instance."
           #
           # Does it raise an exception if the name resolves to an invalid
           # object?
    1:     def test_loadTestsFromName__relative_bad_object(self):
    1:         m = types.ModuleType('m')
    1:         m.testcase_1 = object()
       
    1:         loader = unittest.TestLoader()
    1:         try:
    1:             loader.loadTestsFromName('testcase_1', m)
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("Should have raised TypeError")
       
           # "The specifier name is a ``dotted name'' that may
           # resolve either to ... a test case class"
    1:     def test_loadTestsFromName__relative_TestCase_subclass(self):
    1:         m = types.ModuleType('m')
    2:         class MyTestCase(unittest.TestCase):
    1:             def test(self):
>>>>>>                 pass
    1:         m.testcase_1 = MyTestCase
       
    1:         loader = unittest.TestLoader()
    1:         suite = loader.loadTestsFromName('testcase_1', m)
    1:         self.assertIsInstance(suite, loader.suiteClass)
    1:         self.assertEqual(list(suite), [MyTestCase('test')])
       
           # "The specifier name is a ``dotted name'' that may resolve either to
           # a module, a test case class, a TestSuite instance, a test method
           # within a test case class, or a callable object which returns a
           # TestCase or TestSuite instance."
    1:     def test_loadTestsFromName__relative_TestSuite(self):
    1:         m = types.ModuleType('m')
    2:         class MyTestCase(unittest.TestCase):
    1:             def test(self):
>>>>>>                 pass
    1:         m.testsuite = unittest.TestSuite([MyTestCase('test')])
       
    1:         loader = unittest.TestLoader()
    1:         suite = loader.loadTestsFromName('testsuite', m)
    1:         self.assertIsInstance(suite, loader.suiteClass)
       
    1:         self.assertEqual(list(suite), [MyTestCase('test')])
       
           # "The specifier name is a ``dotted name'' that may resolve ... to
           # ... a test method within a test case class"
    1:     def test_loadTestsFromName__relative_testmethod(self):
    1:         m = types.ModuleType('m')
    2:         class MyTestCase(unittest.TestCase):
    1:             def test(self):
>>>>>>                 pass
    1:         m.testcase_1 = MyTestCase
       
    1:         loader = unittest.TestLoader()
    1:         suite = loader.loadTestsFromName('testcase_1.test', m)
    1:         self.assertIsInstance(suite, loader.suiteClass)
       
    1:         self.assertEqual(list(suite), [MyTestCase('test')])
       
           # "The specifier name is a ``dotted name'' that may resolve either to
           # a module, a test case class, a TestSuite instance, a test method
           # within a test case class, or a callable object which returns a
           # TestCase or TestSuite instance."
           #
           # Does loadTestsFromName() raise the proper exception when trying to
           # resolve "a test method within a test case class" that doesn't exist
           # for the given name (relative to a provided module)?
    1:     def test_loadTestsFromName__relative_invalid_testmethod(self):
    1:         m = types.ModuleType('m')
    2:         class MyTestCase(unittest.TestCase):
    1:             def test(self):
>>>>>>                 pass
    1:         m.testcase_1 = MyTestCase
       
    1:         loader = unittest.TestLoader()
    1:         try:
    1:             loader.loadTestsFromName('testcase_1.testfoo', m)
    1:         except AttributeError, e:
    1:             self.assertEqual(str(e), "type object 'MyTestCase' has no attribute 'testfoo'")
               else:
>>>>>>             self.fail("Failed to raise AttributeError")
       
           # "The specifier name is a ``dotted name'' that may resolve ... to
           # ... a callable object which returns a ... TestSuite instance"
    1:     def test_loadTestsFromName__callable__TestSuite(self):
    1:         m = types.ModuleType('m')
    1:         testcase_1 = unittest.FunctionTestCase(lambda: None)
    1:         testcase_2 = unittest.FunctionTestCase(lambda: None)
    1:         def return_TestSuite():
    1:             return unittest.TestSuite([testcase_1, testcase_2])
    1:         m.return_TestSuite = return_TestSuite
       
    1:         loader = unittest.TestLoader()
    1:         suite = loader.loadTestsFromName('return_TestSuite', m)
    1:         self.assertIsInstance(suite, loader.suiteClass)
    1:         self.assertEqual(list(suite), [testcase_1, testcase_2])
       
           # "The specifier name is a ``dotted name'' that may resolve ... to
           # ... a callable object which returns a TestCase ... instance"
    1:     def test_loadTestsFromName__callable__TestCase_instance(self):
    1:         m = types.ModuleType('m')
    1:         testcase_1 = unittest.FunctionTestCase(lambda: None)
    1:         def return_TestCase():
    1:             return testcase_1
    1:         m.return_TestCase = return_TestCase
       
    1:         loader = unittest.TestLoader()
    1:         suite = loader.loadTestsFromName('return_TestCase', m)
    1:         self.assertIsInstance(suite, loader.suiteClass)
    1:         self.assertEqual(list(suite), [testcase_1])
       
           # "The specifier name is a ``dotted name'' that may resolve ... to
           # ... a callable object which returns a TestCase ... instance"
           #*****************************************************************
           #Override the suiteClass attribute to ensure that the suiteClass
           #attribute is used
    1:     def test_loadTestsFromName__callable__TestCase_instance_ProperSuiteClass(self):
    2:         class SubTestSuite(unittest.TestSuite):
    1:             pass
    1:         m = types.ModuleType('m')
    1:         testcase_1 = unittest.FunctionTestCase(lambda: None)
    1:         def return_TestCase():
    1:             return testcase_1
    1:         m.return_TestCase = return_TestCase
       
    1:         loader = unittest.TestLoader()
    1:         loader.suiteClass = SubTestSuite
    1:         suite = loader.loadTestsFromName('return_TestCase', m)
    1:         self.assertIsInstance(suite, loader.suiteClass)
    1:         self.assertEqual(list(suite), [testcase_1])
       
           # "The specifier name is a ``dotted name'' that may resolve ... to
           # ... a test method within a test case class"
           #*****************************************************************
           #Override the suiteClass attribute to ensure that the suiteClass
           #attribute is used
    1:     def test_loadTestsFromName__relative_testmethod_ProperSuiteClass(self):
    2:         class SubTestSuite(unittest.TestSuite):
    1:             pass
    1:         m = types.ModuleType('m')
    2:         class MyTestCase(unittest.TestCase):
    1:             def test(self):
>>>>>>                 pass
    1:         m.testcase_1 = MyTestCase
       
    1:         loader = unittest.TestLoader()
    1:         loader.suiteClass=SubTestSuite
    1:         suite = loader.loadTestsFromName('testcase_1.test', m)
    1:         self.assertIsInstance(suite, loader.suiteClass)
       
    1:         self.assertEqual(list(suite), [MyTestCase('test')])
       
           # "The specifier name is a ``dotted name'' that may resolve ... to
           # ... a callable object which returns a TestCase or TestSuite instance"
           #
           # What happens if the callable returns something else?
    1:     def test_loadTestsFromName__callable__wrong_type(self):
    1:         m = types.ModuleType('m')
    1:         def return_wrong():
    1:             return 6
    1:         m.return_wrong = return_wrong
       
    1:         loader = unittest.TestLoader()
    1:         try:
    1:             loader.loadTestsFromName('return_wrong', m)
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("TestLoader.loadTestsFromName failed to raise TypeError")
       
           # "The specifier can refer to modules and packages which have not been
           # imported; they will be imported as a side-effect"
    1:     def test_loadTestsFromName__module_not_loaded(self):
               # We're going to try to load this module as a side-effect, so it
               # better not be loaded before we try.
               #
    1:         module_name = 'unittest.test.dummy'
    1:         sys.modules.pop(module_name, None)
       
    1:         loader = unittest.TestLoader()
    1:         try:
    1:             suite = loader.loadTestsFromName(module_name)
       
    1:             self.assertIsInstance(suite, loader.suiteClass)
    1:             self.assertEqual(list(suite), [])
       
                   # module should now be loaded, thanks to loadTestsFromName()
    1:             self.assertIn(module_name, sys.modules)
               finally:
    1:             if module_name in sys.modules:
    1:                 del sys.modules[module_name]
       
           ################################################################
           ### Tests for TestLoader.loadTestsFromName()
       
           ### Tests for TestLoader.loadTestsFromNames()
           ################################################################
       
           # "Similar to loadTestsFromName(), but takes a sequence of names rather
           # than a single name."
           #
           # What happens if that sequence of names is empty?
    1:     def test_loadTestsFromNames__empty_name_list(self):
    1:         loader = unittest.TestLoader()
       
    1:         suite = loader.loadTestsFromNames([])
    1:         self.assertIsInstance(suite, loader.suiteClass)
    1:         self.assertEqual(list(suite), [])
       
           # "Similar to loadTestsFromName(), but takes a sequence of names rather
           # than a single name."
           # ...
           # "The method optionally resolves name relative to the given module"
           #
           # What happens if that sequence of names is empty?
           #
           # XXX Should this raise a ValueError or just return an empty TestSuite?
    1:     def test_loadTestsFromNames__relative_empty_name_list(self):
    1:         loader = unittest.TestLoader()
       
    1:         suite = loader.loadTestsFromNames([], unittest)
    1:         self.assertIsInstance(suite, loader.suiteClass)
    1:         self.assertEqual(list(suite), [])
       
           # "The specifier name is a ``dotted name'' that may resolve either to
           # a module, a test case class, a TestSuite instance, a test method
           # within a test case class, or a callable object which returns a
           # TestCase or TestSuite instance."
           #
           # Is ValueError raised in response to an empty name?
    1:     def test_loadTestsFromNames__empty_name(self):
    1:         loader = unittest.TestLoader()
       
    1:         try:
    1:             loader.loadTestsFromNames([''])
    1:         except ValueError, e:
    1:             self.assertEqual(str(e), "Empty module name")
               else:
>>>>>>             self.fail("TestLoader.loadTestsFromNames failed to raise ValueError")
       
           # "The specifier name is a ``dotted name'' that may resolve either to
           # a module, a test case class, a TestSuite instance, a test method
           # within a test case class, or a callable object which returns a
           # TestCase or TestSuite instance."
           #
           # What happens when presented with an impossible module name?
    1:     def test_loadTestsFromNames__malformed_name(self):
    1:         loader = unittest.TestLoader()
       
               # XXX Should this raise ValueError or ImportError?
    1:         try:
    1:             loader.loadTestsFromNames(['abc () //'])
    1:         except ValueError:
>>>>>>             pass
    1:         except ImportError:
    1:             pass
               else:
>>>>>>             self.fail("TestLoader.loadTestsFromNames failed to raise ValueError")
       
           # "The specifier name is a ``dotted name'' that may resolve either to
           # a module, a test case class, a TestSuite instance, a test method
           # within a test case class, or a callable object which returns a
           # TestCase or TestSuite instance."
           #
           # What happens when no module can be found for the given name?
    1:     def test_loadTestsFromNames__unknown_module_name(self):
    1:         loader = unittest.TestLoader()
       
    1:         try:
    1:             loader.loadTestsFromNames(['sdasfasfasdf'])
    1:         except ImportError, e:
    1:             self.assertEqual(str(e), "No module named sdasfasfasdf")
               else:
>>>>>>             self.fail("TestLoader.loadTestsFromNames failed to raise ImportError")
       
           # "The specifier name is a ``dotted name'' that may resolve either to
           # a module, a test case class, a TestSuite instance, a test method
           # within a test case class, or a callable object which returns a
           # TestCase or TestSuite instance."
           #
           # What happens when the module can be found, but not the attribute?
    1:     def test_loadTestsFromNames__unknown_attr_name(self):
    1:         loader = unittest.TestLoader()
       
    1:         try:
    1:             loader.loadTestsFromNames(['unittest.sdasfasfasdf', 'unittest'])
    1:         except AttributeError, e:
    1:             self.assertEqual(str(e), "'module' object has no attribute 'sdasfasfasdf'")
               else:
>>>>>>             self.fail("TestLoader.loadTestsFromNames failed to raise AttributeError")
       
           # "The specifier name is a ``dotted name'' that may resolve either to
           # a module, a test case class, a TestSuite instance, a test method
           # within a test case class, or a callable object which returns a
           # TestCase or TestSuite instance."
           # ...
           # "The method optionally resolves name relative to the given module"
           #
           # What happens when given an unknown attribute on a specified `module`
           # argument?
    1:     def test_loadTestsFromNames__unknown_name_relative_1(self):
    1:         loader = unittest.TestLoader()
       
    1:         try:
    1:             loader.loadTestsFromNames(['sdasfasfasdf'], unittest)
    1:         except AttributeError, e:
    1:             self.assertEqual(str(e), "'module' object has no attribute 'sdasfasfasdf'")
               else:
>>>>>>             self.fail("TestLoader.loadTestsFromName failed to raise AttributeError")
       
           # "The specifier name is a ``dotted name'' that may resolve either to
           # a module, a test case class, a TestSuite instance, a test method
           # within a test case class, or a callable object which returns a
           # TestCase or TestSuite instance."
           # ...
           # "The method optionally resolves name relative to the given module"
           #
           # Do unknown attributes (relative to a provided module) still raise an
           # exception even in the presence of valid attribute names?
    1:     def test_loadTestsFromNames__unknown_name_relative_2(self):
    1:         loader = unittest.TestLoader()
       
    1:         try:
    1:             loader.loadTestsFromNames(['TestCase', 'sdasfasfasdf'], unittest)
    1:         except AttributeError, e:
    1:             self.assertEqual(str(e), "'module' object has no attribute 'sdasfasfasdf'")
               else:
>>>>>>             self.fail("TestLoader.loadTestsFromName failed to raise AttributeError")
       
           # "The specifier name is a ``dotted name'' that may resolve either to
           # a module, a test case class, a TestSuite instance, a test method
           # within a test case class, or a callable object which returns a
           # TestCase or TestSuite instance."
           # ...
           # "The method optionally resolves name relative to the given module"
           #
           # What happens when faced with the empty string?
           #
           # XXX This currently raises AttributeError, though ValueError is probably
           # more appropriate
    1:     def test_loadTestsFromNames__relative_empty_name(self):
    1:         loader = unittest.TestLoader()
       
    1:         try:
    1:             loader.loadTestsFromNames([''], unittest)
    1:         except AttributeError:
    1:             pass
               else:
>>>>>>             self.fail("Failed to raise ValueError")
       
           # "The specifier name is a ``dotted name'' that may resolve either to
           # a module, a test case class, a TestSuite instance, a test method
           # within a test case class, or a callable object which returns a
           # TestCase or TestSuite instance."
           # ...
           # "The method optionally resolves name relative to the given module"
           #
           # What happens when presented with an impossible attribute name?
    1:     def test_loadTestsFromNames__relative_malformed_name(self):
    1:         loader = unittest.TestLoader()
       
               # XXX Should this raise AttributeError or ValueError?
    1:         try:
    1:             loader.loadTestsFromNames(['abc () //'], unittest)
    1:         except AttributeError:
    1:             pass
>>>>>>         except ValueError:
>>>>>>             pass
               else:
>>>>>>             self.fail("TestLoader.loadTestsFromNames failed to raise ValueError")
       
           # "The method optionally resolves name relative to the given module"
           #
           # Does loadTestsFromNames() make sure the provided `module` is in fact
           # a module?
           #
           # XXX This validation is currently not done. This flexibility should
           # either be documented or a TypeError should be raised.
    1:     def test_loadTestsFromNames__relative_not_a_module(self):
    2:         class MyTestCase(unittest.TestCase):
    1:             def test(self):
>>>>>>                 pass
       
    2:         class NotAModule(object):
    1:             test_2 = MyTestCase
       
    1:         loader = unittest.TestLoader()
    1:         suite = loader.loadTestsFromNames(['test_2'], NotAModule)
       
    1:         reference = [unittest.TestSuite([MyTestCase('test')])]
    1:         self.assertEqual(list(suite), reference)
       
           # "The specifier name is a ``dotted name'' that may resolve either to
           # a module, a test case class, a TestSuite instance, a test method
           # within a test case class, or a callable object which returns a
           # TestCase or TestSuite instance."
           #
           # Does it raise an exception if the name resolves to an invalid
           # object?
    1:     def test_loadTestsFromNames__relative_bad_object(self):
    1:         m = types.ModuleType('m')
    1:         m.testcase_1 = object()
       
    1:         loader = unittest.TestLoader()
    1:         try:
    1:             loader.loadTestsFromNames(['testcase_1'], m)
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("Should have raised TypeError")
       
           # "The specifier name is a ``dotted name'' that may resolve ... to
           # ... a test case class"
    1:     def test_loadTestsFromNames__relative_TestCase_subclass(self):
    1:         m = types.ModuleType('m')
    2:         class MyTestCase(unittest.TestCase):
    1:             def test(self):
>>>>>>                 pass
    1:         m.testcase_1 = MyTestCase
       
    1:         loader = unittest.TestLoader()
    1:         suite = loader.loadTestsFromNames(['testcase_1'], m)
    1:         self.assertIsInstance(suite, loader.suiteClass)
       
    1:         expected = loader.suiteClass([MyTestCase('test')])
    1:         self.assertEqual(list(suite), [expected])
       
           # "The specifier name is a ``dotted name'' that may resolve ... to
           # ... a TestSuite instance"
    1:     def test_loadTestsFromNames__relative_TestSuite(self):
    1:         m = types.ModuleType('m')
    2:         class MyTestCase(unittest.TestCase):
    1:             def test(self):
>>>>>>                 pass
    1:         m.testsuite = unittest.TestSuite([MyTestCase('test')])
       
    1:         loader = unittest.TestLoader()
    1:         suite = loader.loadTestsFromNames(['testsuite'], m)
    1:         self.assertIsInstance(suite, loader.suiteClass)
       
    1:         self.assertEqual(list(suite), [m.testsuite])
       
           # "The specifier name is a ``dotted name'' that may resolve ... to ... a
           # test method within a test case class"
    1:     def test_loadTestsFromNames__relative_testmethod(self):
    1:         m = types.ModuleType('m')
    2:         class MyTestCase(unittest.TestCase):
    1:             def test(self):
>>>>>>                 pass
    1:         m.testcase_1 = MyTestCase
       
    1:         loader = unittest.TestLoader()
    1:         suite = loader.loadTestsFromNames(['testcase_1.test'], m)
    1:         self.assertIsInstance(suite, loader.suiteClass)
       
    1:         ref_suite = unittest.TestSuite([MyTestCase('test')])
    1:         self.assertEqual(list(suite), [ref_suite])
       
           # "The specifier name is a ``dotted name'' that may resolve ... to ... a
           # test method within a test case class"
           #
           # Does the method gracefully handle names that initially look like they
           # resolve to "a test method within a test case class" but don't?
    1:     def test_loadTestsFromNames__relative_invalid_testmethod(self):
    1:         m = types.ModuleType('m')
    2:         class MyTestCase(unittest.TestCase):
    1:             def test(self):
>>>>>>                 pass
    1:         m.testcase_1 = MyTestCase
       
    1:         loader = unittest.TestLoader()
    1:         try:
    1:             loader.loadTestsFromNames(['testcase_1.testfoo'], m)
    1:         except AttributeError, e:
    1:             self.assertEqual(str(e), "type object 'MyTestCase' has no attribute 'testfoo'")
               else:
>>>>>>             self.fail("Failed to raise AttributeError")
       
           # "The specifier name is a ``dotted name'' that may resolve ... to
           # ... a callable object which returns a ... TestSuite instance"
    1:     def test_loadTestsFromNames__callable__TestSuite(self):
    1:         m = types.ModuleType('m')
    1:         testcase_1 = unittest.FunctionTestCase(lambda: None)
    1:         testcase_2 = unittest.FunctionTestCase(lambda: None)
    1:         def return_TestSuite():
    1:             return unittest.TestSuite([testcase_1, testcase_2])
    1:         m.return_TestSuite = return_TestSuite
       
    1:         loader = unittest.TestLoader()
    1:         suite = loader.loadTestsFromNames(['return_TestSuite'], m)
    1:         self.assertIsInstance(suite, loader.suiteClass)
       
    1:         expected = unittest.TestSuite([testcase_1, testcase_2])
    1:         self.assertEqual(list(suite), [expected])
       
           # "The specifier name is a ``dotted name'' that may resolve ... to
           # ... a callable object which returns a TestCase ... instance"
    1:     def test_loadTestsFromNames__callable__TestCase_instance(self):
    1:         m = types.ModuleType('m')
    1:         testcase_1 = unittest.FunctionTestCase(lambda: None)
    1:         def return_TestCase():
    1:             return testcase_1
    1:         m.return_TestCase = return_TestCase
       
    1:         loader = unittest.TestLoader()
    1:         suite = loader.loadTestsFromNames(['return_TestCase'], m)
    1:         self.assertIsInstance(suite, loader.suiteClass)
       
    1:         ref_suite = unittest.TestSuite([testcase_1])
    1:         self.assertEqual(list(suite), [ref_suite])
       
           # "The specifier name is a ``dotted name'' that may resolve ... to
           # ... a callable object which returns a TestCase or TestSuite instance"
           #
           # Are staticmethods handled correctly?
    1:     def test_loadTestsFromNames__callable__call_staticmethod(self):
    1:         m = types.ModuleType('m')
    2:         class Test1(unittest.TestCase):
    1:             def test(self):
>>>>>>                 pass
       
    1:         testcase_1 = Test1('test')
    2:         class Foo(unittest.TestCase):
    1:             @staticmethod
                   def foo():
    1:                 return testcase_1
    1:         m.Foo = Foo
       
    1:         loader = unittest.TestLoader()
    1:         suite = loader.loadTestsFromNames(['Foo.foo'], m)
    1:         self.assertIsInstance(suite, loader.suiteClass)
       
    1:         ref_suite = unittest.TestSuite([testcase_1])
    1:         self.assertEqual(list(suite), [ref_suite])
       
           # "The specifier name is a ``dotted name'' that may resolve ... to
           # ... a callable object which returns a TestCase or TestSuite instance"
           #
           # What happens when the callable returns something else?
    1:     def test_loadTestsFromNames__callable__wrong_type(self):
    1:         m = types.ModuleType('m')
    1:         def return_wrong():
    1:             return 6
    1:         m.return_wrong = return_wrong
       
    1:         loader = unittest.TestLoader()
    1:         try:
    1:             loader.loadTestsFromNames(['return_wrong'], m)
    1:         except TypeError:
    1:             pass
               else:
>>>>>>             self.fail("TestLoader.loadTestsFromNames failed to raise TypeError")
       
           # "The specifier can refer to modules and packages which have not been
           # imported; they will be imported as a side-effect"
    1:     def test_loadTestsFromNames__module_not_loaded(self):
               # We're going to try to load this module as a side-effect, so it
               # better not be loaded before we try.
               #
    1:         module_name = 'unittest.test.dummy'
    1:         sys.modules.pop(module_name, None)
       
    1:         loader = unittest.TestLoader()
    1:         try:
    1:             suite = loader.loadTestsFromNames([module_name])
       
    1:             self.assertIsInstance(suite, loader.suiteClass)
    1:             self.assertEqual(list(suite), [unittest.TestSuite()])
       
                   # module should now be loaded, thanks to loadTestsFromName()
    1:             self.assertIn(module_name, sys.modules)
               finally:
    1:             if module_name in sys.modules:
    1:                 del sys.modules[module_name]
       
           ################################################################
           ### /Tests for TestLoader.loadTestsFromNames()
       
           ### Tests for TestLoader.getTestCaseNames()
           ################################################################
       
           # "Return a sorted sequence of method names found within testCaseClass"
           #
           # Test.foobar is defined to make sure getTestCaseNames() respects
           # loader.testMethodPrefix
    1:     def test_getTestCaseNames(self):
    2:         class Test(unittest.TestCase):
    1:             def test_1(self): pass
    1:             def test_2(self): pass
    1:             def foobar(self): pass
       
    1:         loader = unittest.TestLoader()
       
    1:         self.assertEqual(loader.getTestCaseNames(Test), ['test_1', 'test_2'])
       
           # "Return a sorted sequence of method names found within testCaseClass"
           #
           # Does getTestCaseNames() behave appropriately if no tests are found?
    1:     def test_getTestCaseNames__no_tests(self):
    2:         class Test(unittest.TestCase):
    1:             def foobar(self): pass
       
    1:         loader = unittest.TestLoader()
       
    1:         self.assertEqual(loader.getTestCaseNames(Test), [])
       
           # "Return a sorted sequence of method names found within testCaseClass"
           #
           # Are not-TestCases handled gracefully?
           #
           # XXX This should raise a TypeError, not return a list
           #
           # XXX It's too late in the 2.5 release cycle to fix this, but it should
           # probably be revisited for 2.6
    1:     def test_getTestCaseNames__not_a_TestCase(self):
    2:         class BadCase(int):
    1:             def test_foo(self):
>>>>>>                 pass
       
    1:         loader = unittest.TestLoader()
    1:         names = loader.getTestCaseNames(BadCase)
       
    1:         self.assertEqual(names, ['test_foo'])
       
           # "Return a sorted sequence of method names found within testCaseClass"
           #
           # Make sure inherited names are handled.
           #
           # TestP.foobar is defined to make sure getTestCaseNames() respects
           # loader.testMethodPrefix
    1:     def test_getTestCaseNames__inheritance(self):
    2:         class TestP(unittest.TestCase):
    1:             def test_1(self): pass
    1:             def test_2(self): pass
    1:             def foobar(self): pass
       
    2:         class TestC(TestP):
    1:             def test_1(self): pass
    1:             def test_3(self): pass
       
    1:         loader = unittest.TestLoader()
       
    1:         names = ['test_1', 'test_2', 'test_3']
    1:         self.assertEqual(loader.getTestCaseNames(TestC), names)
       
           ################################################################
           ### /Tests for TestLoader.getTestCaseNames()
       
           ### Tests for TestLoader.testMethodPrefix
           ################################################################
       
           # "String giving the prefix of method names which will be interpreted as
           # test methods"
           #
           # Implicit in the documentation is that testMethodPrefix is respected by
           # all loadTestsFrom* methods.
    1:     def test_testMethodPrefix__loadTestsFromTestCase(self):
    2:         class Foo(unittest.TestCase):
    1:             def test_1(self): pass
    1:             def test_2(self): pass
    1:             def foo_bar(self): pass
       
    1:         tests_1 = unittest.TestSuite([Foo('foo_bar')])
    1:         tests_2 = unittest.TestSuite([Foo('test_1'), Foo('test_2')])
       
    1:         loader = unittest.TestLoader()
    1:         loader.testMethodPrefix = 'foo'
    1:         self.assertEqual(loader.loadTestsFromTestCase(Foo), tests_1)
       
    1:         loader.testMethodPrefix = 'test'
    1:         self.assertEqual(loader.loadTestsFromTestCase(Foo), tests_2)
       
           # "String giving the prefix of method names which will be interpreted as
           # test methods"
           #
           # Implicit in the documentation is that testMethodPrefix is respected by
           # all loadTestsFrom* methods.
    1:     def test_testMethodPrefix__loadTestsFromModule(self):
    1:         m = types.ModuleType('m')
    2:         class Foo(unittest.TestCase):
    1:             def test_1(self): pass
    1:             def test_2(self): pass
    1:             def foo_bar(self): pass
    1:         m.Foo = Foo
       
    1:         tests_1 = [unittest.TestSuite([Foo('foo_bar')])]
    1:         tests_2 = [unittest.TestSuite([Foo('test_1'), Foo('test_2')])]
       
    1:         loader = unittest.TestLoader()
    1:         loader.testMethodPrefix = 'foo'
    1:         self.assertEqual(list(loader.loadTestsFromModule(m)), tests_1)
       
    1:         loader.testMethodPrefix = 'test'
    1:         self.assertEqual(list(loader.loadTestsFromModule(m)), tests_2)
       
           # "String giving the prefix of method names which will be interpreted as
           # test methods"
           #
           # Implicit in the documentation is that testMethodPrefix is respected by
           # all loadTestsFrom* methods.
    1:     def test_testMethodPrefix__loadTestsFromName(self):
    1:         m = types.ModuleType('m')
    2:         class Foo(unittest.TestCase):
    1:             def test_1(self): pass
    1:             def test_2(self): pass
    1:             def foo_bar(self): pass
    1:         m.Foo = Foo
       
    1:         tests_1 = unittest.TestSuite([Foo('foo_bar')])
    1:         tests_2 = unittest.TestSuite([Foo('test_1'), Foo('test_2')])
       
    1:         loader = unittest.TestLoader()
    1:         loader.testMethodPrefix = 'foo'
    1:         self.assertEqual(loader.loadTestsFromName('Foo', m), tests_1)
       
    1:         loader.testMethodPrefix = 'test'
    1:         self.assertEqual(loader.loadTestsFromName('Foo', m), tests_2)
       
           # "String giving the prefix of method names which will be interpreted as
           # test methods"
           #
           # Implicit in the documentation is that testMethodPrefix is respected by
           # all loadTestsFrom* methods.
    1:     def test_testMethodPrefix__loadTestsFromNames(self):
    1:         m = types.ModuleType('m')
    2:         class Foo(unittest.TestCase):
    1:             def test_1(self): pass
    1:             def test_2(self): pass
    1:             def foo_bar(self): pass
    1:         m.Foo = Foo
       
    1:         tests_1 = unittest.TestSuite([unittest.TestSuite([Foo('foo_bar')])])
    1:         tests_2 = unittest.TestSuite([Foo('test_1'), Foo('test_2')])
    1:         tests_2 = unittest.TestSuite([tests_2])
       
    1:         loader = unittest.TestLoader()
    1:         loader.testMethodPrefix = 'foo'
    1:         self.assertEqual(loader.loadTestsFromNames(['Foo'], m), tests_1)
       
    1:         loader.testMethodPrefix = 'test'
    1:         self.assertEqual(loader.loadTestsFromNames(['Foo'], m), tests_2)
       
           # "The default value is 'test'"
    1:     def test_testMethodPrefix__default_value(self):
    1:         loader = unittest.TestLoader()
    1:         self.assertTrue(loader.testMethodPrefix == 'test')
       
           ################################################################
           ### /Tests for TestLoader.testMethodPrefix
       
           ### Tests for TestLoader.sortTestMethodsUsing
           ################################################################
       
           # "Function to be used to compare method names when sorting them in
           # getTestCaseNames() and all the loadTestsFromX() methods"
    1:     def test_sortTestMethodsUsing__loadTestsFromTestCase(self):
    1:         def reversed_cmp(x, y):
    1:             return -cmp(x, y)
       
    2:         class Foo(unittest.TestCase):
    1:             def test_1(self): pass
    1:             def test_2(self): pass
       
    1:         loader = unittest.TestLoader()
    1:         loader.sortTestMethodsUsing = reversed_cmp
       
    1:         tests = loader.suiteClass([Foo('test_2'), Foo('test_1')])
    1:         self.assertEqual(loader.loadTestsFromTestCase(Foo), tests)
       
           # "Function to be used to compare method names when sorting them in
           # getTestCaseNames() and all the loadTestsFromX() methods"
    1:     def test_sortTestMethodsUsing__loadTestsFromModule(self):
    1:         def reversed_cmp(x, y):
    1:             return -cmp(x, y)
       
    1:         m = types.ModuleType('m')
    2:         class Foo(unittest.TestCase):
    1:             def test_1(self): pass
    1:             def test_2(self): pass
    1:         m.Foo = Foo
       
    1:         loader = unittest.TestLoader()
    1:         loader.sortTestMethodsUsing = reversed_cmp
       
    1:         tests = [loader.suiteClass([Foo('test_2'), Foo('test_1')])]
    1:         self.assertEqual(list(loader.loadTestsFromModule(m)), tests)
       
           # "Function to be used to compare method names when sorting them in
           # getTestCaseNames() and all the loadTestsFromX() methods"
    1:     def test_sortTestMethodsUsing__loadTestsFromName(self):
    1:         def reversed_cmp(x, y):
    1:             return -cmp(x, y)
       
    1:         m = types.ModuleType('m')
    2:         class Foo(unittest.TestCase):
    1:             def test_1(self): pass
    1:             def test_2(self): pass
    1:         m.Foo = Foo
       
    1:         loader = unittest.TestLoader()
    1:         loader.sortTestMethodsUsing = reversed_cmp
       
    1:         tests = loader.suiteClass([Foo('test_2'), Foo('test_1')])
    1:         self.assertEqual(loader.loadTestsFromName('Foo', m), tests)
       
           # "Function to be used to compare method names when sorting them in
           # getTestCaseNames() and all the loadTestsFromX() methods"
    1:     def test_sortTestMethodsUsing__loadTestsFromNames(self):
    1:         def reversed_cmp(x, y):
    1:             return -cmp(x, y)
       
    1:         m = types.ModuleType('m')
    2:         class Foo(unittest.TestCase):
    1:             def test_1(self): pass
    1:             def test_2(self): pass
    1:         m.Foo = Foo
       
    1:         loader = unittest.TestLoader()
    1:         loader.sortTestMethodsUsing = reversed_cmp
       
    1:         tests = [loader.suiteClass([Foo('test_2'), Foo('test_1')])]
    1:         self.assertEqual(list(loader.loadTestsFromNames(['Foo'], m)), tests)
       
           # "Function to be used to compare method names when sorting them in
           # getTestCaseNames()"
           #
           # Does it actually affect getTestCaseNames()?
    1:     def test_sortTestMethodsUsing__getTestCaseNames(self):
    1:         def reversed_cmp(x, y):
    1:             return -cmp(x, y)
       
    2:         class Foo(unittest.TestCase):
    1:             def test_1(self): pass
    1:             def test_2(self): pass
       
    1:         loader = unittest.TestLoader()
    1:         loader.sortTestMethodsUsing = reversed_cmp
       
    1:         test_names = ['test_2', 'test_1']
    1:         self.assertEqual(loader.getTestCaseNames(Foo), test_names)
       
           # "The default value is the built-in cmp() function"
    1:     def test_sortTestMethodsUsing__default_value(self):
    1:         loader = unittest.TestLoader()
    1:         self.assertTrue(loader.sortTestMethodsUsing is cmp)
       
           # "it can be set to None to disable the sort."
           #
           # XXX How is this different from reassigning cmp? Are the tests returned
           # in a random order or something? This behaviour should die
    1:     def test_sortTestMethodsUsing__None(self):
    2:         class Foo(unittest.TestCase):
    1:             def test_1(self): pass
    1:             def test_2(self): pass
       
    1:         loader = unittest.TestLoader()
    1:         loader.sortTestMethodsUsing = None
       
    1:         test_names = ['test_2', 'test_1']
    1:         self.assertEqual(set(loader.getTestCaseNames(Foo)), set(test_names))
       
           ################################################################
           ### /Tests for TestLoader.sortTestMethodsUsing
       
           ### Tests for TestLoader.suiteClass
           ################################################################
       
           # "Callable object that constructs a test suite from a list of tests."
    1:     def test_suiteClass__loadTestsFromTestCase(self):
    2:         class Foo(unittest.TestCase):
    1:             def test_1(self): pass
    1:             def test_2(self): pass
    1:             def foo_bar(self): pass
       
    1:         tests = [Foo('test_1'), Foo('test_2')]
       
    1:         loader = unittest.TestLoader()
    1:         loader.suiteClass = list
    1:         self.assertEqual(loader.loadTestsFromTestCase(Foo), tests)
       
           # It is implicit in the documentation for TestLoader.suiteClass that
           # all TestLoader.loadTestsFrom* methods respect it. Let's make sure
    1:     def test_suiteClass__loadTestsFromModule(self):
    1:         m = types.ModuleType('m')
    2:         class Foo(unittest.TestCase):
    1:             def test_1(self): pass
    1:             def test_2(self): pass
    1:             def foo_bar(self): pass
    1:         m.Foo = Foo
       
    1:         tests = [[Foo('test_1'), Foo('test_2')]]
       
    1:         loader = unittest.TestLoader()
    1:         loader.suiteClass = list
    1:         self.assertEqual(loader.loadTestsFromModule(m), tests)
       
           # It is implicit in the documentation for TestLoader.suiteClass that
           # all TestLoader.loadTestsFrom* methods respect it. Let's make sure
    1:     def test_suiteClass__loadTestsFromName(self):
    1:         m = types.ModuleType('m')
    2:         class Foo(unittest.TestCase):
    1:             def test_1(self): pass
    1:             def test_2(self): pass
    1:             def foo_bar(self): pass
    1:         m.Foo = Foo
       
    1:         tests = [Foo('test_1'), Foo('test_2')]
       
    1:         loader = unittest.TestLoader()
    1:         loader.suiteClass = list
    1:         self.assertEqual(loader.loadTestsFromName('Foo', m), tests)
       
           # It is implicit in the documentation for TestLoader.suiteClass that
           # all TestLoader.loadTestsFrom* methods respect it. Let's make sure
    1:     def test_suiteClass__loadTestsFromNames(self):
    1:         m = types.ModuleType('m')
    2:         class Foo(unittest.TestCase):
    1:             def test_1(self): pass
    1:             def test_2(self): pass
    1:             def foo_bar(self): pass
    1:         m.Foo = Foo
       
    1:         tests = [[Foo('test_1'), Foo('test_2')]]
       
    1:         loader = unittest.TestLoader()
    1:         loader.suiteClass = list
    1:         self.assertEqual(loader.loadTestsFromNames(['Foo'], m), tests)
       
           # "The default value is the TestSuite class"
    1:     def test_suiteClass__default_value(self):
    1:         loader = unittest.TestLoader()
    1:         self.assertIs(loader.suiteClass, unittest.TestSuite)
       
           # Make sure the dotted name resolution works even if the actual
           # function doesn't have the same name as is used to find it.
    1:     def test_loadTestsFromName__function_with_different_name_than_method(self):
               # lambdas have the name '<lambda>'.
    1:         m = types.ModuleType('m')
    2:         class MyTestCase(unittest.TestCase):
    1:             test = lambda: 1
    1:         m.testcase_1 = MyTestCase
       
    1:         loader = unittest.TestLoader()
    1:         suite = loader.loadTestsFromNames(['testcase_1.test'], m)
    1:         self.assertIsInstance(suite, loader.suiteClass)
       
    1:         ref_suite = unittest.TestSuite([MyTestCase('test')])
    1:         self.assertEqual(list(suite), [ref_suite])
       
    1: if __name__ == '__main__':
>>>>>>     unittest.main()
