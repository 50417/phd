    1: """A parser for XML, using the derived class as static DTD."""
       
       # Author: Sjoerd Mullender.
       
    1: import re
    1: import string
       
    1: import warnings
    1: warnings.warn("The xmllib module is obsolete.  Use xml.sax instead.",
    1:               DeprecationWarning, 2)
    1: del warnings
       
    1: version = '0.3'
       
    2: class Error(RuntimeError):
    1:     pass
       
       # Regular expressions used for parsing
       
    1: _S = '[ \t\r\n]+'                       # white space
    1: _opS = '[ \t\r\n]*'                     # optional white space
    1: _Name = '[a-zA-Z_:][-a-zA-Z0-9._:]*'    # valid XML name
    1: _QStr = "(?:'[^']*'|\"[^\"]*\")"        # quoted XML string
    1: illegal = re.compile('[^\t\r\n -\176\240-\377]') # illegal chars in content
    1: interesting = re.compile('[]&<]')
       
    1: amp = re.compile('&')
    1: ref = re.compile('&(' + _Name + '|#[0-9]+|#x[0-9a-fA-F]+)[^-a-zA-Z0-9._:]')
    1: entityref = re.compile('&(?P<name>' + _Name + ')[^-a-zA-Z0-9._:]')
    1: charref = re.compile('&#(?P<char>[0-9]+[^0-9]|x[0-9a-fA-F]+[^0-9a-fA-F])')
    1: space = re.compile(_S + '$')
    1: newline = re.compile('\n')
       
    1: attrfind = re.compile(
           _S + '(?P<name>' + _Name + ')'
           '(' + _opS + '=' + _opS +
    1:     '(?P<value>'+_QStr+'|[-a-zA-Z0-9.:+*%?!\(\)_#=~]+))?')
    1: starttagopen = re.compile('<' + _Name)
    1: starttagend = re.compile(_opS + '(?P<slash>/?)>')
    1: starttagmatch = re.compile('<(?P<tagname>'+_Name+')'
    1:                       '(?P<attrs>(?:'+attrfind.pattern+')*)'+
    1:                       starttagend.pattern)
    1: endtagopen = re.compile('</')
    1: endbracket = re.compile(_opS + '>')
    1: endbracketfind = re.compile('(?:[^>\'"]|'+_QStr+')*>')
    1: tagfind = re.compile(_Name)
    1: cdataopen = re.compile(r'<!\[CDATA\[')
    1: cdataclose = re.compile(r'\]\]>')
       # this matches one of the following:
       # SYSTEM SystemLiteral
       # PUBLIC PubidLiteral SystemLiteral
    1: _SystemLiteral = '(?P<%s>'+_QStr+')'
    1: _PublicLiteral = '(?P<%s>"[-\'\(\)+,./:=?;!*#@$_%% \n\ra-zA-Z0-9]*"|' \
                               "'[-\(\)+,./:=?;!*#@$_%% \n\ra-zA-Z0-9]*')"
       _ExternalId = '(?:SYSTEM|' \
                        'PUBLIC'+_S+_PublicLiteral%'pubid'+ \
    1:               ')'+_S+_SystemLiteral%'syslit'
    1: doctype = re.compile('<!DOCTYPE'+_S+'(?P<name>'+_Name+')'
    1:                      '(?:'+_S+_ExternalId+')?'+_opS)
    1: xmldecl = re.compile('<\?xml'+_S+
                            'version'+_opS+'='+_opS+'(?P<version>'+_QStr+')'+
                            '(?:'+_S+'encoding'+_opS+'='+_opS+
                               "(?P<encoding>'[A-Za-z][-A-Za-z0-9._]*'|"
                               '"[A-Za-z][-A-Za-z0-9._]*"))?'
                            '(?:'+_S+'standalone'+_opS+'='+_opS+
                               '(?P<standalone>\'(?:yes|no)\'|"(?:yes|no)"))?'+
    1:                      _opS+'\?>')
    1: procopen = re.compile(r'<\?(?P<proc>' + _Name + ')' + _opS)
    1: procclose = re.compile(_opS + r'\?>')
    1: commentopen = re.compile('<!--')
    1: commentclose = re.compile('-->')
    1: doubledash = re.compile('--')
    1: attrtrans = string.maketrans(' \r\n\t', '    ')
       
       # definitions for XML namespaces
    1: _NCName = '[a-zA-Z_][-a-zA-Z0-9._]*'    # XML Name, minus the ":"
    1: ncname = re.compile(_NCName + '$')
    1: qname = re.compile('(?:(?P<prefix>' + _NCName + '):)?' # optional prefix
    1:                    '(?P<local>' + _NCName + ')$')
       
    1: xmlns = re.compile('xmlns(?::(?P<ncname>'+_NCName+'))?$')
       
       # XML parser base class -- find tags and call handler functions.
       # Usage: p = XMLParser(); p.feed(data); ...; p.close().
       # The dtd is defined by deriving a class which defines methods with
       # special names to handle tags: start_foo and end_foo to handle <foo>
       # and </foo>, respectively.  The data between tags is passed to the
       # parser by calling self.handle_data() with some data as argument (the
       # data may be split up in arbitrary chunks).
       
    2: class XMLParser:
    1:     attributes = {}                     # default, to be overridden
    1:     elements = {}                       # default, to be overridden
       
           # parsing options, settable using keyword args in __init__
    1:     __accept_unquoted_attributes = 0
    1:     __accept_missing_endtag_name = 0
    1:     __map_case = 0
    1:     __accept_utf8 = 0
    1:     __translate_attribute_references = 1
       
           # Interface -- initialize and reset this instance
    1:     def __init__(self, **kw):
    2:         self.__fixed = 0
    2:         if 'accept_unquoted_attributes' in kw:
>>>>>>             self.__accept_unquoted_attributes = kw['accept_unquoted_attributes']
    2:         if 'accept_missing_endtag_name' in kw:
>>>>>>             self.__accept_missing_endtag_name = kw['accept_missing_endtag_name']
    2:         if 'map_case' in kw:
>>>>>>             self.__map_case = kw['map_case']
    2:         if 'accept_utf8' in kw:
>>>>>>             self.__accept_utf8 = kw['accept_utf8']
    2:         if 'translate_attribute_references' in kw:
>>>>>>             self.__translate_attribute_references = kw['translate_attribute_references']
    2:         self.reset()
       
    1:     def __fixelements(self):
    2:         self.__fixed = 1
    2:         self.elements = {}
    2:         self.__fixdict(self.__dict__)
    2:         self.__fixclass(self.__class__)
       
    1:     def __fixclass(self, kl):
    3:         self.__fixdict(kl.__dict__)
    4:         for k in kl.__bases__:
    1:             self.__fixclass(k)
       
    1:     def __fixdict(self, dict):
  124:         for key in dict.keys():
  119:             if key[:6] == 'start_':
>>>>>>                 tag = key[6:]
>>>>>>                 start, end = self.elements.get(tag, (None, None))
>>>>>>                 if start is None:
>>>>>>                     self.elements[tag] = getattr(self, key), end
  119:             elif key[:4] == 'end_':
>>>>>>                 tag = key[4:]
>>>>>>                 start, end = self.elements.get(tag, (None, None))
>>>>>>                 if end is None:
>>>>>>                     self.elements[tag] = start, getattr(self, key)
       
           # Interface -- reset this instance.  Loses all unprocessed data
    1:     def reset(self):
    2:         self.rawdata = ''
    2:         self.stack = []
    2:         self.nomoretags = 0
    2:         self.literal = 0
    2:         self.lineno = 1
    2:         self.__at_start = 1
    2:         self.__seen_doctype = None
    2:         self.__seen_starttag = 0
    2:         self.__use_namespaces = 0
    2:         self.__namespaces = {'xml':None}   # xml is implicitly declared
               # backward compatibility hack: if elements not overridden,
               # fill it in ourselves
    2:         if self.elements is XMLParser.elements:
    2:             self.__fixelements()
       
           # For derived classes only -- enter literal mode (CDATA) till EOF
    1:     def setnomoretags(self):
>>>>>>         self.nomoretags = self.literal = 1
       
           # For derived classes only -- enter literal mode (CDATA)
    1:     def setliteral(self, *args):
>>>>>>         self.literal = 1
       
           # Interface -- feed some data to the parser.  Call this as
           # often as you want, with as little or as much text as you
           # want (may include '\n').  (This just saves the text, all the
           # processing is done by goahead().)
    1:     def feed(self, data):
  330:         self.rawdata = self.rawdata + data
  330:         self.goahead(0)
       
           # Interface -- handle the remaining data
    1:     def close(self):
    2:         self.goahead(1)
    2:         if self.__fixed:
    2:             self.__fixed = 0
                   # remove self.elements so that we don't leak
    2:             del self.elements
       
           # Interface -- translate references
    1:     def translate_references(self, data, all = 1):
    1:         if not self.__translate_attribute_references:
>>>>>>             return data
    1:         i = 0
    1:         while 1:
    1:             res = amp.search(data, i)
    1:             if res is None:
    1:                 return data
>>>>>>             s = res.start(0)
>>>>>>             res = ref.match(data, s)
>>>>>>             if res is None:
>>>>>>                 self.syntax_error("bogus `&'")
>>>>>>                 i = s+1
>>>>>>                 continue
>>>>>>             i = res.end(0)
>>>>>>             str = res.group(1)
>>>>>>             rescan = 0
>>>>>>             if str[0] == '#':
>>>>>>                 if str[1] == 'x':
>>>>>>                     str = chr(int(str[2:], 16))
                       else:
>>>>>>                     str = chr(int(str[1:]))
>>>>>>                 if data[i - 1] != ';':
>>>>>>                     self.syntax_error("`;' missing after char reference")
>>>>>>                     i = i-1
>>>>>>             elif all:
>>>>>>                 if str in self.entitydefs:
>>>>>>                     str = self.entitydefs[str]
>>>>>>                     rescan = 1
>>>>>>                 elif data[i - 1] != ';':
>>>>>>                     self.syntax_error("bogus `&'")
>>>>>>                     i = s + 1 # just past the &
>>>>>>                     continue
                       else:
>>>>>>                     self.syntax_error("reference to unknown entity `&%s;'" % str)
>>>>>>                     str = '&' + str + ';'
>>>>>>             elif data[i - 1] != ';':
>>>>>>                 self.syntax_error("bogus `&'")
>>>>>>                 i = s + 1 # just past the &
>>>>>>                 continue
       
                   # when we get here, str contains the translated text and i points
                   # to the end of the string that is to be replaced
>>>>>>             data = data[:s] + str + data[i:]
>>>>>>             if rescan:
>>>>>>                 i = s
                   else:
>>>>>>                 i = s + len(str)
       
           # Interface - return a dictionary of all namespaces currently valid
    1:     def getnamespace(self):
>>>>>>         nsdict = {}
>>>>>>         for t, d, nst in self.stack:
>>>>>>             nsdict.update(d)
>>>>>>         return nsdict
       
           # Internal -- handle data as far as reasonable.  May leave state
           # and data to be processed by a subsequent call.  If 'end' is
           # true, force handling all data as if followed by EOF marker.
    1:     def goahead(self, end):
  332:         rawdata = self.rawdata
  332:         i = 0
  332:         n = len(rawdata)
  339:         while i < n:
  330:             if i > 0:
>>>>>>                 self.__at_start = 0
  330:             if self.nomoretags:
>>>>>>                 data = rawdata[i:n]
>>>>>>                 self.handle_data(data)
>>>>>>                 self.lineno = self.lineno + data.count('\n')
>>>>>>                 i = n
>>>>>>                 break
  330:             res = interesting.search(rawdata, i)
  330:             if res:
  312:                 j = res.start(0)
                   else:
   18:                 j = n
  330:             if i < j:
   18:                 data = rawdata[i:j]
   18:                 if self.__at_start and space.match(data) is None:
>>>>>>                     self.syntax_error('illegal data at start of file')
   18:                 self.__at_start = 0
   18:                 if not self.stack and space.match(data) is None:
>>>>>>                     self.syntax_error('data not in content')
   18:                 if not self.__accept_utf8 and illegal.search(data):
>>>>>>                     self.syntax_error('illegal character in content')
   18:                 self.handle_data(data)
   18:                 self.lineno = self.lineno + data.count('\n')
  330:             i = j
  330:             if i == n: break
  312:             if rawdata[i] == '<':
  312:                 if starttagopen.match(rawdata, i):
   10:                     if self.literal:
>>>>>>                         data = rawdata[i]
>>>>>>                         self.handle_data(data)
>>>>>>                         self.lineno = self.lineno + data.count('\n')
>>>>>>                         i = i+1
>>>>>>                         continue
   10:                     k = self.parse_starttag(i)
   10:                     if k < 0: break
    2:                     self.__seen_starttag = 1
    2:                     self.lineno = self.lineno + rawdata[i:k].count('\n')
    2:                     i = k
    2:                     continue
  302:                 if endtagopen.match(rawdata, i):
   10:                     k = self.parse_endtag(i)
   10:                     if k < 0: break
    1:                     self.lineno = self.lineno + rawdata[i:k].count('\n')
    1:                     i =  k
    1:                     continue
  292:                 if commentopen.match(rawdata, i):
  105:                     if self.literal:
>>>>>>                         data = rawdata[i]
>>>>>>                         self.handle_data(data)
>>>>>>                         self.lineno = self.lineno + data.count('\n')
>>>>>>                         i = i+1
>>>>>>                         continue
  105:                     k = self.parse_comment(i)
  105:                     if k < 0: break
    1:                     self.lineno = self.lineno + rawdata[i:k].count('\n')
    1:                     i = k
    1:                     continue
  187:                 if cdataopen.match(rawdata, i):
>>>>>>                     k = self.parse_cdata(i)
>>>>>>                     if k < 0: break
>>>>>>                     self.lineno = self.lineno + rawdata[i:k].count('\n')
>>>>>>                     i = k
>>>>>>                     continue
  187:                 res = xmldecl.match(rawdata, i)
  187:                 if res:
    1:                     if not self.__at_start:
>>>>>>                         self.syntax_error("<?xml?> declaration not at start of document")
    1:                     version, encoding, standalone = res.group('version',
    1:                                                               'encoding',
    1:                                                               'standalone')
    1:                     if version[1:-1] != '1.0':
>>>>>>                         raise Error('only XML version 1.0 supported')
    1:                     if encoding: encoding = encoding[1:-1]
    1:                     if standalone: standalone = standalone[1:-1]
    1:                     self.handle_xml(encoding, standalone)
    1:                     i = res.end(0)
    1:                     continue
  186:                 res = procopen.match(rawdata, i)
  186:                 if res:
  122:                     k = self.parse_proc(i)
  122:                     if k < 0: break
    1:                     self.lineno = self.lineno + rawdata[i:k].count('\n')
    1:                     i = k
    1:                     continue
   64:                 res = doctype.match(rawdata, i)
   64:                 if res:
   45:                     if self.literal:
>>>>>>                         data = rawdata[i]
>>>>>>                         self.handle_data(data)
>>>>>>                         self.lineno = self.lineno + data.count('\n')
>>>>>>                         i = i+1
>>>>>>                         continue
   45:                     if self.__seen_doctype:
>>>>>>                         self.syntax_error('multiple DOCTYPE elements')
   45:                     if self.__seen_starttag:
>>>>>>                         self.syntax_error('DOCTYPE not at beginning of document')
   45:                     k = self.parse_doctype(res)
   45:                     if k < 0: break
    1:                     self.__seen_doctype = res.group('name')
    1:                     if self.__map_case:
>>>>>>                         self.__seen_doctype = self.__seen_doctype.lower()
    1:                     self.lineno = self.lineno + rawdata[i:k].count('\n')
    1:                     i = k
    1:                     continue
>>>>>>             elif rawdata[i] == '&':
>>>>>>                 if self.literal:
>>>>>>                     data = rawdata[i]
>>>>>>                     self.handle_data(data)
>>>>>>                     i = i+1
>>>>>>                     continue
>>>>>>                 res = charref.match(rawdata, i)
>>>>>>                 if res is not None:
>>>>>>                     i = res.end(0)
>>>>>>                     if rawdata[i-1] != ';':
>>>>>>                         self.syntax_error("`;' missing in charref")
>>>>>>                         i = i-1
>>>>>>                     if not self.stack:
>>>>>>                         self.syntax_error('data not in content')
>>>>>>                     self.handle_charref(res.group('char')[:-1])
>>>>>>                     self.lineno = self.lineno + res.group(0).count('\n')
>>>>>>                     continue
>>>>>>                 res = entityref.match(rawdata, i)
>>>>>>                 if res is not None:
>>>>>>                     i = res.end(0)
>>>>>>                     if rawdata[i-1] != ';':
>>>>>>                         self.syntax_error("`;' missing in entityref")
>>>>>>                         i = i-1
>>>>>>                     name = res.group('name')
>>>>>>                     if self.__map_case:
>>>>>>                         name = name.lower()
>>>>>>                     if name in self.entitydefs:
>>>>>>                         self.rawdata = rawdata = rawdata[:res.start(0)] + self.entitydefs[name] + rawdata[i:]
>>>>>>                         n = len(rawdata)
>>>>>>                         i = res.start(0)
                           else:
>>>>>>                         self.unknown_entityref(name)
>>>>>>                     self.lineno = self.lineno + res.group(0).count('\n')
>>>>>>                     continue
>>>>>>             elif rawdata[i] == ']':
>>>>>>                 if self.literal:
>>>>>>                     data = rawdata[i]
>>>>>>                     self.handle_data(data)
>>>>>>                     i = i+1
>>>>>>                     continue
>>>>>>                 if n-i < 3:
>>>>>>                     break
>>>>>>                 if cdataclose.match(rawdata, i):
>>>>>>                     self.syntax_error("bogus `]]>'")
>>>>>>                 self.handle_data(rawdata[i])
>>>>>>                 i = i+1
>>>>>>                 continue
                   else:
>>>>>>                 raise Error('neither < nor & ??')
                   # We get here only if incomplete matches but
                   # nothing else
   19:             break
               # end while
  332:         if i > 0:
   25:             self.__at_start = 0
  332:         if end and i < n:
>>>>>>             data = rawdata[i]
>>>>>>             self.syntax_error("bogus `%s'" % data)
>>>>>>             if not self.__accept_utf8 and illegal.search(data):
>>>>>>                 self.syntax_error('illegal character in content')
>>>>>>             self.handle_data(data)
>>>>>>             self.lineno = self.lineno + data.count('\n')
>>>>>>             self.rawdata = rawdata[i+1:]
>>>>>>             return self.goahead(end)
  332:         self.rawdata = rawdata[i:]
  332:         if end:
    2:             if not self.__seen_starttag:
>>>>>>                 self.syntax_error('no elements in file')
    2:             if self.stack:
>>>>>>                 self.syntax_error('missing end tags')
>>>>>>                 while self.stack:
>>>>>>                     self.finish_endtag(self.stack[-1][0])
       
           # Internal -- parse comment, return length or -1 if not terminated
    1:     def parse_comment(self, i):
  105:         rawdata = self.rawdata
  105:         if rawdata[i:i+4] != '<!--':
>>>>>>             raise Error('unexpected call to handle_comment')
  105:         res = commentclose.search(rawdata, i+4)
  105:         if res is None:
  104:             return -1
    1:         if doubledash.search(rawdata, i+4, res.start(0)):
>>>>>>             self.syntax_error("`--' inside comment")
    1:         if rawdata[res.start(0)-1] == '-':
>>>>>>             self.syntax_error('comment cannot end in three dashes')
    1:         if not self.__accept_utf8 and \
    1:            illegal.search(rawdata, i+4, res.start(0)):
>>>>>>             self.syntax_error('illegal character in comment')
    1:         self.handle_comment(rawdata[i+4: res.start(0)])
    1:         return res.end(0)
       
           # Internal -- handle DOCTYPE tag, return length or -1 if not terminated
    1:     def parse_doctype(self, res):
   45:         rawdata = self.rawdata
   45:         n = len(rawdata)
   45:         name = res.group('name')
   45:         if self.__map_case:
>>>>>>             name = name.lower()
   45:         pubid, syslit = res.group('pubid', 'syslit')
   45:         if pubid is not None:
>>>>>>             pubid = pubid[1:-1]         # remove quotes
>>>>>>             pubid = ' '.join(pubid.split()) # normalize
   45:         if syslit is not None: syslit = syslit[1:-1] # remove quotes
   45:         j = k = res.end(0)
   45:         if k >= n:
    9:             return -1
   36:         if rawdata[k] == '[':
   36:             level = 0
   36:             k = k+1
   36:             dq = sq = 0
  663:             while k < n:
  629:                 c = rawdata[k]
  629:                 if not sq and c == '"':
>>>>>>                     dq = not dq
  629:                 elif not dq and c == "'":
>>>>>>                     sq = not sq
  629:                 elif sq or dq:
>>>>>>                     pass
  629:                 elif level <= 0 and c == ']':
    2:                     res = endbracket.match(rawdata, k+1)
    2:                     if res is None:
    1:                         return -1
    1:                     self.handle_doctype(name, pubid, syslit, rawdata[j+1:k])
    1:                     return res.end(0)
  627:                 elif c == '<':
   32:                     level = level + 1
  595:                 elif c == '>':
    4:                     level = level - 1
    4:                     if level < 0:
>>>>>>                         self.syntax_error("bogus `>' in DOCTYPE")
  627:                 k = k+1
   34:         res = endbracketfind.match(rawdata, k)
   34:         if res is None:
   34:             return -1
>>>>>>         if endbracket.match(rawdata, k) is None:
>>>>>>             self.syntax_error('garbage in DOCTYPE')
>>>>>>         self.handle_doctype(name, pubid, syslit, None)
>>>>>>         return res.end(0)
       
           # Internal -- handle CDATA tag, return length or -1 if not terminated
    1:     def parse_cdata(self, i):
>>>>>>         rawdata = self.rawdata
>>>>>>         if rawdata[i:i+9] != '<![CDATA[':
>>>>>>             raise Error('unexpected call to parse_cdata')
>>>>>>         res = cdataclose.search(rawdata, i+9)
>>>>>>         if res is None:
>>>>>>             return -1
>>>>>>         if not self.__accept_utf8 and \
>>>>>>            illegal.search(rawdata, i+9, res.start(0)):
>>>>>>             self.syntax_error('illegal character in CDATA')
>>>>>>         if not self.stack:
>>>>>>             self.syntax_error('CDATA not in content')
>>>>>>         self.handle_cdata(rawdata[i+9:res.start(0)])
>>>>>>         return res.end(0)
       
    1:     __xml_namespace_attributes = {'ns':None, 'src':None, 'prefix':None}
           # Internal -- handle a processing instruction tag
    1:     def parse_proc(self, i):
  122:         rawdata = self.rawdata
  122:         end = procclose.search(rawdata, i)
  122:         if end is None:
  121:             return -1
    1:         j = end.start(0)
    1:         if not self.__accept_utf8 and illegal.search(rawdata, i+2, j):
>>>>>>             self.syntax_error('illegal character in processing instruction')
    1:         res = tagfind.match(rawdata, i+2)
    1:         if res is None:
>>>>>>             raise Error('unexpected call to parse_proc')
    1:         k = res.end(0)
    1:         name = res.group(0)
    1:         if self.__map_case:
>>>>>>             name = name.lower()
    1:         if name == 'xml:namespace':
>>>>>>             self.syntax_error('old-fashioned namespace declaration')
>>>>>>             self.__use_namespaces = -1
                   # namespace declaration
                   # this must come after the <?xml?> declaration (if any)
                   # and before the <!DOCTYPE> (if any).
>>>>>>             if self.__seen_doctype or self.__seen_starttag:
>>>>>>                 self.syntax_error('xml:namespace declaration too late in document')
>>>>>>             attrdict, namespace, k = self.parse_attributes(name, k, j)
>>>>>>             if namespace:
>>>>>>                 self.syntax_error('namespace declaration inside namespace declaration')
>>>>>>             for attrname in attrdict.keys():
>>>>>>                 if not attrname in self.__xml_namespace_attributes:
>>>>>>                     self.syntax_error("unknown attribute `%s' in xml:namespace tag" % attrname)
>>>>>>             if not 'ns' in attrdict or not 'prefix' in attrdict:
>>>>>>                 self.syntax_error('xml:namespace without required attributes')
>>>>>>             prefix = attrdict.get('prefix')
>>>>>>             if ncname.match(prefix) is None:
>>>>>>                 self.syntax_error('xml:namespace illegal prefix value')
>>>>>>                 return end.end(0)
>>>>>>             if prefix in self.__namespaces:
>>>>>>                 self.syntax_error('xml:namespace prefix not unique')
>>>>>>             self.__namespaces[prefix] = attrdict['ns']
               else:
    1:             if name.lower() == 'xml':
>>>>>>                 self.syntax_error('illegal processing instruction target name')
    1:             self.handle_proc(name, rawdata[k:j])
    1:         return end.end(0)
       
           # Internal -- parse attributes between i and j
    1:     def parse_attributes(self, tag, i, j):
    2:         rawdata = self.rawdata
    2:         attrdict = {}
    2:         namespace = {}
    4:         while i < j:
    2:             res = attrfind.match(rawdata, i)
    2:             if res is None:
>>>>>>                 break
    2:             attrname, attrvalue = res.group('name', 'value')
    2:             if self.__map_case:
>>>>>>                 attrname = attrname.lower()
    2:             i = res.end(0)
    2:             if attrvalue is None:
>>>>>>                 self.syntax_error("no value specified for attribute `%s'" % attrname)
>>>>>>                 attrvalue = attrname
    2:             elif attrvalue[:1] == "'" == attrvalue[-1:] or \
>>>>>>                  attrvalue[:1] == '"' == attrvalue[-1:]:
    2:                 attrvalue = attrvalue[1:-1]
>>>>>>             elif not self.__accept_unquoted_attributes:
>>>>>>                 self.syntax_error("attribute `%s' value not quoted" % attrname)
    2:             res = xmlns.match(attrname)
    2:             if res is not None:
                       # namespace declaration
    1:                 ncname = res.group('ncname')
    1:                 namespace[ncname or ''] = attrvalue or None
    1:                 if not self.__use_namespaces:
    1:                     self.__use_namespaces = len(self.stack)+1
>>>>>>                 continue
    1:             if '<' in attrvalue:
>>>>>>                 self.syntax_error("`<' illegal in attribute value")
    1:             if attrname in attrdict:
>>>>>>                 self.syntax_error("attribute `%s' specified twice" % attrname)
    1:             attrvalue = attrvalue.translate(attrtrans)
    1:             attrdict[attrname] = self.translate_references(attrvalue)
    2:         return attrdict, namespace, i
       
           # Internal -- handle starttag, return length or -1 if not terminated
    1:     def parse_starttag(self, i):
   10:         rawdata = self.rawdata
               # i points to start of tag
   10:         end = endbracketfind.match(rawdata, i+1)
   10:         if end is None:
    8:             return -1
    2:         tag = starttagmatch.match(rawdata, i)
    2:         if tag is None or tag.end(0) != end.end(0):
>>>>>>             self.syntax_error('garbage in starttag')
>>>>>>             return end.end(0)
    2:         nstag = tagname = tag.group('tagname')
    2:         if self.__map_case:
>>>>>>             nstag = tagname = nstag.lower()
    2:         if not self.__seen_starttag and self.__seen_doctype and \
    1:            tagname != self.__seen_doctype:
>>>>>>             self.syntax_error('starttag does not match DOCTYPE')
    2:         if self.__seen_starttag and not self.stack:
>>>>>>             self.syntax_error('multiple elements on top level')
    2:         k, j = tag.span('attrs')
    2:         attrdict, nsdict, k = self.parse_attributes(tagname, k, j)
    2:         self.stack.append((tagname, nsdict, nstag))
    2:         if self.__use_namespaces:
    1:             res = qname.match(tagname)
               else:
    1:             res = None
    2:         if res is not None:
    1:             prefix, nstag = res.group('prefix', 'local')
    1:             if prefix is None:
    1:                 prefix = ''
    1:             ns = None
    2:             for t, d, nst in self.stack:
    1:                 if prefix in d:
    1:                     ns = d[prefix]
    1:             if ns is None and prefix != '':
>>>>>>                 ns = self.__namespaces.get(prefix)
    1:             if ns is not None:
    1:                 nstag = ns + ' ' + nstag
>>>>>>             elif prefix != '':
>>>>>>                 nstag = prefix + ':' + nstag # undo split
    1:             self.stack[-1] = tagname, nsdict, nstag
               # translate namespace of attributes
    2:         attrnamemap = {} # map from new name to old name (used for error reporting)
    3:         for key in attrdict.keys():
    1:             attrnamemap[key] = key
    2:         if self.__use_namespaces:
    1:             nattrdict = {}
    2:             for key, val in attrdict.items():
    1:                 okey = key
    1:                 res = qname.match(key)
    1:                 if res is not None:
    1:                     aprefix, key = res.group('prefix', 'local')
    1:                     if self.__map_case:
>>>>>>                         key = key.lower()
    1:                     if aprefix is not None:
>>>>>>                         ans = None
>>>>>>                         for t, d, nst in self.stack:
>>>>>>                             if aprefix in d:
>>>>>>                                 ans = d[aprefix]
>>>>>>                         if ans is None:
>>>>>>                             ans = self.__namespaces.get(aprefix)
>>>>>>                         if ans is not None:
>>>>>>                             key = ans + ' ' + key
                               else:
>>>>>>                             key = aprefix + ':' + key
    1:                 nattrdict[key] = val
    1:                 attrnamemap[key] = okey
    1:             attrdict = nattrdict
    2:         attributes = self.attributes.get(nstag)
    2:         if attributes is not None:
>>>>>>             for key in attrdict.keys():
>>>>>>                 if not key in attributes:
>>>>>>                     self.syntax_error("unknown attribute `%s' in tag `%s'" % (attrnamemap[key], tagname))
>>>>>>             for key, val in attributes.items():
>>>>>>                 if val is not None and not key in attrdict:
>>>>>>                     attrdict[key] = val
    2:         method = self.elements.get(nstag, (None, None))[0]
    2:         self.finish_starttag(nstag, attrdict, method)
    2:         if tag.group('slash') == '/':
    1:             self.finish_endtag(tagname)
    2:         return tag.end(0)
       
           # Internal -- parse endtag
    1:     def parse_endtag(self, i):
   10:         rawdata = self.rawdata
   10:         end = endbracketfind.match(rawdata, i+1)
   10:         if end is None:
    9:             return -1
    1:         res = tagfind.match(rawdata, i+2)
    1:         if res is None:
>>>>>>             if self.literal:
>>>>>>                 self.handle_data(rawdata[i])
>>>>>>                 return i+1
>>>>>>             if not self.__accept_missing_endtag_name:
>>>>>>                 self.syntax_error('no name specified in end tag')
>>>>>>             tag = self.stack[-1][0]
>>>>>>             k = i+2
               else:
    1:             tag = res.group(0)
    1:             if self.__map_case:
>>>>>>                 tag = tag.lower()
    1:             if self.literal:
>>>>>>                 if not self.stack or tag != self.stack[-1][0]:
>>>>>>                     self.handle_data(rawdata[i])
>>>>>>                     return i+1
    1:             k = res.end(0)
    1:         if endbracket.match(rawdata, k) is None:
>>>>>>             self.syntax_error('garbage in end tag')
    1:         self.finish_endtag(tag)
    1:         return end.end(0)
       
           # Internal -- finish processing of start tag
    1:     def finish_starttag(self, tagname, attrdict, method):
    2:         if method is not None:
>>>>>>             self.handle_starttag(tagname, method, attrdict)
               else:
    2:             self.unknown_starttag(tagname, attrdict)
       
           # Internal -- finish processing of end tag
    1:     def finish_endtag(self, tag):
    2:         self.literal = 0
    2:         if not tag:
>>>>>>             self.syntax_error('name-less end tag')
>>>>>>             found = len(self.stack) - 1
>>>>>>             if found < 0:
>>>>>>                 self.unknown_endtag(tag)
>>>>>>                 return
               else:
    2:             found = -1
    4:             for i in range(len(self.stack)):
    2:                 if tag == self.stack[i][0]:
    2:                     found = i
    2:             if found == -1:
>>>>>>                 self.syntax_error('unopened end tag')
>>>>>>                 return
    4:         while len(self.stack) > found:
    2:             if found < len(self.stack) - 1:
>>>>>>                 self.syntax_error('missing close tag for %s' % self.stack[-1][2])
    2:             nstag = self.stack[-1][2]
    2:             method = self.elements.get(nstag, (None, None))[1]
    2:             if method is not None:
>>>>>>                 self.handle_endtag(nstag, method)
                   else:
    2:                 self.unknown_endtag(nstag)
    2:             if self.__use_namespaces == len(self.stack):
    1:                 self.__use_namespaces = 0
    2:             del self.stack[-1]
       
           # Overridable -- handle xml processing instruction
    1:     def handle_xml(self, encoding, standalone):
    1:         pass
       
           # Overridable -- handle DOCTYPE
    1:     def handle_doctype(self, tag, pubid, syslit, data):
    1:         pass
       
           # Overridable -- handle start tag
    1:     def handle_starttag(self, tag, method, attrs):
>>>>>>         method(attrs)
       
           # Overridable -- handle end tag
    1:     def handle_endtag(self, tag, method):
>>>>>>         method()
       
           # Example -- handle character reference, no need to override
    1:     def handle_charref(self, name):
>>>>>>         try:
>>>>>>             if name[0] == 'x':
>>>>>>                 n = int(name[1:], 16)
                   else:
>>>>>>                 n = int(name)
>>>>>>         except ValueError:
>>>>>>             self.unknown_charref(name)
>>>>>>             return
>>>>>>         if not 0 <= n <= 255:
>>>>>>             self.unknown_charref(name)
>>>>>>             return
>>>>>>         self.handle_data(chr(n))
       
           # Definition of entities -- derived classes may override
    1:     entitydefs = {'lt': '&#60;',        # must use charref
    1:                   'gt': '&#62;',
    1:                   'amp': '&#38;',       # must use charref
    1:                   'quot': '&#34;',
    1:                   'apos': '&#39;',
                         }
       
           # Example -- handle data, should be overridden
    1:     def handle_data(self, data):
   18:         pass
       
           # Example -- handle cdata, could be overridden
    1:     def handle_cdata(self, data):
>>>>>>         pass
       
           # Example -- handle comment, could be overridden
    1:     def handle_comment(self, data):
    1:         pass
       
           # Example -- handle processing instructions, could be overridden
    1:     def handle_proc(self, name, data):
    1:         pass
       
           # Example -- handle relatively harmless syntax errors, could be overridden
    1:     def syntax_error(self, message):
>>>>>>         raise Error('Syntax error at line %d: %s' % (self.lineno, message))
       
           # To be overridden -- handlers for unknown objects
    2:     def unknown_starttag(self, tag, attrs): pass
    3:     def unknown_endtag(self, tag): pass
    1:     def unknown_charref(self, ref): pass
    1:     def unknown_entityref(self, name):
>>>>>>         self.syntax_error("reference to unknown entity `&%s;'" % name)
       
       
    2: class TestXMLParser(XMLParser):
       
    1:     def __init__(self, **kw):
>>>>>>         self.testdata = ""
>>>>>>         XMLParser.__init__(self, **kw)
       
    1:     def handle_xml(self, encoding, standalone):
>>>>>>         self.flush()
>>>>>>         print 'xml: encoding =',encoding,'standalone =',standalone
       
    1:     def handle_doctype(self, tag, pubid, syslit, data):
>>>>>>         self.flush()
>>>>>>         print 'DOCTYPE:',tag, repr(data)
       
    1:     def handle_data(self, data):
>>>>>>         self.testdata = self.testdata + data
>>>>>>         if len(repr(self.testdata)) >= 70:
>>>>>>             self.flush()
       
    1:     def flush(self):
>>>>>>         data = self.testdata
>>>>>>         if data:
>>>>>>             self.testdata = ""
>>>>>>             print 'data:', repr(data)
       
    1:     def handle_cdata(self, data):
>>>>>>         self.flush()
>>>>>>         print 'cdata:', repr(data)
       
    1:     def handle_proc(self, name, data):
>>>>>>         self.flush()
>>>>>>         print 'processing:',name,repr(data)
       
    1:     def handle_comment(self, data):
>>>>>>         self.flush()
>>>>>>         r = repr(data)
>>>>>>         if len(r) > 68:
>>>>>>             r = r[:32] + '...' + r[-32:]
>>>>>>         print 'comment:', r
       
    1:     def syntax_error(self, message):
>>>>>>         print 'error at line %d:' % self.lineno, message
       
    1:     def unknown_starttag(self, tag, attrs):
>>>>>>         self.flush()
>>>>>>         if not attrs:
>>>>>>             print 'start tag: <' + tag + '>'
               else:
>>>>>>             print 'start tag: <' + tag,
>>>>>>             for name, value in attrs.items():
>>>>>>                 print name + '=' + '"' + value + '"',
>>>>>>             print '>'
       
    1:     def unknown_endtag(self, tag):
>>>>>>         self.flush()
>>>>>>         print 'end tag: </' + tag + '>'
       
    1:     def unknown_entityref(self, ref):
>>>>>>         self.flush()
>>>>>>         print '*** unknown entity ref: &' + ref + ';'
       
    1:     def unknown_charref(self, ref):
>>>>>>         self.flush()
>>>>>>         print '*** unknown char ref: &#' + ref + ';'
       
    1:     def close(self):
>>>>>>         XMLParser.close(self)
>>>>>>         self.flush()
       
    1: def test(args = None):
>>>>>>     import sys, getopt
>>>>>>     from time import time
       
>>>>>>     if not args:
>>>>>>         args = sys.argv[1:]
       
>>>>>>     opts, args = getopt.getopt(args, 'st')
>>>>>>     klass = TestXMLParser
>>>>>>     do_time = 0
>>>>>>     for o, a in opts:
>>>>>>         if o == '-s':
>>>>>>             klass = XMLParser
>>>>>>         elif o == '-t':
>>>>>>             do_time = 1
       
>>>>>>     if args:
>>>>>>         file = args[0]
           else:
>>>>>>         file = 'test.xml'
       
>>>>>>     if file == '-':
>>>>>>         f = sys.stdin
           else:
>>>>>>         try:
>>>>>>             f = open(file, 'r')
>>>>>>         except IOError, msg:
>>>>>>             print file, ":", msg
>>>>>>             sys.exit(1)
       
>>>>>>     data = f.read()
>>>>>>     if f is not sys.stdin:
>>>>>>         f.close()
       
>>>>>>     x = klass()
>>>>>>     t0 = time()
>>>>>>     try:
>>>>>>         if do_time:
>>>>>>             x.feed(data)
>>>>>>             x.close()
               else:
>>>>>>             for c in data:
>>>>>>                 x.feed(c)
>>>>>>             x.close()
>>>>>>     except Error, msg:
>>>>>>         t1 = time()
>>>>>>         print msg
>>>>>>         if do_time:
>>>>>>             print 'total time: %g' % (t1-t0)
>>>>>>         sys.exit(1)
>>>>>>     t1 = time()
>>>>>>     if do_time:
>>>>>>         print 'total time: %g' % (t1-t0)
       
       
    1: if __name__ == '__main__':
>>>>>>     test()
