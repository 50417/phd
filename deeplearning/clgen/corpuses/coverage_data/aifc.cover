       """Stuff to parse AIFF-C and AIFF files.
       
       Unless explicitly stated otherwise, the description below is true
       both for AIFF-C files and AIFF files.
       
       An AIFF-C file has the following structure.
       
         +-----------------+
         | FORM            |
         +-----------------+
         | <size>          |
         +----+------------+
         |    | AIFC       |
         |    +------------+
         |    | <chunks>   |
         |    |    .       |
         |    |    .       |
         |    |    .       |
         +----+------------+
       
       An AIFF file has the string "AIFF" instead of "AIFC".
       
       A chunk consists of an identifier (4 bytes) followed by a size (4 bytes,
       big endian order), followed by the data.  The size field does not include
       the size of the 8 byte header.
       
       The following chunk types are recognized.
       
         FVER
             <version number of AIFF-C defining document> (AIFF-C only).
         MARK
             <# of markers> (2 bytes)
             list of markers:
                 <marker ID> (2 bytes, must be > 0)
                 <position> (4 bytes)
                 <marker name> ("pstring")
         COMM
             <# of channels> (2 bytes)
             <# of sound frames> (4 bytes)
             <size of the samples> (2 bytes)
             <sampling frequency> (10 bytes, IEEE 80-bit extended
                 floating point)
             in AIFF-C files only:
             <compression type> (4 bytes)
             <human-readable version of compression type> ("pstring")
         SSND
             <offset> (4 bytes, not used by this program)
             <blocksize> (4 bytes, not used by this program)
             <sound data>
       
       A pstring consists of 1 byte length, a string of characters, and 0 or 1
       byte pad to make the total length even.
       
       Usage.
       
       Reading AIFF files:
         f = aifc.open(file, 'r')
       where file is either the name of a file or an open file pointer.
       The open file pointer must have methods read(), seek(), and close().
       In some types of audio files, if the setpos() method is not used,
       the seek() method is not necessary.
       
       This returns an instance of a class with the following public methods:
         getnchannels()  -- returns number of audio channels (1 for
                    mono, 2 for stereo)
         getsampwidth()  -- returns sample width in bytes
         getframerate()  -- returns sampling frequency
         getnframes()    -- returns number of audio frames
         getcomptype()   -- returns compression type ('NONE' for AIFF files)
         getcompname()   -- returns human-readable version of
                    compression type ('not compressed' for AIFF files)
         getparams() -- returns a tuple consisting of all of the
                    above in the above order
         getmarkers()    -- get the list of marks in the audio file or None
                    if there are no marks
         getmark(id) -- get mark with the specified id (raises an error
                    if the mark does not exist)
         readframes(n)   -- returns at most n frames of audio
         rewind()    -- rewind to the beginning of the audio stream
         setpos(pos) -- seek to the specified position
         tell()      -- return the current position
         close()     -- close the instance (make it unusable)
       The position returned by tell(), the position given to setpos() and
       the position of marks are all compatible and have nothing to do with
       the actual position in the file.
       The close() method is called automatically when the class instance
       is destroyed.
       
       Writing AIFF files:
         f = aifc.open(file, 'w')
       where file is either the name of a file or an open file pointer.
       The open file pointer must have methods write(), tell(), seek(), and
       close().
       
       This returns an instance of a class with the following public methods:
         aiff()      -- create an AIFF file (AIFF-C default)
         aifc()      -- create an AIFF-C file
         setnchannels(n) -- set the number of channels
         setsampwidth(n) -- set the sample width
         setframerate(n) -- set the frame rate
         setnframes(n)   -- set the number of frames
         setcomptype(type, name)
                 -- set the compression type and the
                    human-readable compression type
         setparams(tuple)
                 -- set all parameters at once
         setmark(id, pos, name)
                 -- add specified mark to the list of marks
         tell()      -- return current position in output file (useful
                    in combination with setmark())
         writeframesraw(data)
                 -- write audio frames without pathing up the
                    file header
         writeframes(data)
                 -- write audio frames and patch up the file header
         close()     -- patch up the file header and close the
                    output file
       You should set the parameters before the first writeframesraw or
       writeframes.  The total number of frames does not need to be set,
       but when it is set to the correct value, the header does not have to
       be patched up.
       It is best to first set all parameters, perhaps possibly the
       compression type, and then write audio frames using writeframesraw.
       When all frames have been written, either call writeframes('') or
       close() to patch up the sizes in the header.
       Marks can be added anytime.  If there are any marks, you must call
       close() after all frames have been written.
       The close() method is called automatically when the class instance
       is destroyed.
       
       When a file is opened with the extension '.aiff', an AIFF file is
       written, otherwise an AIFF-C file is written.  This default can be
       changed by calling aiff() or aifc() before the first writeframes or
       writeframesraw.
    1: """
       
    1: import struct
    1: import __builtin__
       
    1: __all__ = ["Error","open","openfp"]
       
    2: class Error(Exception):
    1:     pass
       
    1: _AIFC_version = 0xA2805140L     # Version 1 of AIFF-C
       
    1: def _read_long(file):
   93:     try:
   93:         return struct.unpack('>l', file.read(4))[0]
    1:     except struct.error:
    1:         raise EOFError
       
    1: def _read_ulong(file):
  239:     try:
  239:         return struct.unpack('>L', file.read(4))[0]
    1:     except struct.error:
    1:         raise EOFError
       
    1: def _read_short(file):
  272:     try:
  272:         return struct.unpack('>h', file.read(2))[0]
    2:     except struct.error:
    2:         raise EOFError
       
    1: def _read_ushort(file):
    4:     try:
    4:         return struct.unpack('>H', file.read(2))[0]
    1:     except struct.error:
    1:         raise EOFError
       
    1: def _read_string(file):
   61:     length = ord(file.read(1))
   61:     if length == 0:
   15:         data = ''
           else:
   46:         data = file.read(length)
   61:     if length & 1 == 0:
   57:         dummy = file.read(1)
   61:     return data
       
    1: _HUGE_VAL = 1.79769313486231e+308 # See <limits.h>
       
    1: def _read_float(f): # 10 bytes
   91:     expon = _read_short(f) # 2 bytes
   91:     sign = 1
   91:     if expon < 0:
    1:         sign = -1
    1:         expon = expon + 0x8000
   91:     himant = _read_ulong(f) # 4 bytes
   91:     lomant = _read_ulong(f) # 4 bytes
   91:     if expon == himant == lomant == 0:
    5:         f = 0.0
   86:     elif expon == 0x7FFF:
    2:         f = _HUGE_VAL
           else:
   84:         expon = expon - 16383
   84:         f = (himant * 0x100000000L + lomant) * pow(2.0, expon - 63)
   91:     return sign * f
       
    1: def _write_short(f, x):
  124:     f.write(struct.pack('>h', x))
       
    1: def _write_ushort(f, x):
   67:     f.write(struct.pack('>H', x))
       
    1: def _write_long(f, x):
    5:     f.write(struct.pack('>l', x))
       
    1: def _write_ulong(f, x):
 2125:     f.write(struct.pack('>L', x))
       
    1: def _write_string(f, s):
   61:     if len(s) > 255:
    1:         raise ValueError("string exceeds maximum pstring length")
   60:     f.write(struct.pack('B', len(s)))
   60:     f.write(s)
   60:     if len(s) & 1 == 0:
   57:         f.write(chr(0))
       
    1: def _write_float(f, x):
   64:     import math
   64:     if x < 0:
    1:         sign = 0x8000
    1:         x = x * -1
           else:
   63:         sign = 0
   64:     if x == 0:
    1:         expon = 0
    1:         himant = 0
    1:         lomant = 0
           else:
   63:         fmant, expon = math.frexp(x)
   63:         if expon > 16384 or fmant >= 1 or fmant != fmant: # Infinity or NaN
    2:             expon = sign|0x7FFF
    2:             himant = 0
    2:             lomant = 0
               else:                   # Finite
   61:             expon = expon + 16382
   61:             if expon < 0:           # denormalized
>>>>>>                 fmant = math.ldexp(fmant, expon)
>>>>>>                 expon = 0
   61:             expon = expon | sign
   61:             fmant = math.ldexp(fmant, 32)
   61:             fsmant = math.floor(fmant)
   61:             himant = long(fsmant)
   61:             fmant = math.ldexp(fmant - fsmant, 32)
   61:             fsmant = math.floor(fmant)
   61:             lomant = long(fsmant)
   64:     _write_ushort(f, expon)
   64:     _write_ulong(f, himant)
   64:     _write_ulong(f, lomant)
       
    1: from chunk import Chunk
       
    2: class Aifc_read:
           # Variables used in this class:
           #
           # These variables are available to the user though appropriate
           # methods of this class:
           # _file -- the open file with methods read(), close(), and seek()
           #       set through the __init__() method
           # _nchannels -- the number of audio channels
           #       available through the getnchannels() method
           # _nframes -- the number of audio frames
           #       available through the getnframes() method
           # _sampwidth -- the number of bytes per audio sample
           #       available through the getsampwidth() method
           # _framerate -- the sampling frequency
           #       available through the getframerate() method
           # _comptype -- the AIFF-C compression type ('NONE' if AIFF)
           #       available through the getcomptype() method
           # _compname -- the human-readable AIFF-C compression type
           #       available through the getcomptype() method
           # _markers -- the marks in the audio file
           #       available through the getmarkers() and getmark()
           #       methods
           # _soundpos -- the position in the audio stream
           #       available through the tell() method, set through the
           #       setpos() method
           #
           # These variables are used internally only:
           # _version -- the AIFF-C version number
           # _decomp -- the decompressor from builtin module cl
           # _comm_chunk_read -- 1 iff the COMM chunk has been read
           # _aifc -- 1 iff reading an AIFF-C file
           # _ssnd_seek_needed -- 1 iff positioned correctly in audio
           #       file for readframes()
           # _ssnd_chunk -- instantiation of a chunk class for the SSND chunk
           # _framesize -- size of one frame in the file
       
    1:     _file = None  # Set here since __del__ checks it
       
    1:     def initfp(self, file):
   89:         self._version = 0
   89:         self._decomp = None
   89:         self._convert = None
   89:         self._markers = []
   89:         self._soundpos = 0
   89:         self._file = file
   89:         chunk = Chunk(file)
   89:         if chunk.getname() != 'FORM':
    2:             raise Error, 'file does not start with FORM id'
   87:         formdata = chunk.read(4)
   87:         if formdata == 'AIFF':
   30:             self._aifc = 0
   57:         elif formdata == 'AIFC':
   56:             self._aifc = 1
               else:
    1:             raise Error, 'not an AIFF or AIFF-C file'
   86:         self._comm_chunk_read = 0
   86:         while 1:
  431:             self._ssnd_seek_needed = 1
  431:             try:
  431:                 chunk = Chunk(self._file)
   85:             except EOFError:
   85:                 break
  346:             chunkname = chunk.getname()
  346:             if chunkname == 'COMM':
   85:                 self._read_comm_chunk(chunk)
   84:                 self._comm_chunk_read = 1
  261:             elif chunkname == 'SSND':
   84:                 self._ssnd_chunk = chunk
   84:                 dummy = chunk.read(8)
   84:                 self._ssnd_seek_needed = 0
  177:             elif chunkname == 'FVER':
   53:                 self._version = _read_ulong(chunk)
  124:             elif chunkname == 'MARK':
    2:                 self._readmark(chunk)
  345:             chunk.skip()
   85:         if not self._comm_chunk_read or not self._ssnd_chunk:
    1:             raise Error, 'COMM chunk and/or SSND chunk missing'
   84:         if self._aifc and self._decomp:
>>>>>>             import cl
>>>>>>             params = [cl.ORIGINAL_FORMAT, 0,
>>>>>>                   cl.BITS_PER_COMPONENT, self._sampwidth * 8,
>>>>>>                   cl.FRAME_RATE, self._framerate]
>>>>>>             if self._nchannels == 1:
>>>>>>                 params[1] = cl.MONO
>>>>>>             elif self._nchannels == 2:
>>>>>>                 params[1] = cl.STEREO_INTERLEAVED
                   else:
>>>>>>                 raise Error, 'cannot compress more than 2 channels'
>>>>>>             self._decomp.SetParams(params)
       
    1:     def __init__(self, f):
   89:         if isinstance(f, basestring):
   40:             f = __builtin__.open(f, 'rb')
   40:             try:
   40:                 self.initfp(f)
    1:             except:
    1:                 f.close()
    1:                 raise
               else:
                   # assume it is an open file object already
   49:             self.initfp(f)
       
           #
           # User visible methods.
           #
    1:     def getfp(self):
>>>>>>         return self._file
       
    1:     def rewind(self):
   12:         self._ssnd_seek_needed = 1
   12:         self._soundpos = 0
       
    1:     def close(self):
   87:         decomp = self._decomp
   87:         try:
   87:             if decomp:
>>>>>>                 self._decomp = None
>>>>>>                 decomp.CloseDecompressor()
               finally:
   87:             self._file.close()
       
    1:     def tell(self):
   18:         return self._soundpos
       
    1:     def getnchannels(self):
   78:         return self._nchannels
       
    1:     def getnframes(self):
  102:         return self._nframes
       
    1:     def getsampwidth(self):
   78:         return self._sampwidth
       
    1:     def getframerate(self):
   78:         return self._framerate
       
    1:     def getcomptype(self):
   31:         return self._comptype
       
    1:     def getcompname(self):
   32:         return self._compname
       
       ##  def getversion(self):
       ##      return self._version
       
    1:     def getparams(self):
   24:         return self.getnchannels(), self.getsampwidth(), \
   24:               self.getframerate(), self.getnframes(), \
   24:               self.getcomptype(), self.getcompname()
       
    1:     def getmarkers(self):
    2:         if len(self._markers) == 0:
    1:             return None
    1:         return self._markers
       
    1:     def getmark(self, id):
    6:         for marker in self._markers:
    5:             if id == marker[0]:
    2:                 return marker
    1:         raise Error, 'marker %r does not exist' % (id,)
       
    1:     def setpos(self, pos):
   24:         if pos < 0 or pos > self._nframes:
   12:             raise Error, 'position not in range'
   12:         self._soundpos = pos
   12:         self._ssnd_seek_needed = 1
       
    1:     def readframes(self, nframes):
  582:         if self._ssnd_seek_needed:
   90:             self._ssnd_chunk.seek(0)
   90:             dummy = self._ssnd_chunk.read(8)
   90:             pos = self._soundpos * self._framesize
   90:             if pos:
    6:                 self._ssnd_chunk.seek(pos + 8)
   90:             self._ssnd_seek_needed = 0
  582:         if nframes == 0:
    6:             return ''
  576:         data = self._ssnd_chunk.read(nframes * self._framesize)
  576:         if self._convert and data:
   96:             data = self._convert(data)
  576:         self._soundpos = self._soundpos + len(data) // (self._nchannels * self._sampwidth)
  576:         return data
       
           #
           # Internal methods.
           #
       
    1:     def _decomp_data(self, data):
>>>>>>         import cl
>>>>>>         dummy = self._decomp.SetParam(cl.FRAME_BUFFER_SIZE,
>>>>>>                           len(data) * 2)
>>>>>>         return self._decomp.Decompress(len(data) // self._nchannels,
>>>>>>                            data)
       
    1:     def _ulaw2lin(self, data):
   96:         import audioop
   96:         return audioop.ulaw2lin(data, 2)
       
    1:     def _adpcm2lin(self, data):
>>>>>>         import audioop
>>>>>>         if not hasattr(self, '_adpcmstate'):
                   # first time
>>>>>>             self._adpcmstate = None
>>>>>>         data, self._adpcmstate = audioop.adpcm2lin(data, 2,
>>>>>>                                self._adpcmstate)
>>>>>>         return data
       
    1:     def _read_comm_chunk(self, chunk):
   85:         self._nchannels = _read_short(chunk)
   85:         self._nframes = _read_long(chunk)
   85:         self._sampwidth = (_read_short(chunk) + 7) // 8
   85:         self._framerate = int(_read_float(chunk))
   85:         self._framesize = self._nchannels * self._sampwidth
   85:         if self._aifc:
                   #DEBUG: SGI's soundeditor produces a bad size :-(
   56:             kludge = 0
   56:             if chunk.chunksize == 18:
    2:                 kludge = 1
    2:                 print 'Warning: bad COMM chunk size'
    2:                 chunk.chunksize = 23
                   #DEBUG end
   56:             self._comptype = chunk.read(4)
                   #DEBUG start
   56:             if kludge:
    2:                 length = ord(chunk.file.read(1))
    2:                 if length & 1 == 0:
    1:                     length = length + 1
    2:                 chunk.chunksize = chunk.chunksize + length
    2:                 chunk.file.seek(-1, 1)
                   #DEBUG end
   56:             self._compname = _read_string(chunk)
   56:             if self._comptype != 'NONE':
   14:                 if self._comptype == 'G722':
>>>>>>                     try:
>>>>>>                         import audioop
>>>>>>                     except ImportError:
>>>>>>                         pass
                           else:
>>>>>>                         self._convert = self._adpcm2lin
>>>>>>                         self._sampwidth = 2
>>>>>>                         return
                       # for ULAW and ALAW try Compression Library
   14:                 try:
   14:                     import cl
   14:                 except ImportError:
   14:                     if self._comptype in ('ULAW', 'ulaw'):
   13:                         try:
   13:                             import audioop
   13:                             self._convert = self._ulaw2lin
   13:                             self._sampwidth = 2
   13:                             return
>>>>>>                         except ImportError:
>>>>>>                             pass
    1:                     raise Error, 'cannot read compressed AIFF-C files'
>>>>>>                 if self._comptype in ('ULAW', 'ulaw'):
>>>>>>                     scheme = cl.G711_ULAW
>>>>>>                 elif self._comptype in ('ALAW', 'alaw'):
>>>>>>                     scheme = cl.G711_ALAW
                       else:
>>>>>>                     raise Error, 'unsupported compression type'
>>>>>>                 self._decomp = cl.OpenDecompressor(scheme)
>>>>>>                 self._convert = self._decomp_data
>>>>>>                 self._sampwidth = 2
               else:
   29:             self._comptype = 'NONE'
   29:             self._compname = 'not compressed'
       
    1:     def _readmark(self, chunk):
    2:         nmarkers = _read_short(chunk)
               # Some files appear to contain invalid counts.
               # Cope with this by testing for EOF.
    2:         try:
    4:             for i in range(nmarkers):
    3:                 id = _read_short(chunk)
    2:                 pos = _read_long(chunk)
    2:                 name = _read_string(chunk)
    2:                 if pos or name:
                           # some files appear to have
                           # dummy markers consisting of
                           # a position 0 and name ''
    2:                     self._markers.append((id, pos, name))
    1:         except EOFError:
    1:             print 'Warning: MARK chunk contains only',
    1:             print len(self._markers),
    1:             if len(self._markers) == 1: print 'marker',
    1:             else: print 'markers',
    1:             print 'instead of', nmarkers
       
    2: class Aifc_write:
           # Variables used in this class:
           #
           # These variables are user settable through appropriate methods
           # of this class:
           # _file -- the open file with methods write(), close(), tell(), seek()
           #       set through the __init__() method
           # _comptype -- the AIFF-C compression type ('NONE' in AIFF)
           #       set through the setcomptype() or setparams() method
           # _compname -- the human-readable AIFF-C compression type
           #       set through the setcomptype() or setparams() method
           # _nchannels -- the number of audio channels
           #       set through the setnchannels() or setparams() method
           # _sampwidth -- the number of bytes per audio sample
           #       set through the setsampwidth() or setparams() method
           # _framerate -- the sampling frequency
           #       set through the setframerate() or setparams() method
           # _nframes -- the number of audio frames written to the header
           #       set through the setnframes() or setparams() method
           # _aifc -- whether we're writing an AIFF-C file or an AIFF file
           #       set through the aifc() method, reset through the
           #       aiff() method
           #
           # These variables are used internally only:
           # _version -- the AIFF-C version number
           # _comp -- the compressor from builtin module cl
           # _nframeswritten -- the number of audio frames actually written
           # _datalength -- the size of the audio samples written to the header
           # _datawritten -- the size of the audio samples actually written
       
    1:     _file = None  # Set here since __del__ checks it
       
    1:     def __init__(self, f):
   75:         if isinstance(f, basestring):
   20:             filename = f
   20:             f = __builtin__.open(f, 'wb')
               else:
                   # else, assume it is an open file object already
   55:             filename = '???'
   75:         self.initfp(f)
   75:         if filename[-5:] == '.aiff':
    1:             self._aifc = 0
               else:
   74:             self._aifc = 1
       
    1:     def initfp(self, file):
   83:         self._file = file
   83:         self._version = _AIFC_version
   83:         self._comptype = 'NONE'
   83:         self._compname = 'not compressed'
   83:         self._comp = None
   83:         self._convert = None
   83:         self._nchannels = 0
   83:         self._sampwidth = 0
   83:         self._framerate = 0
   83:         self._nframes = 0
   83:         self._nframeswritten = 0
   83:         self._datawritten = 0
   83:         self._datalength = 0
   83:         self._markers = []
   83:         self._marklength = 0
   83:         self._aifc = 1      # AIFF-C is default
       
    1:     def __del__(self):
   63:         if self._file:
    2:             self.close()
       
           #
           # User visible methods.
           #
    1:     def aiff(self):
    3:         if self._nframeswritten:
    1:             raise Error, 'cannot change parameters after starting to write'
    2:         self._aifc = 0
       
    1:     def aifc(self):
    3:         if self._nframeswritten:
    1:             raise Error, 'cannot change parameters after starting to write'
    2:         self._aifc = 1
       
    1:     def setnchannels(self, nchannels):
   63:         if self._nframeswritten:
    1:             raise Error, 'cannot change parameters after starting to write'
   62:         if nchannels < 1:
    1:             raise Error, 'bad # of channels'
   61:         self._nchannels = nchannels
       
    1:     def getnchannels(self):
   10:         if not self._nchannels:
    1:             raise Error, 'number of channels not set'
    9:         return self._nchannels
       
    1:     def setsampwidth(self, sampwidth):
   67:         if self._nframeswritten:
    1:             raise Error, 'cannot change parameters after starting to write'
   66:         if sampwidth < 1 or sampwidth > 4:
    1:             raise Error, 'bad sample width'
   65:         self._sampwidth = sampwidth
       
    1:     def getsampwidth(self):
    9:         if not self._sampwidth:
    1:             raise Error, 'sample width not set'
    8:         return self._sampwidth
       
    1:     def setframerate(self, framerate):
   61:         if self._nframeswritten:
    1:             raise Error, 'cannot change parameters after starting to write'
   60:         if framerate <= 0:
    1:             raise Error, 'bad frame rate'
   59:         self._framerate = framerate
       
    1:     def getframerate(self):
    8:         if not self._framerate:
    1:             raise Error, 'frame rate not set'
    7:         return self._framerate
       
    1:     def setnframes(self, nframes):
   60:         if self._nframeswritten:
    1:             raise Error, 'cannot change parameters after starting to write'
   59:         self._nframes = nframes
       
    1:     def getnframes(self):
    8:         return self._nframeswritten
       
    1:     def setcomptype(self, comptype, compname):
   65:         if self._nframeswritten:
    1:             raise Error, 'cannot change parameters after starting to write'
   64:         if comptype not in ('NONE', 'ULAW', 'ulaw', 'ALAW', 'alaw', 'G722'):
    1:             raise Error, 'unsupported compression type'
   63:         self._comptype = comptype
   63:         self._compname = compname
       
    1:     def getcomptype(self):
    7:         return self._comptype
       
    1:     def getcompname(self):
    7:         return self._compname
       
       ##  def setversion(self, version):
       ##      if self._nframeswritten:
       ##          raise Error, 'cannot change parameters after starting to write'
       ##      self._version = version
       
    1:     def setparams(self, info):
   11:         nchannels, sampwidth, framerate, nframes, comptype, compname = info
   11:         if self._nframeswritten:
    1:             raise Error, 'cannot change parameters after starting to write'
   10:         if comptype not in ('NONE', 'ULAW', 'ulaw', 'ALAW', 'alaw', 'G722'):
    1:             raise Error, 'unsupported compression type'
    9:         self.setnchannels(nchannels)
    9:         self.setsampwidth(sampwidth)
    9:         self.setframerate(framerate)
    9:         self.setnframes(nframes)
    9:         self.setcomptype(comptype, compname)
       
    1:     def getparams(self):
    8:         if not self._nchannels or not self._sampwidth or not self._framerate:
    1:             raise Error, 'not all parameters set'
    7:         return self._nchannels, self._sampwidth, self._framerate, \
    7:               self._nframes, self._comptype, self._compname
       
    1:     def setmark(self, id, pos, name):
    7:         if id <= 0:
    1:             raise Error, 'marker ID must be > 0'
    6:         if pos < 0:
    1:             raise Error, 'marker position must be >= 0'
    5:         if type(name) != type(''):
    1:             raise Error, 'marker name must be a string'
    5:         for i in range(len(self._markers)):
    2:             if id == self._markers[i][0]:
    1:                 self._markers[i] = id, pos, name
    1:                 return
    3:         self._markers.append((id, pos, name))
       
    1:     def getmark(self, id):
    2:         for marker in self._markers:
    1:             if id == marker[0]:
    1:                 return marker
    1:         raise Error, 'marker %r does not exist' % (id,)
       
    1:     def getmarkers(self):
    2:         if len(self._markers) == 0:
    1:             return None
    1:         return self._markers
       
    1:     def tell(self):
    2:         return self._nframeswritten
       
    1:     def writeframesraw(self, data):
  544:         self._ensure_header_written(len(data))
  544:         nframes = len(data) // (self._sampwidth * self._nchannels)
  544:         if self._convert:
   90:             data = self._convert(data)
  544:         self._file.write(data)
  544:         self._nframeswritten = self._nframeswritten + nframes
  544:         self._datawritten = self._datawritten + len(data)
       
    1:     def writeframes(self, data):
  544:         self.writeframesraw(data)
  544:         if self._nframeswritten != self._nframes or \
   22:               self._datalength != self._datawritten:
  524:             self._patchheader()
       
    1:     def close(self):
  127:         if self._file is None:
   55:             return
   72:         try:
   72:             self._ensure_header_written(0)
   58:             if self._datawritten & 1:
                       # quick pad to even size
    2:                 self._file.write(chr(0))
    2:                 self._datawritten = self._datawritten + 1
   58:             self._writemarkers()
   58:             if self._nframeswritten != self._nframes or \
   46:                   self._datalength != self._datawritten or \
   46:                   self._marklength:
   13:                 self._patchheader()
   46:             if self._comp:
>>>>>>                 self._comp.CloseCompressor()
>>>>>>                 self._comp = None
               finally:
                   # Prevent ref cycles
   72:             self._convert = None
   72:             f = self._file
   72:             self._file = None
   72:             f.close()
       
           #
           # Internal methods.
           #
       
    1:     def _comp_data(self, data):
>>>>>>         import cl
>>>>>>         dummy = self._comp.SetParam(cl.FRAME_BUFFER_SIZE, len(data))
>>>>>>         dummy = self._comp.SetParam(cl.COMPRESSED_BUFFER_SIZE, len(data))
>>>>>>         return self._comp.Compress(self._nframes, data)
       
    1:     def _lin2ulaw(self, data):
   90:         import audioop
   90:         return audioop.lin2ulaw(data, 2)
       
    1:     def _lin2adpcm(self, data):
>>>>>>         import audioop
>>>>>>         if not hasattr(self, '_adpcmstate'):
>>>>>>             self._adpcmstate = None
>>>>>>         data, self._adpcmstate = audioop.lin2adpcm(data, 2,
>>>>>>                                self._adpcmstate)
>>>>>>         return data
       
    1:     def _ensure_header_written(self, datasize):
  616:         if not self._nframeswritten:
   72:             if self._comptype in ('ULAW', 'ulaw', 'ALAW', 'alaw'):
   14:                 if not self._sampwidth:
>>>>>>                     self._sampwidth = 2
   14:                 if self._sampwidth != 2:
    4:                     raise Error, 'sample width must be 2 when compressing with ULAW or ALAW'
   68:             if self._comptype == 'G722':
    1:                 if not self._sampwidth:
>>>>>>                     self._sampwidth = 2
    1:                 if self._sampwidth != 2:
    1:                     raise Error, 'sample width must be 2 when compressing with G7.22 (ADPCM)'
   67:             if not self._nchannels:
    7:                 raise Error, '# channels not specified'
   60:             if not self._sampwidth:
    1:                 raise Error, 'sample width not specified'
   59:             if not self._framerate:
    1:                 raise Error, 'sampling rate not specified'
   58:             self._write_header(datasize)
       
    1:     def _init_compression(self):
    9:         if self._comptype == 'G722':
>>>>>>             self._convert = self._lin2adpcm
>>>>>>             return
    9:         try:
    9:             import cl
    9:         except ImportError:
    9:             if self._comptype in ('ULAW', 'ulaw'):
    9:                 try:
    9:                     import audioop
    9:                     self._convert = self._lin2ulaw
    9:                     return
>>>>>>                 except ImportError:
>>>>>>                     pass
>>>>>>             raise Error, 'cannot write compressed AIFF-C files'
>>>>>>         if self._comptype in ('ULAW', 'ulaw'):
>>>>>>             scheme = cl.G711_ULAW
>>>>>>         elif self._comptype in ('ALAW', 'alaw'):
>>>>>>             scheme = cl.G711_ALAW
               else:
>>>>>>             raise Error, 'unsupported compression type'
>>>>>>         self._comp = cl.OpenCompressor(scheme)
>>>>>>         params = [cl.ORIGINAL_FORMAT, 0,
>>>>>>               cl.BITS_PER_COMPONENT, self._sampwidth * 8,
>>>>>>               cl.FRAME_RATE, self._framerate,
>>>>>>               cl.FRAME_BUFFER_SIZE, 100,
>>>>>>               cl.COMPRESSED_BUFFER_SIZE, 100]
>>>>>>         if self._nchannels == 1:
>>>>>>             params[1] = cl.MONO
>>>>>>         elif self._nchannels == 2:
>>>>>>             params[1] = cl.STEREO_INTERLEAVED
               else:
>>>>>>             raise Error, 'cannot compress more than 2 channels'
>>>>>>         self._comp.SetParams(params)
               # the compressor produces a header which we ignore
>>>>>>         dummy = self._comp.Compress(0, '')
>>>>>>         self._convert = self._comp_data
       
    1:     def _write_header(self, initlength):
   58:         if self._aifc and self._comptype != 'NONE':
    9:             self._init_compression()
   58:         self._file.write('FORM')
   58:         if not self._nframes:
>>>>>>             self._nframes = initlength // (self._nchannels * self._sampwidth)
   58:         self._datalength = self._nframes * self._nchannels * self._sampwidth
   58:         if self._datalength & 1:
    2:             self._datalength = self._datalength + 1
   58:         if self._aifc:
   55:             if self._comptype in ('ULAW', 'ulaw', 'ALAW', 'alaw'):
    9:                 self._datalength = self._datalength // 2
    9:                 if self._datalength & 1:
>>>>>>                     self._datalength = self._datalength + 1
   46:             elif self._comptype == 'G722':
>>>>>>                 self._datalength = (self._datalength + 3) // 4
>>>>>>                 if self._datalength & 1:
>>>>>>                     self._datalength = self._datalength + 1
   58:         try:
   58:             self._form_length_pos = self._file.tell()
   18:         except (AttributeError, IOError):
   18:             self._form_length_pos = None
   58:         commlength = self._write_form_length(self._datalength)
   58:         if self._aifc:
   55:             self._file.write('AIFC')
   55:             self._file.write('FVER')
   55:             _write_ulong(self._file, 4)
   55:             _write_ulong(self._file, self._version)
               else:
    3:             self._file.write('AIFF')
   58:         self._file.write('COMM')
   58:         _write_ulong(self._file, commlength)
   58:         _write_short(self._file, self._nchannels)
   58:         if self._form_length_pos is not None:
   40:             self._nframes_pos = self._file.tell()
   58:         _write_ulong(self._file, self._nframes)
   58:         if self._comptype in ('ULAW', 'ulaw', 'ALAW', 'alaw', 'G722'):
   10:             _write_short(self._file, 8)
               else:
   48:             _write_short(self._file, self._sampwidth * 8)
   58:         _write_float(self._file, self._framerate)
   58:         if self._aifc:
   55:             self._file.write(self._comptype)
   55:             _write_string(self._file, self._compname)
   58:         self._file.write('SSND')
   58:         if self._form_length_pos is not None:
   40:             self._ssnd_length_pos = self._file.tell()
   58:         _write_ulong(self._file, self._datalength + 8)
   58:         _write_ulong(self._file, 0)
   58:         _write_ulong(self._file, 0)
       
    1:     def _write_form_length(self, datalength):
  569:         if self._aifc:
  565:             commlength = 18 + 5 + len(self._compname)
  565:             if commlength & 1:
  565:                 commlength = commlength + 1
  565:             verslength = 12
               else:
    4:             commlength = 18
    4:             verslength = 0
  569:         _write_ulong(self._file, 4 + verslength + self._marklength + \
  569:                      8 + commlength + 16 + datalength)
  569:         return commlength
       
    1:     def _patchheader(self):
  537:         curpos = self._file.tell()
  513:         if self._datawritten & 1:
    2:             datalength = self._datawritten + 1
    2:             self._file.write(chr(0))
               else:
  511:             datalength = self._datawritten
  513:         if datalength == self._datalength and \
    3:               self._nframes == self._nframeswritten and \
    3:               self._marklength == 0:
    2:             self._file.seek(curpos, 0)
    2:             return
  511:         self._file.seek(self._form_length_pos, 0)
  511:         dummy = self._write_form_length(datalength)
  511:         self._file.seek(self._nframes_pos, 0)
  511:         _write_ulong(self._file, self._nframeswritten)
  511:         self._file.seek(self._ssnd_length_pos, 0)
  511:         _write_ulong(self._file, datalength + 8)
  511:         self._file.seek(curpos, 0)
  511:         self._nframes = self._nframeswritten
  511:         self._datalength = datalength
       
    1:     def _writemarkers(self):
   58:         if len(self._markers) == 0:
   57:             return
    1:         self._file.write('MARK')
    1:         length = 2
    3:         for marker in self._markers:
    2:             id, pos, name = marker
    2:             length = length + len(name) + 1 + 6
    2:             if len(name) & 1 == 0:
    1:                 length = length + 1
    1:         _write_ulong(self._file, length)
    1:         self._marklength = length + 8
    1:         _write_short(self._file, len(self._markers))
    3:         for marker in self._markers:
    2:             id, pos, name = marker
    2:             _write_short(self._file, id)
    2:             _write_ulong(self._file, pos)
    2:             _write_string(self._file, name)
       
    1: def open(f, mode=None):
  164:     if mode is None:
   32:         if hasattr(f, 'mode'):
    6:             mode = f.mode
               else:
   26:             mode = 'rb'
  164:     if mode in ('r', 'rb'):
   88:         return Aifc_read(f)
   76:     elif mode in ('w', 'wb'):
   75:         return Aifc_write(f)
           else:
    1:         raise Error, "mode must be 'r', 'rb', 'w', or 'wb'"
       
    1: openfp = open # B/W compatibility
       
    1: if __name__ == '__main__':
>>>>>>     import sys
>>>>>>     if not sys.argv[1:]:
>>>>>>         sys.argv.append('/usr/demos/data/audio/bach.aiff')
>>>>>>     fn = sys.argv[1]
>>>>>>     f = open(fn, 'r')
>>>>>>     try:
>>>>>>         print "Reading", fn
>>>>>>         print "nchannels =", f.getnchannels()
>>>>>>         print "nframes   =", f.getnframes()
>>>>>>         print "sampwidth =", f.getsampwidth()
>>>>>>         print "framerate =", f.getframerate()
>>>>>>         print "comptype  =", f.getcomptype()
>>>>>>         print "compname  =", f.getcompname()
>>>>>>         if sys.argv[2:]:
>>>>>>             gn = sys.argv[2]
>>>>>>             print "Writing", gn
>>>>>>             g = open(gn, 'w')
>>>>>>             try:
>>>>>>                 g.setparams(f.getparams())
>>>>>>                 while 1:
>>>>>>                     data = f.readframes(1024)
>>>>>>                     if not data:
>>>>>>                         break
>>>>>>                     g.writeframes(data)
                   finally:
>>>>>>                 g.close()
>>>>>>             print "Done."
           finally:
>>>>>>         f.close()
