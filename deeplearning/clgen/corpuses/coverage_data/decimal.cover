       # Copyright (c) 2004 Python Software Foundation.
       # All rights reserved.
       
       # Written by Eric Price <eprice at tjhsst.edu>
       #    and Facundo Batista <facundo at taniquetil.com.ar>
       #    and Raymond Hettinger <python at rcn.com>
       #    and Aahz <aahz at pobox.com>
       #    and Tim Peters
       
       # This module is currently Py2.3 compatible and should be kept that way
       # unless a major compelling advantage arises.  IOW, 2.3 compatibility is
       # strongly preferred, but not guaranteed.
       
       # Also, this module should be kept in sync with the latest updates of
       # the IBM specification as it evolves.  Those updates will be treated
       # as bug fixes (deviation from the spec is a compatibility, usability
       # bug) and will be backported.  At this point the spec is stabilizing
       # and the updates are becoming fewer, smaller, and less significant.
       
       """
       This is a Py2.3 implementation of decimal floating point arithmetic based on
       the General Decimal Arithmetic Specification:
       
           http://speleotrove.com/decimal/decarith.html
       
       and IEEE standard 854-1987:
       
           http://en.wikipedia.org/wiki/IEEE_854-1987
       
       Decimal floating point has finite precision with arbitrarily large bounds.
       
       The purpose of this module is to support arithmetic using familiar
       "schoolhouse" rules and to avoid some of the tricky representation
       issues associated with binary floating point.  The package is especially
       useful for financial applications or for contexts where users have
       expectations that are at odds with binary floating point (for instance,
       in binary floating point, 1.00 % 0.1 gives 0.09999999999999995 instead
       of the expected Decimal('0.00') returned by decimal floating point).
       
       Here are some examples of using the decimal module:
       
       >>> from decimal import *
       >>> setcontext(ExtendedContext)
       >>> Decimal(0)
       Decimal('0')
       >>> Decimal('1')
       Decimal('1')
       >>> Decimal('-.0123')
       Decimal('-0.0123')
       >>> Decimal(123456)
       Decimal('123456')
       >>> Decimal('123.45e12345678901234567890')
       Decimal('1.2345E+12345678901234567892')
       >>> Decimal('1.33') + Decimal('1.27')
       Decimal('2.60')
       >>> Decimal('12.34') + Decimal('3.87') - Decimal('18.41')
       Decimal('-2.20')
       >>> dig = Decimal(1)
       >>> print dig / Decimal(3)
       0.333333333
       >>> getcontext().prec = 18
       >>> print dig / Decimal(3)
       0.333333333333333333
       >>> print dig.sqrt()
       1
       >>> print Decimal(3).sqrt()
       1.73205080756887729
       >>> print Decimal(3) ** 123
       4.85192780976896427E+58
       >>> inf = Decimal(1) / Decimal(0)
       >>> print inf
       Infinity
       >>> neginf = Decimal(-1) / Decimal(0)
       >>> print neginf
       -Infinity
       >>> print neginf + inf
       NaN
       >>> print neginf * inf
       -Infinity
       >>> print dig / 0
       Infinity
       >>> getcontext().traps[DivisionByZero] = 1
       >>> print dig / 0
       Traceback (most recent call last):
         ...
         ...
         ...
       DivisionByZero: x / 0
       >>> c = Context()
       >>> c.traps[InvalidOperation] = 0
       >>> print c.flags[InvalidOperation]
       0
       >>> c.divide(Decimal(0), Decimal(0))
       Decimal('NaN')
       >>> c.traps[InvalidOperation] = 1
       >>> print c.flags[InvalidOperation]
       1
       >>> c.flags[InvalidOperation] = 0
       >>> print c.flags[InvalidOperation]
       0
       >>> print c.divide(Decimal(0), Decimal(0))
       Traceback (most recent call last):
         ...
         ...
         ...
       InvalidOperation: 0 / 0
       >>> print c.flags[InvalidOperation]
       1
       >>> c.flags[InvalidOperation] = 0
       >>> c.traps[InvalidOperation] = 0
       >>> print c.divide(Decimal(0), Decimal(0))
       NaN
       >>> print c.flags[InvalidOperation]
       1
       >>>
    1: """
       
       __all__ = [
           # Two major classes
    1:     'Decimal', 'Context',
       
           # Contexts
    1:     'DefaultContext', 'BasicContext', 'ExtendedContext',
       
           # Exceptions
    1:     'DecimalException', 'Clamped', 'InvalidOperation', 'DivisionByZero',
    1:     'Inexact', 'Rounded', 'Subnormal', 'Overflow', 'Underflow',
       
           # Constants for use in setting up contexts
    1:     'ROUND_DOWN', 'ROUND_HALF_UP', 'ROUND_HALF_EVEN', 'ROUND_CEILING',
    1:     'ROUND_FLOOR', 'ROUND_UP', 'ROUND_HALF_DOWN', 'ROUND_05UP',
       
           # Functions for manipulating contexts
    1:     'setcontext', 'getcontext', 'localcontext'
       ]
       
    1: __version__ = '1.70'    # Highest version of the spec this complies with
       
    1: import math as _math
    1: import numbers as _numbers
       
    1: try:
    1:     from collections import namedtuple as _namedtuple
    1:     DecimalTuple = _namedtuple('DecimalTuple', 'sign digits exponent')
>>>>>> except ImportError:
>>>>>>     DecimalTuple = lambda *args: args
       
       # Rounding
    1: ROUND_DOWN = 'ROUND_DOWN'
    1: ROUND_HALF_UP = 'ROUND_HALF_UP'
    1: ROUND_HALF_EVEN = 'ROUND_HALF_EVEN'
    1: ROUND_CEILING = 'ROUND_CEILING'
    1: ROUND_FLOOR = 'ROUND_FLOOR'
    1: ROUND_UP = 'ROUND_UP'
    1: ROUND_HALF_DOWN = 'ROUND_HALF_DOWN'
    1: ROUND_05UP = 'ROUND_05UP'
       
       # Errors
       
    2: class DecimalException(ArithmeticError):
           """Base exception class.
       
           Used exceptions derive from this.
           If an exception derives from another exception besides this (such as
           Underflow (Inexact, Rounded, Subnormal) that indicates that it is only
           called if the others are present.  This isn't actually used for
           anything, though.
       
           handle  -- Called when context._raise_error is called and the
                      trap_enabler is not set.  First argument is self, second is the
                      context.  More arguments can be given, those being after
                      the explanation in _raise_error (For example,
                      context._raise_error(NewError, '(-x)!', self._sign) would
                      call NewError().handle(context, self._sign).)
       
           To define a new exception, it should be sufficient to have it derive
           from DecimalException.
    1:     """
    1:     def handle(self, context, *args):
 5415:         pass
       
       
    2: class Clamped(DecimalException):
           """Exponent of a 0 changed to fit bounds.
       
           This occurs and signals clamped if the exponent of a result has been
           altered in order to fit the constraints of a specific concrete
           representation.  This may occur when the exponent of a zero result would
           be outside the bounds of a representation, or when a large normal
           number would have an encoded exponent that cannot be represented.  In
           this latter case, the exponent is reduced to fit and the corresponding
           number of zero digits are appended to the coefficient ("fold-down").
    1:     """
       
    2: class InvalidOperation(DecimalException):
           """An invalid operation was performed.
       
           Various bad things cause this:
       
           Something creates a signaling NaN
           -INF + INF
           0 * (+-)INF
           (+-)INF / (+-)INF
           x % 0
           (+-)INF % x
           x._rescale( non-integer )
           sqrt(-x) , x > 0
           0 ** 0
           x ** (non-integer)
           x ** (+-)INF
           An operand is invalid
       
           The result of the operation after these is a quiet positive NaN,
           except when the cause is a signaling NaN, in which case the result is
           also a quiet NaN, but with the original sign, and an optional
           diagnostic information.
    1:     """
    1:     def handle(self, context, *args):
  570:         if args:
  283:             ans = _dec_from_triple(args[0]._sign, args[0]._int, 'n', True)
  283:             return ans._fix_nan(context)
  287:         return _NaN
       
    2: class ConversionSyntax(InvalidOperation):
           """Trying to convert badly formed string.
       
           This occurs and signals invalid-operation if a string is being
           converted to a number and it does not conform to the numeric string
           syntax.  The result is [0,qNaN].
    1:     """
    1:     def handle(self, context, *args):
   49:         return _NaN
       
    2: class DivisionByZero(DecimalException, ZeroDivisionError):
           """Division by 0.
       
           This occurs and signals division-by-zero if division of a finite number
           by zero was attempted (during a divide-integer or divide operation, or a
           power operation with negative right-hand operand), and the dividend was
           not zero.
       
           The result of the operation is [sign,inf], where sign is the exclusive
           or of the signs of the operands for divide, or is 1 for an odd power of
           -0, for power.
    1:     """
       
    1:     def handle(self, context, sign, *args):
   43:         return _SignedInfinity[sign]
       
    2: class DivisionImpossible(InvalidOperation):
           """Cannot perform the division adequately.
       
           This occurs and signals invalid-operation if the integer result of a
           divide-integer or remainder operation had too many digits (would be
           longer than precision).  The result is [0,qNaN].
    1:     """
       
    1:     def handle(self, context, *args):
   71:         return _NaN
       
    2: class DivisionUndefined(InvalidOperation, ZeroDivisionError):
           """Undefined result of division.
       
           This occurs and signals invalid-operation if division by zero was
           attempted (during a divide-integer, divide, or remainder operation), and
           the dividend is also zero.  The result is [0,qNaN].
    1:     """
       
    1:     def handle(self, context, *args):
   14:         return _NaN
       
    2: class Inexact(DecimalException):
           """Had to round, losing information.
       
           This occurs and signals inexact whenever the result of an operation is
           not exact (that is, it needed to be rounded and any discarded digits
           were non-zero), or if an overflow or underflow condition occurs.  The
           result in all cases is unchanged.
       
           The inexact signal may be tested (or trapped) to determine if a given
           operation (or sequence of operations) was inexact.
    1:     """
       
    2: class InvalidContext(InvalidOperation):
           """Invalid context.  Unknown rounding, for example.
       
           This occurs and signals invalid-operation if an invalid context was
           detected during an operation.  This can occur if contexts are not checked
           on creation and either the precision exceeds the capability of the
           underlying concrete representation or an unknown or unsupported rounding
           was specified.  These aspects of the context need only be checked when
           the values are required to be used.  The result is [0,qNaN].
    1:     """
       
    1:     def handle(self, context, *args):
>>>>>>         return _NaN
       
    2: class Rounded(DecimalException):
           """Number got rounded (not  necessarily changed during rounding).
       
           This occurs and signals rounded whenever the result of an operation is
           rounded (that is, some zero or non-zero digits were discarded from the
           coefficient), or if an overflow or underflow condition occurs.  The
           result in all cases is unchanged.
       
           The rounded signal may be tested (or trapped) to determine if a given
           operation (or sequence of operations) caused a loss of precision.
    1:     """
       
    2: class Subnormal(DecimalException):
           """Exponent < Emin before rounding.
       
           This occurs and signals subnormal whenever the result of a conversion or
           operation is subnormal (that is, its adjusted exponent is less than
           Emin, before any rounding).  The result in all cases is unchanged.
       
           The subnormal signal may be tested (or trapped) to determine if a given
           or operation (or sequence of operations) yielded a subnormal result.
    1:     """
       
    2: class Overflow(Inexact, Rounded):
           """Numerical overflow.
       
           This occurs and signals overflow if the adjusted exponent of a result
           (from a conversion or from an operation that is not an attempt to divide
           by zero), after rounding, would be greater than the largest value that
           can be handled by the implementation (the value Emax).
       
           The result depends on the rounding mode:
       
           For round-half-up and round-half-even (and for round-half-down and
           round-up, if implemented), the result of the operation is [sign,inf],
           where sign is the sign of the intermediate result.  For round-down, the
           result is the largest finite number that can be represented in the
           current precision, with the sign of the intermediate result.  For
           round-ceiling, the result is the same as for round-down if the sign of
           the intermediate result is 1, or is [0,inf] otherwise.  For round-floor,
           the result is the same as for round-down if the sign of the intermediate
           result is 0, or is [1,inf] otherwise.  In all cases, Inexact and Rounded
           will also be raised.
    1:     """
       
    1:     def handle(self, context, sign, *args):
   90:         if context.rounding in (ROUND_HALF_UP, ROUND_HALF_EVEN,
   90:                                 ROUND_HALF_DOWN, ROUND_UP):
   83:             return _SignedInfinity[sign]
    7:         if sign == 0:
    3:             if context.rounding == ROUND_CEILING:
    1:                 return _SignedInfinity[sign]
    2:             return _dec_from_triple(sign, '9'*context.prec,
    2:                             context.Emax-context.prec+1)
    4:         if sign == 1:
    4:             if context.rounding == ROUND_FLOOR:
    2:                 return _SignedInfinity[sign]
    2:             return _dec_from_triple(sign, '9'*context.prec,
    2:                              context.Emax-context.prec+1)
       
       
    2: class Underflow(Inexact, Rounded, Subnormal):
           """Numerical underflow with result rounded to 0.
       
           This occurs and signals underflow if a result is inexact and the
           adjusted exponent of the result would be smaller (more negative) than
           the smallest value that can be handled by the implementation (the value
           Emin).  That is, the result is both inexact and subnormal.
       
           The result after an underflow will be a subnormal number rounded, if
           necessary, so that its exponent is not less than Etiny.  This may result
           in 0 with the sign of the intermediate result and an exponent of Etiny.
       
           In all cases, Inexact, Rounded, and Subnormal will also be raised.
    1:     """
       
       # List of public traps and flags
    1: _signals = [Clamped, DivisionByZero, Inexact, Overflow, Rounded,
    1:            Underflow, InvalidOperation, Subnormal]
       
       # Map conditions (per the spec) to signals
    1: _condition_map = {ConversionSyntax:InvalidOperation,
    1:                   DivisionImpossible:InvalidOperation,
    1:                   DivisionUndefined:InvalidOperation,
    1:                   InvalidContext:InvalidOperation}
       
       ##### Context Functions ##################################################
       
       # The getcontext() and setcontext() function manage access to a thread-local
       # current context.  Py2.4 offers direct support for thread locals.  If that
       # is not available, use threading.currentThread() which is slower but will
       # work for older Pythons.  If threads are not part of the build, create a
       # mock threading object with threading.local() returning the module namespace.
       
    1: try:
    1:     import threading
>>>>>> except ImportError:
           # Python was compiled without threads; create a mock object instead
>>>>>>     import sys
>>>>>>     class MockThreading(object):
>>>>>>         def local(self, sys=sys):
>>>>>>             return sys.modules[__name__]
>>>>>>     threading = MockThreading()
>>>>>>     del sys, MockThreading
       
    1: try:
    1:     threading.local
       
>>>>>> except AttributeError:
       
           # To fix reloading, force it to create a new context
           # Old contexts have different exceptions in their dicts, making problems.
>>>>>>     if hasattr(threading.currentThread(), '__decimal_context__'):
>>>>>>         del threading.currentThread().__decimal_context__
       
>>>>>>     def setcontext(context):
               """Set this thread's context to context."""
>>>>>>         if context in (DefaultContext, BasicContext, ExtendedContext):
>>>>>>             context = context.copy()
>>>>>>             context.clear_flags()
>>>>>>         threading.currentThread().__decimal_context__ = context
       
>>>>>>     def getcontext():
               """Returns this thread's context.
       
               If this thread does not yet have a context, returns
               a new context and sets this thread's context.
               New contexts are copies of DefaultContext.
               """
>>>>>>         try:
>>>>>>             return threading.currentThread().__decimal_context__
>>>>>>         except AttributeError:
>>>>>>             context = Context()
>>>>>>             threading.currentThread().__decimal_context__ = context
>>>>>>             return context
       
       else:
       
    1:     local = threading.local()
    1:     if hasattr(local, '__decimal_context__'):
>>>>>>         del local.__decimal_context__
       
    1:     def getcontext(_local=local):
               """Returns this thread's context.
       
               If this thread does not yet have a context, returns
               a new context and sets this thread's context.
               New contexts are copies of DefaultContext.
               """
 4266:         try:
 4266:             return _local.__decimal_context__
    3:         except AttributeError:
    3:             context = Context()
    3:             _local.__decimal_context__ = context
    3:             return context
       
    1:     def setcontext(context, _local=local):
               """Set this thread's context to context."""
   14:         if context in (DefaultContext, BasicContext, ExtendedContext):
    2:             context = context.copy()
    2:             context.clear_flags()
   14:         _local.__decimal_context__ = context
       
    1:     del threading, local        # Don't contaminate the namespace
       
    1: def localcontext(ctx=None):
           """Return a context manager for a copy of the supplied context
       
           Uses a copy of the current context if no context is specified
           The returned context manager creates a local decimal context
           in a with statement:
               def sin(x):
                    with localcontext() as ctx:
                        ctx.prec += 2
                        # Rest of sin calculation algorithm
                        # uses a precision 2 greater than normal
                    return +s  # Convert result to normal precision
       
                def sin(x):
                    with localcontext(ExtendedContext):
                        # Rest of sin calculation algorithm
                        # uses the Extended Context from the
                        # General Decimal Arithmetic Specification
                    return +s  # Convert result to normal context
       
           >>> setcontext(DefaultContext)
           >>> print getcontext().prec
           28
           >>> with localcontext():
           ...     ctx = getcontext()
           ...     ctx.prec += 2
           ...     print ctx.prec
           ...
           30
           >>> with localcontext(ExtendedContext):
           ...     print getcontext().prec
           ...
           9
           >>> print getcontext().prec
           28
           """
    5:     if ctx is None: ctx = getcontext()
    5:     return _ContextManager(ctx)
       
       
       ##### Decimal class #######################################################
       
    2: class Decimal(object):
    1:     """Floating point class for decimal arithmetic."""
       
    1:     __slots__ = ('_exp','_int','_sign', '_is_special')
           # Generally, the value of the Decimal instance is given by
           #  (-1)**_sign * _int * 10**_exp
           # Special values are signified by _is_special == True
       
           # We're immutable, so use __new__ not __init__
    1:     def __new__(cls, value="0", context=None):
               """Create a decimal point instance.
       
               >>> Decimal('3.14')              # string input
               Decimal('3.14')
               >>> Decimal((0, (3, 1, 4), -2))  # tuple (sign, digit_tuple, exponent)
               Decimal('3.14')
               >>> Decimal(314)                 # int or long
               Decimal('314')
               >>> Decimal(Decimal(314))        # another decimal instance
               Decimal('314')
               >>> Decimal('  3.14  \\n')        # leading and trailing whitespace okay
               Decimal('3.14')
               """
       
               # Note that the coefficient, self._int, is actually stored as
               # a string rather than as a tuple of digits.  This speeds up
               # the "digits to integer" and "integer to digits" conversions
               # that are used in almost every arithmetic operation on
               # Decimals.  This is an internal detail: the as_tuple function
               # and the Decimal constructor still deal with tuples of
               # digits.
       
22897:         self = object.__new__(cls)
       
               # From a string
               # REs insist on real strings, so we can too.
22897:         if isinstance(value, basestring):
15048:             m = _parser(value.strip())
15048:             if m is None:
   44:                 if context is None:
    2:                     context = getcontext()
   44:                 return context._raise_error(ConversionSyntax,
   44:                                 "Invalid literal for Decimal: %r" % value)
       
15004:             if m.group('sign') == "-":
 4247:                 self._sign = 1
                   else:
10757:                 self._sign = 0
15004:             intpart = m.group('int')
15004:             if intpart is not None:
                       # finite number
13644:                 fracpart = m.group('frac') or ''
13644:                 exp = int(m.group('exp') or '0')
13644:                 self._int = str(int(intpart+fracpart))
13644:                 self._exp = exp - len(fracpart)
13644:                 self._is_special = False
                   else:
 1360:                 diag = m.group('diag')
 1360:                 if diag is not None:
                           # NaN
  781:                     self._int = str(int(diag or '0')).lstrip('0')
  781:                     if m.group('signal'):
  367:                         self._exp = 'N'
                           else:
  414:                         self._exp = 'n'
                       else:
                           # infinity
  579:                     self._int = '0'
  579:                     self._exp = 'F'
 1360:                 self._is_special = True
15004:             return self
       
               # From an integer
 7849:         if isinstance(value, (int,long)):
 3069:             if value >= 0:
 2170:                 self._sign = 0
                   else:
  899:                 self._sign = 1
 3069:             self._exp = 0
 3069:             self._int = str(abs(value))
 3069:             self._is_special = False
 3069:             return self
       
               # From another decimal
 4780:         if isinstance(value, Decimal):
 3559:             self._exp  = value._exp
 3559:             self._sign = value._sign
 3559:             self._int  = value._int
 3559:             self._is_special  = value._is_special
 3559:             return self
       
               # From an internal working value
 1221:         if isinstance(value, _WorkRep):
  981:             self._sign = value.sign
  981:             self._int = str(value.int)
  981:             self._exp = int(value.exp)
  981:             self._is_special = False
  981:             return self
       
               # tuple/list conversion (possibly from as_tuple())
  240:         if isinstance(value, (list,tuple)):
   30:             if len(value) != 3:
    1:                 raise ValueError('Invalid tuple size in creation of Decimal '
                                        'from list or tuple.  The list or tuple '
                                        'should have exactly three elements.')
                   # process sign.  The isinstance test rejects floats
   29:             if not (isinstance(value[0], (int, long)) and value[0] in (0,1)):
    3:                 raise ValueError("Invalid sign.  The first value in the tuple "
                                        "should be an integer; either 0 for a "
                                        "positive number or 1 for a negative number.")
   26:             self._sign = value[0]
   26:             if value[2] == 'F':
                       # infinity: value[1] is ignored
    2:                 self._int = '0'
    2:                 self._exp = value[2]
    2:                 self._is_special = True
                   else:
                       # process and validate the digits in value[1]
   24:                 digits = []
  120:                 for digit in value[1]:
  100:                     if isinstance(digit, (int, long)) and 0 <= digit <= 9:
                               # skip leading zeros
   96:                         if digits or digit != 0:
   84:                             digits.append(digit)
                           else:
    4:                         raise ValueError("The second value in the tuple must "
                                                "be composed of integers in the range "
                                                "0 through 9.")
   20:                 if value[2] in ('n', 'N'):
                           # NaN: digits form the diagnostic
    3:                     self._int = ''.join(map(str, digits))
    3:                     self._exp = value[2]
    3:                     self._is_special = True
   17:                 elif isinstance(value[2], (int, long)):
                           # finite number: digits give the coefficient
   14:                     self._int = ''.join(map(str, digits or [0]))
   14:                     self._exp = value[2]
   14:                     self._is_special = False
                       else:
    3:                     raise ValueError("The third value in the tuple must "
                                            "be an integer, or one of the "
                                            "strings 'F', 'n', 'N'.")
   19:             return self
       
  210:         if isinstance(value, float):
  208:             value = Decimal.from_float(value)
  208:             self._exp  = value._exp
  208:             self._sign = value._sign
  208:             self._int  = value._int
  208:             self._is_special  = value._is_special
  208:             return self
       
    2:         raise TypeError("Cannot convert %r to Decimal" % value)
       
           # @classmethod, but @decorator is not valid Python 2.3 syntax, so
           # don't use it (see notes on Py2.3 compatibility at top of file)
    1:     def from_float(cls, f):
               """Converts a float to a decimal number, exactly.
       
               Note that Decimal.from_float(0.1) is not the same as Decimal('0.1').
               Since 0.1 is not exactly representable in binary floating point, the
               value is stored as the nearest representable value which is
               0x1.999999999999ap-4.  The exact equivalent of the value in decimal
               is 0.1000000000000000055511151231257827021181583404541015625.
       
               >>> Decimal.from_float(0.1)
               Decimal('0.1000000000000000055511151231257827021181583404541015625')
               >>> Decimal.from_float(float('nan'))
               Decimal('NaN')
               >>> Decimal.from_float(float('inf'))
               Decimal('Infinity')
               >>> Decimal.from_float(-float('inf'))
               Decimal('-Infinity')
               >>> Decimal.from_float(-0.0)
               Decimal('-0')
       
               """
 1033:         if isinstance(f, (int, long)):        # handle integer inputs
    2:             return cls(f)
 1031:         if _math.isinf(f) or _math.isnan(f):  # raises TypeError if not a float
   15:             return cls(repr(f))
 1015:         if _math.copysign(1.0, f) == 1.0:
  535:             sign = 0
               else:
  480:             sign = 1
 1015:         n, d = abs(f).as_integer_ratio()
 1015:         k = d.bit_length() - 1
 1015:         result = _dec_from_triple(sign, str(n*5**k), -k)
 1015:         if cls is Decimal:
  814:             return result
               else:
  201:             return cls(result)
    1:     from_float = classmethod(from_float)
       
    1:     def _isnan(self):
               """Returns whether the number is not actually one.
       
               0 if a number
               1 if NaN
               2 if sNaN
               """
12163:         if self._is_special:
 1333:             exp = self._exp
 1333:             if exp == 'n':
  466:                 return 1
  867:             elif exp == 'N':
  343:                 return 2
11354:         return 0
       
    1:     def _isinfinity(self):
               """Returns whether the number is infinite
       
               0 if finite or not a number
               1 if +INF
               -1 if -INF
               """
 3827:         if self._exp == 'F':
  373:             if self._sign:
  142:                 return -1
  231:             return 1
 3454:         return 0
       
    1:     def _check_nans(self, other=None, context=None):
               """Returns whether the number is not actually one.
       
               if self, other are sNaN, signal
               if self, other are NaN return nan
               return 0
       
               Done before operations.
               """
       
 4887:         self_is_nan = self._isnan()
 4887:         if other is None:
  359:             other_is_nan = False
               else:
 4528:             other_is_nan = other._isnan()
       
 4887:         if self_is_nan or other_is_nan:
  388:             if context is None:
   62:                 context = getcontext()
       
  388:             if self_is_nan == 2:
  108:                 return context._raise_error(InvalidOperation, 'sNaN',
  108:                                         self)
  280:             if other_is_nan == 2:
  119:                 return context._raise_error(InvalidOperation, 'sNaN',
  119:                                         other)
  161:             if self_is_nan:
  101:                 return self._fix_nan(context)
       
   60:             return other._fix_nan(context)
 4499:         return 0
       
    1:     def _compare_check_nans(self, other, context):
               """Version of _check_nans used for the signaling comparisons
               compare_signal, __le__, __lt__, __ge__, __gt__.
       
               Signal InvalidOperation if either self or other is a (quiet
               or signaling) NaN.  Signaling NaNs take precedence over quiet
               NaNs.
       
               Return 0 if neither operand is a NaN.
       
               """
 1466:         if context is None:
 1341:             context = getcontext()
       
 1466:         if self._is_special or other._is_special:
  148:             if self.is_snan():
   34:                 return context._raise_error(InvalidOperation,
   34:                                             'comparison involving sNaN',
   34:                                             self)
  114:             elif other.is_snan():
   29:                 return context._raise_error(InvalidOperation,
   29:                                             'comparison involving sNaN',
   29:                                             other)
   85:             elif self.is_qnan():
   29:                 return context._raise_error(InvalidOperation,
   29:                                             'comparison involving NaN',
   29:                                             self)
   56:             elif other.is_qnan():
   17:                 return context._raise_error(InvalidOperation,
   17:                                             'comparison involving NaN',
   17:                                             other)
 1357:         return 0
       
    1:     def __nonzero__(self):
               """Return True if self is nonzero; otherwise return False.
       
               NaNs and infinities are considered nonzero.
               """
27579:         return self._is_special or self._int != '0'
       
    1:     def _cmp(self, other):
               """Compare the two non-NaN decimal instances self and other.
       
               Returns -1 if self < other, 0 if self == other and 1
               if self > other.  This routine is for internal use only."""
       
 4728:         if self._is_special or other._is_special:
  151:             self_inf = self._isinfinity()
  151:             other_inf = other._isinfinity()
  151:             if self_inf == other_inf:
   34:                 return 0
  117:             elif self_inf < other_inf:
   55:                 return -1
                   else:
   62:                 return 1
       
               # check for zeros;  Decimal('0') == Decimal('-0')
 4577:         if not self:
  748:             if not other:
  648:                 return 0
                   else:
  100:                 return -((-1)**other._sign)
 3829:         if not other:
   96:             return (-1)**self._sign
       
               # If different signs, neg one is less
 3733:         if other._sign < self._sign:
   72:             return -1
 3661:         if self._sign < other._sign:
  108:             return 1
       
 3553:         self_adjusted = self.adjusted()
 3553:         other_adjusted = other.adjusted()
 3553:         if self_adjusted == other_adjusted:
 2753:             self_padded = self._int + '0'*(self._exp - other._exp)
 2753:             other_padded = other._int + '0'*(other._exp - self._exp)
 2753:             if self_padded == other_padded:
 1690:                 return 0
 1063:             elif self_padded < other_padded:
  498:                 return -(-1)**self._sign
                   else:
  565:                 return (-1)**self._sign
  800:         elif self_adjusted > other_adjusted:
  382:             return (-1)**self._sign
               else: # self_adjusted < other_adjusted
  418:             return -((-1)**self._sign)
       
           # Note: The Decimal standard doesn't cover rich comparisons for
           # Decimals.  In particular, the specification is silent on the
           # subject of what should happen for a comparison involving a NaN.
           # We take the following approach:
           #
           #   == comparisons involving a quiet NaN always return False
           #   != comparisons involving a quiet NaN always return True
           #   == or != comparisons involving a signaling NaN signal
           #      InvalidOperation, and return False or True as above if the
           #      InvalidOperation is not trapped.
           #   <, >, <= and >= comparisons involving a (quiet or signaling)
           #      NaN signal InvalidOperation, and return False if the
           #      InvalidOperation is not trapped.
           #
           # This behavior is designed to conform as closely as possible to
           # that specified by IEEE 754.
       
    1:     def __eq__(self, other, context=None):
 2466:         other = _convert_other(other, allow_float=True)
 2466:         if other is NotImplemented:
    7:             return other
 2459:         if self._check_nans(other, context):
   17:             return False
 2428:         return self._cmp(other) == 0
       
    1:     def __ne__(self, other, context=None):
  306:         other = _convert_other(other, allow_float=True)
  306:         if other is NotImplemented:
    4:             return other
  302:         if self._check_nans(other, context):
   17:             return True
  271:         return self._cmp(other) != 0
       
    1:     def __lt__(self, other, context=None):
  975:         other = _convert_other(other, allow_float=True)
  975:         if other is NotImplemented:
    2:             return other
  973:         ans = self._compare_check_nans(other, context)
  961:         if ans:
   12:             return False
  949:         return self._cmp(other) < 0
       
    1:     def __le__(self, other, context=None):
   30:         other = _convert_other(other, allow_float=True)
   30:         if other is NotImplemented:
    1:             return other
   29:         ans = self._compare_check_nans(other, context)
   17:         if ans:
   12:             return False
    5:         return self._cmp(other) <= 0
       
    1:     def __gt__(self, other, context=None):
  310:         other = _convert_other(other, allow_float=True)
  310:         if other is NotImplemented:
    2:             return other
  308:         ans = self._compare_check_nans(other, context)
  296:         if ans:
   12:             return False
  284:         return self._cmp(other) > 0
       
    1:     def __ge__(self, other, context=None):
   30:         other = _convert_other(other, allow_float=True)
   30:         if other is NotImplemented:
    1:             return other
   29:         ans = self._compare_check_nans(other, context)
   17:         if ans:
   12:             return False
    5:         return self._cmp(other) >= 0
       
    1:     def compare(self, other, context=None):
               """Compares one to another.
       
               -1 => a < b
               0  => a = b
               1  => a > b
               NaN => one is NaN
               Like __cmp__, but returns Decimal instances.
               """
  411:         other = _convert_other(other, raiseit=True)
       
               # Compare(NaN, NaN) = NaN
  410:         if (self._is_special or other and other._is_special):
   27:             ans = self._check_nans(other, context)
   27:             if ans:
   18:                 return ans
       
  392:         return Decimal(self._cmp(other))
       
    1:     def __hash__(self):
               """x.__hash__() <==> hash(x)"""
               # Decimal integers must hash the same as the ints
               #
               # The hash of a nonspecial noninteger Decimal must depend only
               # on the value of that Decimal, and not on its representation.
               # For example: hash(Decimal('100E-1')) == hash(Decimal('10')).
       
               # Equality comparisons involving signaling nans can raise an
               # exception; since equality checks are implicitly and
               # unpredictably used when checking set and dict membership, we
               # prevent signaling nans from being used as set elements or
               # dict keys by making __hash__ raise an exception.
  596:         if self._is_special:
    9:             if self.is_snan():
    1:                 raise TypeError('Cannot hash a signaling NaN value.')
    8:             elif self.is_nan():
                       # 0 to match hash(float('nan'))
    2:                 return 0
                   else:
                       # values chosen to match hash(float('inf')) and
                       # hash(float('-inf')).
    6:                 if self._sign:
    3:                     return -271828
                       else:
    3:                     return 314159
       
               # In Python 2.7, we're allowing comparisons (but not
               # arithmetic operations) between floats and Decimals;  so if
               # a Decimal instance is exactly representable as a float then
               # its hash should match that of the float.
  587:         self_as_float = float(self)
  587:         if Decimal.from_float(self_as_float) == self:
  385:             return hash(self_as_float)
       
  202:         if self._isinteger():
  199:             op = _WorkRep(self.to_integral_value())
                   # to make computation feasible for Decimals with large
                   # exponent, we use the fact that hash(n) == hash(m) for
                   # any two nonzero integers n and m such that (i) n and m
                   # have the same sign, and (ii) n is congruent to m modulo
                   # 2**64-1.  So we can replace hash((-1)**s*c*10**e) with
                   # hash((-1)**s*c*pow(10, e, 2**64-1).
  199:             return hash((-1)**op.sign*op.int*pow(10, op.exp, 2**64-1))
               # The value of a nonzero nonspecial Decimal instance is
               # faithfully represented by the triple consisting of its sign,
               # its adjusted exponent, and its coefficient with trailing
               # zeros removed.
    3:         return hash((self._sign,
    3:                      self._exp+len(self._int),
    3:                      self._int.rstrip('0')))
       
    1:     def as_tuple(self):
               """Represents the number as a triple tuple.
       
               To show the internals exactly as they are.
               """
   22:         return DecimalTuple(self._sign, tuple(map(int, self._int)), self._exp)
       
    1:     def __repr__(self):
               """Represents the number as an instance of Decimal."""
               # Invariant:  eval(repr(d)) == d
  527:         return "Decimal('%s')" % str(self)
       
    1:     def __str__(self, eng=False, context=None):
               """Return string representation of the number in scientific notation.
       
               Captures all of the information in the underlying representation.
               """
       
 7943:         sign = ['', '-'][self._sign]
 7943:         if self._is_special:
 1259:             if self._exp == 'F':
  316:                 return sign + 'Infinity'
  943:             elif self._exp == 'n':
  871:                 return sign + 'NaN' + self._int
                   else: # self._exp == 'N'
   72:                 return sign + 'sNaN' + self._int
       
               # number of digits of self._int to left of decimal point
 6684:         leftdigits = self._exp + len(self._int)
       
               # dotplace is number of digits of self._int to the left of the
               # decimal point in the mantissa of the output string (that is,
               # after adjusting the exponent)
 6684:         if self._exp <= 0 and leftdigits > -6:
                   # no exponent required
 5277:             dotplace = leftdigits
 1407:         elif not eng:
                   # usual scientific notation: 1 digit on left of the point
 1359:             dotplace = 1
   48:         elif self._int == '0':
                   # engineering notation, zero
   24:             dotplace = (leftdigits + 1) % 3 - 1
               else:
                   # engineering notation, nonzero
   24:             dotplace = (leftdigits - 1) % 3 + 1
       
 6684:         if dotplace <= 0:
 1007:             intpart = '0'
 1007:             fracpart = '.' + '0'*(-dotplace) + self._int
 5677:         elif dotplace >= len(self._int):
 3585:             intpart = self._int+'0'*(dotplace-len(self._int))
 3585:             fracpart = ''
               else:
 2092:             intpart = self._int[:dotplace]
 2092:             fracpart = '.' + self._int[dotplace:]
 6684:         if leftdigits == dotplace:
 5281:             exp = ''
               else:
 1403:             if context is None:
 1233:                 context = getcontext()
 1403:             exp = ['e', 'E'][context.capitals] + "%+d" % (leftdigits-dotplace)
       
 6684:         return sign + intpart + fracpart + exp
       
    1:     def to_eng_string(self, context=None):
               """Convert to a string, using engineering notation if an exponent is needed.
       
               Engineering notation has an exponent which is a multiple of 3.  This
               can leave up to 3 digits to the left of the decimal place and may
               require the addition of either one or two trailing zeros.
               """
   83:         return self.__str__(eng=True, context=context)
       
    1:     def __neg__(self, context=None):
               """Returns a copy with the sign switched.
       
               Rounds, if it has reason.
               """
   44:         if self._is_special:
    3:             ans = self._check_nans(context=context)
    3:             if ans:
    3:                 return ans
       
   41:         if context is None:
    5:             context = getcontext()
       
   41:         if not self and context.rounding != ROUND_FLOOR:
                   # -Decimal('0') is Decimal('0'), not Decimal('-0'), except
                   # in ROUND_FLOOR rounding mode.
    5:             ans = self.copy_abs()
               else:
   36:             ans = self.copy_negate()
       
   41:         return ans._fix(context)
       
    1:     def __pos__(self, context=None):
               """Returns a copy, unless it is a sNaN.
       
               Rounds the number (if more than precision digits)
               """
   48:         if self._is_special:
    2:             ans = self._check_nans(context=context)
    2:             if ans:
    1:                 return ans
       
   47:         if context is None:
    4:             context = getcontext()
       
   47:         if not self and context.rounding != ROUND_FLOOR:
                   # + (-0) = 0, except in ROUND_FLOOR rounding mode.
    8:             ans = self.copy_abs()
               else:
   39:             ans = Decimal(self)
       
   47:         return ans._fix(context)
       
    1:     def __abs__(self, round=True, context=None):
               """Returns the absolute value of self.
       
               If the keyword argument 'round' is false, do not round.  The
               expression self.__abs__(round=False) is equivalent to
               self.copy_abs().
               """
   40:         if not round:
>>>>>>             return self.copy_abs()
       
   40:         if self._is_special:
    2:             ans = self._check_nans(context=context)
    2:             if ans:
    2:                 return ans
       
   38:         if self._sign:
   18:             ans = self.__neg__(context=context)
               else:
   20:             ans = self.__pos__(context=context)
       
   38:         return ans
       
    1:     def __add__(self, other, context=None):
               """Returns self + other.
       
               -INF + INF (or the reverse) cause InvalidOperation errors.
               """
 1530:         other = _convert_other(other)
 1530:         if other is NotImplemented:
    7:             return other
       
 1523:         if context is None:
   36:             context = getcontext()
       
 1523:         if self._is_special or other._is_special:
   82:             ans = self._check_nans(other, context)
   82:             if ans:
   41:                 return ans
       
   41:             if self._isinfinity():
                       # If both INF, same sign => same as both, opposite => error.
   31:                 if self._sign != other._sign and other._isinfinity():
    5:                     return context._raise_error(InvalidOperation, '-INF + INF')
   26:                 return Decimal(self)
   10:             if other._isinfinity():
   10:                 return Decimal(other)  # Can't both be infinity here
       
 1441:         exp = min(self._exp, other._exp)
 1441:         negativezero = 0
 1441:         if context.rounding == ROUND_FLOOR and self._sign != other._sign:
                   # If the answer is 0, the sign should be negative, in this case.
   54:             negativezero = 1
       
 1441:         if not self and not other:
   94:             sign = min(self._sign, other._sign)
   94:             if negativezero:
    4:                 sign = 1
   94:             ans = _dec_from_triple(sign, '0', exp)
   94:             ans = ans._fix(context)
   94:             return ans
 1347:         if not self:
  131:             exp = max(exp, other._exp - context.prec-1)
  131:             ans = other._rescale(exp, context.rounding)
  131:             ans = ans._fix(context)
  131:             return ans
 1216:         if not other:
  197:             exp = max(exp, self._exp - context.prec-1)
  197:             ans = self._rescale(exp, context.rounding)
  197:             ans = ans._fix(context)
  197:             return ans
       
 1019:         op1 = _WorkRep(self)
 1019:         op2 = _WorkRep(other)
 1019:         op1, op2 = _normalize(op1, op2, context.prec)
       
 1019:         result = _WorkRep()
 1019:         if op1.sign != op2.sign:
                   # Equal and opposite
  468:             if op1.int == op2.int:
   38:                 ans = _dec_from_triple(negativezero, '0', exp)
   38:                 ans = ans._fix(context)
   38:                 return ans
  430:             if op1.int < op2.int:
  124:                 op1, op2 = op2, op1
                       # OK, now abs(op1) > abs(op2)
  430:             if op1.sign == 1:
  191:                 result.sign = 1
  191:                 op1.sign, op2.sign = op2.sign, op1.sign
                   else:
  239:                 result.sign = 0
                       # So we know the sign, and op1 > 0.
  551:         elif op1.sign == 1:
   84:             result.sign = 1
   84:             op1.sign, op2.sign = (0, 0)
               else:
  467:             result.sign = 0
               # Now, op1 > abs(op2) > 0
       
  981:         if op2.sign == 0:
  551:             result.int = op1.int + op2.int
               else:
  430:             result.int = op1.int - op2.int
       
  981:         result.exp = op1.exp
  981:         ans = Decimal(result)
  981:         ans = ans._fix(context)
  981:         return ans
       
    1:     __radd__ = __add__
       
    1:     def __sub__(self, other, context=None):
               """Return self - other"""
  340:         other = _convert_other(other)
  340:         if other is NotImplemented:
    2:             return other
       
  338:         if self._is_special or other._is_special:
   27:             ans = self._check_nans(other, context=context)
   27:             if ans:
   21:                 return ans
       
               # self - other is computed as self + other.copy_negate()
  317:         return self.__add__(other.copy_negate(), context=context)
       
    1:     def __rsub__(self, other, context=None):
               """Return other - self"""
    2:         other = _convert_other(other)
    2:         if other is NotImplemented:
>>>>>>             return other
       
    2:         return other.__sub__(self, context=context)
       
    1:     def __mul__(self, other, context=None):
               """Return self * other.
       
               (+-) INF * 0 (or its reverse) raise InvalidOperation.
               """
  302:         other = _convert_other(other)
  302:         if other is NotImplemented:
    2:             return other
       
  300:         if context is None:
   10:             context = getcontext()
       
  300:         resultsign = self._sign ^ other._sign
       
  300:         if self._is_special or other._is_special:
   40:             ans = self._check_nans(other, context)
   40:             if ans:
   23:                 return ans
       
   17:             if self._isinfinity():
   12:                 if not other:
    2:                     return context._raise_error(InvalidOperation, '(+-)INF * 0')
   10:                 return _SignedInfinity[resultsign]
       
    5:             if other._isinfinity():
    5:                 if not self:
    2:                     return context._raise_error(InvalidOperation, '0 * (+-)INF')
    3:                 return _SignedInfinity[resultsign]
       
  260:         resultexp = self._exp + other._exp
       
               # Special case for multiplying by zero
  260:         if not self or not other:
   19:             ans = _dec_from_triple(resultsign, '0', resultexp)
                   # Fixing in case the exponent is out of bounds
   19:             ans = ans._fix(context)
   19:             return ans
       
               # Special case for multiplying by power of 10
  241:         if self._int == '1':
   25:             ans = _dec_from_triple(resultsign, other._int, resultexp)
   25:             ans = ans._fix(context)
   25:             return ans
  216:         if other._int == '1':
   21:             ans = _dec_from_triple(resultsign, self._int, resultexp)
   21:             ans = ans._fix(context)
   21:             return ans
       
  195:         op1 = _WorkRep(self)
  195:         op2 = _WorkRep(other)
       
  195:         ans = _dec_from_triple(resultsign, str(op1.int * op2.int), resultexp)
  195:         ans = ans._fix(context)
       
  195:         return ans
    1:     __rmul__ = __mul__
       
    1:     def __truediv__(self, other, context=None):
               """Return self / other."""
  369:         other = _convert_other(other)
  369:         if other is NotImplemented:
    2:             return NotImplemented
       
  367:         if context is None:
   20:             context = getcontext()
       
  367:         sign = self._sign ^ other._sign
       
  367:         if self._is_special or other._is_special:
   26:             ans = self._check_nans(other, context)
   26:             if ans:
   17:                 return ans
       
    9:             if self._isinfinity() and other._isinfinity():
    3:                 return context._raise_error(InvalidOperation, '(+-)INF/(+-)INF')
       
    6:             if self._isinfinity():
    4:                 return _SignedInfinity[sign]
       
    2:             if other._isinfinity():
    2:                 context._raise_error(Clamped, 'Division by infinity')
    2:                 return _dec_from_triple(sign, '0', context.Etiny())
       
               # Special cases for zeroes
  341:         if not other:
   30:             if not self:
    7:                 return context._raise_error(DivisionUndefined, '0 / 0')
   23:             return context._raise_error(DivisionByZero, 'x / 0', sign)
       
  311:         if not self:
   19:             exp = self._exp - other._exp
   19:             coeff = 0
               else:
                   # OK, so neither = 0, INF or NaN
  292:             shift = len(other._int) - len(self._int) + context.prec + 1
  292:             exp = self._exp - other._exp - shift
  292:             op1 = _WorkRep(self)
  292:             op2 = _WorkRep(other)
  292:             if shift >= 0:
  292:                 coeff, remainder = divmod(op1.int * 10**shift, op2.int)
                   else:
>>>>>>                 coeff, remainder = divmod(op1.int, op2.int * 10**-shift)
  292:             if remainder:
                       # result is not exact; adjust to ensure correct rounding
  175:                 if coeff % 5 == 0:
   36:                     coeff += 1
                   else:
                       # result is exact; get as close to ideal exponent as possible
  117:                 ideal_exp = self._exp - other._exp
 1915:                 while exp < ideal_exp and coeff % 10 == 0:
 1798:                     coeff //= 10
 1798:                     exp += 1
       
  311:         ans = _dec_from_triple(sign, str(coeff), exp)
  311:         return ans._fix(context)
       
    1:     def _divide(self, other, context):
               """Return (self // other, self % other), to context.prec precision.
       
               Assumes that neither self nor other is a NaN, that self is not
               infinite and that other is nonzero.
               """
  447:         sign = self._sign ^ other._sign
  447:         if other._isinfinity():
    9:             ideal_exp = self._exp
               else:
  438:             ideal_exp = min(self._exp, other._exp)
       
  447:         expdiff = self.adjusted() - other.adjusted()
  447:         if not self or other._isinfinity() or expdiff <= -2:
  155:             return (_dec_from_triple(sign, '0', 0),
  155:                     self._rescale(ideal_exp, context.rounding))
  292:         if expdiff <= context.prec:
  224:             op1 = _WorkRep(self)
  224:             op2 = _WorkRep(other)
  224:             if op1.exp >= op2.exp:
  188:                 op1.int *= 10**(op1.exp - op2.exp)
                   else:
   36:                 op2.int *= 10**(op2.exp - op1.exp)
  224:             q, r = divmod(op1.int, op2.int)
  224:             if q < 10**context.prec:
  223:                 return (_dec_from_triple(sign, str(q), 0),
  223:                         _dec_from_triple(self._sign, str(r), ideal_exp))
       
               # Here the quotient is too large to be representable
   69:         ans = context._raise_error(DivisionImpossible,
   69:                                    'quotient too large in //, % or divmod')
   69:         return ans, ans
       
    1:     def __rtruediv__(self, other, context=None):
               """Swaps self/other and returns __truediv__."""
    2:         other = _convert_other(other)
    2:         if other is NotImplemented:
>>>>>>             return other
    2:         return other.__truediv__(self, context=context)
       
    1:     __div__ = __truediv__
    1:     __rdiv__ = __rtruediv__
       
    1:     def __divmod__(self, other, context=None):
               """
               Return (self // other, self % other)
               """
   16:         other = _convert_other(other)
   16:         if other is NotImplemented:
    2:             return other
       
   14:         if context is None:
    5:             context = getcontext()
       
   14:         ans = self._check_nans(other, context)
   14:         if ans:
>>>>>>             return (ans, ans)
       
   14:         sign = self._sign ^ other._sign
   14:         if self._isinfinity():
>>>>>>             if other._isinfinity():
>>>>>>                 ans = context._raise_error(InvalidOperation, 'divmod(INF, INF)')
>>>>>>                 return ans, ans
                   else:
>>>>>>                 return (_SignedInfinity[sign],
>>>>>>                         context._raise_error(InvalidOperation, 'INF % x'))
       
   14:         if not other:
>>>>>>             if not self:
>>>>>>                 ans = context._raise_error(DivisionUndefined, 'divmod(0, 0)')
>>>>>>                 return ans, ans
                   else:
>>>>>>                 return (context._raise_error(DivisionByZero, 'x // 0', sign),
>>>>>>                         context._raise_error(InvalidOperation, 'x % 0'))
       
   14:         quotient, remainder = self._divide(other, context)
   14:         remainder = remainder._fix(context)
   14:         return quotient, remainder
       
    1:     def __rdivmod__(self, other, context=None):
               """Swaps self/other and returns __divmod__."""
    2:         other = _convert_other(other)
    2:         if other is NotImplemented:
>>>>>>             return other
    2:         return other.__divmod__(self, context=context)
       
    1:     def __mod__(self, other, context=None):
               """
               self % other
               """
  271:         other = _convert_other(other)
  271:         if other is NotImplemented:
    2:             return other
       
  269:         if context is None:
    8:             context = getcontext()
       
  269:         ans = self._check_nans(other, context)
  269:         if ans:
   13:             return ans
       
  256:         if self._isinfinity():
    2:             return context._raise_error(InvalidOperation, 'INF % x')
  254:         elif not other:
    6:             if self:
    4:                 return context._raise_error(InvalidOperation, 'x % 0')
                   else:
    2:                 return context._raise_error(DivisionUndefined, '0 % 0')
       
  248:         remainder = self._divide(other, context)[1]
  248:         remainder = remainder._fix(context)
  248:         return remainder
       
    1:     def __rmod__(self, other, context=None):
               """Swaps self/other and returns __mod__."""
    2:         other = _convert_other(other)
    2:         if other is NotImplemented:
>>>>>>             return other
    2:         return other.__mod__(self, context=context)
       
    1:     def remainder_near(self, other, context=None):
               """
               Remainder nearest to 0-  abs(remainder-near) <= other/2
               """
  157:         if context is None:
    3:             context = getcontext()
       
  157:         other = _convert_other(other, raiseit=True)
       
  156:         ans = self._check_nans(other, context)
  156:         if ans:
   14:             return ans
       
               # self == +/-infinity -> InvalidOperation
  142:         if self._isinfinity():
    5:             return context._raise_error(InvalidOperation,
    5:                                         'remainder_near(infinity, x)')
       
               # other == 0 -> either InvalidOperation or DivisionUndefined
  137:         if not other:
   11:             if self:
    8:                 return context._raise_error(InvalidOperation,
    8:                                             'remainder_near(x, 0)')
                   else:
    3:                 return context._raise_error(DivisionUndefined,
    3:                                             'remainder_near(0, 0)')
       
               # other = +/-infinity -> remainder = self
  126:         if other._isinfinity():
    3:             ans = Decimal(self)
    3:             return ans._fix(context)
       
               # self = 0 -> remainder = self, with ideal exponent
  123:         ideal_exponent = min(self._exp, other._exp)
  123:         if not self:
   10:             ans = _dec_from_triple(self._sign, '0', ideal_exponent)
   10:             return ans._fix(context)
       
               # catch most cases of large or small quotient
  113:         expdiff = self.adjusted() - other.adjusted()
  113:         if expdiff >= context.prec + 1:
                   # expdiff >= prec+1 => abs(self/other) > 10**prec
    2:             return context._raise_error(DivisionImpossible)
  111:         if expdiff <= -2:
                   # expdiff <= -2 => abs(self/other) < 0.1
   19:             ans = self._rescale(ideal_exponent, context.rounding)
   19:             return ans._fix(context)
       
               # adjust both arguments to have the same exponent, then divide
   92:         op1 = _WorkRep(self)
   92:         op2 = _WorkRep(other)
   92:         if op1.exp >= op2.exp:
   68:             op1.int *= 10**(op1.exp - op2.exp)
               else:
   24:             op2.int *= 10**(op2.exp - op1.exp)
   92:         q, r = divmod(op1.int, op2.int)
               # remainder is r*10**ideal_exponent; other is +/-op2.int *
               # 10**ideal_exponent.   Apply correction to ensure that
               # abs(remainder) <= abs(other)/2
   92:         if 2*r + (q&1) > op2.int:
   19:             r -= op2.int
   19:             q += 1
       
   92:         if q >= 10**context.prec:
>>>>>>             return context._raise_error(DivisionImpossible)
       
               # result has same sign as self unless r is negative
   92:         sign = self._sign
   92:         if r < 0:
   19:             sign = 1-sign
   19:             r = -r
       
   92:         ans = _dec_from_triple(sign, str(r), ideal_exponent)
   92:         return ans._fix(context)
       
    1:     def __floordiv__(self, other, context=None):
               """self // other"""
  225:         other = _convert_other(other)
  225:         if other is NotImplemented:
    2:             return other
       
  223:         if context is None:
    8:             context = getcontext()
       
  223:         ans = self._check_nans(other, context)
  223:         if ans:
   17:             return ans
       
  206:         if self._isinfinity():
    5:             if other._isinfinity():
    1:                 return context._raise_error(InvalidOperation, 'INF // INF')
                   else:
    4:                 return _SignedInfinity[self._sign ^ other._sign]
       
  201:         if not other:
   16:             if self:
   13:                 return context._raise_error(DivisionByZero, 'x // 0',
   13:                                             self._sign ^ other._sign)
                   else:
    3:                 return context._raise_error(DivisionUndefined, '0 // 0')
       
  185:         return self._divide(other, context)[0]
       
    1:     def __rfloordiv__(self, other, context=None):
               """Swaps self/other and returns __floordiv__."""
    2:         other = _convert_other(other)
    2:         if other is NotImplemented:
>>>>>>             return other
    2:         return other.__floordiv__(self, context=context)
       
    1:     def __float__(self):
               """Float representation."""
  998:         if self._isnan():
    8:             if self.is_snan():
    4:                 raise ValueError("Cannot convert signaling NaN to float")
    4:             s = "-nan" if self._sign else "nan"
               else:
  990:             s = str(self)
  994:         return float(s)
       
    1:     def __int__(self):
               """Converts self to an int, truncating if necessary."""
 3004:         if self._is_special:
    8:             if self._isnan():
    4:                 raise ValueError("Cannot convert NaN to integer")
    4:             elif self._isinfinity():
    4:                 raise OverflowError("Cannot convert infinity to integer")
 2996:         s = (-1)**self._sign
 2996:         if self._exp >= 0:
  986:             return s*int(self._int)*10**self._exp
               else:
 2010:             return s*int(self._int[:self._exp] or '0')
       
    1:     __trunc__ = __int__
       
    1:     def real(self):
>>>>>>         return self
    1:     real = property(real)
       
    1:     def imag(self):
>>>>>>         return Decimal(0)
    1:     imag = property(imag)
       
    1:     def conjugate(self):
>>>>>>         return self
       
    1:     def __complex__(self):
>>>>>>         return complex(float(self))
       
    1:     def __long__(self):
               """Converts to a long.
       
               Equivalent to long(int(self))
               """
    7:         return long(self.__int__())
       
    1:     def _fix_nan(self, context):
               """Decapitate the payload of a NaN to fit the context"""
  541:         payload = self._int
       
               # maximum length of payload is precision if _clamp=0,
               # precision-1 if _clamp=1.
  541:         max_payload_len = context.prec - context._clamp
  541:         if len(payload) > max_payload_len:
    3:             payload = payload[len(payload)-max_payload_len:].lstrip('0')
    3:             return _dec_from_triple(self._sign, payload, self._exp, True)
  538:         return Decimal(self)
       
    1:     def _fix(self, context):
               """Round if it is necessary to keep self within prec precision.
       
               Rounds and fixes the exponent.  Does not raise on a sNaN.
       
               Arguments:
               self - Decimal instance
               context - context used.
               """
       
 4675:         if self._is_special:
  139:             if self._isnan():
                       # decapitate payload if necessary
   97:                 return self._fix_nan(context)
                   else:
                       # self is +/-Infinity; return unaltered
   42:                 return Decimal(self)
       
               # if self is zero then exponent should be between Etiny and
               # Emax if _clamp==0, and between Etiny and Etop if _clamp==1.
 4536:         Etiny = context.Etiny()
 4536:         Etop = context.Etop()
 4536:         if not self:
  544:             exp_max = [context.Emax, Etop][context._clamp]
  544:             new_exp = min(max(self._exp, Etiny), exp_max)
  544:             if new_exp != self._exp:
   36:                 context._raise_error(Clamped)
   36:                 return _dec_from_triple(self._sign, '0', new_exp)
                   else:
  508:                 return Decimal(self)
       
               # exp_min is the smallest allowable exponent of the result,
               # equal to max(self.adjusted()-context.prec+1, Etiny)
 3992:         exp_min = len(self._int) + self._exp - context.prec
 3992:         if exp_min > Etop:
                   # overflow: exp_min > Etop iff self.adjusted() > Emax
   74:             ans = context._raise_error(Overflow, 'above Emax', self._sign)
   74:             context._raise_error(Inexact)
   74:             context._raise_error(Rounded)
   74:             return ans
       
 3918:         self_is_subnormal = exp_min < Etiny
 3918:         if self_is_subnormal:
  358:             exp_min = Etiny
       
               # round if self has too many digits
 3918:         if self._exp < exp_min:
 2099:             digits = len(self._int) + self._exp - exp_min
 2099:             if digits < 0:
   60:                 self = _dec_from_triple(self._sign, '1', exp_min-1)
   60:                 digits = 0
 2099:             rounding_method = self._pick_rounding_function[context.rounding]
 2099:             changed = rounding_method(self, digits)
 2099:             coeff = self._int[:digits] or '0'
 2099:             if changed > 0:
  975:                 coeff = str(int(coeff)+1)
  975:                 if len(coeff) > context.prec:
   94:                     coeff = coeff[:-1]
   94:                     exp_min += 1
       
                   # check whether the rounding pushed the exponent out of range
 2099:             if exp_min > Etop:
   15:                 ans = context._raise_error(Overflow, 'above Emax', self._sign)
                   else:
 2084:                 ans = _dec_from_triple(self._sign, coeff, exp_min)
       
                   # raise the appropriate signals, taking care to respect
                   # the precedence described in the specification
 2099:             if changed and self_is_subnormal:
  231:                 context._raise_error(Underflow)
 2099:             if self_is_subnormal:
  247:                 context._raise_error(Subnormal)
 2099:             if changed:
 1988:                 context._raise_error(Inexact)
 2097:             context._raise_error(Rounded)
 2097:             if not ans:
                       # raise Clamped on underflow to 0
   95:                 context._raise_error(Clamped)
 2097:             return ans
       
 1819:         if self_is_subnormal:
  111:             context._raise_error(Subnormal)
       
               # fold down if _clamp == 1 and self has too few digits
 1819:         if context._clamp == 1 and self._exp > Etop:
   21:             context._raise_error(Clamped)
   21:             self_padded = self._int + '0'*(self._exp - Etop)
   21:             return _dec_from_triple(self._sign, self_padded, Etop)
       
               # here self was representable to begin with; return unchanged
 1798:         return Decimal(self)
       
           # for each of the rounding functions below:
           #   self is a finite, nonzero Decimal
           #   prec is an integer satisfying 0 <= prec < len(self._int)
           #
           # each function returns either -1, 0, or 1, as follows:
           #   1 indicates that self should be rounded up (away from zero)
           #   0 indicates that self should be truncated, and that all the
           #     digits to be truncated are zeros (so the value is unchanged)
           #  -1 indicates that there are nonzero digits to be truncated
       
    1:     def _round_down(self, prec):
               """Also known as round-towards-0, truncate."""
 1328:         if _all_zeros(self._int, prec):
   22:             return 0
               else:
 1306:             return -1
       
    1:     def _round_up(self, prec):
               """Rounds away from 0."""
   35:         return -self._round_down(prec)
       
    1:     def _round_half_up(self, prec):
               """Rounds 5 up (away from 0)"""
 1903:         if self._int[prec] in '56789':
  906:             return 1
  997:         elif _all_zeros(self._int, prec):
  111:             return 0
               else:
  886:             return -1
       
    1:     def _round_half_down(self, prec):
               """Round 5 down"""
   27:         if _exact_half(self._int, prec):
    3:             return -1
               else:
   24:             return self._round_half_up(prec)
       
    1:     def _round_half_even(self, prec):
               """Round 5 to even, rest to nearest."""
 1268:         if _exact_half(self._int, prec) and \
   79:                 (prec == 0 or self._int[prec-1] in '02468'):
   30:             return -1
               else:
 1238:             return self._round_half_up(prec)
       
    1:     def _round_ceiling(self, prec):
               """Rounds up (not away from 0 if negative.)"""
  103:         if self._sign:
   42:             return self._round_down(prec)
               else:
   61:             return -self._round_down(prec)
       
    1:     def _round_floor(self, prec):
               """Rounds down (not towards 0 if negative)"""
   89:         if not self._sign:
   58:             return self._round_down(prec)
               else:
   31:             return -self._round_down(prec)
       
    1:     def _round_05up(self, prec):
               """Round down unless digit prec-1 is 0 or 5."""
   27:         if prec and self._int[prec-1] not in '05':
   18:             return self._round_down(prec)
               else:
    9:             return -self._round_down(prec)
       
    1:     _pick_rounding_function = dict(
    1:         ROUND_DOWN = _round_down,
    1:         ROUND_UP = _round_up,
    1:         ROUND_HALF_UP = _round_half_up,
    1:         ROUND_HALF_DOWN = _round_half_down,
    1:         ROUND_HALF_EVEN = _round_half_even,
    1:         ROUND_CEILING = _round_ceiling,
    1:         ROUND_FLOOR = _round_floor,
    1:         ROUND_05UP = _round_05up,
           )
       
    1:     def fma(self, other, third, context=None):
               """Fused multiply-add.
       
               Returns self*other+third with no rounding of the intermediate
               product self*other.
       
               self and other are multiplied together, with no rounding of
               the result.  The third operand is then added to the result,
               and a single final rounding is performed.
               """
       
  580:         other = _convert_other(other, raiseit=True)
       
               # compute product; raise InvalidOperation if either operand is
               # a signaling NaN or if the product is zero times infinity.
  579:         if self._is_special or other._is_special:
   65:             if context is None:
>>>>>>                 context = getcontext()
   65:             if self._exp == 'N':
    5:                 return context._raise_error(InvalidOperation, 'sNaN', self)
   60:             if other._exp == 'N':
   17:                 return context._raise_error(InvalidOperation, 'sNaN', other)
   43:             if self._exp == 'n':
    8:                 product = self
   35:             elif other._exp == 'n':
    4:                 product = other
   31:             elif self._exp == 'F':
   13:                 if not other:
>>>>>>                     return context._raise_error(InvalidOperation,
>>>>>>                                                 'INF * 0 in fma')
   13:                 product = _SignedInfinity[self._sign ^ other._sign]
   18:             elif other._exp == 'F':
   18:                 if not self:
    4:                     return context._raise_error(InvalidOperation,
    4:                                                 '0 * INF in fma')
   14:                 product = _SignedInfinity[self._sign ^ other._sign]
               else:
  514:             product = _dec_from_triple(self._sign ^ other._sign,
  514:                                        str(int(self._int) * int(other._int)),
  514:                                        self._exp + other._exp)
       
  553:         third = _convert_other(third, raiseit=True)
  552:         return product.__add__(third, context)
       
    1:     def _power_modulo(self, other, modulo, context=None):
               """Three argument version of __pow__"""
       
               # if can't convert other and modulo to Decimal, raise
               # TypeError; there's no point returning NotImplemented (no
               # equivalent of __rpow__ for three argument pow)
   58:         other = _convert_other(other, raiseit=True)
   57:         modulo = _convert_other(modulo, raiseit=True)
       
   56:         if context is None:
>>>>>>             context = getcontext()
       
               # deal with NaNs: if there are any sNaNs then first one wins,
               # (i.e. behaviour for NaNs is identical to that of fma)
   56:         self_is_nan = self._isnan()
   56:         other_is_nan = other._isnan()
   56:         modulo_is_nan = modulo._isnan()
   56:         if self_is_nan or other_is_nan or modulo_is_nan:
    1:             if self_is_nan == 2:
>>>>>>                 return context._raise_error(InvalidOperation, 'sNaN',
>>>>>>                                         self)
    1:             if other_is_nan == 2:
    1:                 return context._raise_error(InvalidOperation, 'sNaN',
    1:                                         other)
>>>>>>             if modulo_is_nan == 2:
>>>>>>                 return context._raise_error(InvalidOperation, 'sNaN',
>>>>>>                                         modulo)
>>>>>>             if self_is_nan:
>>>>>>                 return self._fix_nan(context)
>>>>>>             if other_is_nan:
>>>>>>                 return other._fix_nan(context)
>>>>>>             return modulo._fix_nan(context)
       
               # check inputs: we apply same restrictions as Python's pow()
   55:         if not (self._isinteger() and
   55:                 other._isinteger() and
   55:                 modulo._isinteger()):
>>>>>>             return context._raise_error(InvalidOperation,
>>>>>>                                         'pow() 3rd argument not allowed '
                                               'unless all arguments are integers')
   55:         if other < 0:
>>>>>>             return context._raise_error(InvalidOperation,
>>>>>>                                         'pow() 2nd argument cannot be '
                                               'negative when 3rd argument specified')
   55:         if not modulo:
>>>>>>             return context._raise_error(InvalidOperation,
>>>>>>                                         'pow() 3rd argument cannot be 0')
       
               # additional restriction for decimal: the modulus must be less
               # than 10**prec in absolute value
   55:         if modulo.adjusted() >= context.prec:
>>>>>>             return context._raise_error(InvalidOperation,
>>>>>>                                         'insufficient precision: pow() 3rd '
                                               'argument must not have more than '
                                               'precision digits')
       
               # define 0**0 == NaN, for consistency with two-argument pow
               # (even though it hurts!)
   55:         if not other and not self:
    3:             return context._raise_error(InvalidOperation,
    3:                                         'at least one of pow() 1st argument '
                                               'and 2nd argument must be nonzero ;'
                                               '0**0 is not defined')
       
               # compute sign of result
   52:         if other._iseven():
   32:             sign = 0
               else:
   20:             sign = self._sign
       
               # convert modulo to a Python integer, and self and other to
               # Decimal integers (i.e. force their exponents to be >= 0)
   52:         modulo = abs(int(modulo))
   52:         base = _WorkRep(self.to_integral_value())
   52:         exponent = _WorkRep(other.to_integral_value())
       
               # compute result using integer pow()
   52:         base = (base.int % modulo * pow(10, base.exp, modulo)) % modulo
  250:         for i in xrange(exponent.exp):
  198:             base = pow(base, 10, modulo)
   52:         base = pow(base, exponent.int, modulo)
       
   52:         return _dec_from_triple(sign, str(base), 0)
       
    1:     def _power_exact(self, other, p):
               """Attempt to compute self**other exactly.
       
               Given Decimals self and other and an integer p, attempt to
               compute an exact result for the power self**other, with p
               digits of precision.  Return None if self**other is not
               exactly representable in p digits.
       
               Assumes that elimination of special cases has already been
               performed: self and other must both be nonspecial; self must
               be positive and not numerically equal to 1; other must be
               nonzero.  For efficiency, other._exp should not be too large,
               so that 10**abs(other._exp) is a feasible calculation."""
       
               # In the comments below, we write x for the value of self and y for the
               # value of other.  Write x = xc*10**xe and abs(y) = yc*10**ye, with xc
               # and yc positive integers not divisible by 10.
       
               # The main purpose of this method is to identify the *failure*
               # of x**y to be exactly representable with as little effort as
               # possible.  So we look for cheap and easy tests that
               # eliminate the possibility of x**y being exact.  Only if all
               # these tests are passed do we go on to actually compute x**y.
       
               # Here's the main idea.  Express y as a rational number m/n, with m and
               # n relatively prime and n>0.  Then for x**y to be exactly
               # representable (at *any* precision), xc must be the nth power of a
               # positive integer and xe must be divisible by n.  If y is negative
               # then additionally xc must be a power of either 2 or 5, hence a power
               # of 2**n or 5**n.
               #
               # There's a limit to how small |y| can be: if y=m/n as above
               # then:
               #
               #  (1) if xc != 1 then for the result to be representable we
               #      need xc**(1/n) >= 2, and hence also xc**|y| >= 2.  So
               #      if |y| <= 1/nbits(xc) then xc < 2**nbits(xc) <=
               #      2**(1/|y|), hence xc**|y| < 2 and the result is not
               #      representable.
               #
               #  (2) if xe != 0, |xe|*(1/n) >= 1, so |xe|*|y| >= 1.  Hence if
               #      |y| < 1/|xe| then the result is not representable.
               #
               # Note that since x is not equal to 1, at least one of (1) and
               # (2) must apply.  Now |y| < 1/nbits(xc) iff |yc|*nbits(xc) <
               # 10**-ye iff len(str(|yc|*nbits(xc)) <= -ye.
               #
               # There's also a limit to how large y can be, at least if it's
               # positive: the normalized result will have coefficient xc**y,
               # so if it's representable then xc**y < 10**p, and y <
               # p/log10(xc).  Hence if y*log10(xc) >= p then the result is
               # not exactly representable.
       
               # if len(str(abs(yc*xe)) <= -ye then abs(yc*xe) < 10**-ye,
               # so |y| < 1/xe and the result is not representable.
               # Similarly, len(str(abs(yc)*xc_bits)) <= -ye implies |y|
               # < 1/nbits(xc).
       
  426:         x = _WorkRep(self)
  426:         xc, xe = x.int, x.exp
  513:         while xc % 10 == 0:
   87:             xc //= 10
   87:             xe += 1
       
  426:         y = _WorkRep(other)
  426:         yc, ye = y.int, y.exp
  464:         while yc % 10 == 0:
   38:             yc //= 10
   38:             ye += 1
       
               # case where xc == 1: result is 10**(xe*y), with xe*y
               # required to be an integer
  426:         if xc == 1:
   33:             xe *= yc
                   # result is now 10**(xe * 10**ye);  xe * 10**ye must be integral
   36:             while xe % 10 == 0:
    3:                 xe //= 10
    3:                 ye += 1
   33:             if ye < 0:
   13:                 return None
   20:             exponent = xe * 10**ye
   20:             if y.sign == 1:
    2:                 exponent = -exponent
                   # if other is a nonnegative integer, use ideal exponent
   20:             if other._isinteger() and other._sign == 0:
   17:                 ideal_exponent = self._exp*int(other)
   17:                 zeros = min(exponent-ideal_exponent, p-1)
                   else:
    3:                 zeros = 0
   20:             return _dec_from_triple(0, '1' + '0'*zeros, exponent-zeros)
       
               # case where y is negative: xc must be either a power
               # of 2 or a power of 5.
  393:         if y.sign == 1:
   67:             last_digit = xc % 10
   67:             if last_digit in (2,4,6,8):
                       # quick test for power of 2
   29:                 if xc & -xc != xc:
   23:                     return None
                       # now xc is a power of 2; e is its exponent
    6:                 e = _nbits(xc)-1
       
                       # We now have:
                       #
                       #   x = 2**e * 10**xe, e > 0, and y < 0.
                       #
                       # The exact result is:
                       #
                       #   x**y = 5**(-e*y) * 10**(e*y + xe*y)
                       #
                       # provided that both e*y and xe*y are integers.  Note that if
                       # 5**(-e*y) >= 10**p, then the result can't be expressed
                       # exactly with p digits of precision.
                       #
                       # Using the above, we can guard against large values of ye.
                       # 93/65 is an upper bound for log(10)/log(5), so if
                       #
                       #   ye >= len(str(93*p//65))
                       #
                       # then
                       #
                       #   -e*y >= -y >= 10**ye > 93*p/65 > p*log(10)/log(5),
                       #
                       # so 5**(-e*y) >= 10**p, and the coefficient of the result
                       # can't be expressed in p digits.
       
                       # emax >= largest e such that 5**e < 10**p.
    6:                 emax = p*93//65
    6:                 if ye >= len(str(emax)):
>>>>>>                     return None
       
                       # Find -e*y and -xe*y; both must be integers
    6:                 e = _decimal_lshift_exact(e * yc, ye)
    6:                 xe = _decimal_lshift_exact(xe * yc, ye)
    6:                 if e is None or xe is None:
>>>>>>                     return None
       
    6:                 if e > emax:
    1:                     return None
    5:                 xc = 5**e
       
   38:             elif last_digit == 5:
                       # e >= log_5(xc) if xc is a power of 5; we have
                       # equality all the way up to xc=5**2658
   15:                 e = _nbits(xc)*28//65
   15:                 xc, remainder = divmod(5**e, xc)
   15:                 if remainder:
   11:                     return None
    4:                 while xc % 5 == 0:
>>>>>>                     xc //= 5
>>>>>>                     e -= 1
       
                       # Guard against large values of ye, using the same logic as in
                       # the 'xc is a power of 2' branch.  10/3 is an upper bound for
                       # log(10)/log(2).
    4:                 emax = p*10//3
    4:                 if ye >= len(str(emax)):
>>>>>>                     return None
       
    4:                 e = _decimal_lshift_exact(e * yc, ye)
    4:                 xe = _decimal_lshift_exact(xe * yc, ye)
    4:                 if e is None or xe is None:
>>>>>>                     return None
       
    4:                 if e > emax:
>>>>>>                     return None
    4:                 xc = 2**e
                   else:
   23:                 return None
       
    9:             if xc >= 10**p:
>>>>>>                 return None
    9:             xe = -e-xe
    9:             return _dec_from_triple(0, str(xc), xe)
       
               # now y is positive; find m and n such that y = m/n
  326:         if ye >= 0:
   60:             m, n = yc*10**ye, 1
               else:
  266:             if xe != 0 and len(str(abs(yc*xe))) <= -ye:
   25:                 return None
  241:             xc_bits = _nbits(xc)
  241:             if xc != 1 and len(str(abs(yc)*xc_bits)) <= -ye:
>>>>>>                 return None
  241:             m, n = yc, 10**(-ye)
  259:             while m % 2 == n % 2 == 0:
   18:                 m //= 2
   18:                 n //= 2
  468:             while m % 5 == n % 5 == 0:
  227:                 m //= 5
  227:                 n //= 5
       
               # compute nth root of xc*10**xe
  301:         if n > 1:
                   # if 1 < xc < 2**n then xc isn't an nth power
  241:             if xc != 1 and xc_bits <= n:
   22:                 return None
       
  219:             xe, rem = divmod(xe, n)
  219:             if rem != 0:
  107:                 return None
       
                   # compute nth root of xc using Newton's method
  112:             a = 1L << -(-_nbits(xc)//n) # initial estimate
  286:             while True:
  286:                 q, r = divmod(xc, a**(n-1))
  286:                 if a <= q:
  112:                     break
                       else:
  174:                     a = (a*(n-1) + q)//n
  112:             if not (a == q and r == 0):
  103:                 return None
    9:             xc = a
       
               # now xc*10**xe is the nth root of the original xc*10**xe
               # compute mth power of xc*10**xe
       
               # if m > p*100//_log10_lb(xc) then m > p/log10(xc), hence xc**m >
               # 10**p and the result is not representable.
   69:         if xc > 1 and m > p*100//_log10_lb(xc):
   41:             return None
   28:         xc = xc**m
   28:         xe *= m
   28:         if xc > 10**p:
>>>>>>             return None
       
               # by this point the result *is* exactly representable
               # adjust the exponent to get as close as possible to the ideal
               # exponent, if necessary
   28:         str_xc = str(xc)
   28:         if other._isinteger() and other._sign == 0:
   19:             ideal_exponent = self._exp*int(other)
   19:             zeros = min(xe-ideal_exponent, p-len(str_xc))
               else:
    9:             zeros = 0
   28:         return _dec_from_triple(0, str_xc+'0'*zeros, xe-zeros)
       
    1:     def __pow__(self, other, modulo=None, context=None):
               """Return self ** other [ % modulo].
       
               With two arguments, compute self**other.
       
               With three arguments, compute (self**other) % modulo.  For the
               three argument form, the following restrictions on the
               arguments hold:
       
                - all three arguments must be integral
                - other must be nonnegative
                - either self or other (or both) must be nonzero
                - modulo must be nonzero and must have at most p digits,
                  where p is the context precision.
       
               If any of these restrictions is violated the InvalidOperation
               flag is raised.
       
               The result of pow(self, other, modulo) is identical to the
               result that would be obtained by computing (self**other) %
               modulo with unbounded precision, but is computed more
               efficiently.  It is always exact.
               """
       
  549:         if modulo is not None:
   58:             return self._power_modulo(other, modulo, context)
       
  491:         other = _convert_other(other)
  491:         if other is NotImplemented:
    1:             return other
       
  490:         if context is None:
    9:             context = getcontext()
       
               # either argument is a NaN => result is NaN
  490:         ans = self._check_nans(other, context)
  490:         if ans:
    7:             return ans
       
               # 0**0 = NaN (!), x**0 = 1 for nonzero x (including +/-Infinity)
  483:         if not other:
   10:             if not self:
    1:                 return context._raise_error(InvalidOperation, '0 ** 0')
                   else:
    9:                 return _One
       
               # result has sign 1 iff self._sign is 1 and other is an odd integer
  473:         result_sign = 0
  473:         if self._sign == 1:
   59:             if other._isinteger():
   54:                 if not other._iseven():
   23:                     result_sign = 1
                   else:
                       # -ve**noninteger = NaN
                       # (-0)**noninteger = 0**noninteger
    5:                 if self:
    5:                     return context._raise_error(InvalidOperation,
    5:                         'x ** y with x negative and y not an integer')
                   # negate self, without doing any unwanted rounding
   54:             self = self.copy_negate()
       
               # 0**(+ve or Inf)= 0; 0**(-ve or -Inf) = Infinity
  468:         if not self:
    4:             if other._sign == 0:
    3:                 return _dec_from_triple(result_sign, '0', 0)
                   else:
    1:                 return _SignedInfinity[result_sign]
       
               # Inf**(+ve or Inf) = Inf; Inf**(-ve or -Inf) = 0
  464:         if self._isinfinity():
    7:             if other._sign == 0:
    4:                 return _SignedInfinity[result_sign]
                   else:
    3:                 return _dec_from_triple(result_sign, '0', 0)
       
               # 1**other = 1, but the choice of exponent and the flags
               # depend on the exponent of self, and on whether other is a
               # positive integer, a negative integer, or neither
  457:         if self == _One:
    6:             if other._isinteger():
                       # exp = max(self._exp*max(int(other), 0),
                       # 1-context.prec) but evaluating int(other) directly
                       # is dangerous until we know other is small (other
                       # could be 1e999999999)
    4:                 if other._sign == 1:
    1:                     multiplier = 0
    3:                 elif other > context.prec:
    3:                     multiplier = context.prec
                       else:
>>>>>>                     multiplier = int(other)
       
    4:                 exp = self._exp * multiplier
    4:                 if exp < 1-context.prec:
>>>>>>                     exp = 1-context.prec
>>>>>>                     context._raise_error(Rounded)
                   else:
    2:                 context._raise_error(Inexact)
    2:                 context._raise_error(Rounded)
    2:                 exp = 1-context.prec
       
    6:             return _dec_from_triple(result_sign, '1'+'0'*-exp, exp)
       
               # compute adjusted exponent of self
  451:         self_adj = self.adjusted()
       
               # self ** infinity is infinity if self > 1, 0 if self < 1
               # self ** -infinity is infinity if self < 1, 0 if self > 1
  451:         if other._isinfinity():
    1:             if (other._sign == 0) == (self_adj < 0):
>>>>>>                 return _dec_from_triple(result_sign, '0', 0)
                   else:
    1:                 return _SignedInfinity[result_sign]
       
               # from here on, the result always goes through the call
               # to _fix at the end of this function.
  450:         ans = None
  450:         exact = False
       
               # crude test to catch cases of extreme overflow/underflow.  If
               # log10(self)*other >= 10**bound and bound >= len(str(Emax))
               # then 10**bound >= 10**len(str(Emax)) >= Emax+1 and hence
               # self**other >= 10**(Emax+1), so overflow occurs.  The test
               # for underflow is similar.
  450:         bound = self._log10_exp_bound() + other.adjusted()
  450:         if (self_adj >= 0) == (other._sign == 0):
                   # self > 1 and other +ve, or self < 1 and other -ve
                   # possibility of overflow
  151:             if bound >= len(str(context.Emax)):
   13:                 ans = _dec_from_triple(result_sign, '1', context.Emax+1)
               else:
                   # self > 1 and other -ve, or self < 1 and other +ve
                   # possibility of underflow to 0
  299:             Etiny = context.Etiny()
  299:             if bound >= len(str(-Etiny)):
   11:                 ans = _dec_from_triple(result_sign, '1', Etiny-1)
       
               # try for an exact result with precision +1
  450:         if ans is None:
  426:             ans = self._power_exact(other, context.prec + 1)
  426:             if ans is not None:
   57:                 if result_sign == 1:
    4:                     ans = _dec_from_triple(1, ans._int, ans._exp)
   57:                 exact = True
       
               # usual case: inexact result, x**y computed directly as exp(y*log(x))
  450:         if ans is None:
  369:             p = context.prec
  369:             x = _WorkRep(self)
  369:             xc, xe = x.int, x.exp
  369:             y = _WorkRep(other)
  369:             yc, ye = y.int, y.exp
  369:             if y.sign == 1:
   58:                 yc = -yc
       
                   # compute correctly rounded result:  start with precision +3,
                   # then increase precision until result is unambiguously roundable
  369:             extra = 3
  370:             while True:
  370:                 coeff, exp = _dpower(xc, xe, yc, ye, p+extra)
  370:                 if coeff % (5*10**(len(str(coeff))-p-1)):
  369:                     break
    1:                 extra += 3
       
  369:             ans = _dec_from_triple(result_sign, str(coeff), exp)
       
               # unlike exp, ln and log10, the power function respects the
               # rounding mode; no need to switch to ROUND_HALF_EVEN here
       
               # There's a difficulty here when 'other' is not an integer and
               # the result is exact.  In this case, the specification
               # requires that the Inexact flag be raised (in spite of
               # exactness), but since the result is exact _fix won't do this
               # for us.  (Correspondingly, the Underflow signal should also
               # be raised for subnormal results.)  We can't directly raise
               # these signals either before or after calling _fix, since
               # that would violate the precedence for signals.  So we wrap
               # the ._fix call in a temporary context, and reraise
               # afterwards.
  450:         if exact and not other._isinteger():
                   # pad with zeros up to length context.prec+1 if necessary; this
                   # ensures that the Rounded signal will be raised.
   11:             if len(ans._int) <= context.prec:
   11:                 expdiff = context.prec + 1 - len(ans._int)
   11:                 ans = _dec_from_triple(ans._sign, ans._int+'0'*expdiff,
   11:                                        ans._exp-expdiff)
       
                   # create a copy of the current context, with cleared flags/traps
   11:             newcontext = context.copy()
   11:             newcontext.clear_flags()
   99:             for exception in _signals:
   88:                 newcontext.traps[exception] = 0
       
                   # round in the new context
   11:             ans = ans._fix(newcontext)
       
                   # raise Inexact, and if necessary, Underflow
   11:             newcontext._raise_error(Inexact)
   11:             if newcontext.flags[Subnormal]:
>>>>>>                 newcontext._raise_error(Underflow)
       
                   # propagate signals to the original context; _fix could
                   # have raised any of Overflow, Underflow, Subnormal,
                   # Inexact, Rounded, Clamped.  Overflow needs the correct
                   # arguments.  Note that the order of the exceptions is
                   # important here.
   11:             if newcontext.flags[Overflow]:
>>>>>>                 context._raise_error(Overflow, 'above Emax', ans._sign)
   66:             for exception in Underflow, Subnormal, Inexact, Rounded, Clamped:
   55:                 if newcontext.flags[exception]:
   22:                     context._raise_error(exception)
       
               else:
  439:             ans = ans._fix(context)
       
  450:         return ans
       
    1:     def __rpow__(self, other, context=None):
               """Swaps self/other and returns __pow__."""
    2:         other = _convert_other(other)
    2:         if other is NotImplemented:
>>>>>>             return other
    2:         return other.__pow__(self, context=context)
       
    1:     def normalize(self, context=None):
               """Normalize- strip trailing 0s, change anything equal to 0 to 0e0"""
       
   51:         if context is None:
    1:             context = getcontext()
       
   51:         if self._is_special:
    3:             ans = self._check_nans(context=context)
    3:             if ans:
    3:                 return ans
       
   48:         dup = self._fix(context)
   48:         if dup._isinfinity():
    1:             return dup
       
   47:         if not dup:
   11:             return _dec_from_triple(dup._sign, '0', 0)
   36:         exp_max = [context.Emax, context.Etop()][context._clamp]
   36:         end = len(dup._int)
   36:         exp = dup._exp
   79:         while dup._int[end-1] == '0' and exp < exp_max:
   43:             exp += 1
   43:             end -= 1
   36:         return _dec_from_triple(dup._sign, dup._int[:end], exp)
       
    1:     def quantize(self, exp, rounding=None, context=None, watchexp=True):
               """Quantize self so its exponent is the same as that of exp.
       
               Similar to self._rescale(exp._exp) but with error checking.
               """
  228:         exp = _convert_other(exp, raiseit=True)
       
  227:         if context is None:
    3:             context = getcontext()
  227:         if rounding is None:
  227:             rounding = context.rounding
       
  227:         if self._is_special or exp._is_special:
   30:             ans = self._check_nans(exp, context)
   30:             if ans:
   18:                 return ans
       
   12:             if exp._isinfinity() or self._isinfinity():
   12:                 if exp._isinfinity() and self._isinfinity():
    3:                     return Decimal(self)  # if both are inf, it is OK
    9:                 return context._raise_error(InvalidOperation,
    9:                                         'quantize with one INF')
       
               # if we're not watching exponents, do a simple rescale
  197:         if not watchexp:
>>>>>>             ans = self._rescale(exp._exp, rounding)
                   # raise Inexact and Rounded where appropriate
>>>>>>             if ans._exp > self._exp:
>>>>>>                 context._raise_error(Rounded)
>>>>>>                 if ans != self:
>>>>>>                     context._raise_error(Inexact)
>>>>>>             return ans
       
               # exp._exp should be between Etiny and Emax
  197:         if not (context.Etiny() <= exp._exp <= context.Emax):
    3:             return context._raise_error(InvalidOperation,
    3:                    'target exponent out of bounds in quantize')
       
  194:         if not self:
   15:             ans = _dec_from_triple(self._sign, '0', exp._exp)
   15:             return ans._fix(context)
       
  179:         self_adjusted = self.adjusted()
  179:         if self_adjusted > context.Emax:
>>>>>>             return context._raise_error(InvalidOperation,
>>>>>>                                         'exponent of quantize result too large for current context')
  179:         if self_adjusted - exp._exp + 1 > context.prec:
    6:             return context._raise_error(InvalidOperation,
    6:                                         'quantize result has too many digits for current context')
       
  173:         ans = self._rescale(exp._exp, rounding)
  173:         if ans.adjusted() > context.Emax:
>>>>>>             return context._raise_error(InvalidOperation,
>>>>>>                                         'exponent of quantize result too large for current context')
  173:         if len(ans._int) > context.prec:
    1:             return context._raise_error(InvalidOperation,
    1:                                         'quantize result has too many digits for current context')
       
               # raise appropriate flags
  172:         if ans and ans.adjusted() < context.Emin:
    6:             context._raise_error(Subnormal)
  172:         if ans._exp > self._exp:
  103:             if ans != self:
   93:                 context._raise_error(Inexact)
  103:             context._raise_error(Rounded)
       
               # call to fix takes care of any necessary folddown, and
               # signals Clamped if necessary
  172:         ans = ans._fix(context)
  172:         return ans
       
    1:     def same_quantum(self, other):
               """Return True if self and other have the same exponent; otherwise
               return False.
       
               If either operand is a special value, the following rules are used:
                  * return True if both operands are infinities
                  * return True if both operands are NaNs
                  * otherwise, return False.
               """
  125:         other = _convert_other(other, raiseit=True)
  124:         if self._is_special or other._is_special:
   43:             return (self.is_nan() and other.is_nan() or
   41:                     self.is_infinite() and other.is_infinite())
   81:         return self._exp == other._exp
       
    1:     def _rescale(self, exp, rounding):
               """Rescale self so that the exponent is exp, either by padding with zeros
               or by truncating digits, using the given rounding mode.
       
               Specials are returned without change.  This operation is
               quiet: it raises no flags, and uses no information from the
               context.
       
               exp = exp to scale to (an integer)
               rounding = rounding mode
               """
 1757:         if self._is_special:
>>>>>>             return Decimal(self)
 1757:         if not self:
   36:             return _dec_from_triple(self._sign, '0', exp)
       
 1721:         if self._exp >= exp:
                   # pad answer with zeros if necessary
  556:             return _dec_from_triple(self._sign,
  556:                                         self._int + '0'*(self._exp - exp), exp)
       
               # too many digits; round and lose data.  If self.adjusted() <
               # exp-1, replace self by 10**(exp-1) before rounding
 1165:         digits = len(self._int) + self._exp - exp
 1165:         if digits < 0:
   74:             self = _dec_from_triple(self._sign, '1', exp-1)
   74:             digits = 0
 1165:         this_function = self._pick_rounding_function[rounding]
 1165:         changed = this_function(self, digits)
 1165:         coeff = self._int[:digits] or '0'
 1165:         if changed == 1:
   60:             coeff = str(int(coeff)+1)
 1165:         return _dec_from_triple(self._sign, coeff, exp)
       
    1:     def _round(self, places, rounding):
               """Round a nonzero, nonspecial Decimal to a fixed number of
               significant figures, using the given rounding mode.
       
               Infinities, NaNs and zeros are returned unaltered.
       
               This operation is quiet: it raises no flags, and uses no
               information from the context.
       
               """
   17:         if places <= 0:
>>>>>>             raise ValueError("argument should be at least 1 in _round")
   17:         if self._is_special or not self:
    2:             return Decimal(self)
   15:         ans = self._rescale(self.adjusted()+1-places, rounding)
               # it can happen that the rescale alters the adjusted exponent;
               # for example when rounding 99.97 to 3 significant figures.
               # When this happens we end up with an extra 0 at the end of
               # the number; a second rescale fixes this.
   15:         if ans.adjusted() != self.adjusted():
    1:             ans = ans._rescale(ans.adjusted()+1-places, rounding)
   15:         return ans
       
    1:     def to_integral_exact(self, rounding=None, context=None):
               """Rounds to a nearby integer.
       
               If no rounding mode is specified, take the rounding mode from
               the context.  This method raises the Rounded and Inexact flags
               when appropriate.
       
               See also: to_integral_value, which does exactly the same as
               this method except that it doesn't raise Inexact or Rounded.
               """
   67:         if self._is_special:
    3:             ans = self._check_nans(context=context)
    3:             if ans:
    2:                 return ans
    1:             return Decimal(self)
   64:         if self._exp >= 0:
   32:             return Decimal(self)
   32:         if not self:
    4:             return _dec_from_triple(self._sign, '0', 0)
   28:         if context is None:
>>>>>>             context = getcontext()
   28:         if rounding is None:
   28:             rounding = context.rounding
   28:         ans = self._rescale(0, rounding)
   28:         if ans != self:
   26:             context._raise_error(Inexact)
   28:         context._raise_error(Rounded)
   28:         return ans
       
    1:     def to_integral_value(self, rounding=None, context=None):
               """Rounds to the nearest integer, without raising inexact, rounded."""
 1332:         if context is None:
 1304:             context = getcontext()
 1332:         if rounding is None:
  332:             rounding = context.rounding
 1332:         if self._is_special:
    4:             ans = self._check_nans(context=context)
    4:             if ans:
    2:                 return ans
    2:             return Decimal(self)
 1328:         if self._exp >= 0:
  313:             return Decimal(self)
               else:
 1015:             return self._rescale(0, rounding)
       
           # the method name changed, but we provide also the old one, for compatibility
    1:     to_integral = to_integral_value
       
    1:     def sqrt(self, context=None):
               """Return the square root of self."""
  388:         if context is None:
    4:             context = getcontext()
       
  388:         if self._is_special:
    2:             ans = self._check_nans(context=context)
    2:             if ans:
    2:                 return ans
       
>>>>>>             if self._isinfinity() and self._sign == 0:
>>>>>>                 return Decimal(self)
       
  386:         if not self:
                   # exponent = self._exp // 2.  sqrt(-0) = -0
    8:             ans = _dec_from_triple(self._sign, '0', self._exp // 2)
    8:             return ans._fix(context)
       
  378:         if self._sign == 1:
    2:             return context._raise_error(InvalidOperation, 'sqrt(-x), x > 0')
       
               # At this point self represents a positive number.  Let p be
               # the desired precision and express self in the form c*100**e
               # with c a positive real number and e an integer, c and e
               # being chosen so that 100**(p-1) <= c < 100**p.  Then the
               # (exact) square root of self is sqrt(c)*10**e, and 10**(p-1)
               # <= sqrt(c) < 10**p, so the closest representable Decimal at
               # precision p is n*10**e where n = round_half_even(sqrt(c)),
               # the closest integer to sqrt(c) with the even integer chosen
               # in the case of a tie.
               #
               # To ensure correct rounding in all cases, we use the
               # following trick: we compute the square root to an extra
               # place (precision p+1 instead of precision p), rounding down.
               # Then, if the result is inexact and its last digit is 0 or 5,
               # we increase the last digit to 1 or 6 respectively; if it's
               # exact we leave the last digit alone.  Now the final round to
               # p places (or fewer in the case of underflow) will round
               # correctly and raise the appropriate flags.
       
               # use an extra digit of precision
  376:         prec = context.prec+1
       
               # write argument in the form c*100**e where e = self._exp//2
               # is the 'ideal' exponent, to be used if the square root is
               # exactly representable.  l is the number of 'digits' of c in
               # base 100, so that 100**(l-1) <= c < 100**l.
  376:         op = _WorkRep(self)
  376:         e = op.exp >> 1
  376:         if op.exp & 1:
  128:             c = op.int * 10
  128:             l = (len(self._int) >> 1) + 1
               else:
  248:             c = op.int
  248:             l = len(self._int)+1 >> 1
       
               # rescale so that c has exactly prec base 100 'digits'
  376:         shift = prec-l
  376:         if shift >= 0:
  376:             c *= 100**shift
  376:             exact = True
               else:
>>>>>>             c, remainder = divmod(c, 100**-shift)
>>>>>>             exact = not remainder
  376:         e -= shift
       
               # find n = floor(sqrt(c)) using Newton's method
  376:         n = 10**prec
 1917:         while True:
 1917:             q = c//n
 1917:             if n <= q:
  376:                 break
                   else:
 1541:                 n = n + q >> 1
  376:         exact = exact and n*n == c
       
  376:         if exact:
                   # result is exact; rescale to use ideal exponent e
   74:             if shift >= 0:
                       # assert n % 10**shift == 0
   74:                 n //= 10**shift
                   else:
>>>>>>                 n *= 10**-shift
   74:             e += shift
               else:
                   # result is not exact; fix last digit as described above
  302:             if n % 5 == 0:
   41:                 n += 1
       
  376:         ans = _dec_from_triple(0, str(n), e)
       
               # round, and fit to current context
  376:         context = context._shallow_copy()
  376:         rounding = context._set_rounding(ROUND_HALF_EVEN)
  376:         ans = ans._fix(context)
  376:         context.rounding = rounding
       
  376:         return ans
       
    1:     def max(self, other, context=None):
               """Returns the larger value.
       
               Like max(self, other) except if one is not a number, returns
               NaN (and signals if one is sNaN).  Also rounds.
               """
  110:         other = _convert_other(other, raiseit=True)
       
  109:         if context is None:
    4:             context = getcontext()
       
  109:         if self._is_special or other._is_special:
                   # If one operand is a quiet NaN and the other is number, then the
                   # number is always returned
   33:             sn = self._isnan()
   33:             on = other._isnan()
   33:             if sn or on:
   21:                 if on == 1 and sn == 0:
    7:                     return self._fix(context)
   14:                 if sn == 1 and on == 0:
    4:                     return other._fix(context)
   10:                 return self._check_nans(other, context)
       
   88:         c = self._cmp(other)
   88:         if c == 0:
                   # If both operands are finite and equal in numerical value
                   # then an ordering is applied:
                   #
                   # If the signs differ then max returns the operand with the
                   # positive sign and min returns the operand with the negative sign
                   #
                   # If the signs are the same then the exponent is used to select
                   # the result.  This is exactly the ordering used in compare_total.
   28:             c = self.compare_total(other)
       
   88:         if c == -1:
   47:             ans = other
               else:
   41:             ans = self
       
   88:         return ans._fix(context)
       
    1:     def min(self, other, context=None):
               """Returns the smaller value.
       
               Like min(self, other) except if one is not a number, returns
               NaN (and signals if one is sNaN).  Also rounds.
               """
   91:         other = _convert_other(other, raiseit=True)
       
   90:         if context is None:
    3:             context = getcontext()
       
   90:         if self._is_special or other._is_special:
                   # If one operand is a quiet NaN and the other is number, then the
                   # number is always returned
   21:             sn = self._isnan()
   21:             on = other._isnan()
   21:             if sn or on:
   12:                 if on == 1 and sn == 0:
    3:                     return self._fix(context)
    9:                 if sn == 1 and on == 0:
    1:                     return other._fix(context)
    8:                 return self._check_nans(other, context)
       
   78:         c = self._cmp(other)
   78:         if c == 0:
   24:             c = self.compare_total(other)
       
   78:         if c == -1:
   36:             ans = self
               else:
   42:             ans = other
       
   78:         return ans._fix(context)
       
    1:     def _isinteger(self):
               """Returns whether self is an integer"""
  537:         if self._is_special:
    2:             return False
  535:         if self._exp >= 0:
  502:             return True
   33:         rest = self._int[self._exp:]
   33:         return rest == '0'*len(rest)
       
    1:     def _iseven(self):
               """Returns True if self is even.  Assumes self is an integer."""
  106:         if not self or self._exp > 0:
   11:             return True
   95:         return self._int[-1+self._exp] in '02468'
       
    1:     def adjusted(self):
               """Return the adjusted exponent of self"""
 9924:         try:
 9924:             return self._exp + len(self._int) - 1
               # If NaN or Infinity, self._exp is string
    9:         except TypeError:
    9:             return 0
       
    1:     def canonical(self, context=None):
               """Returns the same Decimal object.
       
               As we do not have different encodings for the same number, the
               received object already is in its canonical form.
               """
    1:         return self
       
    1:     def compare_signal(self, other, context=None):
               """Compares self to the other operand numerically.
       
               It's pretty much like compare(), but all NaNs signal, with signaling
               NaNs taking precedence over quiet NaNs.
               """
  128:         other = _convert_other(other, raiseit = True)
  127:         ans = self._compare_check_nans(other, context)
  127:         if ans:
   13:             return ans
  114:         return self.compare(other, context=context)
       
    1:     def compare_total(self, other):
               """Compares self to other using the abstract representations.
       
               This is not like the standard compare, which use their numerical
               value. Note that a total ordering is defined for all possible abstract
               representations.
               """
  513:         other = _convert_other(other, raiseit=True)
       
               # if one is negative and the other is positive, it's easy
  512:         if self._sign and not other._sign:
   54:             return _NegativeOne
  458:         if not self._sign and other._sign:
   56:             return _One
  402:         sign = self._sign
       
               # let's handle both NaN types
  402:         self_nan = self._isnan()
  402:         other_nan = other._isnan()
  402:         if self_nan or other_nan:
   48:             if self_nan == other_nan:
                       # compare payloads as though they're integers
   16:                 self_key = len(self._int), self._int
   16:                 other_key = len(other._int), other._int
   16:                 if self_key < other_key:
    4:                     if sign:
>>>>>>                         return _One
                           else:
    4:                         return _NegativeOne
   12:                 if self_key > other_key:
    3:                     if sign:
    1:                         return _NegativeOne
                           else:
    2:                         return _One
    9:                 return _Zero
       
   32:             if sign:
    4:                 if self_nan == 1:
>>>>>>                     return _NegativeOne
    4:                 if other_nan == 1:
>>>>>>                     return _One
    4:                 if self_nan == 2:
    3:                     return _NegativeOne
    1:                 if other_nan == 2:
    1:                     return _One
                   else:
   28:                 if self_nan == 1:
    4:                     return _One
   24:                 if other_nan == 1:
    7:                     return _NegativeOne
   17:                 if self_nan == 2:
    3:                     return _One
   14:                 if other_nan == 2:
   14:                     return _NegativeOne
       
  354:         if self < other:
   86:             return _NegativeOne
  268:         if self > other:
   94:             return _One
       
  174:         if self._exp < other._exp:
   41:             if sign:
   10:                 return _One
                   else:
   31:                 return _NegativeOne
  133:         if self._exp > other._exp:
   69:             if sign:
   15:                 return _NegativeOne
                   else:
   54:                 return _One
   64:         return _Zero
       
       
    1:     def compare_total_mag(self, other):
               """Compares self to other using abstract repr., ignoring sign.
       
               Like compare_total, but with operand's sign ignored and assumed to be 0.
               """
  191:         other = _convert_other(other, raiseit=True)
       
  190:         s = self.copy_abs()
  190:         o = other.copy_abs()
  190:         return s.compare_total(o)
       
    1:     def copy_abs(self):
               """Returns a copy with the sign set to 0. """
  712:         return _dec_from_triple(0, self._int, self._exp, self._is_special)
       
    1:     def copy_negate(self):
               """Returns a copy with the sign inverted."""
  422:         if self._sign:
  170:             return _dec_from_triple(0, self._int, self._exp, self._is_special)
               else:
  252:             return _dec_from_triple(1, self._int, self._exp, self._is_special)
       
    1:     def copy_sign(self, other):
               """Returns self with the sign of other."""
   53:         other = _convert_other(other, raiseit=True)
   51:         return _dec_from_triple(other._sign, self._int,
   51:                                 self._exp, self._is_special)
       
    1:     def exp(self, context=None):
               """Returns e ** self."""
       
   54:         if context is None:
>>>>>>             context = getcontext()
       
               # exp(NaN) = NaN
   54:         ans = self._check_nans(context=context)
   54:         if ans:
>>>>>>             return ans
       
               # exp(-Infinity) = 0
   54:         if self._isinfinity() == -1:
    2:             return _Zero
       
               # exp(0) = 1
   52:         if not self:
    3:             return _One
       
               # exp(Infinity) = Infinity
   49:         if self._isinfinity() == 1:
    1:             return Decimal(self)
       
               # the result is now guaranteed to be inexact (the true
               # mathematical result is transcendental). There's no need to
               # raise Rounded and Inexact here---they'll always be raised as
               # a result of the call to _fix.
   48:         p = context.prec
   48:         adj = self.adjusted()
       
               # we only need to do any computation for quite a small range
               # of adjusted exponents---for example, -29 <= adj <= 10 for
               # the default context.  For smaller exponent the result is
               # indistinguishable from 1 at the given precision, while for
               # larger exponent the result either overflows or underflows.
   48:         if self._sign == 0 and adj > len(str((context.Emax+1)*3)):
                   # overflow
>>>>>>             ans = _dec_from_triple(0, '1', context.Emax+1)
   48:         elif self._sign == 1 and adj > len(str((-context.Etiny()+1)*3)):
                   # underflow to 0
    2:             ans = _dec_from_triple(0, '1', context.Etiny()-1)
   46:         elif self._sign == 0 and adj < -p:
                   # p+1 digits; final round will raise correct flags
    1:             ans = _dec_from_triple(0, '1' + '0'*(p-1) + '1', -p)
   45:         elif self._sign == 1 and adj < -p-1:
                   # p+1 digits; final round will raise correct flags
>>>>>>             ans = _dec_from_triple(0, '9'*(p+1), -p-1)
               # general case
               else:
   45:             op = _WorkRep(self)
   45:             c, e = op.int, op.exp
   45:             if op.sign == 1:
   12:                 c = -c
       
                   # compute correctly rounded result: increase precision by
                   # 3 digits at a time until we get an unambiguously
                   # roundable result
   45:             extra = 3
   46:             while True:
   46:                 coeff, exp = _dexp(c, e, p+extra)
   46:                 if coeff % (5*10**(len(str(coeff))-p-1)):
   45:                     break
    1:                 extra += 3
       
   45:             ans = _dec_from_triple(0, str(coeff), exp)
       
               # at this stage, ans should round correctly with *any*
               # rounding mode, not just with ROUND_HALF_EVEN
   48:         context = context._shallow_copy()
   48:         rounding = context._set_rounding(ROUND_HALF_EVEN)
   48:         ans = ans._fix(context)
   48:         context.rounding = rounding
       
   48:         return ans
       
    1:     def is_canonical(self):
               """Return True if self is canonical; otherwise return False.
       
               Currently, the encoding of a Decimal instance is always
               canonical, so this method returns True for any Decimal.
               """
   19:         return True
       
    1:     def is_finite(self):
               """Return True if self is finite; otherwise return False.
       
               A Decimal instance is considered finite if it is neither
               infinite nor a NaN.
               """
   49:         return not self._is_special
       
    1:     def is_infinite(self):
               """Return True if self is infinite; otherwise return False."""
   76:         return self._exp == 'F'
       
    1:     def is_nan(self):
               """Return True if self is a qNaN or sNaN; otherwise return False."""
   89:         return self._exp in ('n', 'N')
       
    1:     def is_normal(self, context=None):
               """Return True if self is a normal number; otherwise return False."""
   23:         if self._is_special or not self:
    8:             return False
   15:         if context is None:
>>>>>>             context = getcontext()
   15:         return context.Emin <= self.adjusted()
       
    1:     def is_qnan(self):
               """Return True if self is a quiet NaN; otherwise return False."""
  202:         return self._exp == 'n'
       
    1:     def is_signed(self):
               """Return True if self is negative; otherwise return False."""
   18:         return self._sign == 1
       
    1:     def is_snan(self):
               """Return True if self is a signaling NaN; otherwise return False."""
  349:         return self._exp == 'N'
       
    1:     def is_subnormal(self, context=None):
               """Return True if self is subnormal; otherwise return False."""
   56:         if self._is_special or not self:
   10:             return False
   46:         if context is None:
>>>>>>             context = getcontext()
   46:         return self.adjusted() < context.Emin
       
    1:     def is_zero(self):
               """Return True if self is a zero; otherwise return False."""
   57:         return not self._is_special and self._int == '0'
       
    1:     def _ln_exp_bound(self):
               """Compute a lower bound for the adjusted exponent of self.ln().
               In other words, compute r such that self.ln() >= 10**r.  Assumes
               that self is finite and positive and that self != 1.
               """
       
               # for 0.1 <= x <= 10 we use the inequalities 1-1/x <= ln(x) <= x-1
   36:         adj = self._exp + len(self._int) - 1
   36:         if adj >= 1:
                   # argument >= 10; we use 23/10 = 2.3 as a lower bound for ln(10)
   16:             return len(str(adj*23//10)) - 1
   20:         if adj <= -2:
                   # argument <= 0.1
    7:             return len(str((-1-adj)*23//10)) - 1
   13:         op = _WorkRep(self)
   13:         c, e = op.int, op.exp
   13:         if adj == 0:
                   # 1 < self < 10
    9:             num = str(c-10**-e)
    9:             den = str(c)
    9:             return len(num) - len(den) - (num < den)
               # adj == -1, 0.1 <= self < 1
    4:         return e + len(str(10**-e - c)) - 1
       
       
    1:     def ln(self, context=None):
               """Returns the natural (base e) logarithm of self."""
       
   45:         if context is None:
>>>>>>             context = getcontext()
       
               # ln(NaN) = NaN
   45:         ans = self._check_nans(context=context)
   45:         if ans:
>>>>>>             return ans
       
               # ln(0.0) == -Infinity
   45:         if not self:
    3:             return _NegativeInfinity
       
               # ln(Infinity) = Infinity
   42:         if self._isinfinity() == 1:
    3:             return _Infinity
       
               # ln(1.0) == 0.0
   39:         if self == _One:
    2:             return _Zero
       
               # ln(negative) raises InvalidOperation
   37:         if self._sign == 1:
    1:             return context._raise_error(InvalidOperation,
    1:                                         'ln of a negative value')
       
               # result is irrational, so necessarily inexact
   36:         op = _WorkRep(self)
   36:         c, e = op.int, op.exp
   36:         p = context.prec
       
               # correctly rounded result: repeatedly increase precision by 3
               # until we get an unambiguously roundable result
   36:         places = p - self._ln_exp_bound() + 2 # at least p+3 places
   36:         while True:
   36:             coeff = _dlog(c, e, places)
                   # assert len(str(abs(coeff)))-p >= 1
   36:             if coeff % (5*10**(len(str(abs(coeff)))-p-1)):
   36:                 break
>>>>>>             places += 3
   36:         ans = _dec_from_triple(int(coeff<0), str(abs(coeff)), -places)
       
   36:         context = context._shallow_copy()
   36:         rounding = context._set_rounding(ROUND_HALF_EVEN)
   36:         ans = ans._fix(context)
   36:         context.rounding = rounding
   36:         return ans
       
    1:     def _log10_exp_bound(self):
               """Compute a lower bound for the adjusted exponent of self.log10().
               In other words, find r such that self.log10() >= 10**r.
               Assumes that self is finite and positive and that self != 1.
               """
       
               # For x >= 10 or x < 0.1 we only need a bound on the integer
               # part of log10(self), and this comes directly from the
               # exponent of x.  For 0.1 <= x <= 10 we use the inequalities
               # 1-1/x <= log(x) <= x-1. If x > 1 we have |log10(x)| >
               # (1-1/x)/2.31 > 0.  If x < 1 then |log10(x)| > (1-x)/2.31 > 0
       
  470:         adj = self._exp + len(self._int) - 1
  470:         if adj >= 1:
                   # self >= 10
  155:             return len(str(adj))-1
  315:         if adj <= -2:
                   # self < 0.1
  150:             return len(str(-1-adj))-1
  165:         op = _WorkRep(self)
  165:         c, e = op.int, op.exp
  165:         if adj == 0:
                   # 1 < self < 10
   44:             num = str(c-10**-e)
   44:             den = str(231*c)
   44:             return len(num) - len(den) - (num < den) + 2
               # adj == -1, 0.1 <= self < 1
  121:         num = str(10**-e-c)
  121:         return len(num) + e - (num < "231") - 1
       
    1:     def log10(self, context=None):
               """Returns the base 10 logarithm of self."""
       
   42:         if context is None:
>>>>>>             context = getcontext()
       
               # log10(NaN) = NaN
   42:         ans = self._check_nans(context=context)
   42:         if ans:
>>>>>>             return ans
       
               # log10(0.0) == -Infinity
   42:         if not self:
    3:             return _NegativeInfinity
       
               # log10(Infinity) = Infinity
   39:         if self._isinfinity() == 1:
    1:             return _Infinity
       
               # log10(negative or -Infinity) raises InvalidOperation
   38:         if self._sign == 1:
    3:             return context._raise_error(InvalidOperation,
    3:                                         'log10 of a negative value')
       
               # log10(10**n) = n
   35:         if self._int[0] == '1' and self._int[1:] == '0'*(len(self._int) - 1):
                   # answer may need rounding
   15:             ans = Decimal(self._exp + len(self._int) - 1)
               else:
                   # result is irrational, so necessarily inexact
   20:             op = _WorkRep(self)
   20:             c, e = op.int, op.exp
   20:             p = context.prec
       
                   # correctly rounded result: repeatedly increase precision
                   # until result is unambiguously roundable
   20:             places = p-self._log10_exp_bound()+2
   20:             while True:
   20:                 coeff = _dlog10(c, e, places)
                       # assert len(str(abs(coeff)))-p >= 1
   20:                 if coeff % (5*10**(len(str(abs(coeff)))-p-1)):
   20:                     break
>>>>>>                 places += 3
   20:             ans = _dec_from_triple(int(coeff<0), str(abs(coeff)), -places)
       
   35:         context = context._shallow_copy()
   35:         rounding = context._set_rounding(ROUND_HALF_EVEN)
   35:         ans = ans._fix(context)
   35:         context.rounding = rounding
   35:         return ans
       
    1:     def logb(self, context=None):
               """ Returns the exponent of the magnitude of self's MSD.
       
               The result is the integer which is the exponent of the magnitude
               of the most significant digit of self (as though it were truncated
               to a single digit while maintaining the value of that digit and
               without limiting the resulting exponent).
               """
               # logb(NaN) = NaN
   51:         ans = self._check_nans(context=context)
   51:         if ans:
    3:             return ans
       
   48:         if context is None:
>>>>>>             context = getcontext()
       
               # logb(+/-Inf) = +Inf
   48:         if self._isinfinity():
    1:             return _Infinity
       
               # logb(0) = -Inf, DivisionByZero
   47:         if not self:
    8:             return context._raise_error(DivisionByZero, 'logb(0)', 1)
       
               # otherwise, simply return the adjusted exponent of self, as a
               # Decimal.  Note that no attempt is made to fit the result
               # into the current context.
   39:         ans = Decimal(self.adjusted())
   39:         return ans._fix(context)
       
    1:     def _islogical(self):
               """Return True if self is a logical operand.
       
               For being logical, it must be a finite number with a sign of 0,
               an exponent of 0, and a coefficient whose digits must all be
               either 0 or 1.
               """
  581:         if self._sign != 0 or self._exp != 0:
  117:             return False
 5250:         for dig in self._int:
 4862:             if dig not in '01':
   76:                 return False
  388:         return True
       
    1:     def _fill_logical(self, context, opa, opb):
  174:         dif = context.prec - len(opa)
  174:         if dif > 0:
  131:             opa = '0'*dif + opa
   43:         elif dif < 0:
    2:             opa = opa[-context.prec:]
  174:         dif = context.prec - len(opb)
  174:         if dif > 0:
  106:             opb = '0'*dif + opb
   68:         elif dif < 0:
    3:             opb = opb[-context.prec:]
  174:         return opa, opb
       
    1:     def logical_and(self, other, context=None):
               """Applies an 'and' operation between self and other's digits."""
  106:         if context is None:
    2:             context = getcontext()
       
  106:         other = _convert_other(other, raiseit=True)
       
  105:         if not self._islogical() or not other._islogical():
   55:             return context._raise_error(InvalidOperation)
       
               # fill to context.prec
   50:         (opa, opb) = self._fill_logical(context, self._int, other._int)
       
               # make the operation, and clean starting zeroes
 1118:         result = "".join([str(int(a)&int(b)) for a,b in zip(opa,opb)])
   50:         return _dec_from_triple(0, result.lstrip('0') or '0', 0)
       
    1:     def logical_invert(self, context=None):
               """Invert all its digits."""
   55:         if context is None:
>>>>>>             context = getcontext()
   55:         return self.logical_xor(_dec_from_triple(0,'1'*context.prec,0),
   55:                                 context)
       
    1:     def logical_or(self, other, context=None):
               """Applies an 'or' operation between self and other's digits."""
  102:         if context is None:
    2:             context = getcontext()
       
  102:         other = _convert_other(other, raiseit=True)
       
  101:         if not self._islogical() or not other._islogical():
   49:             return context._raise_error(InvalidOperation)
       
               # fill to context.prec
   52:         (opa, opb) = self._fill_logical(context, self._int, other._int)
       
               # make the operation, and clean starting zeroes
 1231:         result = "".join([str(int(a)|int(b)) for a,b in zip(opa,opb)])
   52:         return _dec_from_triple(0, result.lstrip('0') or '0', 0)
       
    1:     def logical_xor(self, other, context=None):
               """Applies an 'xor' operation between self and other's digits."""
  162:         if context is None:
    2:             context = getcontext()
       
  162:         other = _convert_other(other, raiseit=True)
       
  161:         if not self._islogical() or not other._islogical():
   89:             return context._raise_error(InvalidOperation)
       
               # fill to context.prec
   72:         (opa, opb) = self._fill_logical(context, self._int, other._int)
       
               # make the operation, and clean starting zeroes
 1556:         result = "".join([str(int(a)^int(b)) for a,b in zip(opa,opb)])
   72:         return _dec_from_triple(0, result.lstrip('0') or '0', 0)
       
    1:     def max_mag(self, other, context=None):
               """Compares the values numerically with their sign ignored."""
   88:         other = _convert_other(other, raiseit=True)
       
   87:         if context is None:
    2:             context = getcontext()
       
   87:         if self._is_special or other._is_special:
                   # If one operand is a quiet NaN and the other is number, then the
                   # number is always returned
   28:             sn = self._isnan()
   28:             on = other._isnan()
   28:             if sn or on:
   16:                 if on == 1 and sn == 0:
    3:                     return self._fix(context)
   13:                 if sn == 1 and on == 0:
    3:                     return other._fix(context)
   10:                 return self._check_nans(other, context)
       
   71:         c = self.copy_abs()._cmp(other.copy_abs())
   71:         if c == 0:
   29:             c = self.compare_total(other)
       
   71:         if c == -1:
   33:             ans = other
               else:
   38:             ans = self
       
   71:         return ans._fix(context)
       
    1:     def min_mag(self, other, context=None):
               """Compares the values numerically with their sign ignored."""
   94:         other = _convert_other(other, raiseit=True)
       
   93:         if context is None:
    2:             context = getcontext()
       
   93:         if self._is_special or other._is_special:
                   # If one operand is a quiet NaN and the other is number, then the
                   # number is always returned
   34:             sn = self._isnan()
   34:             on = other._isnan()
   34:             if sn or on:
   19:                 if on == 1 and sn == 0:
    6:                     return self._fix(context)
   13:                 if sn == 1 and on == 0:
    3:                     return other._fix(context)
   10:                 return self._check_nans(other, context)
       
   74:         c = self.copy_abs()._cmp(other.copy_abs())
   74:         if c == 0:
   19:             c = self.compare_total(other)
       
   74:         if c == -1:
   29:             ans = self
               else:
   45:             ans = other
       
   74:         return ans._fix(context)
       
    1:     def next_minus(self, context=None):
               """Returns the largest representable number smaller than itself."""
   67:         if context is None:
>>>>>>             context = getcontext()
       
   67:         ans = self._check_nans(context=context)
   67:         if ans:
    2:             return ans
       
   65:         if self._isinfinity() == -1:
    1:             return _NegativeInfinity
   64:         if self._isinfinity() == 1:
    2:             return _dec_from_triple(0, '9'*context.prec, context.Etop())
       
   62:         context = context.copy()
   62:         context._set_rounding(ROUND_FLOOR)
   62:         context._ignore_all_flags()
   62:         new_self = self._fix(context)
   62:         if new_self != self:
    3:             return new_self
   59:         return self.__sub__(_dec_from_triple(0, '1', context.Etiny()-1),
   59:                             context)
       
    1:     def next_plus(self, context=None):
               """Returns the smallest representable number larger than itself."""
   81:         if context is None:
>>>>>>             context = getcontext()
       
   81:         ans = self._check_nans(context=context)
   81:         if ans:
    3:             return ans
       
   78:         if self._isinfinity() == 1:
>>>>>>             return _Infinity
   78:         if self._isinfinity() == -1:
    6:             return _dec_from_triple(1, '9'*context.prec, context.Etop())
       
   72:         context = context.copy()
   72:         context._set_rounding(ROUND_CEILING)
   72:         context._ignore_all_flags()
   72:         new_self = self._fix(context)
   72:         if new_self != self:
    6:             return new_self
   66:         return self.__add__(_dec_from_triple(0, '1', context.Etiny()-1),
   66:                             context)
       
    1:     def next_toward(self, other, context=None):
               """Returns the number closest to self, in the direction towards other.
       
               The result is the closest representable number to self
               (excluding self) that is in the direction towards other,
               unless both have the same value.  If the two operands are
               numerically equal, then the result is a copy of self with the
               sign set to be the same as the sign of other.
               """
  110:         other = _convert_other(other, raiseit=True)
       
  109:         if context is None:
    2:             context = getcontext()
       
  109:         ans = self._check_nans(other, context)
  109:         if ans:
   26:             return ans
       
   83:         comparison = self._cmp(other)
   83:         if comparison == 0:
    9:             return self.copy_sign(other)
       
   74:         if comparison == -1:
   45:             ans = self.next_plus(context)
               else: # comparison == 1
   29:             ans = self.next_minus(context)
       
               # decide which flags to raise using value of ans
   74:         if ans._isinfinity():
    1:             context._raise_error(Overflow,
    1:                                  'Infinite result from next_toward',
    1:                                  ans._sign)
    1:             context._raise_error(Inexact)
    1:             context._raise_error(Rounded)
   73:         elif ans.adjusted() < context.Emin:
   23:             context._raise_error(Underflow)
   23:             context._raise_error(Subnormal)
   23:             context._raise_error(Inexact)
   23:             context._raise_error(Rounded)
                   # if precision == 1 then we don't raise Clamped for a
                   # result 0E-Etiny.
   23:             if not ans:
    4:                 context._raise_error(Clamped)
       
   74:         return ans
       
    1:     def number_class(self, context=None):
               """Returns an indication of the class of self.
       
               The class is one of the following strings:
                 sNaN
                 NaN
                 -Infinity
                 -Normal
                 -Subnormal
                 -Zero
                 +Zero
                 +Subnormal
                 +Normal
                 +Infinity
               """
   37:         if self.is_snan():
    2:             return "sNaN"
   35:         if self.is_qnan():
    2:             return "NaN"
   33:         inf = self._isinfinity()
   33:         if inf == 1:
    2:             return "+Infinity"
   31:         if inf == -1:
    1:             return "-Infinity"
   30:         if self.is_zero():
    8:             if self._sign:
    3:                 return "-Zero"
                   else:
    5:                 return "+Zero"
   22:         if context is None:
>>>>>>             context = getcontext()
   22:         if self.is_subnormal(context=context):
    3:             if self._sign:
    2:                 return "-Subnormal"
                   else:
    1:                 return "+Subnormal"
               # just a normal, regular, boring number, :)
   19:         if self._sign:
    7:             return "-Normal"
               else:
   12:             return "+Normal"
       
    1:     def radix(self):
               """Just returns 10, as this is Decimal, :)"""
>>>>>>         return Decimal(10)
       
    1:     def rotate(self, other, context=None):
               """Returns a rotated copy of self, value-of-other times."""
   84:         if context is None:
    2:             context = getcontext()
       
   84:         other = _convert_other(other, raiseit=True)
       
   83:         ans = self._check_nans(other, context)
   83:         if ans:
   20:             return ans
       
   63:         if other._exp != 0:
    7:             return context._raise_error(InvalidOperation)
   56:         if not (-context.prec <= int(other) <= context.prec):
    2:             return context._raise_error(InvalidOperation)
       
   54:         if self._isinfinity():
    2:             return Decimal(self)
       
               # get values, pad if necessary
   52:         torot = int(other)
   52:         rotdig = self._int
   52:         topad = context.prec - len(rotdig)
   52:         if topad > 0:
   24:             rotdig = '0'*topad + rotdig
   28:         elif topad < 0:
>>>>>>             rotdig = rotdig[-topad:]
       
               # let's rotate!
   52:         rotated = rotdig[torot:] + rotdig[:torot]
   52:         return _dec_from_triple(self._sign,
   52:                                 rotated.lstrip('0') or '0', self._exp)
       
    1:     def scaleb(self, other, context=None):
               """Returns self operand after adding the second value to its exp."""
   59:         if context is None:
    2:             context = getcontext()
       
   59:         other = _convert_other(other, raiseit=True)
       
   58:         ans = self._check_nans(other, context)
   58:         if ans:
    4:             return ans
       
   54:         if other._exp != 0:
    4:             return context._raise_error(InvalidOperation)
   50:         liminf = -2 * (context.Emax + context.prec)
   50:         limsup =  2 * (context.Emax + context.prec)
   50:         if not (liminf <= int(other) <= limsup):
>>>>>>             return context._raise_error(InvalidOperation)
       
   50:         if self._isinfinity():
    1:             return Decimal(self)
       
   49:         d = _dec_from_triple(self._sign, self._int, self._exp + int(other))
   49:         d = d._fix(context)
   49:         return d
       
    1:     def shift(self, other, context=None):
               """Returns a shifted copy of self, value-of-other times."""
   96:         if context is None:
    2:             context = getcontext()
       
   96:         other = _convert_other(other, raiseit=True)
       
   95:         ans = self._check_nans(other, context)
   95:         if ans:
   26:             return ans
       
   69:         if other._exp != 0:
    8:             return context._raise_error(InvalidOperation)
   61:         if not (-context.prec <= int(other) <= context.prec):
    3:             return context._raise_error(InvalidOperation)
       
   58:         if self._isinfinity():
    2:             return Decimal(self)
       
               # get values, pad if necessary
   56:         torot = int(other)
   56:         rotdig = self._int
   56:         topad = context.prec - len(rotdig)
   56:         if topad > 0:
   21:             rotdig = '0'*topad + rotdig
   35:         elif topad < 0:
    1:             rotdig = rotdig[-topad:]
       
               # let's shift!
   56:         if torot < 0:
   31:             shifted = rotdig[:torot]
               else:
   25:             shifted = rotdig + '0'*torot
   25:             shifted = shifted[-context.prec:]
       
   56:         return _dec_from_triple(self._sign,
   56:                                     shifted.lstrip('0') or '0', self._exp)
       
           # Support for pickling, copy, and deepcopy
    1:     def __reduce__(self):
    3:         return (self.__class__, (str(self),))
       
    1:     def __copy__(self):
    1:         if type(self) is Decimal:
    1:             return self     # I'm immutable; therefore I am my own clone
>>>>>>         return self.__class__(str(self))
       
    1:     def __deepcopy__(self, memo):
    1:         if type(self) is Decimal:
    1:             return self     # My components are also immutable
>>>>>>         return self.__class__(str(self))
       
           # PEP 3101 support.  the _localeconv keyword argument should be
           # considered private: it's provided for ease of testing only.
    1:     def __format__(self, specifier, context=None, _localeconv=None):
               """Format a Decimal instance according to the given specifier.
       
               The specifier should be a standard format specifier, with the
               form described in PEP 3101.  Formatting types 'e', 'E', 'f',
               'F', 'g', 'G', 'n' and '%' are supported.  If the formatting
               type is omitted it defaults to 'g' or 'G', depending on the
               value of context.capitals.
               """
       
               # Note: PEP 3101 says that if the type is not present then
               # there should be at least one digit after the decimal point.
               # We take the liberty of ignoring this requirement for
               # Decimal---it's presumably there to make sure that
               # format(float, '') behaves similarly to str(float).
  157:         if context is None:
  157:             context = getcontext()
       
  157:         spec = _parse_format_specifier(specifier, _localeconv=_localeconv)
       
               # special values don't care about the type or precision
  157:         if self._is_special:
   12:             sign = _format_sign(self._sign, spec)
   12:             body = str(self.copy_abs())
   12:             if spec['type'] == '%':
    3:                 body += '%'
   12:             return _format_align(sign, body, spec)
       
               # a type of None defaults to 'g' or 'G', depending on context
  145:         if spec['type'] is None:
   40:             spec['type'] = ['g', 'G'][context.capitals]
       
               # if type is '%', adjust exponent of self accordingly
  145:         if spec['type'] == '%':
   13:             self = _dec_from_triple(self._sign, self._int, self._exp+2)
       
               # round if necessary, taking rounding mode from the context
  145:         rounding = context.rounding
  145:         precision = spec['precision']
  145:         if precision is not None:
   38:             if spec['type'] in 'eE':
    6:                 self = self._round(precision+1, rounding)
   32:             elif spec['type'] in 'fF%':
   19:                 self = self._rescale(-precision, rounding)
   13:             elif spec['type'] in 'gG' and len(self._int) > precision:
   11:                 self = self._round(precision, rounding)
               # special case: zeros with a positive exponent can't be
               # represented in fixed point; rescale them to 0e0.
  145:         if not self and self._exp > 0 and spec['type'] in 'fF%':
    4:             self = self._rescale(0, rounding)
       
               # figure out placement of the decimal point
  145:         leftdigits = self._exp + len(self._int)
  145:         if spec['type'] in 'eE':
   23:             if not self and precision is not None:
    2:                 dotplace = 1 - precision
                   else:
   21:                 dotplace = 1
  122:         elif spec['type'] in 'fF%':
   36:             dotplace = leftdigits
   86:         elif spec['type'] in 'gG':
   86:             if self._exp <= 0 and leftdigits > -6:
   78:                 dotplace = leftdigits
                   else:
    8:                 dotplace = 1
       
               # find digits before and after decimal point, and get exponent
  145:         if dotplace < 0:
   16:             intpart = '0'
   16:             fracpart = '0'*(-dotplace) + self._int
  129:         elif dotplace > len(self._int):
    1:             intpart = self._int + '0'*(dotplace-len(self._int))
    1:             fracpart = ''
               else:
  128:             intpart = self._int[:dotplace] or '0'
  128:             fracpart = self._int[dotplace:]
  145:         exp = leftdigits-dotplace
       
               # done with the decimal-specific stuff;  hand over the rest
               # of the formatting to the _format_number function
  145:         return _format_number(self._sign, intpart, fracpart, exp, spec)
       
    1: def _dec_from_triple(sign, coefficient, exponent, special=False):
           """Create a decimal instance directly, without any validation,
           normalization (e.g. removal of leading zeros) or argument
           conversion.
       
           This function is for *internal use only*.
           """
       
10059:     self = object.__new__(Decimal)
10059:     self._sign = sign
10059:     self._int = coefficient
10059:     self._exp = exponent
10059:     self._is_special = special
       
10059:     return self
       
       # Register Decimal as a kind of Number (an abstract base class).
       # However, do not register it as Real (because Decimals are not
       # interoperable with floats).
    1: _numbers.Number.register(Decimal)
       
       
       ##### Context class #######################################################
       
    2: class _ContextManager(object):
           """Context manager class to support localcontext().
       
             Sets a copy of the supplied context in __enter__() and restores
             the previous decimal context in __exit__()
    1:     """
    1:     def __init__(self, new_context):
    5:         self.new_context = new_context.copy()
    1:     def __enter__(self):
    5:         self.saved_context = getcontext()
    5:         setcontext(self.new_context)
    5:         return self.new_context
    1:     def __exit__(self, t, v, tb):
    5:         setcontext(self.saved_context)
       
    2: class Context(object):
           """Contains the context for a Decimal instance.
       
           Contains:
           prec - precision (for use in rounding, division, square roots..)
           rounding - rounding type (how you round)
           traps - If traps[exception] = 1, then the exception is
                           raised when it is caused.  Otherwise, a value is
                           substituted in.
           flags  - When an exception is caused, flags[exception] is set.
                    (Whether or not the trap_enabler is set)
                    Should be reset by user of Decimal instance.
           Emin -   Minimum exponent
           Emax -   Maximum exponent
           capitals -      If 1, 1*10^1 is printed as 1E+1.
                           If 0, printed as 1e1
           _clamp - If 1, change exponents if too high (Default 0)
    1:     """
       
    1:     def __init__(self, prec=None, rounding=None,
    1:                  traps=None, flags=None,
    1:                  Emin=None, Emax=None,
    1:                  capitals=None, _clamp=0,
    1:                  _ignored_flags=None):
               # Set defaults; for everything except flags and _ignored_flags,
               # inherit from DefaultContext.
  879:         try:
  879:             dc = DefaultContext
    1:         except NameError:
    1:             pass
       
  879:         self.prec = prec if prec is not None else dc.prec
  879:         self.rounding = rounding if rounding is not None else dc.rounding
  879:         self.Emin = Emin if Emin is not None else dc.Emin
  879:         self.Emax = Emax if Emax is not None else dc.Emax
  879:         self.capitals = capitals if capitals is not None else dc.capitals
  879:         self._clamp = _clamp if _clamp is not None else dc._clamp
       
  879:         if _ignored_flags is None:
  220:             self._ignored_flags = []
               else:
  659:             self._ignored_flags = _ignored_flags
       
  879:         if traps is None:
  213:             self.traps = dc.traps.copy()
  666:         elif not isinstance(traps, dict):
   60:             self.traps = dict((s, int(s in traps)) for s in _signals)
               else:
  660:             self.traps = traps
       
  879:         if flags is None:
  216:             self.flags = dict.fromkeys(_signals, 0)
  663:         elif not isinstance(flags, dict):
   40:             self.flags = dict((s, int(s in flags)) for s in _signals)
               else:
  659:             self.flags = flags
       
    1:     def __repr__(self):
               """Show the current context."""
>>>>>>         s = []
>>>>>>         s.append('Context(prec=%(prec)d, rounding=%(rounding)s, '
                        'Emin=%(Emin)d, Emax=%(Emax)d, capitals=%(capitals)d'
>>>>>>                  % vars(self))
>>>>>>         names = [f.__name__ for f, v in self.flags.items() if v]
>>>>>>         s.append('flags=[' + ', '.join(names) + ']')
>>>>>>         names = [t.__name__ for t, v in self.traps.items() if v]
>>>>>>         s.append('traps=[' + ', '.join(names) + ']')
>>>>>>         return ', '.join(s) + ')'
       
    1:     def clear_flags(self):
               """Reset all flags to zero"""
59373:         for flag in self.flags:
52776:             self.flags[flag] = 0
       
    1:     def _shallow_copy(self):
               """Returns a shallow copy from self."""
  495:         nc = Context(self.prec, self.rounding, self.traps,
  495:                      self.flags, self.Emin, self.Emax,
  495:                      self.capitals, self._clamp, self._ignored_flags)
  495:         return nc
       
    1:     def copy(self):
               """Returns a deep copy from self."""
  164:         nc = Context(self.prec, self.rounding, self.traps.copy(),
  164:                      self.flags.copy(), self.Emin, self.Emax,
  164:                      self.capitals, self._clamp, self._ignored_flags)
  164:         return nc
    1:     __copy__ = copy
       
    1:     def _raise_error(self, condition, explanation = None, *args):
               """Handles an error
       
               If the flag is in _ignored_flags, returns the default response.
               Otherwise, it sets the flag, then, if the corresponding
               trap_enabler is set, it reraises the exception.  Otherwise, it returns
               the default value after setting the flag.
               """
 6332:         error = _condition_map.get(condition, condition)
 6332:         if error in self._ignored_flags:
                   # Don't touch the flag
  401:             return error().handle(self, *args)
       
 5931:         self.flags[error] = 1
 5931:         if not self.traps[error]:
                   # The errors define how to handle themselves.
 5851:             return condition().handle(self, *args)
       
               # Errors should only be risked on copies of the context
               # self._ignored_flags = []
   80:         raise error(explanation)
       
    1:     def _ignore_all_flags(self):
               """Ignore all flags, if they are raised"""
  134:         return self._ignore_flags(*_signals)
       
    1:     def _ignore_flags(self, *flags):
               """Ignore the flags, if they are raised"""
               # Do not mutate-- This way, copies of a context leave the original
               # alone.
  134:         self._ignored_flags = (self._ignored_flags + list(flags))
  134:         return list(flags)
       
    1:     def _regard_flags(self, *flags):
               """Stop ignoring the flags, if they are raised"""
>>>>>>         if flags and isinstance(flags[0], (tuple,list)):
>>>>>>             flags = flags[0]
>>>>>>         for flag in flags:
>>>>>>             self._ignored_flags.remove(flag)
       
           # We inherit object.__hash__, so we must deny this explicitly
    1:     __hash__ = None
       
    1:     def Etiny(self):
               """Returns Etiny (= Emin - prec + 1)"""
 5175:         return int(self.Emin - self.prec + 1)
       
    1:     def Etop(self):
               """Returns maximum exponent (= Emax - prec + 1)"""
 4580:         return int(self.Emax - self.prec + 1)
       
    1:     def _set_rounding(self, type):
               """Sets the rounding type.
       
               Sets the rounding type, and returns the current (previous)
               rounding type.  Often used like:
       
               context = context.copy()
               # so you don't change the calling context
               # if an error occurs in the middle.
               rounding = context._set_rounding(ROUND_UP)
               val = self.__sub__(other, context=context)
               context._set_rounding(rounding)
       
               This will make it round up for that operation.
               """
  629:         rounding = self.rounding
  629:         self.rounding= type
  629:         return rounding
       
    1:     def create_decimal(self, num='0'):
               """Creates a new Decimal instance but using self as context.
       
               This method implements the to-number operation of the
               IBM Decimal specification."""
       
  404:         if isinstance(num, basestring) and num != num.strip():
    4:             return self._raise_error(ConversionSyntax,
    4:                                      "no trailing or leading whitespace is "
                                            "permitted.")
       
  400:         d = Decimal(num, context=self)
  399:         if d._isnan() and len(d._int) > self.prec - self._clamp:
    1:             return self._raise_error(ConversionSyntax,
    1:                                      "diagnostic info too long in NaN")
  398:         return d._fix(self)
       
    1:     def create_decimal_from_float(self, f):
               """Creates a new Decimal instance from a float but rounding using self
               as the context.
       
               >>> context = Context(prec=5, rounding=ROUND_DOWN)
               >>> context.create_decimal_from_float(3.1415926535897932)
               Decimal('3.1415')
               >>> context = Context(prec=5, traps=[Inexact])
               >>> context.create_decimal_from_float(3.1415926535897932)
               Traceback (most recent call last):
                   ...
               Inexact: None
       
               """
    8:         d = Decimal.from_float(f)       # An exact conversion
    8:         return d._fix(self)             # Apply the context rounding
       
           # Methods
    1:     def abs(self, a):
               """Returns the absolute value of the operand.
       
               If the operand is negative, the result is the same as using the minus
               operation on the operand.  Otherwise, the result is the same as using
               the plus operation on the operand.
       
               >>> ExtendedContext.abs(Decimal('2.1'))
               Decimal('2.1')
               >>> ExtendedContext.abs(Decimal('-100'))
               Decimal('100')
               >>> ExtendedContext.abs(Decimal('101.5'))
               Decimal('101.5')
               >>> ExtendedContext.abs(Decimal('-101.5'))
               Decimal('101.5')
               >>> ExtendedContext.abs(-1)
               Decimal('1')
               """
   38:         a = _convert_other(a, raiseit=True)
   37:         return a.__abs__(context=self)
       
    1:     def add(self, a, b):
               """Return the sum of the two operands.
       
               >>> ExtendedContext.add(Decimal('12'), Decimal('7.00'))
               Decimal('19.00')
               >>> ExtendedContext.add(Decimal('1E+2'), Decimal('1.01E+4'))
               Decimal('1.02E+4')
               >>> ExtendedContext.add(1, Decimal(2))
               Decimal('3')
               >>> ExtendedContext.add(Decimal(8), 5)
               Decimal('13')
               >>> ExtendedContext.add(5, 5)
               Decimal('10')
               """
  569:         a = _convert_other(a, raiseit=True)
  568:         r = a.__add__(b, context=self)
  568:         if r is NotImplemented:
    1:             raise TypeError("Unable to convert %s to Decimal" % b)
               else:
  567:             return r
       
    1:     def _apply(self, a):
   32:         return str(a._fix(self))
       
    1:     def canonical(self, a):
               """Returns the same Decimal object.
       
               As we do not have different encodings for the same number, the
               received object already is in its canonical form.
       
               >>> ExtendedContext.canonical(Decimal('2.50'))
               Decimal('2.50')
               """
    1:         return a.canonical(context=self)
       
    1:     def compare(self, a, b):
               """Compares values numerically.
       
               If the signs of the operands differ, a value representing each operand
               ('-1' if the operand is less than zero, '0' if the operand is zero or
               negative zero, or '1' if the operand is greater than zero) is used in
               place of that operand for the comparison instead of the actual
               operand.
       
               The comparison is then effected by subtracting the second operand from
               the first and then returning a value according to the result of the
               subtraction: '-1' if the result is less than zero, '0' if the result is
               zero or negative zero, or '1' if the result is greater than zero.
       
               >>> ExtendedContext.compare(Decimal('2.1'), Decimal('3'))
               Decimal('-1')
               >>> ExtendedContext.compare(Decimal('2.1'), Decimal('2.1'))
               Decimal('0')
               >>> ExtendedContext.compare(Decimal('2.1'), Decimal('2.10'))
               Decimal('0')
               >>> ExtendedContext.compare(Decimal('3'), Decimal('2.1'))
               Decimal('1')
               >>> ExtendedContext.compare(Decimal('2.1'), Decimal('-3'))
               Decimal('1')
               >>> ExtendedContext.compare(Decimal('-3'), Decimal('2.1'))
               Decimal('-1')
               >>> ExtendedContext.compare(1, 2)
               Decimal('-1')
               >>> ExtendedContext.compare(Decimal(1), 2)
               Decimal('-1')
               >>> ExtendedContext.compare(1, Decimal(2))
               Decimal('-1')
               """
  295:         a = _convert_other(a, raiseit=True)
  294:         return a.compare(b, context=self)
       
    1:     def compare_signal(self, a, b):
               """Compares the values of the two operands numerically.
       
               It's pretty much like compare(), but all NaNs signal, with signaling
               NaNs taking precedence over quiet NaNs.
       
               >>> c = ExtendedContext
               >>> c.compare_signal(Decimal('2.1'), Decimal('3'))
               Decimal('-1')
               >>> c.compare_signal(Decimal('2.1'), Decimal('2.1'))
               Decimal('0')
               >>> c.flags[InvalidOperation] = 0
               >>> print c.flags[InvalidOperation]
               0
               >>> c.compare_signal(Decimal('NaN'), Decimal('2.1'))
               Decimal('NaN')
               >>> print c.flags[InvalidOperation]
               1
               >>> c.flags[InvalidOperation] = 0
               >>> print c.flags[InvalidOperation]
               0
               >>> c.compare_signal(Decimal('sNaN'), Decimal('2.1'))
               Decimal('NaN')
               >>> print c.flags[InvalidOperation]
               1
               >>> c.compare_signal(-1, 2)
               Decimal('-1')
               >>> c.compare_signal(Decimal(-1), 2)
               Decimal('-1')
               >>> c.compare_signal(-1, Decimal(2))
               Decimal('-1')
               """
  127:         a = _convert_other(a, raiseit=True)
  126:         return a.compare_signal(b, context=self)
       
    1:     def compare_total(self, a, b):
               """Compares two operands using their abstract representation.
       
               This is not like the standard compare, which use their numerical
               value. Note that a total ordering is defined for all possible abstract
               representations.
       
               >>> ExtendedContext.compare_total(Decimal('12.73'), Decimal('127.9'))
               Decimal('-1')
               >>> ExtendedContext.compare_total(Decimal('-127'),  Decimal('12'))
               Decimal('-1')
               >>> ExtendedContext.compare_total(Decimal('12.30'), Decimal('12.3'))
               Decimal('-1')
               >>> ExtendedContext.compare_total(Decimal('12.30'), Decimal('12.30'))
               Decimal('0')
               >>> ExtendedContext.compare_total(Decimal('12.3'),  Decimal('12.300'))
               Decimal('1')
               >>> ExtendedContext.compare_total(Decimal('12.3'),  Decimal('NaN'))
               Decimal('-1')
               >>> ExtendedContext.compare_total(1, 2)
               Decimal('-1')
               >>> ExtendedContext.compare_total(Decimal(1), 2)
               Decimal('-1')
               >>> ExtendedContext.compare_total(1, Decimal(2))
               Decimal('-1')
               """
  222:         a = _convert_other(a, raiseit=True)
  221:         return a.compare_total(b)
       
    1:     def compare_total_mag(self, a, b):
               """Compares two operands using their abstract representation ignoring sign.
       
               Like compare_total, but with operand's sign ignored and assumed to be 0.
               """
  190:         a = _convert_other(a, raiseit=True)
  189:         return a.compare_total_mag(b)
       
    1:     def copy_abs(self, a):
               """Returns a copy of the operand with the sign set to 0.
       
               >>> ExtendedContext.copy_abs(Decimal('2.1'))
               Decimal('2.1')
               >>> ExtendedContext.copy_abs(Decimal('-100'))
               Decimal('100')
               >>> ExtendedContext.copy_abs(-1)
               Decimal('1')
               """
   18:         a = _convert_other(a, raiseit=True)
   17:         return a.copy_abs()
       
    1:     def copy_decimal(self, a):
               """Returns a copy of the decimal object.
       
               >>> ExtendedContext.copy_decimal(Decimal('2.1'))
               Decimal('2.1')
               >>> ExtendedContext.copy_decimal(Decimal('-1.00'))
               Decimal('-1.00')
               >>> ExtendedContext.copy_decimal(1)
               Decimal('1')
               """
   24:         a = _convert_other(a, raiseit=True)
   23:         return Decimal(a)
       
    1:     def copy_negate(self, a):
               """Returns a copy of the operand with the sign inverted.
       
               >>> ExtendedContext.copy_negate(Decimal('101.5'))
               Decimal('-101.5')
               >>> ExtendedContext.copy_negate(Decimal('-101.5'))
               Decimal('101.5')
               >>> ExtendedContext.copy_negate(1)
               Decimal('-1')
               """
   16:         a = _convert_other(a, raiseit=True)
   15:         return a.copy_negate()
       
    1:     def copy_sign(self, a, b):
               """Copies the second operand's sign to the first one.
       
               In detail, it returns a copy of the first operand with the sign
               equal to the sign of the second operand.
       
               >>> ExtendedContext.copy_sign(Decimal( '1.50'), Decimal('7.33'))
               Decimal('1.50')
               >>> ExtendedContext.copy_sign(Decimal('-1.50'), Decimal('7.33'))
               Decimal('1.50')
               >>> ExtendedContext.copy_sign(Decimal( '1.50'), Decimal('-7.33'))
               Decimal('-1.50')
               >>> ExtendedContext.copy_sign(Decimal('-1.50'), Decimal('-7.33'))
               Decimal('-1.50')
               >>> ExtendedContext.copy_sign(1, -2)
               Decimal('-1')
               >>> ExtendedContext.copy_sign(Decimal(1), -2)
               Decimal('-1')
               >>> ExtendedContext.copy_sign(1, Decimal(-2))
               Decimal('-1')
               """
   42:         a = _convert_other(a, raiseit=True)
   41:         return a.copy_sign(b)
       
    1:     def divide(self, a, b):
               """Decimal division in a specified context.
       
               >>> ExtendedContext.divide(Decimal('1'), Decimal('3'))
               Decimal('0.333333333')
               >>> ExtendedContext.divide(Decimal('2'), Decimal('3'))
               Decimal('0.666666667')
               >>> ExtendedContext.divide(Decimal('5'), Decimal('2'))
               Decimal('2.5')
               >>> ExtendedContext.divide(Decimal('1'), Decimal('10'))
               Decimal('0.1')
               >>> ExtendedContext.divide(Decimal('12'), Decimal('12'))
               Decimal('1')
               >>> ExtendedContext.divide(Decimal('8.00'), Decimal('2'))
               Decimal('4.00')
               >>> ExtendedContext.divide(Decimal('2.400'), Decimal('2.0'))
               Decimal('1.20')
               >>> ExtendedContext.divide(Decimal('1000'), Decimal('100'))
               Decimal('10')
               >>> ExtendedContext.divide(Decimal('1000'), Decimal('1'))
               Decimal('1000')
               >>> ExtendedContext.divide(Decimal('2.40E+6'), Decimal('2'))
               Decimal('1.20E+6')
               >>> ExtendedContext.divide(5, 5)
               Decimal('1')
               >>> ExtendedContext.divide(Decimal(5), 5)
               Decimal('1')
               >>> ExtendedContext.divide(5, Decimal(5))
               Decimal('1')
               """
  349:         a = _convert_other(a, raiseit=True)
  348:         r = a.__div__(b, context=self)
  347:         if r is NotImplemented:
    1:             raise TypeError("Unable to convert %s to Decimal" % b)
               else:
  346:             return r
       
    1:     def divide_int(self, a, b):
               """Divides two numbers and returns the integer part of the result.
       
               >>> ExtendedContext.divide_int(Decimal('2'), Decimal('3'))
               Decimal('0')
               >>> ExtendedContext.divide_int(Decimal('10'), Decimal('3'))
               Decimal('3')
               >>> ExtendedContext.divide_int(Decimal('1'), Decimal('0.3'))
               Decimal('3')
               >>> ExtendedContext.divide_int(10, 3)
               Decimal('3')
               >>> ExtendedContext.divide_int(Decimal(10), 3)
               Decimal('3')
               >>> ExtendedContext.divide_int(10, Decimal(3))
               Decimal('3')
               """
  217:         a = _convert_other(a, raiseit=True)
  216:         r = a.__floordiv__(b, context=self)
  216:         if r is NotImplemented:
    1:             raise TypeError("Unable to convert %s to Decimal" % b)
               else:
  215:             return r
       
    1:     def divmod(self, a, b):
               """Return (a // b, a % b).
       
               >>> ExtendedContext.divmod(Decimal(8), Decimal(3))
               (Decimal('2'), Decimal('2'))
               >>> ExtendedContext.divmod(Decimal(8), Decimal(4))
               (Decimal('2'), Decimal('0'))
               >>> ExtendedContext.divmod(8, 4)
               (Decimal('2'), Decimal('0'))
               >>> ExtendedContext.divmod(Decimal(8), 4)
               (Decimal('2'), Decimal('0'))
               >>> ExtendedContext.divmod(8, Decimal(4))
               (Decimal('2'), Decimal('0'))
               """
   11:         a = _convert_other(a, raiseit=True)
   10:         r = a.__divmod__(b, context=self)
   10:         if r is NotImplemented:
    1:             raise TypeError("Unable to convert %s to Decimal" % b)
               else:
    9:             return r
       
    1:     def exp(self, a):
               """Returns e ** a.
       
               >>> c = ExtendedContext.copy()
               >>> c.Emin = -999
               >>> c.Emax = 999
               >>> c.exp(Decimal('-Infinity'))
               Decimal('0')
               >>> c.exp(Decimal('-1'))
               Decimal('0.367879441')
               >>> c.exp(Decimal('0'))
               Decimal('1')
               >>> c.exp(Decimal('1'))
               Decimal('2.71828183')
               >>> c.exp(Decimal('0.693147181'))
               Decimal('2.00000000')
               >>> c.exp(Decimal('+Infinity'))
               Decimal('Infinity')
               >>> c.exp(10)
               Decimal('22026.4658')
               """
   55:         a =_convert_other(a, raiseit=True)
   54:         return a.exp(context=self)
       
    1:     def fma(self, a, b, c):
               """Returns a multiplied by b, plus c.
       
               The first two operands are multiplied together, using multiply,
               the third operand is then added to the result of that
               multiplication, using add, all with only one final rounding.
       
               >>> ExtendedContext.fma(Decimal('3'), Decimal('5'), Decimal('7'))
               Decimal('22')
               >>> ExtendedContext.fma(Decimal('3'), Decimal('-5'), Decimal('7'))
               Decimal('-8')
               >>> ExtendedContext.fma(Decimal('888565290'), Decimal('1557.96930'), Decimal('-86087.7578'))
               Decimal('1.38435736E+12')
               >>> ExtendedContext.fma(1, 3, 4)
               Decimal('7')
               >>> ExtendedContext.fma(1, Decimal(3), 4)
               Decimal('7')
               >>> ExtendedContext.fma(1, 3, Decimal(4))
               Decimal('7')
               """
  575:         a = _convert_other(a, raiseit=True)
  574:         return a.fma(b, c, context=self)
       
    1:     def is_canonical(self, a):
               """Return True if the operand is canonical; otherwise return False.
       
               Currently, the encoding of a Decimal instance is always
               canonical, so this method returns True for any Decimal.
       
               >>> ExtendedContext.is_canonical(Decimal('2.50'))
               True
               """
   19:         return a.is_canonical()
       
    1:     def is_finite(self, a):
               """Return True if the operand is finite; otherwise return False.
       
               A Decimal instance is considered finite if it is neither
               infinite nor a NaN.
       
               >>> ExtendedContext.is_finite(Decimal('2.50'))
               True
               >>> ExtendedContext.is_finite(Decimal('-0.3'))
               True
               >>> ExtendedContext.is_finite(Decimal('0'))
               True
               >>> ExtendedContext.is_finite(Decimal('Inf'))
               False
               >>> ExtendedContext.is_finite(Decimal('NaN'))
               False
               >>> ExtendedContext.is_finite(1)
               True
               """
   33:         a = _convert_other(a, raiseit=True)
   32:         return a.is_finite()
       
    1:     def is_infinite(self, a):
               """Return True if the operand is infinite; otherwise return False.
       
               >>> ExtendedContext.is_infinite(Decimal('2.50'))
               False
               >>> ExtendedContext.is_infinite(Decimal('-Inf'))
               True
               >>> ExtendedContext.is_infinite(Decimal('NaN'))
               False
               >>> ExtendedContext.is_infinite(1)
               False
               """
   23:         a = _convert_other(a, raiseit=True)
   22:         return a.is_infinite()
       
    1:     def is_nan(self, a):
               """Return True if the operand is a qNaN or sNaN;
               otherwise return False.
       
               >>> ExtendedContext.is_nan(Decimal('2.50'))
               False
               >>> ExtendedContext.is_nan(Decimal('NaN'))
               True
               >>> ExtendedContext.is_nan(Decimal('-sNaN'))
               True
               >>> ExtendedContext.is_nan(1)
               False
               """
   21:         a = _convert_other(a, raiseit=True)
   20:         return a.is_nan()
       
    1:     def is_normal(self, a):
               """Return True if the operand is a normal number;
               otherwise return False.
       
               >>> c = ExtendedContext.copy()
               >>> c.Emin = -999
               >>> c.Emax = 999
               >>> c.is_normal(Decimal('2.50'))
               True
               >>> c.is_normal(Decimal('0.1E-999'))
               False
               >>> c.is_normal(Decimal('0.00'))
               False
               >>> c.is_normal(Decimal('-Inf'))
               False
               >>> c.is_normal(Decimal('NaN'))
               False
               >>> c.is_normal(1)
               True
               """
   24:         a = _convert_other(a, raiseit=True)
   23:         return a.is_normal(context=self)
       
    1:     def is_qnan(self, a):
               """Return True if the operand is a quiet NaN; otherwise return False.
       
               >>> ExtendedContext.is_qnan(Decimal('2.50'))
               False
               >>> ExtendedContext.is_qnan(Decimal('NaN'))
               True
               >>> ExtendedContext.is_qnan(Decimal('sNaN'))
               False
               >>> ExtendedContext.is_qnan(1)
               False
               """
   25:         a = _convert_other(a, raiseit=True)
   24:         return a.is_qnan()
       
    1:     def is_signed(self, a):
               """Return True if the operand is negative; otherwise return False.
       
               >>> ExtendedContext.is_signed(Decimal('2.50'))
               False
               >>> ExtendedContext.is_signed(Decimal('-12'))
               True
               >>> ExtendedContext.is_signed(Decimal('-0'))
               True
               >>> ExtendedContext.is_signed(8)
               False
               >>> ExtendedContext.is_signed(-8)
               True
               """
   19:         a = _convert_other(a, raiseit=True)
   18:         return a.is_signed()
       
    1:     def is_snan(self, a):
               """Return True if the operand is a signaling NaN;
               otherwise return False.
       
               >>> ExtendedContext.is_snan(Decimal('2.50'))
               False
               >>> ExtendedContext.is_snan(Decimal('NaN'))
               False
               >>> ExtendedContext.is_snan(Decimal('sNaN'))
               True
               >>> ExtendedContext.is_snan(1)
               False
               """
   34:         a = _convert_other(a, raiseit=True)
   33:         return a.is_snan()
       
    1:     def is_subnormal(self, a):
               """Return True if the operand is subnormal; otherwise return False.
       
               >>> c = ExtendedContext.copy()
               >>> c.Emin = -999
               >>> c.Emax = 999
               >>> c.is_subnormal(Decimal('2.50'))
               False
               >>> c.is_subnormal(Decimal('0.1E-999'))
               True
               >>> c.is_subnormal(Decimal('0.00'))
               False
               >>> c.is_subnormal(Decimal('-Inf'))
               False
               >>> c.is_subnormal(Decimal('NaN'))
               False
               >>> c.is_subnormal(1)
               False
               """
   35:         a = _convert_other(a, raiseit=True)
   34:         return a.is_subnormal(context=self)
       
    1:     def is_zero(self, a):
               """Return True if the operand is a zero; otherwise return False.
       
               >>> ExtendedContext.is_zero(Decimal('0'))
               True
               >>> ExtendedContext.is_zero(Decimal('2.50'))
               False
               >>> ExtendedContext.is_zero(Decimal('-0E+2'))
               True
               >>> ExtendedContext.is_zero(1)
               False
               >>> ExtendedContext.is_zero(0)
               True
               """
   28:         a = _convert_other(a, raiseit=True)
   27:         return a.is_zero()
       
    1:     def ln(self, a):
               """Returns the natural (base e) logarithm of the operand.
       
               >>> c = ExtendedContext.copy()
               >>> c.Emin = -999
               >>> c.Emax = 999
               >>> c.ln(Decimal('0'))
               Decimal('-Infinity')
               >>> c.ln(Decimal('1.000'))
               Decimal('0')
               >>> c.ln(Decimal('2.71828183'))
               Decimal('1.00000000')
               >>> c.ln(Decimal('10'))
               Decimal('2.30258509')
               >>> c.ln(Decimal('+Infinity'))
               Decimal('Infinity')
               >>> c.ln(1)
               Decimal('0')
               """
   46:         a = _convert_other(a, raiseit=True)
   45:         return a.ln(context=self)
       
    1:     def log10(self, a):
               """Returns the base 10 logarithm of the operand.
       
               >>> c = ExtendedContext.copy()
               >>> c.Emin = -999
               >>> c.Emax = 999
               >>> c.log10(Decimal('0'))
               Decimal('-Infinity')
               >>> c.log10(Decimal('0.001'))
               Decimal('-3')
               >>> c.log10(Decimal('1.000'))
               Decimal('0')
               >>> c.log10(Decimal('2'))
               Decimal('0.301029996')
               >>> c.log10(Decimal('10'))
               Decimal('1')
               >>> c.log10(Decimal('70'))
               Decimal('1.84509804')
               >>> c.log10(Decimal('+Infinity'))
               Decimal('Infinity')
               >>> c.log10(0)
               Decimal('-Infinity')
               >>> c.log10(1)
               Decimal('0')
               """
   43:         a = _convert_other(a, raiseit=True)
   42:         return a.log10(context=self)
       
    1:     def logb(self, a):
               """ Returns the exponent of the magnitude of the operand's MSD.
       
               The result is the integer which is the exponent of the magnitude
               of the most significant digit of the operand (as though the
               operand were truncated to a single digit while maintaining the
               value of that digit and without limiting the resulting exponent).
       
               >>> ExtendedContext.logb(Decimal('250'))
               Decimal('2')
               >>> ExtendedContext.logb(Decimal('2.50'))
               Decimal('0')
               >>> ExtendedContext.logb(Decimal('0.03'))
               Decimal('-2')
               >>> ExtendedContext.logb(Decimal('0'))
               Decimal('-Infinity')
               >>> ExtendedContext.logb(1)
               Decimal('0')
               >>> ExtendedContext.logb(10)
               Decimal('1')
               >>> ExtendedContext.logb(100)
               Decimal('2')
               """
   52:         a = _convert_other(a, raiseit=True)
   51:         return a.logb(context=self)
       
    1:     def logical_and(self, a, b):
               """Applies the logical operation 'and' between each operand's digits.
       
               The operands must be both logical numbers.
       
               >>> ExtendedContext.logical_and(Decimal('0'), Decimal('0'))
               Decimal('0')
               >>> ExtendedContext.logical_and(Decimal('0'), Decimal('1'))
               Decimal('0')
               >>> ExtendedContext.logical_and(Decimal('1'), Decimal('0'))
               Decimal('0')
               >>> ExtendedContext.logical_and(Decimal('1'), Decimal('1'))
               Decimal('1')
               >>> ExtendedContext.logical_and(Decimal('1100'), Decimal('1010'))
               Decimal('1000')
               >>> ExtendedContext.logical_and(Decimal('1111'), Decimal('10'))
               Decimal('10')
               >>> ExtendedContext.logical_and(110, 1101)
               Decimal('100')
               >>> ExtendedContext.logical_and(Decimal(110), 1101)
               Decimal('100')
               >>> ExtendedContext.logical_and(110, Decimal(1101))
               Decimal('100')
               """
  105:         a = _convert_other(a, raiseit=True)
  104:         return a.logical_and(b, context=self)
       
    1:     def logical_invert(self, a):
               """Invert all the digits in the operand.
       
               The operand must be a logical number.
       
               >>> ExtendedContext.logical_invert(Decimal('0'))
               Decimal('111111111')
               >>> ExtendedContext.logical_invert(Decimal('1'))
               Decimal('111111110')
               >>> ExtendedContext.logical_invert(Decimal('111111111'))
               Decimal('0')
               >>> ExtendedContext.logical_invert(Decimal('101010101'))
               Decimal('10101010')
               >>> ExtendedContext.logical_invert(1101)
               Decimal('111110010')
               """
   56:         a = _convert_other(a, raiseit=True)
   55:         return a.logical_invert(context=self)
       
    1:     def logical_or(self, a, b):
               """Applies the logical operation 'or' between each operand's digits.
       
               The operands must be both logical numbers.
       
               >>> ExtendedContext.logical_or(Decimal('0'), Decimal('0'))
               Decimal('0')
               >>> ExtendedContext.logical_or(Decimal('0'), Decimal('1'))
               Decimal('1')
               >>> ExtendedContext.logical_or(Decimal('1'), Decimal('0'))
               Decimal('1')
               >>> ExtendedContext.logical_or(Decimal('1'), Decimal('1'))
               Decimal('1')
               >>> ExtendedContext.logical_or(Decimal('1100'), Decimal('1010'))
               Decimal('1110')
               >>> ExtendedContext.logical_or(Decimal('1110'), Decimal('10'))
               Decimal('1110')
               >>> ExtendedContext.logical_or(110, 1101)
               Decimal('1111')
               >>> ExtendedContext.logical_or(Decimal(110), 1101)
               Decimal('1111')
               >>> ExtendedContext.logical_or(110, Decimal(1101))
               Decimal('1111')
               """
  101:         a = _convert_other(a, raiseit=True)
  100:         return a.logical_or(b, context=self)
       
    1:     def logical_xor(self, a, b):
               """Applies the logical operation 'xor' between each operand's digits.
       
               The operands must be both logical numbers.
       
               >>> ExtendedContext.logical_xor(Decimal('0'), Decimal('0'))
               Decimal('0')
               >>> ExtendedContext.logical_xor(Decimal('0'), Decimal('1'))
               Decimal('1')
               >>> ExtendedContext.logical_xor(Decimal('1'), Decimal('0'))
               Decimal('1')
               >>> ExtendedContext.logical_xor(Decimal('1'), Decimal('1'))
               Decimal('0')
               >>> ExtendedContext.logical_xor(Decimal('1100'), Decimal('1010'))
               Decimal('110')
               >>> ExtendedContext.logical_xor(Decimal('1111'), Decimal('10'))
               Decimal('1101')
               >>> ExtendedContext.logical_xor(110, 1101)
               Decimal('1011')
               >>> ExtendedContext.logical_xor(Decimal(110), 1101)
               Decimal('1011')
               >>> ExtendedContext.logical_xor(110, Decimal(1101))
               Decimal('1011')
               """
  106:         a = _convert_other(a, raiseit=True)
  105:         return a.logical_xor(b, context=self)
       
    1:     def max(self, a, b):
               """max compares two values numerically and returns the maximum.
       
               If either operand is a NaN then the general rules apply.
               Otherwise, the operands are compared as though by the compare
               operation.  If they are numerically equal then the left-hand operand
               is chosen as the result.  Otherwise the maximum (closer to positive
               infinity) of the two operands is chosen as the result.
       
               >>> ExtendedContext.max(Decimal('3'), Decimal('2'))
               Decimal('3')
               >>> ExtendedContext.max(Decimal('-10'), Decimal('3'))
               Decimal('3')
               >>> ExtendedContext.max(Decimal('1.0'), Decimal('1'))
               Decimal('1')
               >>> ExtendedContext.max(Decimal('7'), Decimal('NaN'))
               Decimal('7')
               >>> ExtendedContext.max(1, 2)
               Decimal('2')
               >>> ExtendedContext.max(Decimal(1), 2)
               Decimal('2')
               >>> ExtendedContext.max(1, Decimal(2))
               Decimal('2')
               """
  107:         a = _convert_other(a, raiseit=True)
  106:         return a.max(b, context=self)
       
    1:     def max_mag(self, a, b):
               """Compares the values numerically with their sign ignored.
       
               >>> ExtendedContext.max_mag(Decimal('7'), Decimal('NaN'))
               Decimal('7')
               >>> ExtendedContext.max_mag(Decimal('7'), Decimal('-10'))
               Decimal('-10')
               >>> ExtendedContext.max_mag(1, -2)
               Decimal('-2')
               >>> ExtendedContext.max_mag(Decimal(1), -2)
               Decimal('-2')
               >>> ExtendedContext.max_mag(1, Decimal(-2))
               Decimal('-2')
               """
   87:         a = _convert_other(a, raiseit=True)
   86:         return a.max_mag(b, context=self)
       
    1:     def min(self, a, b):
               """min compares two values numerically and returns the minimum.
       
               If either operand is a NaN then the general rules apply.
               Otherwise, the operands are compared as though by the compare
               operation.  If they are numerically equal then the left-hand operand
               is chosen as the result.  Otherwise the minimum (closer to negative
               infinity) of the two operands is chosen as the result.
       
               >>> ExtendedContext.min(Decimal('3'), Decimal('2'))
               Decimal('2')
               >>> ExtendedContext.min(Decimal('-10'), Decimal('3'))
               Decimal('-10')
               >>> ExtendedContext.min(Decimal('1.0'), Decimal('1'))
               Decimal('1.0')
               >>> ExtendedContext.min(Decimal('7'), Decimal('NaN'))
               Decimal('7')
               >>> ExtendedContext.min(1, 2)
               Decimal('1')
               >>> ExtendedContext.min(Decimal(1), 2)
               Decimal('1')
               >>> ExtendedContext.min(1, Decimal(29))
               Decimal('1')
               """
   89:         a = _convert_other(a, raiseit=True)
   88:         return a.min(b, context=self)
       
    1:     def min_mag(self, a, b):
               """Compares the values numerically with their sign ignored.
       
               >>> ExtendedContext.min_mag(Decimal('3'), Decimal('-2'))
               Decimal('-2')
               >>> ExtendedContext.min_mag(Decimal('-3'), Decimal('NaN'))
               Decimal('-3')
               >>> ExtendedContext.min_mag(1, -2)
               Decimal('1')
               >>> ExtendedContext.min_mag(Decimal(1), -2)
               Decimal('1')
               >>> ExtendedContext.min_mag(1, Decimal(-2))
               Decimal('1')
               """
   93:         a = _convert_other(a, raiseit=True)
   92:         return a.min_mag(b, context=self)
       
    1:     def minus(self, a):
               """Minus corresponds to unary prefix minus in Python.
       
               The operation is evaluated using the same rules as subtract; the
               operation minus(a) is calculated as subtract('0', a) where the '0'
               has the same exponent as the operand.
       
               >>> ExtendedContext.minus(Decimal('1.3'))
               Decimal('-1.3')
               >>> ExtendedContext.minus(Decimal('-1.3'))
               Decimal('1.3')
               >>> ExtendedContext.minus(1)
               Decimal('-1')
               """
   24:         a = _convert_other(a, raiseit=True)
   23:         return a.__neg__(context=self)
       
    1:     def multiply(self, a, b):
               """multiply multiplies two operands.
       
               If either operand is a special value then the general rules apply.
               Otherwise, the operands are multiplied together
               ('long multiplication'), resulting in a number which may be as long as
               the sum of the lengths of the two operands.
       
               >>> ExtendedContext.multiply(Decimal('1.20'), Decimal('3'))
               Decimal('3.60')
               >>> ExtendedContext.multiply(Decimal('7'), Decimal('3'))
               Decimal('21')
               >>> ExtendedContext.multiply(Decimal('0.9'), Decimal('0.8'))
               Decimal('0.72')
               >>> ExtendedContext.multiply(Decimal('0.9'), Decimal('-0'))
               Decimal('-0.0')
               >>> ExtendedContext.multiply(Decimal('654321'), Decimal('654321'))
               Decimal('4.28135971E+11')
               >>> ExtendedContext.multiply(7, 7)
               Decimal('49')
               >>> ExtendedContext.multiply(Decimal(7), 7)
               Decimal('49')
               >>> ExtendedContext.multiply(7, Decimal(7))
               Decimal('49')
               """
  292:         a = _convert_other(a, raiseit=True)
  291:         r = a.__mul__(b, context=self)
  291:         if r is NotImplemented:
    1:             raise TypeError("Unable to convert %s to Decimal" % b)
               else:
  290:             return r
       
    1:     def next_minus(self, a):
               """Returns the largest representable number smaller than a.
       
               >>> c = ExtendedContext.copy()
               >>> c.Emin = -999
               >>> c.Emax = 999
               >>> ExtendedContext.next_minus(Decimal('1'))
               Decimal('0.999999999')
               >>> c.next_minus(Decimal('1E-1007'))
               Decimal('0E-1007')
               >>> ExtendedContext.next_minus(Decimal('-1.00000003'))
               Decimal('-1.00000004')
               >>> c.next_minus(Decimal('Infinity'))
               Decimal('9.99999999E+999')
               >>> c.next_minus(1)
               Decimal('0.999999999')
               """
   39:         a = _convert_other(a, raiseit=True)
   38:         return a.next_minus(context=self)
       
    1:     def next_plus(self, a):
               """Returns the smallest representable number larger than a.
       
               >>> c = ExtendedContext.copy()
               >>> c.Emin = -999
               >>> c.Emax = 999
               >>> ExtendedContext.next_plus(Decimal('1'))
               Decimal('1.00000001')
               >>> c.next_plus(Decimal('-1E-1007'))
               Decimal('-0E-1007')
               >>> ExtendedContext.next_plus(Decimal('-1.00000003'))
               Decimal('-1.00000002')
               >>> c.next_plus(Decimal('-Infinity'))
               Decimal('-9.99999999E+999')
               >>> c.next_plus(1)
               Decimal('1.00000001')
               """
   37:         a = _convert_other(a, raiseit=True)
   36:         return a.next_plus(context=self)
       
    1:     def next_toward(self, a, b):
               """Returns the number closest to a, in direction towards b.
       
               The result is the closest representable number from the first
               operand (but not the first operand) that is in the direction
               towards the second operand, unless the operands have the same
               value.
       
               >>> c = ExtendedContext.copy()
               >>> c.Emin = -999
               >>> c.Emax = 999
               >>> c.next_toward(Decimal('1'), Decimal('2'))
               Decimal('1.00000001')
               >>> c.next_toward(Decimal('-1E-1007'), Decimal('1'))
               Decimal('-0E-1007')
               >>> c.next_toward(Decimal('-1.00000003'), Decimal('0'))
               Decimal('-1.00000002')
               >>> c.next_toward(Decimal('1'), Decimal('0'))
               Decimal('0.999999999')
               >>> c.next_toward(Decimal('1E-1007'), Decimal('-100'))
               Decimal('0E-1007')
               >>> c.next_toward(Decimal('-1.00000003'), Decimal('-10'))
               Decimal('-1.00000004')
               >>> c.next_toward(Decimal('0.00'), Decimal('-0.0000'))
               Decimal('-0.00')
               >>> c.next_toward(0, 1)
               Decimal('1E-1007')
               >>> c.next_toward(Decimal(0), 1)
               Decimal('1E-1007')
               >>> c.next_toward(0, Decimal(1))
               Decimal('1E-1007')
               """
  109:         a = _convert_other(a, raiseit=True)
  108:         return a.next_toward(b, context=self)
       
    1:     def normalize(self, a):
               """normalize reduces an operand to its simplest form.
       
               Essentially a plus operation with all trailing zeros removed from the
               result.
       
               >>> ExtendedContext.normalize(Decimal('2.1'))
               Decimal('2.1')
               >>> ExtendedContext.normalize(Decimal('-2.0'))
               Decimal('-2')
               >>> ExtendedContext.normalize(Decimal('1.200'))
               Decimal('1.2')
               >>> ExtendedContext.normalize(Decimal('-120'))
               Decimal('-1.2E+2')
               >>> ExtendedContext.normalize(Decimal('120.00'))
               Decimal('1.2E+2')
               >>> ExtendedContext.normalize(Decimal('0.00'))
               Decimal('0')
               >>> ExtendedContext.normalize(6)
               Decimal('6')
               """
   51:         a = _convert_other(a, raiseit=True)
   50:         return a.normalize(context=self)
       
    1:     def number_class(self, a):
               """Returns an indication of the class of the operand.
       
               The class is one of the following strings:
                 -sNaN
                 -NaN
                 -Infinity
                 -Normal
                 -Subnormal
                 -Zero
                 +Zero
                 +Subnormal
                 +Normal
                 +Infinity
       
               >>> c = Context(ExtendedContext)
               >>> c.Emin = -999
               >>> c.Emax = 999
               >>> c.number_class(Decimal('Infinity'))
               '+Infinity'
               >>> c.number_class(Decimal('1E-10'))
               '+Normal'
               >>> c.number_class(Decimal('2.50'))
               '+Normal'
               >>> c.number_class(Decimal('0.1E-999'))
               '+Subnormal'
               >>> c.number_class(Decimal('0'))
               '+Zero'
               >>> c.number_class(Decimal('-0'))
               '-Zero'
               >>> c.number_class(Decimal('-0.1E-999'))
               '-Subnormal'
               >>> c.number_class(Decimal('-1E-10'))
               '-Normal'
               >>> c.number_class(Decimal('-2.50'))
               '-Normal'
               >>> c.number_class(Decimal('-Infinity'))
               '-Infinity'
               >>> c.number_class(Decimal('NaN'))
               'NaN'
               >>> c.number_class(Decimal('-NaN'))
               'NaN'
               >>> c.number_class(Decimal('sNaN'))
               'sNaN'
               >>> c.number_class(123)
               '+Normal'
               """
   37:         a = _convert_other(a, raiseit=True)
   37:         return a.number_class(context=self)
       
    1:     def plus(self, a):
               """Plus corresponds to unary prefix plus in Python.
       
               The operation is evaluated using the same rules as add; the
               operation plus(a) is calculated as add('0', a) where the '0'
               has the same exponent as the operand.
       
               >>> ExtendedContext.plus(Decimal('1.3'))
               Decimal('1.3')
               >>> ExtendedContext.plus(Decimal('-1.3'))
               Decimal('-1.3')
               >>> ExtendedContext.plus(-1)
               Decimal('-1')
               """
   26:         a = _convert_other(a, raiseit=True)
   25:         return a.__pos__(context=self)
       
    1:     def power(self, a, b, modulo=None):
               """Raises a to the power of b, to modulo if given.
       
               With two arguments, compute a**b.  If a is negative then b
               must be integral.  The result will be inexact unless b is
               integral and the result is finite and can be expressed exactly
               in 'precision' digits.
       
               With three arguments, compute (a**b) % modulo.  For the
               three argument form, the following restrictions on the
               arguments hold:
       
                - all three arguments must be integral
                - b must be nonnegative
                - at least one of a or b must be nonzero
                - modulo must be nonzero and have at most 'precision' digits
       
               The result of pow(a, b, modulo) is identical to the result
               that would be obtained by computing (a**b) % modulo with
               unbounded precision, but is computed more efficiently.  It is
               always exact.
       
               >>> c = ExtendedContext.copy()
               >>> c.Emin = -999
               >>> c.Emax = 999
               >>> c.power(Decimal('2'), Decimal('3'))
               Decimal('8')
               >>> c.power(Decimal('-2'), Decimal('3'))
               Decimal('-8')
               >>> c.power(Decimal('2'), Decimal('-3'))
               Decimal('0.125')
               >>> c.power(Decimal('1.7'), Decimal('8'))
               Decimal('69.7575744')
               >>> c.power(Decimal('10'), Decimal('0.301029996'))
               Decimal('2.00000000')
               >>> c.power(Decimal('Infinity'), Decimal('-1'))
               Decimal('0')
               >>> c.power(Decimal('Infinity'), Decimal('0'))
               Decimal('1')
               >>> c.power(Decimal('Infinity'), Decimal('1'))
               Decimal('Infinity')
               >>> c.power(Decimal('-Infinity'), Decimal('-1'))
               Decimal('-0')
               >>> c.power(Decimal('-Infinity'), Decimal('0'))
               Decimal('1')
               >>> c.power(Decimal('-Infinity'), Decimal('1'))
               Decimal('-Infinity')
               >>> c.power(Decimal('-Infinity'), Decimal('2'))
               Decimal('Infinity')
               >>> c.power(Decimal('0'), Decimal('0'))
               Decimal('NaN')
       
               >>> c.power(Decimal('3'), Decimal('7'), Decimal('16'))
               Decimal('11')
               >>> c.power(Decimal('-3'), Decimal('7'), Decimal('16'))
               Decimal('-11')
               >>> c.power(Decimal('-3'), Decimal('8'), Decimal('16'))
               Decimal('1')
               >>> c.power(Decimal('3'), Decimal('7'), Decimal('-16'))
               Decimal('11')
               >>> c.power(Decimal('23E12345'), Decimal('67E189'), Decimal('123456789'))
               Decimal('11729830')
               >>> c.power(Decimal('-0'), Decimal('17'), Decimal('1729'))
               Decimal('-0')
               >>> c.power(Decimal('-23'), Decimal('0'), Decimal('65537'))
               Decimal('1')
               >>> ExtendedContext.power(7, 7)
               Decimal('823543')
               >>> ExtendedContext.power(Decimal(7), 7)
               Decimal('823543')
               >>> ExtendedContext.power(7, Decimal(7), 2)
               Decimal('1')
               """
  540:         a = _convert_other(a, raiseit=True)
  539:         r = a.__pow__(b, modulo, context=self)
  537:         if r is NotImplemented:
>>>>>>             raise TypeError("Unable to convert %s to Decimal" % b)
               else:
  537:             return r
       
    1:     def quantize(self, a, b):
               """Returns a value equal to 'a' (rounded), having the exponent of 'b'.
       
               The coefficient of the result is derived from that of the left-hand
               operand.  It may be rounded using the current rounding setting (if the
               exponent is being increased), multiplied by a positive power of ten (if
               the exponent is being decreased), or is unchanged (if the exponent is
               already equal to that of the right-hand operand).
       
               Unlike other operations, if the length of the coefficient after the
               quantize operation would be greater than precision then an Invalid
               operation condition is raised.  This guarantees that, unless there is
               an error condition, the exponent of the result of a quantize is always
               equal to that of the right-hand operand.
       
               Also unlike other operations, quantize will never raise Underflow, even
               if the result is subnormal and inexact.
       
               >>> ExtendedContext.quantize(Decimal('2.17'), Decimal('0.001'))
               Decimal('2.170')
               >>> ExtendedContext.quantize(Decimal('2.17'), Decimal('0.01'))
               Decimal('2.17')
               >>> ExtendedContext.quantize(Decimal('2.17'), Decimal('0.1'))
               Decimal('2.2')
               >>> ExtendedContext.quantize(Decimal('2.17'), Decimal('1e+0'))
               Decimal('2')
               >>> ExtendedContext.quantize(Decimal('2.17'), Decimal('1e+1'))
               Decimal('0E+1')
               >>> ExtendedContext.quantize(Decimal('-Inf'), Decimal('Infinity'))
               Decimal('-Infinity')
               >>> ExtendedContext.quantize(Decimal('2'), Decimal('Infinity'))
               Decimal('NaN')
               >>> ExtendedContext.quantize(Decimal('-0.1'), Decimal('1'))
               Decimal('-0')
               >>> ExtendedContext.quantize(Decimal('-0'), Decimal('1e+5'))
               Decimal('-0E+5')
               >>> ExtendedContext.quantize(Decimal('+35236450.6'), Decimal('1e-2'))
               Decimal('NaN')
               >>> ExtendedContext.quantize(Decimal('-35236450.6'), Decimal('1e-2'))
               Decimal('NaN')
               >>> ExtendedContext.quantize(Decimal('217'), Decimal('1e-1'))
               Decimal('217.0')
               >>> ExtendedContext.quantize(Decimal('217'), Decimal('1e-0'))
               Decimal('217')
               >>> ExtendedContext.quantize(Decimal('217'), Decimal('1e+1'))
               Decimal('2.2E+2')
               >>> ExtendedContext.quantize(Decimal('217'), Decimal('1e+2'))
               Decimal('2E+2')
               >>> ExtendedContext.quantize(1, 2)
               Decimal('1')
               >>> ExtendedContext.quantize(Decimal(1), 2)
               Decimal('1')
               >>> ExtendedContext.quantize(1, Decimal(2))
               Decimal('1')
               """
  226:         a = _convert_other(a, raiseit=True)
  225:         return a.quantize(b, context=self)
       
    1:     def radix(self):
               """Just returns 10, as this is Decimal, :)
       
               >>> ExtendedContext.radix()
               Decimal('10')
               """
    1:         return Decimal(10)
       
    1:     def remainder(self, a, b):
               """Returns the remainder from integer division.
       
               The result is the residue of the dividend after the operation of
               calculating integer division as described for divide-integer, rounded
               to precision digits if necessary.  The sign of the result, if
               non-zero, is the same as that of the original dividend.
       
               This operation will fail under the same conditions as integer division
               (that is, if integer division on the same two operands would fail, the
               remainder cannot be calculated).
       
               >>> ExtendedContext.remainder(Decimal('2.1'), Decimal('3'))
               Decimal('2.1')
               >>> ExtendedContext.remainder(Decimal('10'), Decimal('3'))
               Decimal('1')
               >>> ExtendedContext.remainder(Decimal('-10'), Decimal('3'))
               Decimal('-1')
               >>> ExtendedContext.remainder(Decimal('10.2'), Decimal('1'))
               Decimal('0.2')
               >>> ExtendedContext.remainder(Decimal('10'), Decimal('0.3'))
               Decimal('0.1')
               >>> ExtendedContext.remainder(Decimal('3.6'), Decimal('1.3'))
               Decimal('1.0')
               >>> ExtendedContext.remainder(22, 6)
               Decimal('4')
               >>> ExtendedContext.remainder(Decimal(22), 6)
               Decimal('4')
               >>> ExtendedContext.remainder(22, Decimal(6))
               Decimal('4')
               """
  263:         a = _convert_other(a, raiseit=True)
  262:         r = a.__mod__(b, context=self)
  262:         if r is NotImplemented:
    1:             raise TypeError("Unable to convert %s to Decimal" % b)
               else:
  261:             return r
       
    1:     def remainder_near(self, a, b):
               """Returns to be "a - b * n", where n is the integer nearest the exact
               value of "x / b" (if two integers are equally near then the even one
               is chosen).  If the result is equal to 0 then its sign will be the
               sign of a.
       
               This operation will fail under the same conditions as integer division
               (that is, if integer division on the same two operands would fail, the
               remainder cannot be calculated).
       
               >>> ExtendedContext.remainder_near(Decimal('2.1'), Decimal('3'))
               Decimal('-0.9')
               >>> ExtendedContext.remainder_near(Decimal('10'), Decimal('6'))
               Decimal('-2')
               >>> ExtendedContext.remainder_near(Decimal('10'), Decimal('3'))
               Decimal('1')
               >>> ExtendedContext.remainder_near(Decimal('-10'), Decimal('3'))
               Decimal('-1')
               >>> ExtendedContext.remainder_near(Decimal('10.2'), Decimal('1'))
               Decimal('0.2')
               >>> ExtendedContext.remainder_near(Decimal('10'), Decimal('0.3'))
               Decimal('0.1')
               >>> ExtendedContext.remainder_near(Decimal('3.6'), Decimal('1.3'))
               Decimal('-0.3')
               >>> ExtendedContext.remainder_near(3, 11)
               Decimal('3')
               >>> ExtendedContext.remainder_near(Decimal(3), 11)
               Decimal('3')
               >>> ExtendedContext.remainder_near(3, Decimal(11))
               Decimal('3')
               """
  155:         a = _convert_other(a, raiseit=True)
  154:         return a.remainder_near(b, context=self)
       
    1:     def rotate(self, a, b):
               """Returns a rotated copy of a, b times.
       
               The coefficient of the result is a rotated copy of the digits in
               the coefficient of the first operand.  The number of places of
               rotation is taken from the absolute value of the second operand,
               with the rotation being to the left if the second operand is
               positive or to the right otherwise.
       
               >>> ExtendedContext.rotate(Decimal('34'), Decimal('8'))
               Decimal('400000003')
               >>> ExtendedContext.rotate(Decimal('12'), Decimal('9'))
               Decimal('12')
               >>> ExtendedContext.rotate(Decimal('123456789'), Decimal('-2'))
               Decimal('891234567')
               >>> ExtendedContext.rotate(Decimal('123456789'), Decimal('0'))
               Decimal('123456789')
               >>> ExtendedContext.rotate(Decimal('123456789'), Decimal('+2'))
               Decimal('345678912')
               >>> ExtendedContext.rotate(1333333, 1)
               Decimal('13333330')
               >>> ExtendedContext.rotate(Decimal(1333333), 1)
               Decimal('13333330')
               >>> ExtendedContext.rotate(1333333, Decimal(1))
               Decimal('13333330')
               """
   83:         a = _convert_other(a, raiseit=True)
   82:         return a.rotate(b, context=self)
       
    1:     def same_quantum(self, a, b):
               """Returns True if the two operands have the same exponent.
       
               The result is never affected by either the sign or the coefficient of
               either operand.
       
               >>> ExtendedContext.same_quantum(Decimal('2.17'), Decimal('0.001'))
               False
               >>> ExtendedContext.same_quantum(Decimal('2.17'), Decimal('0.01'))
               True
               >>> ExtendedContext.same_quantum(Decimal('2.17'), Decimal('1'))
               False
               >>> ExtendedContext.same_quantum(Decimal('Inf'), Decimal('-Inf'))
               True
               >>> ExtendedContext.same_quantum(10000, -1)
               True
               >>> ExtendedContext.same_quantum(Decimal(10000), -1)
               True
               >>> ExtendedContext.same_quantum(10000, Decimal(-1))
               True
               """
  123:         a = _convert_other(a, raiseit=True)
  122:         return a.same_quantum(b)
       
    1:     def scaleb (self, a, b):
               """Returns the first operand after adding the second value its exp.
       
               >>> ExtendedContext.scaleb(Decimal('7.50'), Decimal('-2'))
               Decimal('0.0750')
               >>> ExtendedContext.scaleb(Decimal('7.50'), Decimal('0'))
               Decimal('7.50')
               >>> ExtendedContext.scaleb(Decimal('7.50'), Decimal('3'))
               Decimal('7.50E+3')
               >>> ExtendedContext.scaleb(1, 4)
               Decimal('1E+4')
               >>> ExtendedContext.scaleb(Decimal(1), 4)
               Decimal('1E+4')
               >>> ExtendedContext.scaleb(1, Decimal(4))
               Decimal('1E+4')
               """
   58:         a = _convert_other(a, raiseit=True)
   57:         return a.scaleb(b, context=self)
       
    1:     def shift(self, a, b):
               """Returns a shifted copy of a, b times.
       
               The coefficient of the result is a shifted copy of the digits
               in the coefficient of the first operand.  The number of places
               to shift is taken from the absolute value of the second operand,
               with the shift being to the left if the second operand is
               positive or to the right otherwise.  Digits shifted into the
               coefficient are zeros.
       
               >>> ExtendedContext.shift(Decimal('34'), Decimal('8'))
               Decimal('400000000')
               >>> ExtendedContext.shift(Decimal('12'), Decimal('9'))
               Decimal('0')
               >>> ExtendedContext.shift(Decimal('123456789'), Decimal('-2'))
               Decimal('1234567')
               >>> ExtendedContext.shift(Decimal('123456789'), Decimal('0'))
               Decimal('123456789')
               >>> ExtendedContext.shift(Decimal('123456789'), Decimal('+2'))
               Decimal('345678900')
               >>> ExtendedContext.shift(88888888, 2)
               Decimal('888888800')
               >>> ExtendedContext.shift(Decimal(88888888), 2)
               Decimal('888888800')
               >>> ExtendedContext.shift(88888888, Decimal(2))
               Decimal('888888800')
               """
   95:         a = _convert_other(a, raiseit=True)
   94:         return a.shift(b, context=self)
       
    1:     def sqrt(self, a):
               """Square root of a non-negative number to context precision.
       
               If the result must be inexact, it is rounded using the round-half-even
               algorithm.
       
               >>> ExtendedContext.sqrt(Decimal('0'))
               Decimal('0')
               >>> ExtendedContext.sqrt(Decimal('-0'))
               Decimal('-0')
               >>> ExtendedContext.sqrt(Decimal('0.39'))
               Decimal('0.624499800')
               >>> ExtendedContext.sqrt(Decimal('100'))
               Decimal('10')
               >>> ExtendedContext.sqrt(Decimal('1'))
               Decimal('1')
               >>> ExtendedContext.sqrt(Decimal('1.0'))
               Decimal('1.0')
               >>> ExtendedContext.sqrt(Decimal('1.00'))
               Decimal('1.0')
               >>> ExtendedContext.sqrt(Decimal('7'))
               Decimal('2.64575131')
               >>> ExtendedContext.sqrt(Decimal('10'))
               Decimal('3.16227766')
               >>> ExtendedContext.sqrt(2)
               Decimal('1.41421356')
               >>> ExtendedContext.prec
               9
               """
  385:         a = _convert_other(a, raiseit=True)
  384:         return a.sqrt(context=self)
       
    1:     def subtract(self, a, b):
               """Return the difference between the two operands.
       
               >>> ExtendedContext.subtract(Decimal('1.3'), Decimal('1.07'))
               Decimal('0.23')
               >>> ExtendedContext.subtract(Decimal('1.3'), Decimal('1.30'))
               Decimal('0.00')
               >>> ExtendedContext.subtract(Decimal('1.3'), Decimal('2.07'))
               Decimal('-0.77')
               >>> ExtendedContext.subtract(8, 5)
               Decimal('3')
               >>> ExtendedContext.subtract(Decimal(8), 5)
               Decimal('3')
               >>> ExtendedContext.subtract(8, Decimal(5))
               Decimal('3')
               """
  272:         a = _convert_other(a, raiseit=True)
  271:         r = a.__sub__(b, context=self)
  271:         if r is NotImplemented:
    1:             raise TypeError("Unable to convert %s to Decimal" % b)
               else:
  270:             return r
       
    1:     def to_eng_string(self, a):
               """Convert to a string, using engineering notation if an exponent is needed.
       
               Engineering notation has an exponent which is a multiple of 3.  This
               can leave up to 3 digits to the left of the decimal place and may
               require the addition of either one or two trailing zeros.
       
               The operation is not affected by the context.
       
               >>> ExtendedContext.to_eng_string(Decimal('123E+1'))
               '1.23E+3'
               >>> ExtendedContext.to_eng_string(Decimal('123E+3'))
               '123E+3'
               >>> ExtendedContext.to_eng_string(Decimal('123E-10'))
               '12.3E-9'
               >>> ExtendedContext.to_eng_string(Decimal('-123E-12'))
               '-123E-12'
               >>> ExtendedContext.to_eng_string(Decimal('7E-7'))
               '700E-9'
               >>> ExtendedContext.to_eng_string(Decimal('7E+1'))
               '70'
               >>> ExtendedContext.to_eng_string(Decimal('0E+1'))
               '0.00E+3'
       
               """
   76:         a = _convert_other(a, raiseit=True)
   75:         return a.to_eng_string(context=self)
       
    1:     def to_sci_string(self, a):
               """Converts a number to a string, using scientific notation.
       
               The operation is not affected by the context.
               """
  332:         a = _convert_other(a, raiseit=True)
  331:         return a.__str__(context=self)
       
    1:     def to_integral_exact(self, a):
               """Rounds to an integer.
       
               When the operand has a negative exponent, the result is the same
               as using the quantize() operation using the given operand as the
               left-hand-operand, 1E+0 as the right-hand-operand, and the precision
               of the operand as the precision setting; Inexact and Rounded flags
               are allowed in this operation.  The rounding mode is taken from the
               context.
       
               >>> ExtendedContext.to_integral_exact(Decimal('2.1'))
               Decimal('2')
               >>> ExtendedContext.to_integral_exact(Decimal('100'))
               Decimal('100')
               >>> ExtendedContext.to_integral_exact(Decimal('100.0'))
               Decimal('100')
               >>> ExtendedContext.to_integral_exact(Decimal('101.5'))
               Decimal('102')
               >>> ExtendedContext.to_integral_exact(Decimal('-101.5'))
               Decimal('-102')
               >>> ExtendedContext.to_integral_exact(Decimal('10E+5'))
               Decimal('1.0E+6')
               >>> ExtendedContext.to_integral_exact(Decimal('7.89E+77'))
               Decimal('7.89E+77')
               >>> ExtendedContext.to_integral_exact(Decimal('-Inf'))
               Decimal('-Infinity')
               """
   68:         a = _convert_other(a, raiseit=True)
   67:         return a.to_integral_exact(context=self)
       
    1:     def to_integral_value(self, a):
               """Rounds to an integer.
       
               When the operand has a negative exponent, the result is the same
               as using the quantize() operation using the given operand as the
               left-hand-operand, 1E+0 as the right-hand-operand, and the precision
               of the operand as the precision setting, except that no flags will
               be set.  The rounding mode is taken from the context.
       
               >>> ExtendedContext.to_integral_value(Decimal('2.1'))
               Decimal('2')
               >>> ExtendedContext.to_integral_value(Decimal('100'))
               Decimal('100')
               >>> ExtendedContext.to_integral_value(Decimal('100.0'))
               Decimal('100')
               >>> ExtendedContext.to_integral_value(Decimal('101.5'))
               Decimal('102')
               >>> ExtendedContext.to_integral_value(Decimal('-101.5'))
               Decimal('-102')
               >>> ExtendedContext.to_integral_value(Decimal('10E+5'))
               Decimal('1.0E+6')
               >>> ExtendedContext.to_integral_value(Decimal('7.89E+77'))
               Decimal('7.89E+77')
               >>> ExtendedContext.to_integral_value(Decimal('-Inf'))
               Decimal('-Infinity')
               """
   29:         a = _convert_other(a, raiseit=True)
   28:         return a.to_integral_value(context=self)
       
           # the method name changed, but we provide also the old one, for compatibility
    1:     to_integral = to_integral_value
       
    2: class _WorkRep(object):
    1:     __slots__ = ('sign','int','exp')
           # sign: 0 or 1
           # int:  int or long
           # exp:  None, int, or string
       
    1:     def __init__(self, value=None):
 7211:         if value is None:
 1019:             self.sign = None
 1019:             self.int = 0
 1019:             self.exp = None
 6192:         elif isinstance(value, Decimal):
 6192:             self.sign = value._sign
 6192:             self.int = int(value._int)
 6192:             self.exp = value._exp
               else:
                   # assert isinstance(value, tuple)
>>>>>>             self.sign = value[0]
>>>>>>             self.int = value[1]
>>>>>>             self.exp = value[2]
       
    1:     def __repr__(self):
>>>>>>         return "(%r, %r, %r)" % (self.sign, self.int, self.exp)
       
    1:     __str__ = __repr__
       
       
       
    1: def _normalize(op1, op2, prec = 0):
           """Normalizes op1, op2 to have the same exp and length of coefficient.
       
           Done during addition.
           """
 1019:     if op1.exp < op2.exp:
  196:         tmp = op2
  196:         other = op1
           else:
  823:         tmp = op1
  823:         other = op2
       
           # Let exp = min(tmp.exp - 1, tmp.adjusted() - precision - 1).
           # Then adding 10**exp to tmp has the same effect (after rounding)
           # as adding any positive quantity smaller than 10**exp; similarly
           # for subtraction.  So if other is smaller than 10**exp we replace
           # it with 10**exp.  This avoids tmp.exp - other.exp getting too large.
 1019:     tmp_len = len(str(tmp.int))
 1019:     other_len = len(str(other.int))
 1019:     exp = tmp.exp + min(-1, tmp_len - prec - 2)
 1019:     if other_len + other.exp - 1 < exp:
  293:         other.int = 1
  293:         other.exp = exp
       
 1019:     tmp.int *= 10 ** (tmp.exp - other.exp)
 1019:     tmp.exp = other.exp
 1019:     return op1, op2
       
       ##### Integer arithmetic functions used by ln, log10, exp and __pow__ #####
       
       # This function from Tim Peters was taken from here:
       # http://mail.python.org/pipermail/python-list/1999-July/007758.html
       # The correction being in the function definition is for speed, and
       # the whole function is not resolved with math.log because of avoiding
       # the use of floats.
    1: def _nbits(n, correction = {
    1:         '0': 4, '1': 3, '2': 2, '3': 2,
    1:         '4': 1, '5': 1, '6': 1, '7': 1,
    1:         '8': 0, '9': 0, 'a': 0, 'b': 0,
    1:         'c': 0, 'd': 0, 'e': 0, 'f': 0}):
           """Number of bits in binary representation of the positive integer n,
           or 0 if n == 0.
           """
  789:     if n < 0:
>>>>>>         raise ValueError("The argument to _nbits should be nonnegative.")
  789:     hex_n = "%x" % n
  789:     return 4*len(hex_n) - correction[hex_n[0]]
       
    1: def _decimal_lshift_exact(n, e):
           """ Given integers n and e, return n * 10**e if it's an integer, else None.
       
           The computation is designed to avoid computing large powers of 10
           unnecessarily.
       
           >>> _decimal_lshift_exact(3, 4)
           30000
           >>> _decimal_lshift_exact(300, -999999999)  # returns None
       
           """
   22:     if n == 0:
    2:         return 0
   20:     elif e >= 0:
   17:         return n * 10**e
           else:
               # val_n = largest power of 10 dividing n.
    3:         str_n = str(abs(n))
    3:         val_n = len(str_n) - len(str_n.rstrip('0'))
    3:         return None if val_n < -e else n // 10**-e
       
    1: def _sqrt_nearest(n, a):
           """Closest integer to the square root of the positive integer n.  a is
           an initial approximation to the square root.  Any positive integer
           will do for a, but the closer a is to the square root of n the
           faster convergence will be.
       
           """
 3248:     if n <= 0 or a <= 0:
>>>>>>         raise ValueError("Both arguments to _sqrt_nearest should be positive.")
       
 3248:     b=0
18272:     while a != b:
15024:         b, a = a, a--n//a>>1
 3248:     return a
       
    1: def _rshift_nearest(x, shift):
           """Given an integer x and a nonnegative integer shift, return closest
           integer to x / 2**shift; use round-to-even in case of a tie.
       
           """
 3674:     b, q = 1L << shift, x >> shift
 3674:     return q + (2*(x & (b-1)) + (q&1) > b)
       
    1: def _div_nearest(a, b):
           """Closest integer to a/b, a and b positive integers; rounds to even
           in the case of a tie.
       
           """
18417:     q, r = divmod(a, b)
18417:     return q + (2*r + (q&1) > b)
       
    1: def _ilog(x, M, L = 8):
           """Integer approximation to M*log(x/M), with absolute error boundable
           in terms only of x/M.
       
           Given positive integers x and M, return an integer approximation to
           M * log(x/M).  For L = 8 and 0.1 <= x/M <= 10 the difference
           between the approximation and the exact result is at most 22.  For
           L = 8 and 1.0 <= x/M <= 10.0 the difference is at most 15.  In
           both cases these are upper bounds on the error; it will usually be
           much smaller."""
       
           # The basic algorithm is the following: let log1p be the function
           # log1p(x) = log(1+x).  Then log(x/M) = log1p((x-M)/M).  We use
           # the reduction
           #
           #    log1p(y) = 2*log1p(y/(1+sqrt(1+y)))
           #
           # repeatedly until the argument to log1p is small (< 2**-L in
           # absolute value).  For small y we can use the Taylor series
           # expansion
           #
           #    log1p(y) ~ y - y**2/2 + y**3/3 - ... - (-y)**T/T
           #
           # truncating at T such that y**T is small enough.  The whole
           # computation is carried out in a form of fixed-point arithmetic,
           # with a real number z being represented by an integer
           # approximation to z*M.  To avoid loss of precision, the y below
           # is actually an integer approximation to 2**R*y*M, where R is the
           # number of reductions performed so far.
       
  426:     y = x-M
           # argument reduction; R = number of reductions performed
  426:     R = 0
 3674:     while (R <= L and long(abs(y)) << L-R >= M or
  490:            R > L and abs(y) >> R-L >= M):
 3248:         y = _div_nearest(long(M*y) << 1,
 3248:                          M + _sqrt_nearest(M*(M+_rshift_nearest(y, R)), M))
 3248:         R += 1
       
           # Taylor series with T terms
  426:     T = -int(-10*len(str(M))//(3*L))
  426:     yshift = _rshift_nearest(y, R)
  426:     w = _div_nearest(M, T)
 3240:     for k in xrange(T-1, 0, -1):
 2814:         w = _div_nearest(M, k) - _div_nearest(yshift*w, M)
       
  426:     return _div_nearest(w*y, M)
       
    1: def _dlog10(c, e, p):
           """Given integers c, e and p with c > 0, p >= 0, compute an integer
           approximation to 10**p * log10(c*10**e), with an absolute error of
           at most 1.  Assumes that c*10**e is not exactly 1."""
       
           # increase precision by 2; compensate for this by dividing
           # final result by 100
   20:     p += 2
       
           # write c*10**e as d*10**f with either:
           #   f >= 0 and 1 <= d <= 10, or
           #   f <= 0 and 0.1 <= d <= 1.
           # Thus for c*10**e close to 1, f = 0
   20:     l = len(str(c))
   20:     f = e+l - (e+l >= 1)
       
   20:     if p > 0:
   20:         M = 10**p
   20:         k = e+p-f
   20:         if k >= 0:
   20:             c *= 10**k
               else:
>>>>>>             c = _div_nearest(c, 10**-k)
       
   20:         log_d = _ilog(c, M) # error < 5 + 22 = 27
   20:         log_10 = _log10_digits(p) # error < 1
   20:         log_d = _div_nearest(log_d*M, log_10)
   20:         log_tenpower = f*M # exact
           else:
>>>>>>         log_d = 0  # error < 2.31
>>>>>>         log_tenpower = _div_nearest(f, 10**-p) # error < 0.5
       
   20:     return _div_nearest(log_tenpower+log_d, 100)
       
    1: def _dlog(c, e, p):
           """Given integers c, e and p with c > 0, compute an integer
           approximation to 10**p * log(c*10**e), with an absolute error of
           at most 1.  Assumes that c*10**e is not exactly 1."""
       
           # Increase precision by 2. The precision increase is compensated
           # for at the end with a division by 100.
  406:     p += 2
       
           # rewrite c*10**e as d*10**f with either f >= 0 and 1 <= d <= 10,
           # or f <= 0 and 0.1 <= d <= 1.  Then we can compute 10**p * log(c*10**e)
           # as 10**p * log(d) + 10**p*f * log(10).
  406:     l = len(str(c))
  406:     f = e+l - (e+l >= 1)
       
           # compute approximation to 10**p*log(d), with error < 27
  406:     if p > 0:
  405:         k = e+p-f
  405:         if k >= 0:
  405:             c *= 10**k
               else:
>>>>>>             c = _div_nearest(c, 10**-k)  # error of <= 0.5 in c
       
               # _ilog magnifies existing error in c by a factor of at most 10
  405:         log_d = _ilog(c, 10**p) # error < 5 + 22 = 27
           else:
               # p <= 0: just approximate the whole thing by 0; error < 2.31
    1:         log_d = 0
       
           # compute approximation to f*10**p*log(10), with error < 11.
  406:     if f:
  259:         extra = len(str(abs(f)))-1
  259:         if p + extra >= 0:
                   # error in f * _log10_digits(p+extra) < |f| * 1 = |f|
                   # after division, error < |f|/10**extra + 0.5 < 10 + 0.5 < 11
  258:             f_log_ten = _div_nearest(f*_log10_digits(p+extra), 10**extra)
               else:
    1:             f_log_ten = 0
           else:
  147:         f_log_ten = 0
       
           # error in sum < 11+27 = 38; error after division < 0.38 + 0.5 < 1
  406:     return _div_nearest(f_log_ten + log_d, 100)
       
    2: class _Log10Memoize(object):
           """Class to compute, store, and allow retrieval of, digits of the
           constant log(10) = 2.302585....  This constant is needed by
    1:     Decimal.ln, Decimal.log10, Decimal.exp and Decimal.__pow__."""
    1:     def __init__(self):
    1:         self.digits = "23025850929940456840179914546843642076011014886"
       
    1:     def getdigits(self, p):
               """Given an integer p >= 0, return floor(10**p)*log(10).
       
               For example, self.getdigits(3) returns 2302.
               """
               # digits are stored as a string, for quick conversion to
               # integer in the case that we've already computed enough
               # digits; the stored digits should always be correct
               # (truncated, not rounded to nearest).
  693:         if p < 0:
>>>>>>             raise ValueError("p should be nonnegative")
       
  693:         if p >= len(self.digits):
                   # compute p+3, p+6, p+9, ... digits; continue until at
                   # least one of the extra digits is nonzero
    1:             extra = 3
    1:             while True:
                       # compute p+extra digits, correct to within 1ulp
    1:                 M = 10**(p+extra+2)
    1:                 digits = str(_div_nearest(_ilog(10*M, M), 100))
    1:                 if digits[-extra:] != '0'*extra:
    1:                     break
>>>>>>                 extra += 3
                   # keep all reliable digits so far; remove trailing zeros
                   # and next nonzero digit
    1:             self.digits = digits.rstrip('0')[:-1]
  693:         return int(self.digits[:p+1])
       
    1: _log10_digits = _Log10Memoize().getdigits
       
    1: def _iexp(x, M, L=8):
           """Given integers x and M, M > 0, such that x/M is small in absolute
           value, compute an integer approximation to M*exp(x/M).  For 0 <=
           x/M <= 2.4, the absolute error in the result is bounded by 60 (and
           is usually much smaller)."""
       
           # Algorithm: to compute exp(z) for a real number z, first divide z
           # by a suitable power R of 2 so that |z/2**R| < 2**-L.  Then
           # compute expm1(z/2**R) = exp(z/2**R) - 1 using the usual Taylor
           # series
           #
           #     expm1(x) = x + x**2/2! + x**3/3! + ...
           #
           # Now use the identity
           #
           #     expm1(2x) = expm1(x)*(expm1(x)+2)
           #
           # R times to compute the sequence expm1(z/2**R),
           # expm1(z/2**(R-1)), ... , exp(z/2), exp(z).
       
           # Find R such that x/2**R/M <= 2**-L
  415:     R = _nbits((long(x)<<L)//M)
       
           # Taylor series.  (2**L)**T > M
  415:     T = -int(-10*len(str(M))//(3*L))
  415:     y = _div_nearest(x, T)
  415:     Mshift = long(M)<<R
 2947:     for i in xrange(T-1, 0, -1):
 2532:         y = _div_nearest(x*(Mshift + y), Mshift * i)
       
           # Expansion
 3883:     for k in xrange(R-1, -1, -1):
 3468:         Mshift = long(M)<<(k+2)
 3468:         y = _div_nearest(y*(y+Mshift), Mshift)
       
  415:     return M+y
       
    1: def _dexp(c, e, p):
           """Compute an approximation to exp(c*10**e), with p decimal places of
           precision.
       
           Returns integers d, f such that:
       
             10**(p-1) <= d <= 10**p, and
             (d-1)*10**f < exp(c*10**e) < (d+1)*10**f
       
           In other words, d*10**f is an approximation to exp(c*10**e) with p
           digits of precision, and with an error in d of at most 1.  This is
           almost, but not quite, the same as the error being < 1ulp: when d
           = 10**(p-1) the error could be up to 10 ulp."""
       
           # we'll call iexp with M = 10**(p+2), giving p+3 digits of precision
  415:     p += 2
       
           # compute log(10) with extra precision = adjusted exponent of c*10**e
  415:     extra = max(0, e + len(str(c)) - 1)
  415:     q = p + extra
       
           # compute quotient c*10**e/(log(10)) = c*10**(e+q)/(log(10)*10**q),
           # rounding down
  415:     shift = e+q
  415:     if shift >= 0:
  413:         cshift = c*10**shift
           else:
    2:         cshift = c//10**-shift
  415:     quot, rem = divmod(cshift, _log10_digits(q))
       
           # reduce remainder back to original precision
  415:     rem = _div_nearest(rem, 10**extra)
       
           # error in result of _iexp < 120;  error after division < 0.62
  415:     return _div_nearest(_iexp(rem, 10**p), 1000), quot - p + 3
       
    1: def _dpower(xc, xe, yc, ye, p):
           """Given integers xc, xe, yc and ye representing Decimals x = xc*10**xe and
           y = yc*10**ye, compute x**y.  Returns a pair of integers (c, e) such that:
       
             10**(p-1) <= c <= 10**p, and
             (c-1)*10**e < x**y < (c+1)*10**e
       
           in other words, c*10**e is an approximation to x**y with p digits
           of precision, and with an error in c of at most 1.  (This is
           almost, but not quite, the same as the error being < 1ulp: when c
           == 10**(p-1) we can only guarantee error < 10ulp.)
       
           We assume that: x is positive and not equal to 1, and y is nonzero.
           """
       
           # Find b such that 10**(b-1) <= |y| <= 10**b
  370:     b = len(str(abs(yc))) + ye
       
           # log(x) = lxc*10**(-p-b-1), to p+b+1 places after the decimal point
  370:     lxc = _dlog(xc, xe, p+b+1)
       
           # compute product y*log(x) = yc*lxc*10**(-p-b-1+ye) = pc*10**(-p-1)
  370:     shift = ye-b
  370:     if shift >= 0:
>>>>>>         pc = lxc*yc*10**shift
           else:
  370:         pc = _div_nearest(lxc*yc, 10**-shift)
       
  370:     if pc == 0:
               # we prefer a result that isn't exactly 1; this makes it
               # easier to compute a correctly rounded result in __pow__
    1:         if ((len(str(xc)) + xe >= 1) == (yc > 0)): # if x**y > 1:
    1:             coeff, exp = 10**(p-1)+1, 1-p
               else:
>>>>>>             coeff, exp = 10**p-1, -p
           else:
  369:         coeff, exp = _dexp(pc, -(p+1), p+1)
  369:         coeff = _div_nearest(coeff, 10)
  369:         exp += 1
       
  370:     return coeff, exp
       
    1: def _log10_lb(c, correction = {
    1:         '1': 100, '2': 70, '3': 53, '4': 40, '5': 31,
    1:         '6': 23, '7': 16, '8': 10, '9': 5}):
           """Compute a lower bound for 100*log10(c) for a positive integer c."""
   69:     if c <= 0:
>>>>>>         raise ValueError("The argument to _log10_lb should be nonnegative.")
   69:     str_c = str(c)
   69:     return 100*len(str_c) - correction[str_c[0]]
       
       ##### Helper Functions ####################################################
       
    1: def _convert_other(other, raiseit=False, allow_float=False):
           """Convert other to Decimal.
       
           Verifies that it's ok to use in an implicit construction.
           If allow_float is true, allow conversion from float;  this
           is used in the comparison methods (__eq__ and friends).
       
           """
19024:     if isinstance(other, Decimal):
18337:         return other
  687:     if isinstance(other, (int, long)):
  554:         return Decimal(other)
  133:     if allow_float and isinstance(other, float):
   16:         return Decimal.from_float(other)
       
  117:     if raiseit:
   80:         raise TypeError("Unable to convert %s to Decimal" % other)
   37:     return NotImplemented
       
       ##### Setup Specific Contexts ############################################
       
       # The default context prototype used by Context()
       # Is mutable, so that new contexts can have different default values
       
    1: DefaultContext = Context(
    1:         prec=28, rounding=ROUND_HALF_EVEN,
    1:         traps=[DivisionByZero, Overflow, InvalidOperation],
    1:         flags=[],
    1:         Emax=999999999,
    1:         Emin=-999999999,
    1:         capitals=1
       )
       
       # Pre-made alternate contexts offered by the specification
       # Don't change these; the user should be able to select these
       # contexts and be able to reproduce results from other implementations
       # of the spec.
       
    1: BasicContext = Context(
    1:         prec=9, rounding=ROUND_HALF_UP,
    1:         traps=[DivisionByZero, Overflow, InvalidOperation, Clamped, Underflow],
    1:         flags=[],
       )
       
    1: ExtendedContext = Context(
    1:         prec=9, rounding=ROUND_HALF_EVEN,
    1:         traps=[],
    1:         flags=[],
       )
       
       
       ##### crud for parsing strings #############################################
       #
       # Regular expression used for parsing numeric strings.  Additional
       # comments:
       #
       # 1. Uncomment the two '\s*' lines to allow leading and/or trailing
       # whitespace.  But note that the specification disallows whitespace in
       # a numeric string.
       #
       # 2. For finite numbers (not infinities and NaNs) the body of the
       # number between the optional sign and the optional exponent must have
       # at least one decimal digit, possibly after the decimal point.  The
       # lookahead expression '(?=\d|\.\d)' checks this.
       
    1: import re
    1: _parser = re.compile(r"""        # A numeric string consists of:
       #    \s*
           (?P<sign>[-+])?              # an optional sign, followed by either...
           (
               (?=\d|\.\d)              # ...a number (with at least one digit)
               (?P<int>\d*)             # having a (possibly empty) integer part
               (\.(?P<frac>\d*))?       # followed by an optional fractional part
               (E(?P<exp>[-+]?\d+))?    # followed by an optional exponent, or...
           |
               Inf(inity)?              # ...an infinity, or...
           |
               (?P<signal>s)?           # ...an (optionally signaling)
               NaN                      # NaN
               (?P<diag>\d*)            # with (possibly empty) diagnostic info.
           )
       #    \s*
           \Z
    1: """, re.VERBOSE | re.IGNORECASE | re.UNICODE).match
       
    1: _all_zeros = re.compile('0*$').match
    1: _exact_half = re.compile('50*$').match
       
       ##### PEP3101 support functions ##############################################
       # The functions in this section have little to do with the Decimal
       # class, and could potentially be reused or adapted for other pure
       # Python numeric classes that want to implement __format__
       #
       # A format specifier for Decimal looks like:
       #
       #   [[fill]align][sign][0][minimumwidth][,][.precision][type]
       
    1: _parse_format_specifier_regex = re.compile(r"""\A
       (?:
          (?P<fill>.)?
          (?P<align>[<>=^])
       )?
       (?P<sign>[-+ ])?
       (?P<zeropad>0)?
       (?P<minimumwidth>(?!0)\d+)?
       (?P<thousands_sep>,)?
       (?:\.(?P<precision>0|(?!0)\d+))?
       (?P<type>[eEfFgGn%])?
       \Z
    1: """, re.VERBOSE)
       
    1: del re
       
       # The locale module is only needed for the 'n' format specifier.  The
       # rest of the PEP 3101 code functions quite happily without it, so we
       # don't care too much if locale isn't present.
    1: try:
    1:     import locale as _locale
>>>>>> except ImportError:
>>>>>>     pass
       
    1: def _parse_format_specifier(format_spec, _localeconv=None):
           """Parse and validate a format specifier.
       
           Turns a standard numeric format specifier into a dict, with the
           following entries:
       
             fill: fill character to pad field to minimum width
             align: alignment type, either '<', '>', '=' or '^'
             sign: either '+', '-' or ' '
             minimumwidth: nonnegative integer giving minimum width
             zeropad: boolean, indicating whether to pad with zeros
             thousands_sep: string to use as thousands separator, or ''
             grouping: grouping for thousands separators, in format
               used by localeconv
             decimal_point: string to use for decimal point
             precision: nonnegative integer giving precision, or None
             type: one of the characters 'eEfFgG%', or None
             unicode: boolean (always True for Python 3.x)
       
           """
  157:     m = _parse_format_specifier_regex.match(format_spec)
  157:     if m is None:
>>>>>>         raise ValueError("Invalid format specifier: " + format_spec)
       
           # get the dictionary
  157:     format_dict = m.groupdict()
       
           # zeropad; defaults for fill and alignment.  If zero padding
           # is requested, the fill and align fields should be absent.
  157:     fill = format_dict['fill']
  157:     align = format_dict['align']
  157:     format_dict['zeropad'] = (format_dict['zeropad'] is not None)
  157:     if format_dict['zeropad']:
   30:         if fill is not None:
>>>>>>             raise ValueError("Fill character conflicts with '0'"
>>>>>>                              " in format specifier: " + format_spec)
   30:         if align is not None:
>>>>>>             raise ValueError("Alignment conflicts with '0' in "
>>>>>>                              "format specifier: " + format_spec)
  157:     format_dict['fill'] = fill or ' '
           # PEP 3101 originally specified that the default alignment should
           # be left;  it was later agreed that right-aligned makes more sense
           # for numeric types.  See http://bugs.python.org/issue6857.
  157:     format_dict['align'] = align or '>'
       
           # default sign handling: '-' for negative, '' for positive
  157:     if format_dict['sign'] is None:
  146:         format_dict['sign'] = '-'
       
           # minimumwidth defaults to 0; precision remains None if not given
  157:     format_dict['minimumwidth'] = int(format_dict['minimumwidth'] or '0')
  157:     if format_dict['precision'] is not None:
   43:         format_dict['precision'] = int(format_dict['precision'])
       
           # if format type is 'g' or 'G' then a precision of 0 makes little
           # sense; convert it to 1.  Same if format type is unspecified.
  157:     if format_dict['precision'] == 0:
    7:         if format_dict['type'] is None or format_dict['type'] in 'gG':
    3:             format_dict['precision'] = 1
       
           # determine thousands separator, grouping, and decimal separator, and
           # add appropriate entries to format_dict
  157:     if format_dict['type'] == 'n':
               # apart from separators, 'n' behaves just like 'g'
   30:         format_dict['type'] = 'g'
   30:         if _localeconv is None:
>>>>>>             _localeconv = _locale.localeconv()
   30:         if format_dict['thousands_sep'] is not None:
>>>>>>             raise ValueError("Explicit thousands separator conflicts with "
>>>>>>                              "'n' type in format specifier: " + format_spec)
   30:         format_dict['thousands_sep'] = _localeconv['thousands_sep']
   30:         format_dict['grouping'] = _localeconv['grouping']
   30:         format_dict['decimal_point'] = _localeconv['decimal_point']
           else:
  127:         if format_dict['thousands_sep'] is None:
   98:             format_dict['thousands_sep'] = ''
  127:         format_dict['grouping'] = [3, 0]
  127:         format_dict['decimal_point'] = '.'
       
           # record whether return type should be str or unicode
  157:     try:
  157:         format_dict['unicode'] = isinstance(format_spec, unicode)
>>>>>>     except NameError:
>>>>>>         format_dict['unicode'] = False
       
  157:     return format_dict
       
    1: def _format_align(sign, body, spec):
           """Given an unpadded, non-aligned numeric string 'body' and sign
           string 'sign', add padding and alignment conforming to the given
           format specifier dictionary 'spec' (as produced by
           parse_format_specifier).
       
           Also converts result to unicode if necessary.
       
           """
           # how much extra space do we have to play with?
  157:     minimumwidth = spec['minimumwidth']
  157:     fill = spec['fill']
  157:     padding = fill*(minimumwidth - len(sign) - len(body))
       
  157:     align = spec['align']
  157:     if align == '<':
    5:         result = sign + body + padding
  152:     elif align == '>':
  141:         result = padding + sign + body
   11:     elif align == '=':
    6:         result = sign + padding + body
    5:     elif align == '^':
    5:         half = len(padding)//2
    5:         result = padding[:half] + sign + body + padding[half:]
           else:
>>>>>>         raise ValueError('Unrecognised alignment field')
       
           # make sure that result is unicode if necessary
  157:     if spec['unicode']:
>>>>>>         result = unicode(result)
       
  157:     return result
       
    1: def _group_lengths(grouping):
           """Convert a localeconv-style grouping into a (possibly infinite)
           iterable of integers representing group lengths.
       
           """
           # The result from localeconv()['grouping'], and the input to this
           # function, should be a list of integers in one of the
           # following three forms:
           #
           #   (1) an empty list, or
           #   (2) nonempty list of positive integers + [0]
           #   (3) list of positive integers + [locale.CHAR_MAX], or
       
  145:     from itertools import chain, repeat
  145:     if not grouping:
>>>>>>         return []
  145:     elif grouping[-1] == 0 and len(grouping) >= 2:
  127:         return chain(grouping[:-1], repeat(grouping[-2]))
   18:     elif grouping[-1] == _locale.CHAR_MAX:
   18:         return grouping[:-1]
           else:
>>>>>>         raise ValueError('unrecognised format for grouping')
       
    1: def _insert_thousands_sep(digits, spec, min_width=1):
           """Insert thousands separators into a digit string.
       
           spec is a dictionary whose keys should include 'thousands_sep' and
           'grouping'; typically it's the result of parsing the format
           specifier using _parse_format_specifier.
       
           The min_width keyword argument gives the minimum length of the
           result, which will be padded on the left with zeros if necessary.
       
           If necessary, the zero padding adds an extra '0' on the left to
           avoid a leading thousands separator.  For example, inserting
           commas every three digits in '123456', with min_width=8, gives
           '0,123,456', even though that has length 9.
       
           """
       
  145:     sep = spec['thousands_sep']
  145:     grouping = spec['grouping']
       
  145:     groups = []
  209:     for l in _group_lengths(grouping):
  197:         if l <= 0:
>>>>>>             raise ValueError("group length should be positive")
               # max(..., 1) forces at least 1 digit to the left of a separator
  197:         l = min(max(len(digits), min_width, 1), l)
  197:         groups.append('0'*(l - len(digits)) + digits[-l:])
  197:         digits = digits[:-l]
  197:         min_width -= l
  197:         if not digits and min_width <= 0:
  133:             break
   64:         min_width -= len(sep)
           else:
   12:         l = max(len(digits), min_width, 1)
   12:         groups.append('0'*(l - len(digits)) + digits[-l:])
  145:     return sep.join(reversed(groups))
       
    1: def _format_sign(is_negative, spec):
           """Determine sign character."""
       
  157:     if is_negative:
   14:         return '-'
  143:     elif spec['sign'] in ' +':
   10:         return spec['sign']
           else:
  133:         return ''
       
    1: def _format_number(is_negative, intpart, fracpart, exp, spec):
           """Format a number, given the following data:
       
           is_negative: true if the number is negative, else false
           intpart: string of digits that must appear before the decimal point
           fracpart: string of digits that must come after the point
           exp: exponent, as an integer
           spec: dictionary resulting from parsing the format specifier
       
           This function uses the information in spec to:
             insert separators (decimal separator and thousands separators)
             format the sign
             format the exponent
             add trailing '%' for the '%' type
             zero-pad if necessary
             fill and align if necessary
           """
       
  145:     sign = _format_sign(is_negative, spec)
       
  145:     if fracpart:
   74:         fracpart = spec['decimal_point'] + fracpart
       
  145:     if exp != 0 or spec['type'] in 'eE':
   31:         echar = {'E': 'E', 'e': 'e', 'G': 'E', 'g': 'e'}[spec['type']]
   31:         fracpart += "{0}{1:+}".format(echar, exp)
  145:     if spec['type'] == '%':
   13:         fracpart += '%'
       
  145:     if spec['zeropad']:
   30:         min_width = spec['minimumwidth'] - len(fracpart) - len(sign)
           else:
  115:         min_width = 0
  145:     intpart = _insert_thousands_sep(intpart, spec, min_width)
       
  145:     return _format_align(sign, intpart+fracpart, spec)
       
       
       ##### Useful Constants (internal use only) ################################
       
       # Reusable defaults
    1: _Infinity = Decimal('Inf')
    1: _NegativeInfinity = Decimal('-Inf')
    1: _NaN = Decimal('NaN')
    1: _Zero = Decimal(0)
    1: _One = Decimal(1)
    1: _NegativeOne = Decimal(-1)
       
       # _SignedInfinity[sign] is infinity w/ that sign
    1: _SignedInfinity = (_Infinity, _NegativeInfinity)
       
       
       
    1: if __name__ == '__main__':
>>>>>>     import doctest, sys
>>>>>>     doctest.testmod(sys.modules[__name__])
