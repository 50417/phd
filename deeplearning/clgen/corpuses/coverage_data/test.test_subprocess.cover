    1: import unittest
    1: from test import test_support
    1: import subprocess
    1: import sys
    1: import platform
    1: import signal
    1: import os
    1: import errno
    1: import tempfile
    1: import time
    1: import re
    1: import sysconfig
    1: import textwrap
       
    1: try:
    1:     import ctypes
>>>>>> except ImportError:
>>>>>>     ctypes = None
       else:
    1:     import ctypes.util
       
    1: try:
    1:     import resource
>>>>>> except ImportError:
>>>>>>     resource = None
    1: try:
    1:     import threading
>>>>>> except ImportError:
>>>>>>     threading = None
       
    1: try:
    1:     import _testcapi
>>>>>> except ImportError:
>>>>>>     _testcapi = None
       
    1: mswindows = (sys.platform == "win32")
       
       #
       # Depends on the following external programs: Python
       #
       
    1: if mswindows:
>>>>>>     SETBINARY = ('import msvcrt; msvcrt.setmode(sys.stdout.fileno(), '
                                                       'os.O_BINARY);')
       else:
    1:     SETBINARY = ''
       
       
    2: class BaseTestCase(unittest.TestCase):
    1:     def setUp(self):
               # Try to minimize the number of children we have so this test
               # doesn't crash on some buildbots (Alphas in particular).
  129:         test_support.reap_children()
       
    1:     def tearDown(self):
  130:         for inst in subprocess._active:
    1:             inst.wait()
  129:         subprocess._cleanup()
  129:         self.assertFalse(subprocess._active, "subprocess._active not empty")
  129:         self.doCleanups()
  129:         test_support.reap_children()
       
    1:     def assertStderrEqual(self, stderr, expected, msg=None):
               # In a debug build, stuff like "[6580 refs]" is printed to stderr at
               # shutdown time.  That frustrates tests trying to check stderr produced
               # from a spawned Python process.
   22:         actual = re.sub(r"\[\d+ refs\]\r?\n?$", "", stderr)
   22:         self.assertEqual(actual, expected, msg)
       
       
    2: class PopenTestException(Exception):
    1:     pass
       
       
    2: class PopenExecuteChildRaises(subprocess.Popen):
           """Popen subclass for testing cleanup of subprocess.PIPE filehandles when
           _execute_child fails.
    1:     """
    1:     def _execute_child(self, *args, **kwargs):
>>>>>>         raise PopenTestException("Forced Exception for Test")
       
       
    2: class ProcessTestCase(BaseTestCase):
       
    1:     def test_call_seq(self):
               # call() function with sequence argument
    2:         rc = subprocess.call([sys.executable, "-c",
    2:                               "import sys; sys.exit(47)"])
    2:         self.assertEqual(rc, 47)
       
    1:     def test_check_call_zero(self):
               # check_call() function with zero return code
    2:         rc = subprocess.check_call([sys.executable, "-c",
    2:                                     "import sys; sys.exit(0)"])
    2:         self.assertEqual(rc, 0)
       
    1:     def test_check_call_nonzero(self):
               # check_call() function with non-zero return code
    2:         with self.assertRaises(subprocess.CalledProcessError) as c:
    2:             subprocess.check_call([sys.executable, "-c",
    2:                                    "import sys; sys.exit(47)"])
    2:         self.assertEqual(c.exception.returncode, 47)
       
    1:     def test_check_output(self):
               # check_output() function with zero return code
    2:         output = subprocess.check_output(
    2:                 [sys.executable, "-c", "print 'BDFL'"])
    2:         self.assertIn('BDFL', output)
       
    1:     def test_check_output_nonzero(self):
               # check_call() function with non-zero return code
    2:         with self.assertRaises(subprocess.CalledProcessError) as c:
    2:             subprocess.check_output(
    2:                     [sys.executable, "-c", "import sys; sys.exit(5)"])
    2:         self.assertEqual(c.exception.returncode, 5)
       
    1:     def test_check_output_stderr(self):
               # check_output() function stderr redirected to stdout
    2:         output = subprocess.check_output(
    2:                 [sys.executable, "-c", "import sys; sys.stderr.write('BDFL')"],
    2:                 stderr=subprocess.STDOUT)
    2:         self.assertIn('BDFL', output)
       
    1:     def test_check_output_stdout_arg(self):
               # check_output() function stderr redirected to stdout
    2:         with self.assertRaises(ValueError) as c:
    2:             output = subprocess.check_output(
    2:                     [sys.executable, "-c", "print 'will not be run'"],
    2:                     stdout=sys.stdout)
>>>>>>             self.fail("Expected ValueError when stdout arg supplied.")
    2:         self.assertIn('stdout', c.exception.args[0])
       
    1:     def test_call_kwargs(self):
               # call() function with keyword args
    2:         newenv = os.environ.copy()
    2:         newenv["FRUIT"] = "banana"
    2:         rc = subprocess.call([sys.executable, "-c",
    2:                               'import sys, os;'
                                     'sys.exit(os.getenv("FRUIT")=="banana")'],
    2:                              env=newenv)
    2:         self.assertEqual(rc, 1)
       
    1:     def test_invalid_args(self):
               # Popen() called with invalid arguments should raise TypeError
               # but Popen.__del__ should not complain (issue #12085)
    2:         with test_support.captured_stderr() as s:
    2:             self.assertRaises(TypeError, subprocess.Popen, invalid_arg_name=1)
    2:             argcount = subprocess.Popen.__init__.__code__.co_argcount
    2:             too_many_args = [0] * (argcount + 1)
    2:             self.assertRaises(TypeError, subprocess.Popen, *too_many_args)
    2:         self.assertEqual(s.getvalue(), '')
       
    1:     def test_stdin_none(self):
               # .stdin is None when not redirected
    2:         p = subprocess.Popen([sys.executable, "-c", 'print "banana"'],
    2:                          stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    2:         self.addCleanup(p.stdout.close)
    2:         self.addCleanup(p.stderr.close)
    2:         p.wait()
    2:         self.assertEqual(p.stdin, None)
       
    1:     def test_stdout_none(self):
               # .stdout is None when not redirected, and the child's stdout will
               # be inherited from the parent.  In order to test this we run a
               # subprocess in a subprocess:
               # this_test
               #   \-- subprocess created by this test (parent)
               #          \-- subprocess created by the parent subprocess (child)
               # The parent doesn't specify stdout, so the child will use the
               # parent's stdout.  This test checks that the message printed by the
               # child goes to the parent stdout.  The parent also checks that the
               # child's stdout is None.  See #11963.
    2:         code = ('import sys; from subprocess import Popen, PIPE;'
                       'p = Popen([sys.executable, "-c", "print \'test_stdout_none\'"],'
                       '          stdin=PIPE, stderr=PIPE);'
                       'p.wait(); assert p.stdout is None;')
    2:         p = subprocess.Popen([sys.executable, "-c", code],
    2:                              stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    2:         self.addCleanup(p.stdout.close)
    2:         self.addCleanup(p.stderr.close)
    2:         out, err = p.communicate()
    2:         self.assertEqual(p.returncode, 0, err)
    2:         self.assertEqual(out.rstrip(), 'test_stdout_none')
       
    1:     def test_stderr_none(self):
               # .stderr is None when not redirected
    2:         p = subprocess.Popen([sys.executable, "-c", 'print "banana"'],
    2:                          stdin=subprocess.PIPE, stdout=subprocess.PIPE)
    2:         self.addCleanup(p.stdout.close)
    2:         self.addCleanup(p.stdin.close)
    2:         p.wait()
    2:         self.assertEqual(p.stderr, None)
       
    1:     def test_executable_with_cwd(self):
    2:         python_dir = os.path.dirname(os.path.realpath(sys.executable))
    2:         p = subprocess.Popen(["somethingyoudonthave", "-c",
    2:                               "import sys; sys.exit(47)"],
    2:                              executable=sys.executable, cwd=python_dir)
    2:         p.wait()
    2:         self.assertEqual(p.returncode, 47)
       
    1:     @unittest.skipIf(sysconfig.is_python_build(),
    1:                      "need an installed Python. See #7774")
           def test_executable_without_cwd(self):
               # For a normal installation, it should work without 'cwd'
               # argument.  For test runs in the build directory, see #7774.
    2:         p = subprocess.Popen(["somethingyoudonthave", "-c",
    2:                               "import sys; sys.exit(47)"],
    2:                              executable=sys.executable)
    2:         p.wait()
    2:         self.assertEqual(p.returncode, 47)
       
    1:     def test_stdin_pipe(self):
               # stdin redirection
    2:         p = subprocess.Popen([sys.executable, "-c",
    2:                          'import sys; sys.exit(sys.stdin.read() == "pear")'],
    2:                         stdin=subprocess.PIPE)
    2:         p.stdin.write("pear")
    2:         p.stdin.close()
    2:         p.wait()
    2:         self.assertEqual(p.returncode, 1)
       
    1:     def test_stdin_filedes(self):
               # stdin is set to open file descriptor
    2:         tf = tempfile.TemporaryFile()
    2:         d = tf.fileno()
    2:         os.write(d, "pear")
    2:         os.lseek(d, 0, 0)
    2:         p = subprocess.Popen([sys.executable, "-c",
    2:                          'import sys; sys.exit(sys.stdin.read() == "pear")'],
    2:                          stdin=d)
    2:         p.wait()
    2:         self.assertEqual(p.returncode, 1)
       
    1:     def test_stdin_fileobj(self):
               # stdin is set to open file object
    2:         tf = tempfile.TemporaryFile()
    2:         tf.write("pear")
    2:         tf.seek(0)
    2:         p = subprocess.Popen([sys.executable, "-c",
    2:                          'import sys; sys.exit(sys.stdin.read() == "pear")'],
    2:                          stdin=tf)
    2:         p.wait()
    2:         self.assertEqual(p.returncode, 1)
       
    1:     def test_stdout_pipe(self):
               # stdout redirection
    2:         p = subprocess.Popen([sys.executable, "-c",
    2:                           'import sys; sys.stdout.write("orange")'],
    2:                          stdout=subprocess.PIPE)
    2:         self.addCleanup(p.stdout.close)
    2:         self.assertEqual(p.stdout.read(), "orange")
       
    1:     def test_stdout_filedes(self):
               # stdout is set to open file descriptor
    2:         tf = tempfile.TemporaryFile()
    2:         d = tf.fileno()
    2:         p = subprocess.Popen([sys.executable, "-c",
    2:                           'import sys; sys.stdout.write("orange")'],
    2:                          stdout=d)
    2:         p.wait()
    2:         os.lseek(d, 0, 0)
    2:         self.assertEqual(os.read(d, 1024), "orange")
       
    1:     def test_stdout_fileobj(self):
               # stdout is set to open file object
    2:         tf = tempfile.TemporaryFile()
    2:         p = subprocess.Popen([sys.executable, "-c",
    2:                           'import sys; sys.stdout.write("orange")'],
    2:                          stdout=tf)
    2:         p.wait()
    2:         tf.seek(0)
    2:         self.assertEqual(tf.read(), "orange")
       
    1:     def test_stderr_pipe(self):
               # stderr redirection
    2:         p = subprocess.Popen([sys.executable, "-c",
    2:                           'import sys; sys.stderr.write("strawberry")'],
    2:                          stderr=subprocess.PIPE)
    2:         self.addCleanup(p.stderr.close)
    2:         self.assertStderrEqual(p.stderr.read(), "strawberry")
       
    1:     def test_stderr_filedes(self):
               # stderr is set to open file descriptor
    2:         tf = tempfile.TemporaryFile()
    2:         d = tf.fileno()
    2:         p = subprocess.Popen([sys.executable, "-c",
    2:                           'import sys; sys.stderr.write("strawberry")'],
    2:                          stderr=d)
    2:         p.wait()
    2:         os.lseek(d, 0, 0)
    2:         self.assertStderrEqual(os.read(d, 1024), "strawberry")
       
    1:     def test_stderr_fileobj(self):
               # stderr is set to open file object
    2:         tf = tempfile.TemporaryFile()
    2:         p = subprocess.Popen([sys.executable, "-c",
    2:                           'import sys; sys.stderr.write("strawberry")'],
    2:                          stderr=tf)
    2:         p.wait()
    2:         tf.seek(0)
    2:         self.assertStderrEqual(tf.read(), "strawberry")
       
    1:     def test_stderr_redirect_with_no_stdout_redirect(self):
               # test stderr=STDOUT while stdout=None (not set)
       
               # - grandchild prints to stderr
               # - child redirects grandchild's stderr to its stdout
               # - the parent should get grandchild's stderr in child's stdout
    2:         p = subprocess.Popen([sys.executable, "-c",
    2:                               'import sys, subprocess;'
                                     'rc = subprocess.call([sys.executable, "-c",'
                                     '    "import sys;"'
                                     '    "sys.stderr.write(\'42\')"],'
                                     '    stderr=subprocess.STDOUT);'
                                     'sys.exit(rc)'],
    2:                              stdout=subprocess.PIPE,
    2:                              stderr=subprocess.PIPE)
    2:         stdout, stderr = p.communicate()
               #NOTE: stdout should get stderr from grandchild
    2:         self.assertStderrEqual(stdout, b'42')
    2:         self.assertStderrEqual(stderr, b'') # should be empty
    2:         self.assertEqual(p.returncode, 0)
       
    1:     def test_stdout_stderr_pipe(self):
               # capture stdout and stderr to the same pipe
    2:         p = subprocess.Popen([sys.executable, "-c",
    2:                           'import sys;'
                                 'sys.stdout.write("apple");'
                                 'sys.stdout.flush();'
                                 'sys.stderr.write("orange")'],
    2:                          stdout=subprocess.PIPE,
    2:                          stderr=subprocess.STDOUT)
    2:         self.addCleanup(p.stdout.close)
    2:         self.assertStderrEqual(p.stdout.read(), "appleorange")
       
    1:     def test_stdout_stderr_file(self):
               # capture stdout and stderr to the same open file
    2:         tf = tempfile.TemporaryFile()
    2:         p = subprocess.Popen([sys.executable, "-c",
    2:                           'import sys;'
                                 'sys.stdout.write("apple");'
                                 'sys.stdout.flush();'
                                 'sys.stderr.write("orange")'],
    2:                          stdout=tf,
    2:                          stderr=tf)
    2:         p.wait()
    2:         tf.seek(0)
    2:         self.assertStderrEqual(tf.read(), "appleorange")
       
    1:     def test_stdout_filedes_of_stdout(self):
               # stdout is set to 1 (#1531862).
               # To avoid printing the text on stdout, we do something similar to
               # test_stdout_none (see above).  The parent subprocess calls the child
               # subprocess passing stdout=1, and this test uses stdout=PIPE in
               # order to capture and check the output of the parent. See #11963.
    2:         code = ('import sys, subprocess; '
                       'rc = subprocess.call([sys.executable, "-c", '
                       '    "import os, sys; sys.exit(os.write(sys.stdout.fileno(), '
                            '\'test with stdout=1\'))"], stdout=1); '
                       'assert rc == 18')
    2:         p = subprocess.Popen([sys.executable, "-c", code],
    2:                              stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    2:         self.addCleanup(p.stdout.close)
    2:         self.addCleanup(p.stderr.close)
    2:         out, err = p.communicate()
    2:         self.assertEqual(p.returncode, 0, err)
    2:         self.assertEqual(out.rstrip(), 'test with stdout=1')
       
    1:     def test_cwd(self):
    2:         tmpdir = tempfile.gettempdir()
               # We cannot use os.path.realpath to canonicalize the path,
               # since it doesn't expand Tru64 {memb} strings. See bug 1063571.
    2:         cwd = os.getcwd()
    2:         os.chdir(tmpdir)
    2:         tmpdir = os.getcwd()
    2:         os.chdir(cwd)
    2:         p = subprocess.Popen([sys.executable, "-c",
    2:                           'import sys,os;'
                                 'sys.stdout.write(os.getcwd())'],
    2:                          stdout=subprocess.PIPE,
    2:                          cwd=tmpdir)
    2:         self.addCleanup(p.stdout.close)
    2:         normcase = os.path.normcase
    2:         self.assertEqual(normcase(p.stdout.read()), normcase(tmpdir))
       
    1:     def test_env(self):
    2:         newenv = os.environ.copy()
    2:         newenv["FRUIT"] = "orange"
    2:         p = subprocess.Popen([sys.executable, "-c",
    2:                           'import sys,os;'
                                 'sys.stdout.write(os.getenv("FRUIT"))'],
    2:                          stdout=subprocess.PIPE,
    2:                          env=newenv)
    2:         self.addCleanup(p.stdout.close)
    2:         self.assertEqual(p.stdout.read(), "orange")
       
    1:     def test_invalid_cmd(self):
               # null character in the command name
    2:         cmd = sys.executable + '\0'
    2:         with self.assertRaises(TypeError):
    2:             subprocess.Popen([cmd, "-c", "pass"])
       
               # null character in the command argument
    2:         with self.assertRaises(TypeError):
    2:             subprocess.Popen([sys.executable, "-c", "pass#\0"])
       
    1:     def test_invalid_env(self):
               # null character in the enviroment variable name
    2:         newenv = os.environ.copy()
    2:         newenv["FRUIT\0VEGETABLE"] = "cabbage"
    2:         with self.assertRaises(TypeError):
    2:             subprocess.Popen([sys.executable, "-c", "pass"], env=newenv)
       
               # null character in the enviroment variable value
    2:         newenv = os.environ.copy()
    2:         newenv["FRUIT"] = "orange\0VEGETABLE=cabbage"
    2:         with self.assertRaises(TypeError):
    2:             subprocess.Popen([sys.executable, "-c", "pass"], env=newenv)
       
               # equal character in the enviroment variable name
    2:         newenv = os.environ.copy()
    2:         newenv["FRUIT=ORANGE"] = "lemon"
    2:         with self.assertRaises(ValueError):
    2:             subprocess.Popen([sys.executable, "-c", "pass"], env=newenv)
       
               # equal character in the enviroment variable value
    2:         newenv = os.environ.copy()
    2:         newenv["FRUIT"] = "orange=lemon"
    2:         p = subprocess.Popen([sys.executable, "-c",
    2:                               'import sys, os;'
                                     'sys.stdout.write(os.getenv("FRUIT"))'],
    2:                              stdout=subprocess.PIPE,
    2:                              env=newenv)
    2:         stdout, stderr = p.communicate()
    2:         self.assertEqual(stdout, "orange=lemon")
       
    1:     def test_communicate_stdin(self):
    2:         p = subprocess.Popen([sys.executable, "-c",
    2:                               'import sys;'
                                     'sys.exit(sys.stdin.read() == "pear")'],
    2:                              stdin=subprocess.PIPE)
    2:         p.communicate("pear")
    2:         self.assertEqual(p.returncode, 1)
       
    1:     def test_communicate_stdout(self):
    2:         p = subprocess.Popen([sys.executable, "-c",
    2:                               'import sys; sys.stdout.write("pineapple")'],
    2:                              stdout=subprocess.PIPE)
    2:         (stdout, stderr) = p.communicate()
    2:         self.assertEqual(stdout, "pineapple")
    2:         self.assertEqual(stderr, None)
       
    1:     def test_communicate_stderr(self):
    2:         p = subprocess.Popen([sys.executable, "-c",
    2:                               'import sys; sys.stderr.write("pineapple")'],
    2:                              stderr=subprocess.PIPE)
    2:         (stdout, stderr) = p.communicate()
    2:         self.assertEqual(stdout, None)
    2:         self.assertStderrEqual(stderr, "pineapple")
       
    1:     def test_communicate(self):
    2:         p = subprocess.Popen([sys.executable, "-c",
    2:                           'import sys,os;'
                                 'sys.stderr.write("pineapple");'
                                 'sys.stdout.write(sys.stdin.read())'],
    2:                          stdin=subprocess.PIPE,
    2:                          stdout=subprocess.PIPE,
    2:                          stderr=subprocess.PIPE)
    2:         self.addCleanup(p.stdout.close)
    2:         self.addCleanup(p.stderr.close)
    2:         self.addCleanup(p.stdin.close)
    2:         (stdout, stderr) = p.communicate("banana")
    2:         self.assertEqual(stdout, "banana")
    2:         self.assertStderrEqual(stderr, "pineapple")
       
           # This test is Linux specific for simplicity to at least have
           # some coverage.  It is not a platform specific bug.
    1:     @unittest.skipUnless(os.path.isdir('/proc/%d/fd' % os.getpid()),
    1:                          "Linux specific")
           # Test for the fd leak reported in http://bugs.python.org/issue2791.
           def test_communicate_pipe_fd_leak(self):
>>>>>>         fd_directory = '/proc/%d/fd' % os.getpid()
>>>>>>         num_fds_before_popen = len(os.listdir(fd_directory))
>>>>>>         p = subprocess.Popen([sys.executable, "-c", "print('')"],
>>>>>>                              stdout=subprocess.PIPE)
>>>>>>         p.communicate()
>>>>>>         num_fds_after_communicate = len(os.listdir(fd_directory))
>>>>>>         del p
>>>>>>         num_fds_after_destruction = len(os.listdir(fd_directory))
>>>>>>         self.assertEqual(num_fds_before_popen, num_fds_after_destruction)
>>>>>>         self.assertEqual(num_fds_before_popen, num_fds_after_communicate)
       
    1:     def test_communicate_returns(self):
               # communicate() should return None if no redirection is active
    2:         p = subprocess.Popen([sys.executable, "-c",
    2:                               "import sys; sys.exit(47)"])
    2:         (stdout, stderr) = p.communicate()
    2:         self.assertEqual(stdout, None)
    2:         self.assertEqual(stderr, None)
       
    1:     def test_communicate_pipe_buf(self):
               # communicate() with writes larger than pipe_buf
               # This test will probably deadlock rather than fail, if
               # communicate() does not work properly.
    2:         x, y = os.pipe()
    2:         if mswindows:
>>>>>>             pipe_buf = 512
               else:
    2:             pipe_buf = os.fpathconf(x, "PC_PIPE_BUF")
    2:         os.close(x)
    2:         os.close(y)
    2:         p = subprocess.Popen([sys.executable, "-c",
    2:                           'import sys,os;'
                                 'sys.stdout.write(sys.stdin.read(47));'
                                 'sys.stderr.write("xyz"*%d);'
    2:                           'sys.stdout.write(sys.stdin.read())' % pipe_buf],
    2:                          stdin=subprocess.PIPE,
    2:                          stdout=subprocess.PIPE,
    2:                          stderr=subprocess.PIPE)
    2:         self.addCleanup(p.stdout.close)
    2:         self.addCleanup(p.stderr.close)
    2:         self.addCleanup(p.stdin.close)
    2:         string_to_write = "abc"*pipe_buf
    2:         (stdout, stderr) = p.communicate(string_to_write)
    2:         self.assertEqual(stdout, string_to_write)
       
    1:     def test_writes_before_communicate(self):
               # stdin.write before communicate()
    2:         p = subprocess.Popen([sys.executable, "-c",
    2:                           'import sys,os;'
                                 'sys.stdout.write(sys.stdin.read())'],
    2:                          stdin=subprocess.PIPE,
    2:                          stdout=subprocess.PIPE,
    2:                          stderr=subprocess.PIPE)
    2:         self.addCleanup(p.stdout.close)
    2:         self.addCleanup(p.stderr.close)
    2:         self.addCleanup(p.stdin.close)
    2:         p.stdin.write("banana")
    2:         (stdout, stderr) = p.communicate("split")
    2:         self.assertEqual(stdout, "bananasplit")
    2:         self.assertStderrEqual(stderr, "")
       
    1:     def test_universal_newlines(self):
    2:         p = subprocess.Popen([sys.executable, "-c",
    2:                           'import sys,os;' + SETBINARY +
    2:                           'sys.stdout.write("line1\\n");'
                                 'sys.stdout.flush();'
                                 'sys.stdout.write("line2\\r");'
                                 'sys.stdout.flush();'
                                 'sys.stdout.write("line3\\r\\n");'
                                 'sys.stdout.flush();'
                                 'sys.stdout.write("line4\\r");'
                                 'sys.stdout.flush();'
                                 'sys.stdout.write("\\nline5");'
                                 'sys.stdout.flush();'
                                 'sys.stdout.write("\\nline6");'],
    2:                          stdout=subprocess.PIPE,
    2:                          universal_newlines=1)
    2:         self.addCleanup(p.stdout.close)
    2:         stdout = p.stdout.read()
    2:         if hasattr(file, 'newlines'):
                   # Interpreter with universal newline support
    2:             self.assertEqual(stdout,
    2:                              "line1\nline2\nline3\nline4\nline5\nline6")
               else:
                   # Interpreter without universal newline support
>>>>>>             self.assertEqual(stdout,
>>>>>>                              "line1\nline2\rline3\r\nline4\r\nline5\nline6")
       
    1:     def test_universal_newlines_communicate(self):
               # universal newlines through communicate()
    2:         p = subprocess.Popen([sys.executable, "-c",
    2:                           'import sys,os;' + SETBINARY +
    2:                           'sys.stdout.write("line1\\n");'
                                 'sys.stdout.flush();'
                                 'sys.stdout.write("line2\\r");'
                                 'sys.stdout.flush();'
                                 'sys.stdout.write("line3\\r\\n");'
                                 'sys.stdout.flush();'
                                 'sys.stdout.write("line4\\r");'
                                 'sys.stdout.flush();'
                                 'sys.stdout.write("\\nline5");'
                                 'sys.stdout.flush();'
                                 'sys.stdout.write("\\nline6");'],
    2:                          stdout=subprocess.PIPE, stderr=subprocess.PIPE,
    2:                          universal_newlines=1)
    2:         self.addCleanup(p.stdout.close)
    2:         self.addCleanup(p.stderr.close)
    2:         (stdout, stderr) = p.communicate()
    2:         if hasattr(file, 'newlines'):
                   # Interpreter with universal newline support
    2:             self.assertEqual(stdout,
    2:                              "line1\nline2\nline3\nline4\nline5\nline6")
               else:
                   # Interpreter without universal newline support
>>>>>>             self.assertEqual(stdout,
>>>>>>                              "line1\nline2\rline3\r\nline4\r\nline5\nline6")
       
    1:     def test_no_leaking(self):
               # Make sure we leak no resources
    2:         if not mswindows:
    2:             max_handles = 1026 # too much for most UNIX systems
               else:
>>>>>>             max_handles = 2050 # too much for (at least some) Windows setups
    2:         handles = []
    2:         try:
  480:             for i in range(max_handles):
  480:                 try:
  480:                     handles.append(os.open(test_support.TESTFN,
  480:                                            os.O_WRONLY | os.O_CREAT))
    2:                 except OSError as e:
    2:                     if e.errno != errno.EMFILE:
>>>>>>                         raise
    2:                     break
                   else:
>>>>>>                 self.skipTest("failed to reach the file descriptor limit "
>>>>>>                     "(tried %d)" % max_handles)
                   # Close a couple of them (should be enough for a subprocess)
   22:             for i in range(10):
   20:                 os.close(handles.pop())
                   # Loop creating some subprocesses. If one of them leaks some fds,
                   # the next loop iteration will fail by reaching the max fd limit.
   32:             for i in range(15):
   30:                 p = subprocess.Popen([sys.executable, "-c",
   30:                                       "import sys;"
                                             "sys.stdout.write(sys.stdin.read())"],
   30:                                      stdin=subprocess.PIPE,
   30:                                      stdout=subprocess.PIPE,
   30:                                      stderr=subprocess.PIPE)
   30:                 data = p.communicate(b"lime")[0]
   30:                 self.assertEqual(data, b"lime")
               finally:
  460:             for h in handles:
  458:                 os.close(h)
    2:             test_support.unlink(test_support.TESTFN)
       
    1:     def test_list2cmdline(self):
    2:         self.assertEqual(subprocess.list2cmdline(['a b c', 'd', 'e']),
    2:                          '"a b c" d e')
    2:         self.assertEqual(subprocess.list2cmdline(['ab"c', '\\', 'd']),
    2:                          'ab\\"c \\ d')
    2:         self.assertEqual(subprocess.list2cmdline(['ab"c', ' \\', 'd']),
    2:                          'ab\\"c " \\\\" d')
    2:         self.assertEqual(subprocess.list2cmdline(['a\\\\\\b', 'de fg', 'h']),
    2:                          'a\\\\\\b "de fg" h')
    2:         self.assertEqual(subprocess.list2cmdline(['a\\"b', 'c', 'd']),
    2:                          'a\\\\\\"b c d')
    2:         self.assertEqual(subprocess.list2cmdline(['a\\\\b c', 'd', 'e']),
    2:                          '"a\\\\b c" d e')
    2:         self.assertEqual(subprocess.list2cmdline(['a\\\\b\\ c', 'd', 'e']),
    2:                          '"a\\\\b\\ c" d e')
    2:         self.assertEqual(subprocess.list2cmdline(['ab', '']),
    2:                          'ab ""')
       
       
    1:     def test_poll(self):
    2:         p = subprocess.Popen([sys.executable,
    2:                           "-c", "import time; time.sleep(1)"])
    2:         count = 0
   24:         while p.poll() is None:
   22:             time.sleep(0.1)
   22:             count += 1
               # We expect that the poll loop probably went around about 10 times,
               # but, based on system scheduling we can't control, it's possible
               # poll() never returned None.  It "should be" very rare that it
               # didn't go around at least twice.
    2:         self.assertGreaterEqual(count, 2)
               # Subsequent invocations should just return the returncode
    2:         self.assertEqual(p.poll(), 0)
       
       
    1:     def test_wait(self):
    2:         p = subprocess.Popen([sys.executable,
    2:                           "-c", "import time; time.sleep(2)"])
    2:         self.assertEqual(p.wait(), 0)
               # Subsequent invocations should just return the returncode
    2:         self.assertEqual(p.wait(), 0)
       
       
    1:     def test_invalid_bufsize(self):
               # an invalid type of the bufsize argument should raise
               # TypeError.
    2:         with self.assertRaises(TypeError):
    2:             subprocess.Popen([sys.executable, "-c", "pass"], "orange")
       
    1:     def test_leaking_fds_on_error(self):
               # see bug #5179: Popen leaks file descriptors to PIPEs if
               # the child fails to execute; this will eventually exhaust
               # the maximum number of open fds. 1024 seems a very common
               # value for that limit, but Windows has 2048, so we loop
               # 1024 times (each call leaked two fds).
 2050:         for i in range(1024):
                   # Windows raises IOError.  Others raise OSError.
 2048:             with self.assertRaises(EnvironmentError) as c:
 2048:                 subprocess.Popen(['nonexisting_i_hope'],
 2048:                                  stdout=subprocess.PIPE,
 2048:                                  stderr=subprocess.PIPE)
                   # ignore errors that indicate the command was not found
 2048:             if c.exception.errno not in (errno.ENOENT, errno.EACCES):
>>>>>>                 raise c.exception
       
    1:     @unittest.skipIf(threading is None, "threading required")
           def test_double_close_on_error(self):
               # Issue #18851
    2:         fds = []
    2:         def open_fds():
   42:             for i in range(20):
   40:                 fds.extend(os.pipe())
   40:                 time.sleep(0.001)
    2:         t = threading.Thread(target=open_fds)
    2:         t.start()
    2:         try:
    2:             with self.assertRaises(EnvironmentError):
    2:                 subprocess.Popen(['nonexisting_i_hope'],
    2:                                  stdin=subprocess.PIPE,
    2:                                  stdout=subprocess.PIPE,
    2:                                  stderr=subprocess.PIPE)
               finally:
    2:             t.join()
    2:             exc = None
   82:             for fd in fds:
                       # If a double close occurred, some of those fds will
                       # already have been closed by mistake, and os.close()
                       # here will raise.
   80:                 try:
   80:                     os.close(fd)
>>>>>>                 except OSError as e:
>>>>>>                     exc = e
    2:             if exc is not None:
>>>>>>                 raise exc
       
    1:     def test_handles_closed_on_exception(self):
               # If CreateProcess exits with an error, ensure the
               # duplicate output handles are released
    2:         ifhandle, ifname = tempfile.mkstemp()
    2:         ofhandle, ofname = tempfile.mkstemp()
    2:         efhandle, efname = tempfile.mkstemp()
    2:         try:
    2:             subprocess.Popen (["*"], stdin=ifhandle, stdout=ofhandle,
    2:               stderr=efhandle)
    2:         except OSError:
    2:             os.close(ifhandle)
    2:             os.remove(ifname)
    2:             os.close(ofhandle)
    2:             os.remove(ofname)
    2:             os.close(efhandle)
    2:             os.remove(efname)
    2:         self.assertFalse(os.path.exists(ifname))
    2:         self.assertFalse(os.path.exists(ofname))
    2:         self.assertFalse(os.path.exists(efname))
       
    1:     def test_communicate_epipe(self):
               # Issue 10963: communicate() should hide EPIPE
    2:         p = subprocess.Popen([sys.executable, "-c", 'pass'],
    2:                              stdin=subprocess.PIPE,
    2:                              stdout=subprocess.PIPE,
    2:                              stderr=subprocess.PIPE)
    2:         self.addCleanup(p.stdout.close)
    2:         self.addCleanup(p.stderr.close)
    2:         self.addCleanup(p.stdin.close)
    2:         p.communicate("x" * 2**20)
       
    1:     def test_communicate_epipe_only_stdin(self):
               # Issue 10963: communicate() should hide EPIPE
    2:         p = subprocess.Popen([sys.executable, "-c", 'pass'],
    2:                              stdin=subprocess.PIPE)
    2:         self.addCleanup(p.stdin.close)
    2:         time.sleep(2)
    2:         p.communicate("x" * 2**20)
       
           # This test is Linux-ish specific for simplicity to at least have
           # some coverage.  It is not a platform specific bug.
    1:     @unittest.skipUnless(os.path.isdir('/proc/%d/fd' % os.getpid()),
    1:                          "Linux specific")
           def test_failed_child_execute_fd_leak(self):
               """Test for the fork() failure fd leak reported in issue16327."""
>>>>>>         fd_directory = '/proc/%d/fd' % os.getpid()
>>>>>>         fds_before_popen = os.listdir(fd_directory)
>>>>>>         with self.assertRaises(PopenTestException):
>>>>>>             PopenExecuteChildRaises(
>>>>>>                     [sys.executable, '-c', 'pass'], stdin=subprocess.PIPE,
>>>>>>                     stdout=subprocess.PIPE, stderr=subprocess.PIPE)
       
               # NOTE: This test doesn't verify that the real _execute_child
               # does not close the file descriptors itself on the way out
               # during an exception.  Code inspection has confirmed that.
       
>>>>>>         fds_after_exception = os.listdir(fd_directory)
>>>>>>         self.assertEqual(fds_before_popen, fds_after_exception)
       
       
       # context manager
    2: class _SuppressCoreFiles(object):
    1:     """Try to prevent core files from being created."""
    1:     old_limit = None
       
    1:     def __enter__(self):
               """Try to save previous ulimit, then set it to (0, 0)."""
    1:         if resource is not None:
    1:             try:
    1:                 self.old_limit = resource.getrlimit(resource.RLIMIT_CORE)
    1:                 resource.setrlimit(resource.RLIMIT_CORE, (0, 0))
>>>>>>             except (ValueError, resource.error):
>>>>>>                 pass
       
    1:         if sys.platform == 'darwin':
                   # Check if the 'Crash Reporter' on OSX was configured
                   # in 'Developer' mode and warn that it will get triggered
                   # when it is.
                   #
                   # This assumes that this context manager is used in tests
                   # that might trigger the next manager.
    1:             value = subprocess.Popen(['/usr/bin/defaults', 'read',
    1:                     'com.apple.CrashReporter', 'DialogType'],
    1:                     stdout=subprocess.PIPE).communicate()[0]
    1:             if value.strip() == b'developer':
>>>>>>                 print "this tests triggers the Crash Reporter, that is intentional"
>>>>>>                 sys.stdout.flush()
       
    1:     def __exit__(self, *args):
               """Return core file behavior to default."""
    1:         if self.old_limit is None:
>>>>>>             return
    1:         if resource is not None:
    1:             try:
    1:                 resource.setrlimit(resource.RLIMIT_CORE, self.old_limit)
    1:             except (ValueError, resource.error):
    1:                 pass
       
    1:     @unittest.skipUnless(hasattr(signal, 'SIGALRM'),
    1:                          "Requires signal.SIGALRM")
           def test_communicate_eintr(self):
               # Issue #12493: communicate() should handle EINTR
>>>>>>         def handler(signum, frame):
>>>>>>             pass
>>>>>>         old_handler = signal.signal(signal.SIGALRM, handler)
>>>>>>         self.addCleanup(signal.signal, signal.SIGALRM, old_handler)
       
               # the process is running for 2 seconds
>>>>>>         args = [sys.executable, "-c", 'import time; time.sleep(2)']
>>>>>>         for stream in ('stdout', 'stderr'):
>>>>>>             kw = {stream: subprocess.PIPE}
>>>>>>             with subprocess.Popen(args, **kw) as process:
>>>>>>                 signal.alarm(1)
                       # communicate() will be interrupted by SIGALRM
>>>>>>                 process.communicate()
       
       
    2: @unittest.skipIf(mswindows, "POSIX specific tests")
    1: class POSIXProcessTestCase(BaseTestCase):
       
    1:     def test_exceptions(self):
               # caught & re-raised exceptions
    1:         with self.assertRaises(OSError) as c:
    1:             p = subprocess.Popen([sys.executable, "-c", ""],
    1:                                  cwd="/this/path/does/not/exist")
               # The attribute child_traceback should contain "os.chdir" somewhere.
    1:         self.assertIn("os.chdir", c.exception.child_traceback)
       
    1:     def test_run_abort(self):
               # returncode handles signal termination
    1:         with _SuppressCoreFiles():
    1:             p = subprocess.Popen([sys.executable, "-c",
    1:                                   "import os; os.abort()"])
    1:             p.wait()
    1:         self.assertEqual(-p.returncode, signal.SIGABRT)
       
    1:     def test_preexec(self):
               # preexec function
    1:         p = subprocess.Popen([sys.executable, "-c",
    1:                               "import sys, os;"
                                     "sys.stdout.write(os.getenv('FRUIT'))"],
    1:                              stdout=subprocess.PIPE,
    1:                              preexec_fn=lambda: os.putenv("FRUIT", "apple"))
    1:         self.addCleanup(p.stdout.close)
    1:         self.assertEqual(p.stdout.read(), "apple")
       
    2:     class _TestExecuteChildPopen(subprocess.Popen):
    1:         """Used to test behavior at the end of _execute_child."""
    1:         def __init__(self, testcase, *args, **kwargs):
    1:             self._testcase = testcase
    1:             subprocess.Popen.__init__(self, *args, **kwargs)
       
    1:         def _execute_child(
                       self, args, executable, preexec_fn, close_fds, cwd, env,
                       universal_newlines, startupinfo, creationflags, shell, to_close,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite):
    1:             try:
    1:                 subprocess.Popen._execute_child(
    1:                         self, args, executable, preexec_fn, close_fds,
    1:                         cwd, env, universal_newlines,
    1:                         startupinfo, creationflags, shell, to_close,
    1:                         p2cread, p2cwrite,
    1:                         c2pread, c2pwrite,
    1:                         errread, errwrite)
                   finally:
                       # Open a bunch of file descriptors and verify that
                       # none of them are the same as the ones the Popen
                       # instance is using for stdin/stdout/stderr.
    1:                 devzero_fds = [os.open("/dev/zero", os.O_RDONLY)
    9:                                for _ in range(8)]
    1:                 try:
    9:                     for fd in devzero_fds:
    8:                         self._testcase.assertNotIn(
    8:                                 fd, (p2cwrite, c2pread, errread))
                       finally:
    9:                     for fd in devzero_fds:
    8:                         os.close(fd)
       
    1:     @unittest.skipIf(not os.path.exists("/dev/zero"), "/dev/zero required.")
           def test_preexec_errpipe_does_not_double_close_pipes(self):
               """Issue16140: Don't double close pipes on preexec error."""
       
    1:         def raise_it():
>>>>>>             raise RuntimeError("force the _execute_child() errpipe_data path.")
       
    1:         with self.assertRaises(RuntimeError):
    1:             self._TestExecuteChildPopen(
    1:                     self, [sys.executable, "-c", "pass"],
    1:                     stdin=subprocess.PIPE, stdout=subprocess.PIPE,
    1:                     stderr=subprocess.PIPE, preexec_fn=raise_it)
       
    1:     def test_args_string(self):
               # args is a string
    1:         f, fname = tempfile.mkstemp()
    1:         os.write(f, "#!/bin/sh\n")
    1:         os.write(f, "exec '%s' -c 'import sys; sys.exit(47)'\n" %
    1:                     sys.executable)
    1:         os.close(f)
    1:         os.chmod(fname, 0o700)
    1:         p = subprocess.Popen(fname)
    1:         p.wait()
    1:         os.remove(fname)
    1:         self.assertEqual(p.returncode, 47)
       
    1:     def test_invalid_args(self):
               # invalid arguments should raise ValueError
    1:         self.assertRaises(ValueError, subprocess.call,
    1:                           [sys.executable, "-c",
    1:                            "import sys; sys.exit(47)"],
    1:                           startupinfo=47)
    1:         self.assertRaises(ValueError, subprocess.call,
    1:                           [sys.executable, "-c",
    1:                            "import sys; sys.exit(47)"],
    1:                           creationflags=47)
       
    1:     def test_shell_sequence(self):
               # Run command through the shell (sequence)
    1:         newenv = os.environ.copy()
    1:         newenv["FRUIT"] = "apple"
    1:         p = subprocess.Popen(["echo $FRUIT"], shell=1,
    1:                              stdout=subprocess.PIPE,
    1:                              env=newenv)
    1:         self.addCleanup(p.stdout.close)
    1:         self.assertEqual(p.stdout.read().strip(), "apple")
       
    1:     def test_shell_string(self):
               # Run command through the shell (string)
    1:         newenv = os.environ.copy()
    1:         newenv["FRUIT"] = "apple"
    1:         p = subprocess.Popen("echo $FRUIT", shell=1,
    1:                              stdout=subprocess.PIPE,
    1:                              env=newenv)
    1:         self.addCleanup(p.stdout.close)
    1:         self.assertEqual(p.stdout.read().strip(), "apple")
       
    1:     def test_call_string(self):
               # call() function with string argument on UNIX
    1:         f, fname = tempfile.mkstemp()
    1:         os.write(f, "#!/bin/sh\n")
    1:         os.write(f, "exec '%s' -c 'import sys; sys.exit(47)'\n" %
    1:                     sys.executable)
    1:         os.close(f)
    1:         os.chmod(fname, 0700)
    1:         rc = subprocess.call(fname)
    1:         os.remove(fname)
    1:         self.assertEqual(rc, 47)
       
    1:     def test_specific_shell(self):
               # Issue #9265: Incorrect name passed as arg[0].
    1:         shells = []
    4:         for prefix in ['/bin', '/usr/bin/', '/usr/local/bin']:
    9:             for name in ['bash', 'ksh']:
    6:                 sh = os.path.join(prefix, name)
    6:                 if os.path.isfile(sh):
    2:                     shells.append(sh)
    1:         if not shells: # Will probably work for any shell but csh.
>>>>>>             self.skipTest("bash or ksh required for this test")
    1:         sh = '/bin/sh'
    1:         if os.path.isfile(sh) and not os.path.islink(sh):
                   # Test will fail if /bin/sh is a symlink to csh.
    1:             shells.append(sh)
    4:         for sh in shells:
    3:             p = subprocess.Popen("echo $0", executable=sh, shell=True,
    3:                                  stdout=subprocess.PIPE)
    3:             self.addCleanup(p.stdout.close)
    3:             self.assertEqual(p.stdout.read().strip(), sh)
       
    1:     def _kill_process(self, method, *args):
               # Do not inherit file handles from the parent.
               # It should fix failures on some platforms.
    3:         p = subprocess.Popen([sys.executable, "-c", """if 1:
                                    import sys, time
                                    sys.stdout.write('x\\n')
                                    sys.stdout.flush()
                                    time.sleep(30)
    3:                              """],
    3:                              close_fds=True,
    3:                              stdin=subprocess.PIPE,
    3:                              stdout=subprocess.PIPE,
    3:                              stderr=subprocess.PIPE)
               # Wait for the interpreter to be completely initialized before
               # sending any signal.
    3:         p.stdout.read(1)
    3:         getattr(p, method)(*args)
    3:         return p
       
    1:     @unittest.skipIf(sys.platform.startswith(('netbsd', 'openbsd')),
    1:                      "Due to known OS bug (issue #16762)")
           def _kill_dead_process(self, method, *args):
               # Do not inherit file handles from the parent.
               # It should fix failures on some platforms.
    3:         p = subprocess.Popen([sys.executable, "-c", """if 1:
                                    import sys, time
                                    sys.stdout.write('x\\n')
                                    sys.stdout.flush()
    3:                              """],
    3:                              close_fds=True,
    3:                              stdin=subprocess.PIPE,
    3:                              stdout=subprocess.PIPE,
    3:                              stderr=subprocess.PIPE)
               # Wait for the interpreter to be completely initialized before
               # sending any signal.
    3:         p.stdout.read(1)
               # The process should end after this
    3:         time.sleep(1)
               # This shouldn't raise even though the child is now dead
    3:         getattr(p, method)(*args)
    3:         p.communicate()
       
    1:     def test_send_signal(self):
    1:         p = self._kill_process('send_signal', signal.SIGINT)
    1:         _, stderr = p.communicate()
    1:         self.assertIn('KeyboardInterrupt', stderr)
    1:         self.assertNotEqual(p.wait(), 0)
       
    1:     def test_kill(self):
    1:         p = self._kill_process('kill')
    1:         _, stderr = p.communicate()
    1:         self.assertStderrEqual(stderr, '')
    1:         self.assertEqual(p.wait(), -signal.SIGKILL)
       
    1:     def test_terminate(self):
    1:         p = self._kill_process('terminate')
    1:         _, stderr = p.communicate()
    1:         self.assertStderrEqual(stderr, '')
    1:         self.assertEqual(p.wait(), -signal.SIGTERM)
       
    1:     def test_send_signal_dead(self):
               # Sending a signal to a dead process
    1:         self._kill_dead_process('send_signal', signal.SIGINT)
       
    1:     def test_kill_dead(self):
               # Killing a dead process
    1:         self._kill_dead_process('kill')
       
    1:     def test_terminate_dead(self):
               # Terminating a dead process
    1:         self._kill_dead_process('terminate')
       
    1:     def check_close_std_fds(self, fds):
               # Issue #9905: test that subprocess pipes still work properly with
               # some standard fds closed
    7:         stdin = 0
    7:         newfds = []
   19:         for a in fds:
   12:             b = os.dup(a)
   12:             newfds.append(b)
   12:             if a == 0:
    4:                 stdin = b
    7:         try:
   19:             for fd in fds:
   12:                 os.close(fd)
    7:             out, err = subprocess.Popen([sys.executable, "-c",
    7:                               'import sys;'
                                     'sys.stdout.write("apple");'
                                     'sys.stdout.flush();'
                                     'sys.stderr.write("orange")'],
    7:                        stdin=stdin,
    7:                        stdout=subprocess.PIPE,
    7:                        stderr=subprocess.PIPE).communicate()
    7:             err = test_support.strip_python_stderr(err)
    7:             self.assertEqual((out, err), (b'apple', b'orange'))
               finally:
   19:             for b, a in zip(newfds, fds):
   12:                 os.dup2(b, a)
   19:             for b in newfds:
   12:                 os.close(b)
       
    1:     def test_close_fd_0(self):
    1:         self.check_close_std_fds([0])
       
    1:     def test_close_fd_1(self):
    1:         self.check_close_std_fds([1])
       
    1:     def test_close_fd_2(self):
    1:         self.check_close_std_fds([2])
       
    1:     def test_close_fds_0_1(self):
    1:         self.check_close_std_fds([0, 1])
       
    1:     def test_close_fds_0_2(self):
    1:         self.check_close_std_fds([0, 2])
       
    1:     def test_close_fds_1_2(self):
    1:         self.check_close_std_fds([1, 2])
       
    1:     def test_close_fds_0_1_2(self):
               # Issue #10806: test that subprocess pipes still work properly with
               # all standard fds closed.
    1:         self.check_close_std_fds([0, 1, 2])
       
    1:     def check_swap_fds(self, stdin_no, stdout_no, stderr_no):
               # open up some temporary files
   24:         temps = [tempfile.mkstemp() for i in range(3)]
   24:         temp_fds = [fd for fd, fname in temps]
    6:         try:
                   # unlink the files -- we won't need to reopen them
   24:             for fd, fname in temps:
   18:                 os.unlink(fname)
       
                   # save a copy of the standard file descriptors
   24:             saved_fds = [os.dup(fd) for fd in range(3)]
    6:             try:
                       # duplicate the temp files over the standard fd's 0, 1, 2
   24:                 for fd, temp_fd in enumerate(temp_fds):
   18:                     os.dup2(temp_fd, fd)
       
                       # write some data to what will become stdin, and rewind
    6:                 os.write(stdin_no, b"STDIN")
    6:                 os.lseek(stdin_no, 0, 0)
       
                       # now use those files in the given order, so that subprocess
                       # has to rearrange them in the child
    6:                 p = subprocess.Popen([sys.executable, "-c",
    6:                     'import sys; got = sys.stdin.read();'
                           'sys.stdout.write("got %s"%got); sys.stderr.write("err")'],
    6:                     stdin=stdin_no,
    6:                     stdout=stdout_no,
    6:                     stderr=stderr_no)
    6:                 p.wait()
       
   24:                 for fd in temp_fds:
   18:                     os.lseek(fd, 0, 0)
       
    6:                 out = os.read(stdout_no, 1024)
    6:                 err = test_support.strip_python_stderr(os.read(stderr_no, 1024))
                   finally:
   24:                 for std, saved in enumerate(saved_fds):
   18:                     os.dup2(saved, std)
   18:                     os.close(saved)
       
    6:             self.assertEqual(out, b"got STDIN")
    6:             self.assertEqual(err, b"err")
       
               finally:
   24:             for fd in temp_fds:
   18:                 os.close(fd)
       
           # When duping fds, if there arises a situation where one of the fds is
           # either 0, 1 or 2, it is possible that it is overwritten (#12607).
           # This tests all combinations of this.
    1:     def test_swap_fds(self):
    1:         self.check_swap_fds(0, 1, 2)
    1:         self.check_swap_fds(0, 2, 1)
    1:         self.check_swap_fds(1, 0, 2)
    1:         self.check_swap_fds(1, 2, 0)
    1:         self.check_swap_fds(2, 0, 1)
    1:         self.check_swap_fds(2, 1, 0)
       
    1:     def test_wait_when_sigchild_ignored(self):
               # NOTE: sigchild_ignore.py may not be an effective test on all OSes.
    1:         sigchild_ignore = test_support.findfile("sigchild_ignore.py",
    1:                                                 subdir="subprocessdata")
    1:         p = subprocess.Popen([sys.executable, sigchild_ignore],
    1:                              stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    1:         stdout, stderr = p.communicate()
    1:         self.assertEqual(0, p.returncode, "sigchild_ignore.py exited"
    1:                          " non-zero with this error:\n%s" % stderr)
       
    1:     def test_zombie_fast_process_del(self):
               # Issue #12650: on Unix, if Popen.__del__() was called before the
               # process exited, it wouldn't be added to subprocess._active, and would
               # remain a zombie.
               # spawn a Popen, and delete its reference before it exits
    1:         p = subprocess.Popen([sys.executable, "-c",
    1:                               'import sys, time;'
                                     'time.sleep(0.2)'],
    1:                              stdout=subprocess.PIPE,
    1:                              stderr=subprocess.PIPE)
    1:         self.addCleanup(p.stdout.close)
    1:         self.addCleanup(p.stderr.close)
    1:         ident = id(p)
    1:         pid = p.pid
    1:         del p
               # check that p is in the active processes list
    2:         self.assertIn(ident, [id(o) for o in subprocess._active])
       
    1:     def test_leak_fast_process_del_killed(self):
               # Issue #12650: on Unix, if Popen.__del__() was called before the
               # process exited, and the process got killed by a signal, it would never
               # be removed from subprocess._active, which triggered a FD and memory
               # leak.
               # spawn a Popen, delete its reference and kill it
    1:         p = subprocess.Popen([sys.executable, "-c",
    1:                               'import time;'
                                     'time.sleep(3)'],
    1:                              stdout=subprocess.PIPE,
    1:                              stderr=subprocess.PIPE)
    1:         self.addCleanup(p.stdout.close)
    1:         self.addCleanup(p.stderr.close)
    1:         ident = id(p)
    1:         pid = p.pid
    1:         del p
    1:         os.kill(pid, signal.SIGKILL)
               # check that p is in the active processes list
    2:         self.assertIn(ident, [id(o) for o in subprocess._active])
       
               # let some time for the process to exit, and create a new Popen: this
               # should trigger the wait() of p
    1:         time.sleep(0.2)
    1:         with self.assertRaises(EnvironmentError) as c:
    1:             with subprocess.Popen(['nonexisting_i_hope'],
    1:                                   stdout=subprocess.PIPE,
    1:                                   stderr=subprocess.PIPE) as proc:
>>>>>>                 pass
               # p should have been wait()ed on, and removed from the _active list
    1:         self.assertRaises(OSError, os.waitpid, pid, 0)
    1:         self.assertNotIn(ident, [id(o) for o in subprocess._active])
       
    1:     def test_pipe_cloexec(self):
               # Issue 12786: check that the communication pipes' FDs are set CLOEXEC,
               # and are not inherited by another child process.
    1:         p1 = subprocess.Popen([sys.executable, "-c",
    1:                                'import os;'
                                      'os.read(0, 1)'
                                     ],
    1:                               stdin=subprocess.PIPE, stdout=subprocess.PIPE,
    1:                               stderr=subprocess.PIPE)
       
    1:         p2 = subprocess.Popen([sys.executable, "-c", """if True:
                                      import os, errno, sys
                                      for fd in %r:
                                          try:
                                              os.close(fd)
                                          except OSError as e:
                                              if e.errno != errno.EBADF:
                                                  raise
                                          else:
                                              sys.exit(1)
                                      sys.exit(0)
    1:                                """ % [f.fileno() for f in (p1.stdin, p1.stdout,
    4:                                                            p1.stderr)]
                                     ],
    1:                               stdin=subprocess.PIPE, stdout=subprocess.PIPE,
    1:                               stderr=subprocess.PIPE, close_fds=False)
    1:         p1.communicate('foo')
    1:         _, stderr = p2.communicate()
       
    1:         self.assertEqual(p2.returncode, 0, "Unexpected error: " + repr(stderr))
       
    1:     @unittest.skipUnless(_testcapi is not None
    1:                          and hasattr(_testcapi, 'W_STOPCODE'),
    1:                          'need _testcapi.W_STOPCODE')
           def test_stopped(self):
               """Test wait() behavior when waitpid returns WIFSTOPPED; issue29335."""
    1:         args = [sys.executable, '-c', 'pass']
    1:         proc = subprocess.Popen(args)
       
               # Wait until the real process completes to avoid zombie process
    1:         pid = proc.pid
    1:         pid, status = os.waitpid(pid, 0)
    1:         self.assertEqual(status, 0)
       
    1:         status = _testcapi.W_STOPCODE(3)
       
    1:         def mock_waitpid(pid, flags):
    1:             return (pid, status)
       
    1:         with test_support.swap_attr(os, 'waitpid', mock_waitpid):
    1:             returncode = proc.wait()
       
    1:         self.assertEqual(returncode, -3)
       
       
    2: @unittest.skipUnless(mswindows, "Windows specific tests")
    1: class Win32ProcessTestCase(BaseTestCase):
       
    1:     def test_startupinfo(self):
               # startupinfo argument
               # We uses hardcoded constants, because we do not want to
               # depend on win32all.
>>>>>>         STARTF_USESHOWWINDOW = 1
>>>>>>         SW_MAXIMIZE = 3
>>>>>>         startupinfo = subprocess.STARTUPINFO()
>>>>>>         startupinfo.dwFlags = STARTF_USESHOWWINDOW
>>>>>>         startupinfo.wShowWindow = SW_MAXIMIZE
               # Since Python is a console process, it won't be affected
               # by wShowWindow, but the argument should be silently
               # ignored
>>>>>>         subprocess.call([sys.executable, "-c", "import sys; sys.exit(0)"],
>>>>>>                         startupinfo=startupinfo)
       
    1:     def test_creationflags(self):
               # creationflags argument
>>>>>>         CREATE_NEW_CONSOLE = 16
>>>>>>         sys.stderr.write("    a DOS box should flash briefly ...\n")
>>>>>>         subprocess.call(sys.executable +
>>>>>>                         ' -c "import time; time.sleep(0.25)"',
>>>>>>                         creationflags=CREATE_NEW_CONSOLE)
       
    1:     def test_invalid_args(self):
               # invalid arguments should raise ValueError
>>>>>>         self.assertRaises(ValueError, subprocess.call,
>>>>>>                           [sys.executable, "-c",
>>>>>>                            "import sys; sys.exit(47)"],
>>>>>>                           preexec_fn=lambda: 1)
>>>>>>         self.assertRaises(ValueError, subprocess.call,
>>>>>>                           [sys.executable, "-c",
>>>>>>                            "import sys; sys.exit(47)"],
>>>>>>                           stdout=subprocess.PIPE,
>>>>>>                           close_fds=True)
       
    1:     def test_close_fds(self):
               # close file descriptors
>>>>>>         rc = subprocess.call([sys.executable, "-c",
>>>>>>                               "import sys; sys.exit(47)"],
>>>>>>                               close_fds=True)
>>>>>>         self.assertEqual(rc, 47)
       
    1:     def test_shell_sequence(self):
               # Run command through the shell (sequence)
>>>>>>         newenv = os.environ.copy()
>>>>>>         newenv["FRUIT"] = "physalis"
>>>>>>         p = subprocess.Popen(["set"], shell=1,
>>>>>>                              stdout=subprocess.PIPE,
>>>>>>                              env=newenv)
>>>>>>         self.addCleanup(p.stdout.close)
>>>>>>         self.assertIn("physalis", p.stdout.read())
       
    1:     def test_shell_string(self):
               # Run command through the shell (string)
>>>>>>         newenv = os.environ.copy()
>>>>>>         newenv["FRUIT"] = "physalis"
>>>>>>         p = subprocess.Popen("set", shell=1,
>>>>>>                              stdout=subprocess.PIPE,
>>>>>>                              env=newenv)
>>>>>>         self.addCleanup(p.stdout.close)
>>>>>>         self.assertIn("physalis", p.stdout.read())
       
    1:     def test_call_string(self):
               # call() function with string argument on Windows
>>>>>>         rc = subprocess.call(sys.executable +
>>>>>>                              ' -c "import sys; sys.exit(47)"')
>>>>>>         self.assertEqual(rc, 47)
       
    1:     def _kill_process(self, method, *args):
               # Some win32 buildbot raises EOFError if stdin is inherited
>>>>>>         p = subprocess.Popen([sys.executable, "-c", """if 1:
                                    import sys, time
                                    sys.stdout.write('x\\n')
                                    sys.stdout.flush()
                                    time.sleep(30)
>>>>>>                              """],
>>>>>>                              stdin=subprocess.PIPE,
>>>>>>                              stdout=subprocess.PIPE,
>>>>>>                              stderr=subprocess.PIPE)
>>>>>>         self.addCleanup(p.stdout.close)
>>>>>>         self.addCleanup(p.stderr.close)
>>>>>>         self.addCleanup(p.stdin.close)
               # Wait for the interpreter to be completely initialized before
               # sending any signal.
>>>>>>         p.stdout.read(1)
>>>>>>         getattr(p, method)(*args)
>>>>>>         _, stderr = p.communicate()
>>>>>>         self.assertStderrEqual(stderr, '')
>>>>>>         returncode = p.wait()
>>>>>>         self.assertNotEqual(returncode, 0)
       
    1:     def _kill_dead_process(self, method, *args):
>>>>>>         p = subprocess.Popen([sys.executable, "-c", """if 1:
                                    import sys, time
                                    sys.stdout.write('x\\n')
                                    sys.stdout.flush()
                                    sys.exit(42)
>>>>>>                              """],
>>>>>>                              stdin=subprocess.PIPE,
>>>>>>                              stdout=subprocess.PIPE,
>>>>>>                              stderr=subprocess.PIPE)
>>>>>>         self.addCleanup(p.stdout.close)
>>>>>>         self.addCleanup(p.stderr.close)
>>>>>>         self.addCleanup(p.stdin.close)
               # Wait for the interpreter to be completely initialized before
               # sending any signal.
>>>>>>         p.stdout.read(1)
               # The process should end after this
>>>>>>         time.sleep(1)
               # This shouldn't raise even though the child is now dead
>>>>>>         getattr(p, method)(*args)
>>>>>>         _, stderr = p.communicate()
>>>>>>         self.assertStderrEqual(stderr, b'')
>>>>>>         rc = p.wait()
>>>>>>         self.assertEqual(rc, 42)
       
    1:     def test_send_signal(self):
>>>>>>         self._kill_process('send_signal', signal.SIGTERM)
       
    1:     def test_kill(self):
>>>>>>         self._kill_process('kill')
       
    1:     def test_terminate(self):
>>>>>>         self._kill_process('terminate')
       
    1:     def test_send_signal_dead(self):
>>>>>>         self._kill_dead_process('send_signal', signal.SIGTERM)
       
    1:     def test_kill_dead(self):
>>>>>>         self._kill_dead_process('kill')
       
    1:     def test_terminate_dead(self):
>>>>>>         self._kill_dead_process('terminate')
       
       
    2: @unittest.skipUnless(getattr(subprocess, '_has_poll', False),
    1:                      "poll system call not supported")
    1: class ProcessTestCaseNoPoll(ProcessTestCase):
    1:     def setUp(self):
   50:         subprocess._has_poll = False
   50:         ProcessTestCase.setUp(self)
       
    1:     def tearDown(self):
   50:         subprocess._has_poll = True
   50:         ProcessTestCase.tearDown(self)
       
       
    2: class HelperFunctionTests(unittest.TestCase):
    1:     @unittest.skipIf(mswindows, "errno and EINTR make no sense on windows")
           def test_eintr_retry_call(self):
    1:         record_calls = []
    1:         def fake_os_func(*args):
    3:             record_calls.append(args)
    3:             if len(record_calls) == 2:
    1:                 raise OSError(errno.EINTR, "fake interrupted system call")
    2:             return tuple(reversed(args))
       
    1:         self.assertEqual((999, 256),
    1:                          subprocess._eintr_retry_call(fake_os_func, 256, 999))
    1:         self.assertEqual([(256, 999)], record_calls)
               # This time there will be an EINTR so it will loop once.
    1:         self.assertEqual((666,),
    1:                          subprocess._eintr_retry_call(fake_os_func, 666))
    1:         self.assertEqual([(256, 999), (666,), (666,)], record_calls)
       
    2: @unittest.skipUnless(mswindows, "mswindows only")
    1: class CommandsWithSpaces (BaseTestCase):
       
    1:     def setUp(self):
>>>>>>         super(CommandsWithSpaces, self).setUp()
>>>>>>         f, fname = tempfile.mkstemp(".py", "te st")
>>>>>>         self.fname = fname.lower ()
>>>>>>         os.write(f, b"import sys;"
                           b"sys.stdout.write('%d %s' % (len(sys.argv), [a.lower () for a in sys.argv]))"
               )
>>>>>>         os.close(f)
       
    1:     def tearDown(self):
>>>>>>         os.remove(self.fname)
>>>>>>         super(CommandsWithSpaces, self).tearDown()
       
    1:     def with_spaces(self, *args, **kwargs):
>>>>>>         kwargs['stdout'] = subprocess.PIPE
>>>>>>         p = subprocess.Popen(*args, **kwargs)
>>>>>>         self.addCleanup(p.stdout.close)
>>>>>>         self.assertEqual(
>>>>>>           p.stdout.read ().decode("mbcs"),
>>>>>>           "2 [%r, 'ab cd']" % self.fname
               )
       
    1:     def test_shell_string_with_spaces(self):
               # call() function with string argument with spaces on Windows
>>>>>>         self.with_spaces('"%s" "%s" "%s"' % (sys.executable, self.fname,
>>>>>>                                              "ab cd"), shell=1)
       
    1:     def test_shell_sequence_with_spaces(self):
               # call() function with sequence argument with spaces on Windows
>>>>>>         self.with_spaces([sys.executable, self.fname, "ab cd"], shell=1)
       
    1:     def test_noshell_string_with_spaces(self):
               # call() function with string argument with spaces on Windows
>>>>>>         self.with_spaces('"%s" "%s" "%s"' % (sys.executable, self.fname,
>>>>>>                              "ab cd"))
       
    1:     def test_noshell_sequence_with_spaces(self):
               # call() function with sequence argument with spaces on Windows
>>>>>>         self.with_spaces([sys.executable, self.fname, "ab cd"])
       
    1: def test_main():
    1:     unit_tests = (ProcessTestCase,
    1:                   POSIXProcessTestCase,
    1:                   Win32ProcessTestCase,
    1:                   ProcessTestCaseNoPoll,
    1:                   HelperFunctionTests,
    1:                   CommandsWithSpaces)
       
    1:     test_support.run_unittest(*unit_tests)
    1:     test_support.reap_children()
       
    1: if __name__ == "__main__":
>>>>>>     test_main()
