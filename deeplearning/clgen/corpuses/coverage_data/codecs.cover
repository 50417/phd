       """ codecs -- Python Codec Registry, API and helpers.
       
       
       Written by Marc-Andre Lemburg (mal@lemburg.com).
       
       (c) Copyright CNRI, All Rights Reserved. NO WARRANTY.
       
       """#"
       
>>>>>> import __builtin__, sys
       
       ### Registry and builtin stateless codec functions
       
>>>>>> try:
>>>>>>     from _codecs import *
>>>>>> except ImportError, why:
>>>>>>     raise SystemError('Failed to load the builtin codecs: %s' % why)
       
>>>>>> __all__ = ["register", "lookup", "open", "EncodedFile", "BOM", "BOM_BE",
>>>>>>            "BOM_LE", "BOM32_BE", "BOM32_LE", "BOM64_BE", "BOM64_LE",
>>>>>>            "BOM_UTF8", "BOM_UTF16", "BOM_UTF16_LE", "BOM_UTF16_BE",
>>>>>>            "BOM_UTF32", "BOM_UTF32_LE", "BOM_UTF32_BE",
>>>>>>            "CodecInfo", "Codec", "IncrementalEncoder", "IncrementalDecoder",
>>>>>>            "StreamReader", "StreamWriter",
>>>>>>            "StreamReaderWriter", "StreamRecoder",
>>>>>>            "getencoder", "getdecoder", "getincrementalencoder",
>>>>>>            "getincrementaldecoder", "getreader", "getwriter",
>>>>>>            "encode", "decode", "iterencode", "iterdecode",
>>>>>>            "strict_errors", "ignore_errors", "replace_errors",
>>>>>>            "xmlcharrefreplace_errors", "backslashreplace_errors",
>>>>>>            "register_error", "lookup_error"]
       
       ### Constants
       
       #
       # Byte Order Mark (BOM = ZERO WIDTH NO-BREAK SPACE = U+FEFF)
       # and its possible byte string values
       # for UTF8/UTF16/UTF32 output and little/big endian machines
       #
       
       # UTF-8
>>>>>> BOM_UTF8 = '\xef\xbb\xbf'
       
       # UTF-16, little endian
>>>>>> BOM_LE = BOM_UTF16_LE = '\xff\xfe'
       
       # UTF-16, big endian
>>>>>> BOM_BE = BOM_UTF16_BE = '\xfe\xff'
       
       # UTF-32, little endian
>>>>>> BOM_UTF32_LE = '\xff\xfe\x00\x00'
       
       # UTF-32, big endian
>>>>>> BOM_UTF32_BE = '\x00\x00\xfe\xff'
       
>>>>>> if sys.byteorder == 'little':
       
           # UTF-16, native endianness
>>>>>>     BOM = BOM_UTF16 = BOM_UTF16_LE
       
           # UTF-32, native endianness
>>>>>>     BOM_UTF32 = BOM_UTF32_LE
       
       else:
       
           # UTF-16, native endianness
>>>>>>     BOM = BOM_UTF16 = BOM_UTF16_BE
       
           # UTF-32, native endianness
>>>>>>     BOM_UTF32 = BOM_UTF32_BE
       
       # Old broken names (don't use in new code)
>>>>>> BOM32_LE = BOM_UTF16_LE
>>>>>> BOM32_BE = BOM_UTF16_BE
>>>>>> BOM64_LE = BOM_UTF32_LE
>>>>>> BOM64_BE = BOM_UTF32_BE
       
       
       ### Codec base classes (defining the API)
       
>>>>>> class CodecInfo(tuple):
           """Codec details when looking up the codec registry"""
       
           # Private API to allow Python to blacklist the known non-Unicode
           # codecs in the standard library. A more general mechanism to
           # reliably distinguish test encodings from other codecs will hopefully
           # be defined for Python 3.5
           #
           # See http://bugs.python.org/issue19619
>>>>>>     _is_text_encoding = True # Assume codecs are text encodings by default
       
>>>>>>     def __new__(cls, encode, decode, streamreader=None, streamwriter=None,
>>>>>>         incrementalencoder=None, incrementaldecoder=None, name=None,
>>>>>>         _is_text_encoding=None):
  156:         self = tuple.__new__(cls, (encode, decode, streamreader, streamwriter))
  156:         self.name = name
  156:         self.encode = encode
  156:         self.decode = decode
  156:         self.incrementalencoder = incrementalencoder
  156:         self.incrementaldecoder = incrementaldecoder
  156:         self.streamwriter = streamwriter
  156:         self.streamreader = streamreader
  156:         if _is_text_encoding is not None:
   14:             self._is_text_encoding = _is_text_encoding
  156:         return self
       
>>>>>>     def __repr__(self):
>>>>>>         return "<%s.%s object for encoding %s at 0x%x>" % (self.__class__.__module__, self.__class__.__name__, self.name, id(self))
       
>>>>>> class Codec:
       
           """ Defines the interface for stateless encoders/decoders.
       
               The .encode()/.decode() methods may use different error
               handling schemes by providing the errors argument. These
               string values are predefined:
       
                'strict' - raise a ValueError error (or a subclass)
                'ignore' - ignore the character and continue with the next
                'replace' - replace with a suitable replacement character;
                           Python will use the official U+FFFD REPLACEMENT
                           CHARACTER for the builtin Unicode codecs on
                           decoding and '?' on encoding.
                'xmlcharrefreplace' - Replace with the appropriate XML
                                      character reference (only for encoding).
                'backslashreplace'  - Replace with backslashed escape sequences
                                      (only for encoding).
       
               The set of allowed values can be extended via register_error.
       
           """
>>>>>>     def encode(self, input, errors='strict'):
       
               """ Encodes the object input and returns a tuple (output
                   object, length consumed).
       
                   errors defines the error handling to apply. It defaults to
                   'strict' handling.
       
                   The method may not store state in the Codec instance. Use
                   StreamWriter for codecs which have to keep state in order to
                   make encoding efficient.
       
                   The encoder must be able to handle zero length input and
                   return an empty object of the output object type in this
                   situation.
       
               """
>>>>>>         raise NotImplementedError
       
>>>>>>     def decode(self, input, errors='strict'):
       
               """ Decodes the object input and returns a tuple (output
                   object, length consumed).
       
                   input must be an object which provides the bf_getreadbuf
                   buffer slot. Python strings, buffer objects and memory
                   mapped files are examples of objects providing this slot.
       
                   errors defines the error handling to apply. It defaults to
                   'strict' handling.
       
                   The method may not store state in the Codec instance. Use
                   StreamReader for codecs which have to keep state in order to
                   make decoding efficient.
       
                   The decoder must be able to handle zero length input and
                   return an empty object of the output object type in this
                   situation.
       
               """
>>>>>>         raise NotImplementedError
       
>>>>>> class IncrementalEncoder(object):
           """
           An IncrementalEncoder encodes an input in multiple steps. The input can be
           passed piece by piece to the encode() method. The IncrementalEncoder remembers
           the state of the Encoding process between calls to encode().
           """
>>>>>>     def __init__(self, errors='strict'):
               """
               Creates an IncrementalEncoder instance.
       
               The IncrementalEncoder may use different error handling schemes by
               providing the errors keyword argument. See the module docstring
               for a list of possible values.
               """
 3730:         self.errors = errors
 3730:         self.buffer = ""
       
>>>>>>     def encode(self, input, final=False):
               """
               Encodes input and returns the resulting object.
               """
>>>>>>         raise NotImplementedError
       
  474:     def reset(self):
               """
               Resets the encoder to the initial state.
               """
       
>>>>>>     def getstate(self):
               """
               Return the current state of the encoder.
               """
>>>>>>         return 0
       
  110:     def setstate(self, state):
               """
               Set the current state of the encoder. state must have been
               returned by getstate().
               """
       
>>>>>> class BufferedIncrementalEncoder(IncrementalEncoder):
           """
           This subclass of IncrementalEncoder can be used as the baseclass for an
           incremental encoder if the encoder must keep some of the output in a
           buffer between calls to encode().
           """
>>>>>>     def __init__(self, errors='strict'):
    9:         IncrementalEncoder.__init__(self, errors)
    9:         self.buffer = "" # unencoded input that is kept between calls to encode()
       
>>>>>>     def _buffer_encode(self, input, errors, final):
               # Overwrite this method in subclasses: It must encode input
               # and return an (output, length consumed) tuple
>>>>>>         raise NotImplementedError
       
>>>>>>     def encode(self, input, final=False):
               # encode input (taking the buffer into account)
   75:         data = self.buffer + input
   75:         (result, consumed) = self._buffer_encode(data, self.errors, final)
               # keep unencoded input until the next call
   75:         self.buffer = data[consumed:]
   75:         return result
       
>>>>>>     def reset(self):
    1:         IncrementalEncoder.reset(self)
    1:         self.buffer = ""
       
>>>>>>     def getstate(self):
>>>>>>         return self.buffer or 0
       
>>>>>>     def setstate(self, state):
>>>>>>         self.buffer = state or ""
       
>>>>>> class IncrementalDecoder(object):
           """
           An IncrementalDecoder decodes an input in multiple steps. The input can be
           passed piece by piece to the decode() method. The IncrementalDecoder
           remembers the state of the decoding process between calls to decode().
           """
>>>>>>     def __init__(self, errors='strict'):
               """
               Creates an IncrementalDecoder instance.
       
               The IncrementalDecoder may use different error handling schemes by
               providing the errors keyword argument. See the module docstring
               for a list of possible values.
               """
 9660:         self.errors = errors
       
>>>>>>     def decode(self, input, final=False):
               """
               Decodes input and returns the resulting object.
               """
>>>>>>         raise NotImplementedError
       
 1212:     def reset(self):
               """
               Resets the decoder to the initial state.
               """
       
>>>>>>     def getstate(self):
               """
               Return the current state of the decoder.
       
               This must be a (buffered_input, additional_state_info) tuple.
               buffered_input must be a bytes object containing bytes that
               were passed to decode() that have not yet been converted.
               additional_state_info must be a non-negative integer
               representing the state of the decoder WITHOUT yet having
               processed the contents of buffered_input.  In the initial state
               and after reset(), getstate() must return (b"", 0).
               """
 1148:         return (b"", 0)
       
   62:     def setstate(self, state):
               """
               Set the current state of the decoder.
       
               state must have been returned by getstate().  The effect of
               setstate((b"", 0)) must be equivalent to reset().
               """
       
>>>>>> class BufferedIncrementalDecoder(IncrementalDecoder):
           """
           This subclass of IncrementalDecoder can be used as the baseclass for an
           incremental decoder if the decoder must be able to handle incomplete byte
           sequences.
           """
>>>>>>     def __init__(self, errors='strict'):
 1545:         IncrementalDecoder.__init__(self, errors)
 1545:         self.buffer = "" # undecoded input that is kept between calls to decode()
       
>>>>>>     def _buffer_decode(self, input, errors, final):
               # Overwrite this method in subclasses: It must decode input
               # and return an (output, length consumed) tuple
>>>>>>         raise NotImplementedError
       
>>>>>>     def decode(self, input, final=False):
               # decode input (taking the buffer into account)
62098:         data = self.buffer + input
62098:         (result, consumed) = self._buffer_decode(data, self.errors, final)
               # keep undecoded input until the next call
62096:         self.buffer = data[consumed:]
62096:         return result
       
>>>>>>     def reset(self):
  871:         IncrementalDecoder.reset(self)
  871:         self.buffer = ""
       
>>>>>>     def getstate(self):
               # additional state info is always 0
44345:         return (self.buffer, 0)
       
>>>>>>     def setstate(self, state):
               # ignore additional state info
  961:         self.buffer = state[0]
       
       #
       # The StreamWriter and StreamReader class provide generic working
       # interfaces which can be used to implement new encoding submodules
       # very easily. See encodings/utf_8.py for an example on how this is
       # done.
       #
       
>>>>>> class StreamWriter(Codec):
       
>>>>>>     def __init__(self, stream, errors='strict'):
       
               """ Creates a StreamWriter instance.
       
                   stream must be a file-like object open for writing
                   (binary) data.
       
                   The StreamWriter may use different error handling
                   schemes by providing the errors keyword argument. These
                   parameters are predefined:
       
                    'strict' - raise a ValueError (or a subclass)
                    'ignore' - ignore the character and continue with the next
                    'replace'- replace with a suitable replacement character
                    'xmlcharrefreplace' - Replace with the appropriate XML
                                          character reference.
                    'backslashreplace'  - Replace with backslashed escape
                                          sequences (only for encoding).
       
                   The set of allowed parameter values can be extended via
                   register_error.
               """
 2826:         self.stream = stream
 2826:         self.errors = errors
       
>>>>>>     def write(self, object):
       
               """ Writes the object's contents encoded to self.stream.
               """
149956:         data, consumed = self.encode(object, self.errors)
149955:         self.stream.write(data)
       
>>>>>>     def writelines(self, list):
       
               """ Writes the concatenated list of strings to the stream
                   using .write().
               """
35585:         self.write(''.join(list))
       
>>>>>>     def reset(self):
       
               """ Flushes and resets the codec buffers used for keeping state.
       
                   Calling this method should ensure that the data on the
                   output is put into a clean state, that allows appending
                   of new fresh data without having to rescan the whole
                   stream to recover state.
       
               """
   48:         pass
       
>>>>>>     def seek(self, offset, whence=0):
   12:         self.stream.seek(offset, whence)
   12:         if whence == 0 and offset == 0:
    6:             self.reset()
       
           def __getattr__(self, name,
>>>>>>                     getattr=getattr):
       
               """ Inherit all other methods from the underlying stream.
               """
 4613:         return getattr(self.stream, name)
       
>>>>>>     def __enter__(self):
>>>>>>         return self
       
>>>>>>     def __exit__(self, type, value, tb):
>>>>>>         self.stream.close()
       
       ###
       
>>>>>> class StreamReader(Codec):
       
>>>>>>     def __init__(self, stream, errors='strict'):
       
               """ Creates a StreamReader instance.
       
                   stream must be a file-like object open for reading
                   (binary) data.
       
                   The StreamReader may use different error handling
                   schemes by providing the errors keyword argument. These
                   parameters are predefined:
       
                    'strict' - raise a ValueError (or a subclass)
                    'ignore' - ignore the character and continue with the next
                    'replace'- replace with a suitable replacement character;
       
                   The set of allowed parameter values can be extended via
                   register_error.
               """
 8752:         self.stream = stream
 8752:         self.errors = errors
 8752:         self.bytebuffer = ""
               # For str->str decoding this will stay a str
               # For str->unicode decoding the first read will promote it to unicode
 8752:         self.charbuffer = ""
 8752:         self.linebuffer = None
       
>>>>>>     def decode(self, input, errors='strict'):
>>>>>>         raise NotImplementedError
       
>>>>>>     def read(self, size=-1, chars=-1, firstline=False):
       
               """ Decodes data from the stream self.stream and returns the
                   resulting object.
       
                   chars indicates the number of characters to read from the
                   stream. read() will never return more than chars
                   characters, but it might return less, if there are not enough
                   characters available.
       
                   size indicates the approximate maximum number of bytes to
                   read from the stream for decoding purposes. The decoder
                   can modify this setting as appropriate. The default value
                   -1 indicates to read and decode as much as possible.  size
                   is intended to prevent having to decode huge files in one
                   step.
       
                   If firstline is true, and a UnicodeDecodeError happens
                   after the first line terminator in the input only the first line
                   will be returned, the rest of the input will be kept until the
                   next call to read().
       
                   The method should use a greedy read strategy meaning that
                   it should read as much data as is allowed within the
                   definition of the encoding and the given size, e.g.  if
                   optional encoding endings or state markers are available
                   on the stream, these should be read too.
               """
               # If we have lines cached, first merge them back into characters
116549:         if self.linebuffer:
   18:             self.charbuffer = "".join(self.linebuffer)
   18:             self.linebuffer = None
       
               # read until we get the required number of characters (if available)
372878:         while True:
                   # can the request be satisfied from the character buffer?
372878:             if chars >= 0:
 5632:                 if len(self.charbuffer) >= chars:
  423:                     break
367246:             elif size >= 0:
363708:                 if len(self.charbuffer) >= size:
99848:                     break
                   # we need more data
272607:             if size < 0:
 3538:                 newdata = self.stream.read()
                   else:
269069:                 newdata = self.stream.read(size)
                   # decode bytes (those remaining from the last call included)
272607:             data = self.bytebuffer + newdata
272607:             try:
272607:                 newchars, decodedbytes = self.decode(data, self.errors)
    4:             except UnicodeDecodeError, exc:
    2:                 if firstline:
>>>>>>                     newchars, decodedbytes = self.decode(data[:exc.start], self.errors)
>>>>>>                     lines = newchars.splitlines(True)
>>>>>>                     if len(lines)<=1:
>>>>>>                         raise
                       else:
    2:                     raise
                   # keep undecoded bytes until the next call
272603:             self.bytebuffer = data[decodedbytes:]
                   # put new characters in the character buffer
272603:             self.charbuffer += newchars
                   # there was no data available
272603:             if not newdata:
16274:                 break
116545:         if chars < 0:
                   # Return everything we've got
116068:             result = self.charbuffer
116068:             self.charbuffer = ""
               else:
                   # Return the first chars characters
  477:             result = self.charbuffer[:chars]
  477:             self.charbuffer = self.charbuffer[chars:]
116545:         return result
       
>>>>>>     def readline(self, size=None, keepends=True):
       
               """ Read one line from the input stream and return the
                   decoded data.
       
                   size, if given, is passed as size argument to the
                   read() method.
       
               """
               # If we have lines cached from an earlier read, return
               # them unconditionally
140736:         if self.linebuffer:
72833:             line = self.linebuffer[0]
72833:             del self.linebuffer[0]
72833:             if len(self.linebuffer) == 1:
                       # revert to charbuffer mode; we might need more data
                       # next time
33119:                 self.charbuffer = self.linebuffer[0]
33119:                 self.linebuffer = None
72833:             if not keepends:
35954:                 line = line.splitlines(False)[0]
72833:             return line
       
67903:         readsize = size or 72
67903:         line = ""
               # If size is given, we call read() only once
70335:         while True:
70335:             data = self.read(readsize, firstline=True)
70335:             if data:
                       # If we're at a "\r" read one extra character (which might
                       # be a "\n") to get a proper line ending. If the stream is
                       # temporarily exhausted we return the wrong line ending.
69553:                 if data.endswith("\r"):
  459:                     data += self.read(size=1, chars=1)
       
70335:             line += data
70335:             lines = line.splitlines(True)
70335:             if lines:
69590:                 if len(lines) > 1:
                           # More than one line result; the first line is a full line
                           # to return
41499:                     line = lines[0]
41499:                     del lines[0]
41499:                     if len(lines) > 1:
                               # cache the remaining lines
33137:                         lines[-1] += self.charbuffer
33137:                         self.linebuffer = lines
33137:                         self.charbuffer = None
                           else:
                               # only one remaining line, put it back into charbuffer
 8362:                         self.charbuffer = lines[0] + self.charbuffer
41499:                     if not keepends:
18786:                         line = line.splitlines(False)[0]
41499:                     break
28091:                 line0withend = lines[0]
28091:                 line0withoutend = lines[0].splitlines(False)[0]
28091:                 if line0withend != line0withoutend: # We really have a line end
                           # Put the rest back together and keep it until the next call
 7130:                     self.charbuffer = "".join(lines[1:]) + self.charbuffer
 7130:                     if keepends:
 4135:                         line = line0withend
                           else:
 2995:                         line = line0withoutend
 7130:                     break
                   # we didn't get anything or this was our only try
21706:             if not data or size is not None:
19274:                 if line and not keepends:
   27:                     line = line.splitlines(False)[0]
19274:                 break
 2432:             if readsize<8000:
 2432:                 readsize *= 2
67903:         return line
       
>>>>>>     def readlines(self, sizehint=None, keepends=True):
       
               """ Read all lines available on the input stream
                   and return them as list of lines.
       
                   Line breaks are implemented using the codec's decoder
                   method and are included in the list entries.
       
                   sizehint, if given, is ignored since there is no efficient
                   way to finding the true end-of-line.
       
               """
 1311:         data = self.read()
 1311:         return data.splitlines(keepends)
       
>>>>>>     def reset(self):
       
               """ Resets the codec buffers used for keeping state.
       
                   Note that no stream repositioning should take place.
                   This method is primarily intended to be able to recover
                   from decoding errors.
       
               """
  413:         self.bytebuffer = ""
  413:         self.charbuffer = u""
  413:         self.linebuffer = None
       
>>>>>>     def seek(self, offset, whence=0):
               """ Set the input stream's current position.
       
                   Resets the codec buffers used for keeping state.
               """
  485:         self.stream.seek(offset, whence)
  485:         self.reset()
       
>>>>>>     def next(self):
       
               """ Return the next decoded line from the input stream."""
  558:         line = self.readline()
  558:         if line:
  549:             return line
    9:         raise StopIteration
       
>>>>>>     def __iter__(self):
    9:         return self
       
           def __getattr__(self, name,
>>>>>>                     getattr=getattr):
       
               """ Inherit all other methods from the underlying stream.
               """
>>>>>>         return getattr(self.stream, name)
       
>>>>>>     def __enter__(self):
>>>>>>         return self
       
>>>>>>     def __exit__(self, type, value, tb):
>>>>>>         self.stream.close()
       
       ###
       
>>>>>> class StreamReaderWriter:
       
           """ StreamReaderWriter instances allow wrapping streams which
               work in both read and write modes.
       
               The design is such that one can use the factory functions
               returned by the codec.lookup() function to construct the
               instance.
       
           """
           # Optional attributes set by the file wrappers below
>>>>>>     encoding = 'unknown'
       
>>>>>>     def __init__(self, stream, Reader, Writer, errors='strict'):
       
               """ Creates a StreamReaderWriter instance.
       
                   stream must be a Stream-like object.
       
                   Reader, Writer must be factory functions or classes
                   providing the StreamReader, StreamWriter interface resp.
       
                   Error handling is done in the same way as defined for the
                   StreamWriter/Readers.
       
               """
   80:         self.stream = stream
   80:         self.reader = Reader(stream, errors)
   80:         self.writer = Writer(stream, errors)
   80:         self.errors = errors
       
>>>>>>     def read(self, size=-1):
       
   75:         return self.reader.read(size)
       
>>>>>>     def readline(self, size=None):
       
>>>>>>         return self.reader.readline(size)
       
>>>>>>     def readlines(self, sizehint=None):
       
>>>>>>         return self.reader.readlines(sizehint)
       
>>>>>>     def next(self):
       
               """ Return the next decoded line from the input stream."""
>>>>>>         return self.reader.next()
       
>>>>>>     def __iter__(self):
>>>>>>         return self
       
>>>>>>     def write(self, data):
       
   47:         return self.writer.write(data)
       
>>>>>>     def writelines(self, list):
       
>>>>>>         return self.writer.writelines(list)
       
>>>>>>     def reset(self):
       
>>>>>>         self.reader.reset()
>>>>>>         self.writer.reset()
       
>>>>>>     def seek(self, offset, whence=0):
   48:         self.stream.seek(offset, whence)
   48:         self.reader.reset()
   48:         if whence == 0 and offset == 0:
   42:             self.writer.reset()
       
           def __getattr__(self, name,
>>>>>>                     getattr=getattr):
       
               """ Inherit all other methods from the underlying stream.
               """
   24:         return getattr(self.stream, name)
       
           # these are needed to make "with codecs.open(...)" work properly
       
>>>>>>     def __enter__(self):
   68:         return self
       
>>>>>>     def __exit__(self, type, value, tb):
   68:         self.stream.close()
       
       ###
       
>>>>>> class StreamRecoder:
       
           """ StreamRecoder instances provide a frontend - backend
               view of encoding data.
       
               They use the complete set of APIs returned by the
               codecs.lookup() function to implement their task.
       
               Data written to the stream is first decoded into an
               intermediate format (which is dependent on the given codec
               combination) and then written to the stream using an instance
               of the provided Writer class.
       
               In the other direction, data is read from the stream using a
               Reader instance and then return encoded data to the caller.
       
           """
           # Optional attributes set by the file wrappers below
>>>>>>     data_encoding = 'unknown'
>>>>>>     file_encoding = 'unknown'
       
           def __init__(self, stream, encode, decode, Reader, Writer,
>>>>>>                  errors='strict'):
       
               """ Creates a StreamRecoder instance which implements a two-way
                   conversion: encode and decode work on the frontend (the
                   input to .read() and output of .write()) while
                   Reader and Writer work on the backend (reading and
                   writing to the stream).
       
                   You can use these objects to do transparent direct
                   recodings from e.g. latin-1 to utf-8 and back.
       
                   stream must be a file-like object.
       
                   encode, decode must adhere to the Codec interface, Reader,
                   Writer must be factory functions or classes providing the
                   StreamReader, StreamWriter interface resp.
       
                   encode and decode are needed for the frontend translation,
                   Reader and Writer for the backend translation. Unicode is
                   used as intermediate encoding.
       
                   Error handling is done in the same way as defined for the
                   StreamWriter/Readers.
       
               """
    4:         self.stream = stream
    4:         self.encode = encode
    4:         self.decode = decode
    4:         self.reader = Reader(stream, errors)
    4:         self.writer = Writer(stream, errors)
    4:         self.errors = errors
       
>>>>>>     def read(self, size=-1):
       
    2:         data = self.reader.read(size)
    2:         data, bytesencoded = self.encode(data, self.errors)
    2:         return data
       
>>>>>>     def readline(self, size=None):
       
>>>>>>         if size is None:
>>>>>>             data = self.reader.readline()
               else:
>>>>>>             data = self.reader.readline(size)
>>>>>>         data, bytesencoded = self.encode(data, self.errors)
>>>>>>         return data
       
>>>>>>     def readlines(self, sizehint=None):
       
>>>>>>         data = self.reader.read()
>>>>>>         data, bytesencoded = self.encode(data, self.errors)
>>>>>>         return data.splitlines(1)
       
>>>>>>     def next(self):
       
               """ Return the next decoded line from the input stream."""
>>>>>>         data = self.reader.next()
>>>>>>         data, bytesencoded = self.encode(data, self.errors)
>>>>>>         return data
       
>>>>>>     def __iter__(self):
>>>>>>         return self
       
>>>>>>     def write(self, data):
       
    2:         data, bytesdecoded = self.decode(data, self.errors)
    2:         return self.writer.write(data)
       
>>>>>>     def writelines(self, list):
       
>>>>>>         data = ''.join(list)
>>>>>>         data, bytesdecoded = self.decode(data, self.errors)
>>>>>>         return self.writer.write(data)
       
>>>>>>     def reset(self):
       
>>>>>>         self.reader.reset()
>>>>>>         self.writer.reset()
       
           def __getattr__(self, name,
>>>>>>                     getattr=getattr):
       
               """ Inherit all other methods from the underlying stream.
               """
    1:         return getattr(self.stream, name)
       
>>>>>>     def __enter__(self):
    1:         return self
       
>>>>>>     def __exit__(self, type, value, tb):
    1:         self.stream.close()
       
       ### Shortcuts
       
>>>>>> def open(filename, mode='rb', encoding=None, errors='strict', buffering=1):
       
           """ Open an encoded file using the given mode and return
               a wrapped version providing transparent encoding/decoding.
       
               Note: The wrapped version will only accept the object format
               defined by the codecs, i.e. Unicode objects for most builtin
               codecs. Output is also codec dependent and will usually be
               Unicode as well.
       
               Files are always opened in binary mode, even if no binary mode
               was specified. This is done to avoid data loss due to encodings
               using 8-bit values. The default file mode is 'rb' meaning to
               open the file in binary read mode.
       
               encoding specifies the encoding which is to be used for the
               file.
       
               errors may be given to define the error handling. It defaults
               to 'strict' which causes ValueErrors to be raised in case an
               encoding error occurs.
       
               buffering has the same meaning as for the builtin open() API.
               It defaults to line buffered.
       
               The returned wrapped file object provides an extra attribute
               .encoding which allows querying the used encoding. This
               attribute is only available if an encoding was specified as
               parameter.
       
           """
   82:     if encoding is not None:
   79:         if 'U' in mode:
                   # No automatic conversion of '\n' is done on reading and writing
    1:             mode = mode.strip().replace('U', '')
    1:             if mode[:1] not in set('rwa'):
    1:                 mode = 'r' + mode
   79:         if 'b' not in mode:
                   # Force opening of the file in binary mode
   78:             mode = mode + 'b'
   82:     file = __builtin__.open(filename, mode, buffering)
   82:     if encoding is None:
    3:         return file
   79:     info = lookup(encoding)
   79:     srw = StreamReaderWriter(file, info.streamreader, info.streamwriter, errors)
           # Add attributes to simplify introspection
   79:     srw.encoding = encoding
   79:     return srw
       
>>>>>> def EncodedFile(file, data_encoding, file_encoding=None, errors='strict'):
       
           """ Return a wrapped version of file which provides transparent
               encoding translation.
       
               Strings written to the wrapped file are interpreted according
               to the given data_encoding and then written to the original
               file as string using file_encoding. The intermediate encoding
               will usually be Unicode but depends on the specified codecs.
       
               Strings are read from the file using file_encoding and then
               passed back to the caller as string using data_encoding.
       
               If file_encoding is not given, it defaults to data_encoding.
       
               errors may be given to define the error handling. It defaults
               to 'strict' which causes ValueErrors to be raised in case an
               encoding error occurs.
       
               The returned wrapped file object provides two extra attributes
               .data_encoding and .file_encoding which reflect the given
               parameters of the same name. The attributes can be used for
               introspection by Python programs.
       
           """
    4:     if file_encoding is None:
>>>>>>         file_encoding = data_encoding
    4:     data_info = lookup(data_encoding)
    4:     file_info = lookup(file_encoding)
    4:     sr = StreamRecoder(file, data_info.encode, data_info.decode,
    4:                        file_info.streamreader, file_info.streamwriter, errors)
           # Add attributes to simplify introspection
    4:     sr.data_encoding = data_encoding
    4:     sr.file_encoding = file_encoding
    4:     return sr
       
       ### Helpers for codec lookup
       
>>>>>> def getencoder(encoding):
       
           """ Lookup up the codec for the given encoding and return
               its encoder function.
       
               Raises a LookupError in case the encoding cannot be found.
       
           """
  214:     return lookup(encoding).encode
       
>>>>>> def getdecoder(encoding):
       
           """ Lookup up the codec for the given encoding and return
               its decoder function.
       
               Raises a LookupError in case the encoding cannot be found.
       
           """
  213:     return lookup(encoding).decode
       
>>>>>> def getincrementalencoder(encoding):
       
           """ Lookup up the codec for the given encoding and return
               its IncrementalEncoder class or factory function.
       
               Raises a LookupError in case the encoding cannot be found
               or the codecs doesn't provide an incremental encoder.
       
           """
 2269:     encoder = lookup(encoding).incrementalencoder
 2269:     if encoder is None:
 1644:         raise LookupError(encoding)
  625:     return encoder
       
>>>>>> def getincrementaldecoder(encoding):
       
           """ Lookup up the codec for the given encoding and return
               its IncrementalDecoder class or factory function.
       
               Raises a LookupError in case the encoding cannot be found
               or the codecs doesn't provide an incremental decoder.
       
           """
 2978:     decoder = lookup(encoding).incrementaldecoder
 2978:     if decoder is None:
>>>>>>         raise LookupError(encoding)
 2978:     return decoder
       
>>>>>> def getreader(encoding):
       
           """ Lookup up the codec for the given encoding and return
               its StreamReader class or factory function.
       
               Raises a LookupError in case the encoding cannot be found.
       
           """
 6135:     return lookup(encoding).streamreader
       
>>>>>> def getwriter(encoding):
       
           """ Lookup up the codec for the given encoding and return
               its StreamWriter class or factory function.
       
               Raises a LookupError in case the encoding cannot be found.
       
           """
  148:     return lookup(encoding).streamwriter
       
>>>>>> def iterencode(iterator, encoding, errors='strict', **kwargs):
           """
           Encoding iterator.
       
           Encodes the input strings from the iterator using an IncrementalEncoder.
       
           errors and kwargs are passed through to the IncrementalEncoder
           constructor.
           """
  204:     encoder = getincrementalencoder(encoding)(errors, **kwargs)
  847:     for input in iterator:
  643:         output = encoder.encode(input)
  643:         if output:
  590:             yield output
  204:     output = encoder.encode("", True)
  204:     if output:
    7:         yield output
       
>>>>>> def iterdecode(iterator, encoding, errors='strict', **kwargs):
           """
           Decoding iterator.
       
           Decodes the input strings from the iterator using an IncrementalDecoder.
       
           errors and kwargs are passed through to the IncrementalDecoder
           constructor.
           """
  213:     decoder = getincrementaldecoder(encoding)(errors, **kwargs)
 1002:     for input in iterator:
  789:         output = decoder.decode(input)
  789:         if output:
  638:             yield output
  213:     output = decoder.decode("", True)
  213:     if output:
    2:         yield output
       
       ### Helpers for charmap-based codecs
       
>>>>>> def make_identity_dict(rng):
       
           """ make_identity_dict(rng) -> dict
       
               Return a dictionary where elements of the rng sequence are
               mapped to themselves.
       
           """
   22:     res = {}
 5654:     for i in rng:
 5632:         res[i]=i
   22:     return res
       
>>>>>> def make_encoding_map(decoding_map):
       
           """ Creates an encoding map from a decoding map.
       
               If a target mapping in the decoding map occurs multiple
               times, then that target is mapped to None (undefined mapping),
               causing an exception when encountered by the charmap codec
               during translation.
       
               One example where this happens is cp875.py which decodes
               multiple character to \\u001a.
       
           """
    5:     m = {}
 1285:     for k,v in decoding_map.items():
 1280:         if not v in m:
 1280:             m[v] = k
               else:
>>>>>>             m[v] = None
    5:     return m
       
       ### error handlers
       
>>>>>> try:
>>>>>>     strict_errors = lookup_error("strict")
>>>>>>     ignore_errors = lookup_error("ignore")
>>>>>>     replace_errors = lookup_error("replace")
>>>>>>     xmlcharrefreplace_errors = lookup_error("xmlcharrefreplace")
>>>>>>     backslashreplace_errors = lookup_error("backslashreplace")
>>>>>> except LookupError:
           # In --disable-unicode builds, these error handler are missing
>>>>>>     strict_errors = None
>>>>>>     ignore_errors = None
>>>>>>     replace_errors = None
>>>>>>     xmlcharrefreplace_errors = None
>>>>>>     backslashreplace_errors = None
       
       # Tell modulefinder that using codecs probably needs the encodings
       # package
>>>>>> _false = 0
>>>>>> if _false:
>>>>>>     import encodings
       
       ### Tests
       
>>>>>> if __name__ == '__main__':
       
           # Make stdout translate Latin-1 output into UTF-8 output
>>>>>>     sys.stdout = EncodedFile(sys.stdout, 'latin-1', 'utf-8')
       
           # Have stdin translate Latin-1 input into UTF-8 input
>>>>>>     sys.stdin = EncodedFile(sys.stdin, 'utf-8', 'latin-1')
