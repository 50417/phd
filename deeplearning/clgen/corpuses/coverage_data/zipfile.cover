       """
       Read and write ZIP files.
    1: """
    1: import struct, os, time, sys, shutil
    1: import binascii, cStringIO, stat
    1: import io
    1: import re
    1: import string
       
    1: try:
    1:     import zlib # We may need its compression method
    1:     crc32 = zlib.crc32
>>>>>> except ImportError:
>>>>>>     zlib = None
>>>>>>     crc32 = binascii.crc32
       
    1: __all__ = ["BadZipfile", "error", "ZIP_STORED", "ZIP_DEFLATED", "is_zipfile",
    1:            "ZipInfo", "ZipFile", "PyZipFile", "LargeZipFile" ]
       
    2: class BadZipfile(Exception):
    1:     pass
       
       
    2: class LargeZipFile(Exception):
           """
           Raised when writing a zipfile, the zipfile requires ZIP64 extensions
           and those extensions are disabled.
    1:     """
       
    1: error = BadZipfile      # The exception raised by this module
       
    1: ZIP64_LIMIT = (1 << 31) - 1
    1: ZIP_FILECOUNT_LIMIT = (1 << 16) - 1
    1: ZIP_MAX_COMMENT = (1 << 16) - 1
       
       # constants for Zip file compression methods
    1: ZIP_STORED = 0
    1: ZIP_DEFLATED = 8
       # Other ZIP compression methods not supported
       
       # Below are some formats and associated data for reading/writing headers using
       # the struct module.  The names and structures of headers/records are those used
       # in the PKWARE description of the ZIP file format:
       #     http://www.pkware.com/documents/casestudies/APPNOTE.TXT
       # (URL valid as of January 2008)
       
       # The "end of central directory" structure, magic number, size, and indices
       # (section V.I in the format document)
    1: structEndArchive = "<4s4H2LH"
    1: stringEndArchive = "PK\005\006"
    1: sizeEndCentDir = struct.calcsize(structEndArchive)
       
    1: _ECD_SIGNATURE = 0
    1: _ECD_DISK_NUMBER = 1
    1: _ECD_DISK_START = 2
    1: _ECD_ENTRIES_THIS_DISK = 3
    1: _ECD_ENTRIES_TOTAL = 4
    1: _ECD_SIZE = 5
    1: _ECD_OFFSET = 6
    1: _ECD_COMMENT_SIZE = 7
       # These last two indices are not part of the structure as defined in the
       # spec, but they are used internally by this module as a convenience
    1: _ECD_COMMENT = 8
    1: _ECD_LOCATION = 9
       
       # The "central directory" structure, magic number, size, and indices
       # of entries in the structure (section V.F in the format document)
    1: structCentralDir = "<4s4B4HL2L5H2L"
    1: stringCentralDir = "PK\001\002"
    1: sizeCentralDir = struct.calcsize(structCentralDir)
       
       # indexes of entries in the central directory structure
    1: _CD_SIGNATURE = 0
    1: _CD_CREATE_VERSION = 1
    1: _CD_CREATE_SYSTEM = 2
    1: _CD_EXTRACT_VERSION = 3
    1: _CD_EXTRACT_SYSTEM = 4
    1: _CD_FLAG_BITS = 5
    1: _CD_COMPRESS_TYPE = 6
    1: _CD_TIME = 7
    1: _CD_DATE = 8
    1: _CD_CRC = 9
    1: _CD_COMPRESSED_SIZE = 10
    1: _CD_UNCOMPRESSED_SIZE = 11
    1: _CD_FILENAME_LENGTH = 12
    1: _CD_EXTRA_FIELD_LENGTH = 13
    1: _CD_COMMENT_LENGTH = 14
    1: _CD_DISK_NUMBER_START = 15
    1: _CD_INTERNAL_FILE_ATTRIBUTES = 16
    1: _CD_EXTERNAL_FILE_ATTRIBUTES = 17
    1: _CD_LOCAL_HEADER_OFFSET = 18
       
       # The "local file header" structure, magic number, size, and indices
       # (section V.A in the format document)
    1: structFileHeader = "<4s2B4HL2L2H"
    1: stringFileHeader = "PK\003\004"
    1: sizeFileHeader = struct.calcsize(structFileHeader)
       
    1: _FH_SIGNATURE = 0
    1: _FH_EXTRACT_VERSION = 1
    1: _FH_EXTRACT_SYSTEM = 2
    1: _FH_GENERAL_PURPOSE_FLAG_BITS = 3
    1: _FH_COMPRESSION_METHOD = 4
    1: _FH_LAST_MOD_TIME = 5
    1: _FH_LAST_MOD_DATE = 6
    1: _FH_CRC = 7
    1: _FH_COMPRESSED_SIZE = 8
    1: _FH_UNCOMPRESSED_SIZE = 9
    1: _FH_FILENAME_LENGTH = 10
    1: _FH_EXTRA_FIELD_LENGTH = 11
       
       # The "Zip64 end of central directory locator" structure, magic number, and size
    1: structEndArchive64Locator = "<4sLQL"
    1: stringEndArchive64Locator = "PK\x06\x07"
    1: sizeEndCentDir64Locator = struct.calcsize(structEndArchive64Locator)
       
       # The "Zip64 end of central directory" record, magic number, size, and indices
       # (section V.G in the format document)
    1: structEndArchive64 = "<4sQ2H2L4Q"
    1: stringEndArchive64 = "PK\x06\x06"
    1: sizeEndCentDir64 = struct.calcsize(structEndArchive64)
       
    1: _CD64_SIGNATURE = 0
    1: _CD64_DIRECTORY_RECSIZE = 1
    1: _CD64_CREATE_VERSION = 2
    1: _CD64_EXTRACT_VERSION = 3
    1: _CD64_DISK_NUMBER = 4
    1: _CD64_DISK_NUMBER_START = 5
    1: _CD64_NUMBER_ENTRIES_THIS_DISK = 6
    1: _CD64_NUMBER_ENTRIES_TOTAL = 7
    1: _CD64_DIRECTORY_SIZE = 8
    1: _CD64_OFFSET_START_CENTDIR = 9
       
    1: def _check_zipfile(fp):
   10:     try:
   10:         if _EndRecData(fp):
    6:             return True         # file has correct magic number
>>>>>>     except IOError:
>>>>>>         pass
    4:     return False
       
    1: def is_zipfile(filename):
           """Quickly see if a file is a ZIP file by checking the magic number.
       
           The filename argument may be a file or file-like object too.
           """
   10:     result = False
   10:     try:
   10:         if hasattr(filename, "read"):
    6:             result = _check_zipfile(fp=filename)
               else:
    4:             with open(filename, "rb") as fp:
    4:                 result = _check_zipfile(fp)
>>>>>>     except IOError:
>>>>>>         pass
   10:     return result
       
    1: def _EndRecData64(fpin, offset, endrec):
           """
           Read the ZIP64 end-of-archive records and use that to update endrec
           """
  223:     try:
  223:         fpin.seek(offset - sizeEndCentDir64Locator, 2)
    4:     except IOError:
               # If the seek fails, the file is not large enough to contain a ZIP64
               # end-of-archive record, so just return the end record we were given.
    4:         return endrec
       
  219:     data = fpin.read(sizeEndCentDir64Locator)
  219:     if len(data) != sizeEndCentDir64Locator:
>>>>>>         return endrec
  219:     sig, diskno, reloff, disks = struct.unpack(structEndArchive64Locator, data)
  219:     if sig != stringEndArchive64Locator:
  210:         return endrec
       
    9:     if diskno != 0 or disks != 1:
>>>>>>         raise BadZipfile("zipfiles that span multiple disks are not supported")
       
           # Assume no 'zip64 extensible data'
    9:     fpin.seek(offset - sizeEndCentDir64Locator - sizeEndCentDir64, 2)
    9:     data = fpin.read(sizeEndCentDir64)
    9:     if len(data) != sizeEndCentDir64:
>>>>>>         return endrec
           sig, sz, create_version, read_version, disk_num, disk_dir, \
                   dircount, dircount2, dirsize, diroffset = \
    9:             struct.unpack(structEndArchive64, data)
    9:     if sig != stringEndArchive64:
>>>>>>         return endrec
       
           # Update the original endrec using data from the ZIP64 record
    9:     endrec[_ECD_SIGNATURE] = sig
    9:     endrec[_ECD_DISK_NUMBER] = disk_num
    9:     endrec[_ECD_DISK_START] = disk_dir
    9:     endrec[_ECD_ENTRIES_THIS_DISK] = dircount
    9:     endrec[_ECD_ENTRIES_TOTAL] = dircount2
    9:     endrec[_ECD_SIZE] = dirsize
    9:     endrec[_ECD_OFFSET] = diroffset
    9:     return endrec
       
       
    1: def _EndRecData(fpin):
           """Return data from the "End of Central Directory" record, or None.
       
           The data is a list of the nine items in the ZIP "End of central dir"
           record followed by a tenth item, the file seek offset of this record."""
       
           # Determine file size
  366:     fpin.seek(0, 2)
  366:     filesize = fpin.tell()
       
           # Check to see if this is ZIP file with no archive comment (the
           # "end of central directory" structure should be the last item in the
           # file if this is the case).
  366:     try:
  366:         fpin.seek(-sizeEndCentDir, 2)
    3:     except IOError:
    3:         return None
  363:     data = fpin.read()
  363:     if (len(data) == sizeEndCentDir and
  341:         data[0:4] == stringEndArchive and
  216:         data[-2:] == b"\000\000"):
               # the signature is correct and there's no comment, unpack structure
  216:         endrec = struct.unpack(structEndArchive, data)
  216:         endrec=list(endrec)
       
               # Append a blank comment and record start offset
  216:         endrec.append("")
  216:         endrec.append(filesize - sizeEndCentDir)
       
               # Try to read the "Zip64 end of central directory" structure
  216:         return _EndRecData64(fpin, -sizeEndCentDir, endrec)
       
           # Either this is not a ZIP file, or it is a ZIP file with an archive
           # comment.  Search the end of the file for the "end of central directory"
           # record signature. The comment is the last item in the ZIP file and may be
           # up to 64K long.  It is assumed that the "end of central directory" magic
           # number does not appear in the comment.
  147:     maxCommentStart = max(filesize - (1 << 16) - sizeEndCentDir, 0)
  147:     fpin.seek(maxCommentStart, 0)
  147:     data = fpin.read()
  147:     start = data.rfind(stringEndArchive)
  147:     if start >= 0:
               # found the magic number; attempt to unpack and interpret
   25:         recData = data[start:start+sizeEndCentDir]
   25:         if len(recData) != sizeEndCentDir:
                   # Zip file is corrupted.
   18:             return None
    7:         endrec = list(struct.unpack(structEndArchive, recData))
    7:         commentSize = endrec[_ECD_COMMENT_SIZE] #as claimed by the zip file
    7:         comment = data[start+sizeEndCentDir:start+sizeEndCentDir+commentSize]
    7:         endrec.append(comment)
    7:         endrec.append(maxCommentStart + start)
       
               # Try to read the "Zip64 end of central directory" structure
    7:         return _EndRecData64(fpin, maxCommentStart + start - filesize,
    7:                              endrec)
       
           # Unable to find a valid end of central directory structure
  122:     return None
       
       
    2: class ZipInfo (object):
    1:     """Class with attributes describing each file in the ZIP archive."""
       
           __slots__ = (
                   'orig_filename',
                   'filename',
                   'date_time',
                   'compress_type',
                   'comment',
                   'extra',
                   'create_system',
                   'create_version',
                   'extract_version',
                   'reserved',
                   'flag_bits',
                   'volume',
                   'internal_attr',
                   'external_attr',
                   'header_offset',
                   'CRC',
                   'compress_size',
                   'file_size',
    1:             '_raw_time',
               )
       
    1:     def __init__(self, filename="NoName", date_time=(1980,1,1,0,0,0)):
 1099:         self.orig_filename = filename   # Original file name in archive
       
               # Terminate the file name at the first null byte.  Null bytes in file
               # names are used as tricks by viruses in archives.
 1099:         null_byte = filename.find(chr(0))
 1099:         if null_byte >= 0:
    1:             filename = filename[0:null_byte]
               # This is used to ensure paths in generated ZIP files always use
               # forward slashes as the directory separator, as required by the
               # ZIP format specification.
 1099:         if os.sep != "/" and os.sep in filename:
>>>>>>             filename = filename.replace(os.sep, "/")
       
 1099:         self.filename = filename        # Normalized file name
 1099:         self.date_time = date_time      # year, month, day, hour, min, sec
       
 1099:         if date_time[0] < 1980:
    2:             raise ValueError('ZIP does not support timestamps before 1980')
       
               # Standard values:
 1097:         self.compress_type = ZIP_STORED # Type of compression for the file
 1097:         self.comment = ""               # Comment for each file
 1097:         self.extra = ""                 # ZIP extra data
 1097:         if sys.platform == 'win32':
>>>>>>             self.create_system = 0          # System which created ZIP archive
               else:
                   # Assume everything else is unix-y
 1097:             self.create_system = 3          # System which created ZIP archive
 1097:         self.create_version = 20        # Version which created ZIP archive
 1097:         self.extract_version = 20       # Version needed to extract archive
 1097:         self.reserved = 0               # Must be zero
 1097:         self.flag_bits = 0              # ZIP flag bits
 1097:         self.volume = 0                 # Volume number of file header
 1097:         self.internal_attr = 0          # Internal attributes
 1097:         self.external_attr = 0          # External file attributes
               # Other attributes are set by class ZipFile:
               # header_offset         Byte offset to the file header
               # CRC                   CRC-32 of the uncompressed file
               # compress_size         Size of the compressed file
               # file_size             Size of the uncompressed file
       
    1:     def FileHeader(self, zip64=None):
               """Return the per-file header as a string."""
  908:         dt = self.date_time
  908:         dosdate = (dt[0] - 1980) << 9 | dt[1] << 5 | dt[2]
  908:         dostime = dt[3] << 11 | dt[4] << 5 | (dt[5] // 2)
  908:         if self.flag_bits & 0x08:
                   # Set these to zero because we write them after the file data
>>>>>>             CRC = compress_size = file_size = 0
               else:
  908:             CRC = self.CRC
  908:             compress_size = self.compress_size
  908:             file_size = self.file_size
       
  908:         extra = self.extra
       
  908:         if zip64 is None:
>>>>>>             zip64 = file_size > ZIP64_LIMIT or compress_size > ZIP64_LIMIT
  908:         if zip64:
   32:             fmt = '<HHQQ'
   32:             extra = extra + struct.pack(fmt,
   32:                     1, struct.calcsize(fmt)-4, file_size, compress_size)
  908:         if file_size > ZIP64_LIMIT or compress_size > ZIP64_LIMIT:
   32:             if not zip64:
>>>>>>                 raise LargeZipFile("Filesize would require ZIP64 extensions")
                   # File is larger than what fits into a 4 byte integer,
                   # fall back to the ZIP64 extension
   32:             file_size = 0xffffffff
   32:             compress_size = 0xffffffff
   32:             self.extract_version = max(45, self.extract_version)
   32:             self.create_version = max(45, self.extract_version)
       
  908:         filename, flag_bits = self._encodeFilenameFlags()
  908:         header = struct.pack(structFileHeader, stringFileHeader,
  908:                  self.extract_version, self.reserved, flag_bits,
  908:                  self.compress_type, dostime, dosdate, CRC,
  908:                  compress_size, file_size,
  908:                  len(filename), len(extra))
  908:         return header + filename + extra
       
    1:     def _encodeFilenameFlags(self):
 1500:         if isinstance(self.filename, unicode):
    8:             try:
    8:                 return self.filename.encode('ascii'), self.flag_bits
    4:             except UnicodeEncodeError:
    4:                 return self.filename.encode('utf-8'), self.flag_bits | 0x800
               else:
 1492:             return self.filename, self.flag_bits
       
    1:     def _decodeFilename(self):
  508:         if self.flag_bits & 0x800:
    2:             return self.filename.decode('utf-8')
               else:
  506:             return self.filename
       
    1:     def _decodeExtra(self):
               # Try to decode the extra field.
  508:         extra = self.extra
  508:         unpack = struct.unpack
  569:         while len(extra) >= 4:
   61:             tp, ln = unpack('<HH', extra[:4])
   61:             if tp == 1:
   19:                 if ln >= 24:
   12:                     counts = unpack('<QQQ', extra[4:28])
    7:                 elif ln == 16:
    7:                     counts = unpack('<QQ', extra[4:20])
>>>>>>                 elif ln == 8:
>>>>>>                     counts = unpack('<Q', extra[4:12])
>>>>>>                 elif ln == 0:
>>>>>>                     counts = ()
                       else:
>>>>>>                     raise RuntimeError, "Corrupt extra field %s"%(ln,)
       
   19:                 idx = 0
       
                       # ZIP64 extension (large files and/or large archives)
   19:                 if self.file_size in (0xffffffffffffffffL, 0xffffffffL):
   19:                     self.file_size = counts[idx]
   19:                     idx += 1
       
   19:                 if self.compress_size == 0xFFFFFFFFL:
   19:                     self.compress_size = counts[idx]
   19:                     idx += 1
       
   19:                 if self.header_offset == 0xffffffffL:
   12:                     old = self.header_offset
   12:                     self.header_offset = counts[idx]
   12:                     idx+=1
       
   61:             extra = extra[ln+4:]
       
       
    2: class _ZipDecrypter:
           """Class to handle decryption of files stored within a ZIP archive.
       
           ZIP supports a password-based form of encryption. Even though known
           plaintext attacks have been found against it, it is still useful
           to be able to get data out of such a file.
       
           Usage:
               zd = _ZipDecrypter(mypwd)
               plain_char = zd(cypher_char)
               plain_text = map(zd, cypher_text)
    1:     """
       
    1:     def _GenerateCRCTable():
               """Generate a CRC-32 table.
       
               ZIP encryption uses the CRC32 one-byte primitive for scrambling some
               internal keys. We noticed that a direct implementation is faster than
               relying on binascii.crc32().
               """
    1:         poly = 0xedb88320
    1:         table = [0] * 256
  257:         for i in range(256):
  256:             crc = i
 2304:             for j in range(8):
 2048:                 if crc & 1:
 1024:                     crc = ((crc >> 1) & 0x7FFFFFFF) ^ poly
                       else:
 1024:                     crc = ((crc >> 1) & 0x7FFFFFFF)
  256:             table[i] = crc
    1:         return table
    1:     crctable = _GenerateCRCTable()
       
    1:     def _crc32(self, ch, crc):
               """Compute the CRC32 primitive on one byte."""
  202:         return ((crc >> 8) & 0xffffff) ^ self.crctable[(crc ^ ord(ch)) & 0xff]
       
    1:     def __init__(self, pwd):
    4:         self.key0 = 305419896
    4:         self.key1 = 591751049
    4:         self.key2 = 878082192
   23:         for p in pwd:
   19:             self._UpdateKeys(p)
       
    1:     def _UpdateKeys(self, c):
  101:         self.key0 = self._crc32(c, self.key0)
  101:         self.key1 = (self.key1 + (self.key0 & 255)) & 4294967295
  101:         self.key1 = (self.key1 * 134775813 + 1) & 4294967295
  101:         self.key2 = self._crc32(chr((self.key1 >> 24) & 255), self.key2)
       
    1:     def __call__(self, c):
               """Decrypt a single character."""
   82:         c = ord(c)
   82:         k = self.key2 | 2
   82:         c = c ^ (((k * (k^1)) >> 8) & 255)
   82:         c = chr(c)
   82:         self._UpdateKeys(c)
   82:         return c
       
       
    1: compressor_names = {
    1:     0: 'store',
    1:     1: 'shrink',
    1:     2: 'reduce',
    1:     3: 'reduce',
    1:     4: 'reduce',
    1:     5: 'reduce',
    1:     6: 'implode',
    1:     7: 'tokenize',
    1:     8: 'deflate',
    1:     9: 'deflate64',
    1:     10: 'implode',
    1:     12: 'bzip2',
    1:     14: 'lzma',
    1:     18: 'terse',
    1:     19: 'lz77',
    1:     97: 'wavpack',
    1:     98: 'ppmd',
       }
       
       
    2: class ZipExtFile(io.BufferedIOBase):
           """File-like object for reading an archive member.
              Is returned by ZipFile.open().
    1:     """
       
           # Max size supported by decompressor.
    1:     MAX_N = 1 << 31 - 1
       
           # Read from compressed files in 4k blocks.
    1:     MIN_READ_SIZE = 4096
       
           # Search for universal newlines or line chunks.
    1:     PATTERN = re.compile(r'^(?P<chunk>[^\r\n]+)|(?P<newline>\n|\r\n?)')
       
    1:     def __init__(self, fileobj, mode, zipinfo, decrypter=None,
    1:             close_fileobj=False):
  574:         self._fileobj = fileobj
  574:         self._decrypter = decrypter
  574:         self._close_fileobj = close_fileobj
       
  574:         self._compress_type = zipinfo.compress_type
  574:         self._compress_size = zipinfo.compress_size
  574:         self._compress_left = zipinfo.compress_size
       
  574:         if self._compress_type == ZIP_DEFLATED:
  344:             self._decompressor = zlib.decompressobj(-15)
  230:         elif self._compress_type != ZIP_STORED:
    1:             descr = compressor_names.get(self._compress_type)
    1:             if descr:
    1:                 raise NotImplementedError("compression type %d (%s)" % (self._compress_type, descr))
                   else:
>>>>>>                 raise NotImplementedError("compression type %d" % (self._compress_type,))
  573:         self._unconsumed = ''
       
  573:         self._readbuffer = ''
  573:         self._offset = 0
       
  573:         self._universal = 'U' in mode
  573:         self.newlines = None
       
               # Adjust read size for encrypted files since the first 12 bytes
               # are for the encryption/password information.
  573:         if self._decrypter is not None:
    2:             self._compress_left -= 12
       
  573:         self.mode = mode
  573:         self.name = zipinfo.filename
       
  573:         if hasattr(zipinfo, 'CRC'):
  573:             self._expected_crc = zipinfo.CRC
  573:             self._running_crc = crc32(b'') & 0xffffffff
               else:
>>>>>>             self._expected_crc = None
       
    1:     def readline(self, limit=-1):
               """Read and return a line from the stream.
       
               If limit is specified, at most limit bytes will be read.
               """
       
108413:         if not self._universal and limit < 0:
                   # Shortcut common case - newline found in buffer.
20010:             i = self._readbuffer.find('\n', self._offset) + 1
20010:             if i > 0:
19758:                 line = self._readbuffer[self._offset: i]
19758:                 self._offset = i
19758:                 return line
       
88655:         if not self._universal:
  252:             return io.BufferedIOBase.readline(self, limit)
       
88403:         line = ''
177213:         while limit < 0 or len(line) < limit:
177213:             readahead = self.peek(2)
177213:             if readahead == '':
   19:                 return line
       
                   #
                   # Search for universal newlines or line chunks.
                   #
                   # The pattern returns either a line chunk or a newline, but not
                   # both. Combined with peek(2), we are assured that the sequence
                   # '\r\n' is always retrieved completely and never split into
                   # separate newlines - '\r', '\n' due to coincidental readaheads.
                   #
177194:             match = self.PATTERN.search(readahead)
177194:             newline = match.group('newline')
177194:             if newline is not None:
88384:                 if self.newlines is None:
   73:                     self.newlines = []
88384:                 if newline not in self.newlines:
   73:                     self.newlines.append(newline)
88384:                 self._offset += len(newline)
88384:                 return line + '\n'
       
88810:             chunk = match.group('chunk')
88810:             if limit >= 0:
>>>>>>                 chunk = chunk[: limit - len(line)]
       
88810:             self._offset += len(chunk)
88810:             line += chunk
       
>>>>>>         return line
       
    1:     def peek(self, n=1):
               """Returns buffered bytes without advancing the position."""
177681:         if n > len(self._readbuffer) - self._offset:
  835:             chunk = self.read(n)
  835:             if len(chunk) > self._offset:
>>>>>>                 self._readbuffer = chunk + self._readbuffer[self._offset:]
>>>>>>                 self._offset = 0
                   else:
  835:                 self._offset -= len(chunk)
       
               # Return up to 512 bytes to reduce allocation overhead for tight loops.
177681:         return self._readbuffer[self._offset: self._offset + 512]
       
    1:     def readable(self):
>>>>>>         return True
       
    1:     def read(self, n=-1):
               """Read and return up to n bytes.
               If the argument is omitted, None, or negative, data is read and returned until EOF is reached..
               """
37581:         buf = ''
37581:         if n is None:
>>>>>>             n = -1
73974:         while True:
73974:             if n < 0:
  455:                 data = self.read1(n)
73519:             elif n > len(buf):
36531:                 data = self.read1(n - len(buf))
                   else:
36988:                 return buf
36978:             if len(data) == 0:
  585:                 return buf
36393:             buf += data
       
    1:     def _update_crc(self, newdata, eof):
               # Update the CRC using the given data.
 2640:         if self._expected_crc is None:
                   # No need to compute the CRC if we don't have a reference value
>>>>>>             return
 2640:         self._running_crc = crc32(newdata, self._running_crc) & 0xffffffff
               # Check the CRC if we're at the end of the file
 2640:         if eof and self._running_crc != self._expected_crc:
    8:             raise BadZipfile("Bad CRC-32 for file %r" % self.name)
       
    1:     def read1(self, n):
               """Read up to n bytes with at most one read() system call."""
       
               # Simplify algorithm (branching) by transforming negative n to large n.
36986:         if n < 0 or n is None:
  455:             n = self.MAX_N
       
               # Bytes available in read buffer.
36986:         len_readbuffer = len(self._readbuffer) - self._offset
       
               # Read from file.
36986:         if self._compress_left > 0 and n > len_readbuffer + len(self._unconsumed):
 1819:             nbytes = n - len_readbuffer - len(self._unconsumed)
 1819:             nbytes = max(nbytes, self.MIN_READ_SIZE)
 1819:             nbytes = min(nbytes, self._compress_left)
       
 1819:             data = self._fileobj.read(nbytes)
 1819:             self._compress_left -= len(data)
       
 1819:             if data and self._decrypter is not None:
    2:                 data = ''.join(map(self._decrypter, data))
       
 1819:             if self._compress_type == ZIP_STORED:
 1136:                 self._update_crc(data, eof=(self._compress_left==0))
 1132:                 self._readbuffer = self._readbuffer[self._offset:] + data
 1132:                 self._offset = 0
                   else:
                       # Prepare deflated bytes for decompression.
  683:                 self._unconsumed += data
       
               # Handle unconsumed data.
36982:         if (len(self._unconsumed) > 0 and n > len_readbuffer and
 1504:             self._compress_type == ZIP_DEFLATED):
 1504:             data = self._decompressor.decompress(
 1504:                 self._unconsumed,
 1504:                 max(n - len_readbuffer, self.MIN_READ_SIZE)
                   )
       
 1504:             self._unconsumed = self._decompressor.unconsumed_tail
 1504:             eof = len(self._unconsumed) == 0 and self._compress_left == 0
 1504:             if eof:
  242:                 data += self._decompressor.flush()
       
 1504:             self._update_crc(data, eof=eof)
 1500:             self._readbuffer = self._readbuffer[self._offset:] + data
 1500:             self._offset = 0
       
               # Read from buffer.
36978:         data = self._readbuffer[self._offset: self._offset + n]
36978:         self._offset += len(data)
36978:         return data
       
    1:     def close(self):
  574:         try :
  574:             if self._close_fileobj:
  393:                 self._fileobj.close()
               finally:
  574:             super(ZipExtFile, self).close()
       
       
    2: class ZipFile(object):
           """ Class with methods to open, read, write, close, list zip files.
       
           z = ZipFile(file, mode="r", compression=ZIP_STORED, allowZip64=False)
       
           file: Either the path to the file, or a file-like object.
                 If it is a path, the file will be opened and closed by ZipFile.
           mode: The mode can be either read "r", write "w" or append "a".
           compression: ZIP_STORED (no compression) or ZIP_DEFLATED (requires zlib).
           allowZip64: if True ZipFile will create files with ZIP64 extensions when
                       needed, otherwise it will raise an exception when this would
                       be necessary.
       
    1:     """
       
    1:     fp = None                   # Set here since __del__ checks it
       
    1:     def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=False):
               """Open the ZIP file with mode read "r", write "w" or append "a"."""
  598:         if mode not in ("r", "w", "a"):
    1:             raise RuntimeError('ZipFile() requires mode "r", "w", or "a"')
       
  597:         if compression == ZIP_STORED:
  500:             pass
   97:         elif compression == ZIP_DEFLATED:
   96:             if not zlib:
>>>>>>                 raise RuntimeError,\
>>>>>>                       "Compression requires the (missing) zlib module"
               else:
    1:             raise RuntimeError, "That compression method is not supported"
       
  596:         self._allowZip64 = allowZip64
  596:         self._didModify = False
  596:         self.debug = 0  # Level of printing: 0 through 3
  596:         self.NameToInfo = {}    # Find file info given name
  596:         self.filelist = []      # List of ZipInfo instances for archive
  596:         self.compression = compression  # Method of compression
  596:         self.mode = key = mode.replace('b', '')[0]
  596:         self.pwd = None
  596:         self._comment = ''
       
               # Check if we were passed a file-like object
  596:         if isinstance(file, basestring):
  292:             self._filePassed = 0
  292:             self.filename = file
  292:             modeDict = {'r' : 'rb', 'w': 'wb', 'a' : 'r+b'}
  292:             try:
  292:                 self.fp = open(file, modeDict[mode])
    3:             except IOError:
    3:                 if mode == 'a':
    2:                     mode = key = 'w'
    2:                     self.fp = open(file, modeDict[mode])
                       else:
    1:                     raise
               else:
  304:             self._filePassed = 1
  304:             self.fp = file
  304:             self.filename = getattr(file, 'name', None)
       
  595:         try:
  595:             if key == 'r':
  348:                 self._RealGetContents()
  247:             elif key == 'w':
                       # set the modified flag so central directory gets written
                       # even if no files are added to the archive
  239:                 self._didModify = True
    8:             elif key == 'a':
    8:                 try:
                           # See if file is a zip file
    8:                     self._RealGetContents()
                           # seek to start of directory and overwrite
    7:                     self.fp.seek(self.start_dir, 0)
    1:                 except BadZipfile:
                           # file is not a zip file, just append
    1:                     self.fp.seek(0, 2)
       
                           # set the modified flag so central directory gets written
                           # even if no files are added to the archive
    1:                     self._didModify = True
                   else:
>>>>>>                 raise RuntimeError('Mode must be "r", "w" or "a"')
  138:         except:
  138:             fp = self.fp
  138:             self.fp = None
  138:             if not self._filePassed:
    4:                 fp.close()
  138:             raise
       
    1:     def __enter__(self):
  377:         return self
       
    1:     def __exit__(self, type, value, traceback):
  377:         self.close()
       
    1:     def _RealGetContents(self):
               """Read in the table of contents for the ZIP file."""
  356:         fp = self.fp
  356:         try:
  356:             endrec = _EndRecData(fp)
>>>>>>         except IOError:
>>>>>>             raise BadZipfile("File is not a zip file")
  356:         if not endrec:
  139:             raise BadZipfile, "File is not a zip file"
  217:         if self.debug > 1:
>>>>>>             print endrec
  217:         size_cd = endrec[_ECD_SIZE]             # bytes in central directory
  217:         offset_cd = endrec[_ECD_OFFSET]         # offset of central directory
  217:         self._comment = endrec[_ECD_COMMENT]    # archive comment
       
               # "concat" is zero, unless zip was concatenated to another file
  217:         concat = endrec[_ECD_LOCATION] - size_cd - offset_cd
  217:         if endrec[_ECD_SIGNATURE] == stringEndArchive64:
                   # If Zip64 extension structures are present, account for them
    9:             concat -= (sizeEndCentDir64 + sizeEndCentDir64Locator)
       
  217:         if self.debug > 2:
>>>>>>             inferred = concat + offset_cd
>>>>>>             print "given, inferred, offset", offset_cd, inferred, concat
               # self.start_dir:  Position of start of central directory
  217:         self.start_dir = offset_cd + concat
  217:         fp.seek(self.start_dir, 0)
  217:         data = fp.read(size_cd)
  217:         fp = cStringIO.StringIO(data)
  217:         total = 0
  725:         while total < size_cd:
  508:             centdir = fp.read(sizeCentralDir)
  508:             if len(centdir) != sizeCentralDir:
>>>>>>                 raise BadZipfile("Truncated central directory")
  508:             centdir = struct.unpack(structCentralDir, centdir)
  508:             if centdir[_CD_SIGNATURE] != stringCentralDir:
>>>>>>                 raise BadZipfile("Bad magic number for central directory")
  508:             if self.debug > 2:
>>>>>>                 print centdir
  508:             filename = fp.read(centdir[_CD_FILENAME_LENGTH])
                   # Create ZipInfo instance to store file information
  508:             x = ZipInfo(filename)
  508:             x.extra = fp.read(centdir[_CD_EXTRA_FIELD_LENGTH])
  508:             x.comment = fp.read(centdir[_CD_COMMENT_LENGTH])
  508:             x.header_offset = centdir[_CD_LOCAL_HEADER_OFFSET]
                   (x.create_version, x.create_system, x.extract_version, x.reserved,
                       x.flag_bits, x.compress_type, t, d,
  508:                 x.CRC, x.compress_size, x.file_size) = centdir[1:12]
  508:             x.volume, x.internal_attr, x.external_attr = centdir[15:18]
                   # Convert date/time code to (year, month, day, hour, min, sec)
  508:             x._raw_time = t
  508:             x.date_time = ( (d>>9)+1980, (d>>5)&0xF, d&0x1F,
  508:                                      t>>11, (t>>5)&0x3F, (t&0x1F) * 2 )
       
  508:             x._decodeExtra()
  508:             x.header_offset = x.header_offset + concat
  508:             x.filename = x._decodeFilename()
  508:             self.filelist.append(x)
  508:             self.NameToInfo[x.filename] = x
       
                   # update total bytes read from central directory
                   total = (total + sizeCentralDir + centdir[_CD_FILENAME_LENGTH]
                            + centdir[_CD_EXTRA_FIELD_LENGTH]
  508:                      + centdir[_CD_COMMENT_LENGTH])
       
  508:             if self.debug > 2:
>>>>>>                 print "total", total
       
       
    1:     def namelist(self):
               """Return a list of file names in the archive."""
   72:         l = []
  343:         for data in self.filelist:
  271:             l.append(data.filename)
   72:         return l
       
    1:     def infolist(self):
               """Return a list of class ZipInfo instances for files in the
               archive."""
   15:         return self.filelist
       
    1:     def printdir(self):
               """Print a table of contents for the zip file."""
   13:         print "%-46s %19s %12s" % ("File Name", "Modified    ", "Size")
   52:         for zinfo in self.filelist:
   39:             date = "%d-%02d-%02d %02d:%02d:%02d" % zinfo.date_time[:6]
   39:             print "%-46s %s %12d" % (zinfo.filename, date, zinfo.file_size)
       
    1:     def testzip(self):
               """Read all the files and check the CRC."""
   16:         chunk_size = 2 ** 20
   53:         for zinfo in self.filelist:
   40:             try:
                       # Read by chunks, to avoid an OverflowError or a
                       # MemoryError with very large embedded files.
   40:                 with self.open(zinfo.filename, "r") as f:
   76:                     while f.read(chunk_size):     # Check CRC-32
   37:                         pass
    3:             except BadZipfile:
    2:                 return zinfo.filename
       
    1:     def getinfo(self, name):
               """Return the instance of ZipInfo given 'name'."""
  624:         info = self.NameToInfo.get(name)
  624:         if info is None:
    1:             raise KeyError(
    1:                 'There is no item named %r in the archive' % name)
       
  623:         return info
       
    1:     def setpassword(self, pwd):
               """Set default password for encrypted files."""
    4:         self.pwd = pwd
       
    1:     @property
           def comment(self):
               """The comment text associated with the ZIP file."""
    8:         return self._comment
       
    1:     @comment.setter
           def comment(self, comment):
               # check for valid comment length
    6:         if len(comment) > ZIP_MAX_COMMENT:
    1:             import warnings
    1:             warnings.warn('Archive comment is too long; truncating to %d bytes'
    1:                           % ZIP_MAX_COMMENT, stacklevel=2)
    1:             comment = comment[:ZIP_MAX_COMMENT]
    6:         self._comment = comment
    6:         self._didModify = True
       
    1:     def read(self, name, pwd=None):
               """Return file bytes (as a string) for name."""
  204:         return self.open(name, "r", pwd).read()
       
    1:     def open(self, name, mode="r", pwd=None):
               """Return file-like object for 'name'."""
  583:         if mode not in ("r", "U", "rU"):
    1:             raise RuntimeError, 'open() requires mode "r", "U", or "rU"'
  582:         if not self.fp:
    3:             raise RuntimeError, \
    3:                   "Attempt to read ZIP archive that was already closed"
       
               # Only open a new file for instances where we were not
               # given a file object in the constructor
  579:         if self._filePassed:
  181:             zef_file = self.fp
  181:             should_close = False
               else:
  398:             zef_file = open(self.filename, 'rb')
  398:             should_close = True
       
  579:         try:
                   # Make sure we have an info object
  579:             if isinstance(name, ZipInfo):
                       # 'name' is already an info object
   61:                 zinfo = name
                   else:
                       # Get info object for name
  518:                 zinfo = self.getinfo(name)
       
  578:             zef_file.seek(zinfo.header_offset, 0)
       
                   # Skip the file header:
  578:             fheader = zef_file.read(sizeFileHeader)
  578:             if len(fheader) != sizeFileHeader:
>>>>>>                 raise BadZipfile("Truncated file header")
  578:             fheader = struct.unpack(structFileHeader, fheader)
  578:             if fheader[_FH_SIGNATURE] != stringFileHeader:
>>>>>>                 raise BadZipfile("Bad magic number for file header")
       
  578:             fname = zef_file.read(fheader[_FH_FILENAME_LENGTH])
  578:             if fheader[_FH_EXTRA_FIELD_LENGTH]:
   43:                 zef_file.read(fheader[_FH_EXTRA_FIELD_LENGTH])
       
  578:             if fname != zinfo.orig_filename:
>>>>>>                 raise BadZipfile, \
>>>>>>                         'File name in directory "%s" and header "%s" differ.' % (
>>>>>>                             zinfo.orig_filename, fname)
       
                   # check for encrypted flag & handle password
  578:             is_encrypted = zinfo.flag_bits & 0x1
  578:             zd = None
  578:             if is_encrypted:
    6:                 if not pwd:
    6:                     pwd = self.pwd
    6:                 if not pwd:
    2:                     raise RuntimeError, "File %s is encrypted, " \
    2:                         "password required for extraction" % name
       
    4:                 zd = _ZipDecrypter(pwd)
                       # The first 12 bytes in the cypher stream is an encryption header
                       #  used to strengthen the algorithm. The first 11 bytes are
                       #  completely random, while the 12th contains the MSB of the CRC,
                       #  or the MSB of the file time depending on the header type
                       #  and is used to check the correctness of the password.
    4:                 bytes = zef_file.read(12)
    4:                 h = map(zd, bytes[0:12])
    4:                 if zinfo.flag_bits & 0x8:
                           # compare against the file type from extended local headers
    2:                     check_byte = (zinfo._raw_time >> 8) & 0xff
                       else:
                           # compare against the CRC otherwise
    2:                     check_byte = (zinfo.CRC >> 24) & 0xff
    4:                 if ord(h[11]) != check_byte:
    2:                     raise RuntimeError("Bad password for file", name)
       
  574:             return ZipExtFile(zef_file, mode, zinfo, zd,
  574:                     close_fileobj=should_close)
    6:         except:
    6:             if should_close:
    5:                 zef_file.close()
    6:             raise
       
    1:     def extract(self, member, path=None, pwd=None):
               """Extract a member from the archive to the current working directory,
                  using its full name. Its file information is extracted as accurately
                  as possible. `member' may be a filename or a ZipInfo object. You can
                  specify a different directory using `path'.
               """
   63:         if not isinstance(member, ZipInfo):
   63:             member = self.getinfo(member)
       
   63:         if path is None:
   32:             path = os.getcwd()
       
   63:         return self._extract_member(member, path, pwd)
       
    1:     def extractall(self, path=None, members=None, pwd=None):
               """Extract all members from the archive to the current working
                  directory. `path' specifies a different directory to extract to.
                  `members' is optional and must be a subset of the list returned
                  by namelist().
               """
   27:         if members is None:
   27:             members = self.namelist()
       
   62:         for zipinfo in members:
   35:             self.extract(zipinfo, path, pwd)
       
    1:     def _extract_member(self, member, targetpath, pwd):
               """Extract the ZipInfo object 'member' to a physical
                  file on the path targetpath.
               """
               # build the destination pathname, replacing
               # forward slashes to platform specific separators.
   63:         arcname = member.filename.replace('/', os.path.sep)
       
   63:         if os.path.altsep:
>>>>>>             arcname = arcname.replace(os.path.altsep, os.path.sep)
               # interpret absolute pathname as relative, remove drive letter or
               # UNC path, redundant separators, "." and ".." components.
   63:         arcname = os.path.splitdrive(arcname)[1]
  331:         arcname = os.path.sep.join(x for x in arcname.split(os.path.sep)
  205:                     if x not in ('', os.path.curdir, os.path.pardir))
   63:         if os.path.sep == '\\':
                   # filter illegal characters on Windows
>>>>>>             illegal = ':<>|"?*'
>>>>>>             if isinstance(arcname, unicode):
>>>>>>                 table = {ord(c): ord('_') for c in illegal}
                   else:
>>>>>>                 table = string.maketrans(illegal, '_' * len(illegal))
>>>>>>             arcname = arcname.translate(table)
                   # remove trailing dots
>>>>>>             arcname = (x.rstrip('.') for x in arcname.split(os.path.sep))
>>>>>>             arcname = os.path.sep.join(x for x in arcname if x)
       
   63:         targetpath = os.path.join(targetpath, arcname)
   63:         targetpath = os.path.normpath(targetpath)
       
               # Create all upper directories if necessary.
   63:         upperdirs = os.path.dirname(targetpath)
   63:         if upperdirs and not os.path.exists(upperdirs):
   51:             os.makedirs(upperdirs)
       
   63:         if member.filename[-1] == '/':
    7:             if not os.path.isdir(targetpath):
    6:                 os.mkdir(targetpath)
    7:             return targetpath
       
   56:         with self.open(member, pwd=pwd) as source, \
   56:              file(targetpath, "wb") as target:
   56:             shutil.copyfileobj(source, target)
       
   56:         return targetpath
       
    1:     def _writecheck(self, zinfo):
               """Check for errors before writing a file to the archive."""
  588:         if zinfo.filename in self.NameToInfo:
    1:             import warnings
    1:             warnings.warn('Duplicate name: %r' % zinfo.filename, stacklevel=3)
  588:         if self.mode not in ("w", "a"):
    1:             raise RuntimeError, 'write() requires mode "w" or "a"'
  587:         if not self.fp:
>>>>>>             raise RuntimeError, \
>>>>>>                   "Attempt to write ZIP archive that was already closed"
  587:         if zinfo.compress_type == ZIP_DEFLATED and not zlib:
>>>>>>             raise RuntimeError, \
>>>>>>                   "Compression requires the (missing) zlib module"
  587:         if zinfo.compress_type not in (ZIP_STORED, ZIP_DEFLATED):
>>>>>>             raise RuntimeError, \
>>>>>>                   "That compression method is not supported"
  587:         if not self._allowZip64:
  547:             requires_zip64 = None
  547:             if len(self.filelist) >= ZIP_FILECOUNT_LIMIT:
    2:                 requires_zip64 = "Files count"
  545:             elif zinfo.file_size > ZIP64_LIMIT:
    6:                 requires_zip64 = "Filesize"
  539:             elif zinfo.header_offset > ZIP64_LIMIT:
>>>>>>                 requires_zip64 = "Zipfile size"
  547:             if requires_zip64:
    8:                 raise LargeZipFile(requires_zip64 +
    8:                                    " would require ZIP64 extensions")
       
    1:     def write(self, filename, arcname=None, compress_type=None):
               """Put the bytes from filename into the archive under the name
               arcname."""
  355:         if not self.fp:
    1:             raise RuntimeError(
    1:                   "Attempt to write to ZIP archive that was already closed")
       
  354:         st = os.stat(filename)
  354:         isdir = stat.S_ISDIR(st.st_mode)
  354:         mtime = time.localtime(st.st_mtime)
  354:         date_time = mtime[0:6]
               # Create ZipInfo instance to store file information
  354:         if arcname is None:
    4:             arcname = filename
  354:         arcname = os.path.normpath(os.path.splitdrive(arcname)[1])
  364:         while arcname[0] in (os.sep, os.altsep):
   10:             arcname = arcname[1:]
  354:         if isdir:
   20:             arcname += '/'
  354:         zinfo = ZipInfo(arcname, date_time)
  353:         zinfo.external_attr = (st[0] & 0xFFFF) << 16L      # Unix attributes
  353:         if isdir:
   20:             zinfo.compress_type = ZIP_STORED
  333:         elif compress_type is None:
  331:             zinfo.compress_type = self.compression
               else:
    2:             zinfo.compress_type = compress_type
       
  353:         zinfo.file_size = st.st_size
  353:         zinfo.flag_bits = 0x00
  353:         zinfo.header_offset = self.fp.tell()    # Start of header bytes
       
  353:         self._writecheck(zinfo)
  349:         self._didModify = True
       
  349:         if isdir:
   20:             zinfo.file_size = 0
   20:             zinfo.compress_size = 0
   20:             zinfo.CRC = 0
   20:             zinfo.external_attr |= 0x10  # MS-DOS directory flag
   20:             self.filelist.append(zinfo)
   20:             self.NameToInfo[zinfo.filename] = zinfo
   20:             self.fp.write(zinfo.FileHeader(False))
   20:             return
       
  329:         with open(filename, "rb") as fp:
                   # Must overwrite CRC and sizes with correct data later
  329:             zinfo.CRC = CRC = 0
  329:             zinfo.compress_size = compress_size = 0
                   # Compressed size can be larger than uncompressed size
  329:             zip64 = self._allowZip64 and \
   13:                     zinfo.file_size * 1.05 > ZIP64_LIMIT
  329:             self.fp.write(zinfo.FileHeader(zip64))
  329:             if zinfo.compress_type == ZIP_DEFLATED:
  159:                 cmpr = zlib.compressobj(zlib.Z_DEFAULT_COMPRESSION,
  159:                      zlib.DEFLATED, -15)
                   else:
  170:                 cmpr = None
  329:             file_size = 0
  329:             while 1:
 2270:                 buf = fp.read(1024 * 8)
 2270:                 if not buf:
  329:                     break
 1941:                 file_size = file_size + len(buf)
 1941:                 CRC = crc32(buf, CRC) & 0xffffffff
 1941:                 if cmpr:
  862:                     buf = cmpr.compress(buf)
  862:                     compress_size = compress_size + len(buf)
 1941:                 self.fp.write(buf)
  329:         if cmpr:
  159:             buf = cmpr.flush()
  159:             compress_size = compress_size + len(buf)
  159:             self.fp.write(buf)
  159:             zinfo.compress_size = compress_size
               else:
  170:             zinfo.compress_size = file_size
  329:         zinfo.CRC = CRC
  329:         zinfo.file_size = file_size
  329:         if not zip64 and self._allowZip64:
>>>>>>             if file_size > ZIP64_LIMIT:
>>>>>>                 raise RuntimeError('File size has increased during compressing')
>>>>>>             if compress_size > ZIP64_LIMIT:
>>>>>>                 raise RuntimeError('Compressed size larger than uncompressed size')
               # Seek backwards and write file header (which will now include
               # correct CRC and file sizes)
  329:         position = self.fp.tell()       # Preserve current position in file
  329:         self.fp.seek(zinfo.header_offset, 0)
  329:         self.fp.write(zinfo.FileHeader(zip64))
  329:         self.fp.seek(position, 0)
  329:         self.filelist.append(zinfo)
  329:         self.NameToInfo[zinfo.filename] = zinfo
       
    1:     def writestr(self, zinfo_or_arcname, bytes, compress_type=None):
               """Write a file into the archive.  The contents is the string
               'bytes'.  'zinfo_or_arcname' is either a ZipInfo instance or
               the name of the file in the archive."""
  236:         if not isinstance(zinfo_or_arcname, ZipInfo):
  161:             zinfo = ZipInfo(filename=zinfo_or_arcname,
  161:                             date_time=time.localtime(time.time())[:6])
       
  161:             zinfo.compress_type = self.compression
  161:             if zinfo.filename[-1] == '/':
    1:                 zinfo.external_attr = 0o40775 << 16   # drwxrwxr-x
    1:                 zinfo.external_attr |= 0x10           # MS-DOS directory flag
                   else:
  160:                 zinfo.external_attr = 0o600 << 16     # ?rw-------
               else:
   75:             zinfo = zinfo_or_arcname
       
  236:         if not self.fp:
    1:             raise RuntimeError(
    1:                   "Attempt to write to ZIP archive that was already closed")
       
  235:         if compress_type is not None:
    2:             zinfo.compress_type = compress_type
       
  235:         zinfo.file_size = len(bytes)            # Uncompressed size
  235:         zinfo.header_offset = self.fp.tell()    # Start of header bytes
  235:         self._writecheck(zinfo)
  230:         self._didModify = True
  230:         zinfo.CRC = crc32(bytes) & 0xffffffff       # CRC-32 checksum
  230:         if zinfo.compress_type == ZIP_DEFLATED:
   78:             co = zlib.compressobj(zlib.Z_DEFAULT_COMPRESSION,
   78:                  zlib.DEFLATED, -15)
   78:             bytes = co.compress(bytes) + co.flush()
   78:             zinfo.compress_size = len(bytes)    # Compressed size
               else:
  152:             zinfo.compress_size = zinfo.file_size
  230:         zip64 = zinfo.file_size > ZIP64_LIMIT or \
  224:                 zinfo.compress_size > ZIP64_LIMIT
  230:         if zip64 and not self._allowZip64:
>>>>>>             raise LargeZipFile("Filesize would require ZIP64 extensions")
  230:         self.fp.write(zinfo.FileHeader(zip64))
  230:         self.fp.write(bytes)
  230:         if zinfo.flag_bits & 0x08:
                   # Write CRC and file sizes after the file data
>>>>>>             fmt = '<LQQ' if zip64 else '<LLL'
>>>>>>             self.fp.write(struct.pack(fmt, zinfo.CRC, zinfo.compress_size,
>>>>>>                   zinfo.file_size))
  230:         self.fp.flush()
  230:         self.filelist.append(zinfo)
  230:         self.NameToInfo[zinfo.filename] = zinfo
       
    1:     def __del__(self):
               """Call the "close()" method in case the user forgot."""
  484:         self.close()
       
    1:     def close(self):
               """Close the file, and for mode "w" and "a" write the ending
               records."""
  979:         if self.fp is None:
  522:             return
       
  457:         try:
  457:             if self.mode in ("w", "a") and self._didModify: # write ending records
  245:                 pos1 = self.fp.tell()
  837:                 for zinfo in self.filelist:         # write central directory
  592:                     dt = zinfo.date_time
  592:                     dosdate = (dt[0] - 1980) << 9 | dt[1] << 5 | dt[2]
  592:                     dostime = dt[3] << 11 | dt[4] << 5 | (dt[5] // 2)
  592:                     extra = []
  592:                     if zinfo.file_size > ZIP64_LIMIT \
  573:                             or zinfo.compress_size > ZIP64_LIMIT:
   19:                         extra.append(zinfo.file_size)
   19:                         extra.append(zinfo.compress_size)
   19:                         file_size = 0xffffffff
   19:                         compress_size = 0xffffffff
                           else:
  573:                         file_size = zinfo.file_size
  573:                         compress_size = zinfo.compress_size
       
  592:                     if zinfo.header_offset > ZIP64_LIMIT:
   12:                         extra.append(zinfo.header_offset)
   12:                         header_offset = 0xffffffffL
                           else:
  580:                         header_offset = zinfo.header_offset
       
  592:                     extra_data = zinfo.extra
  592:                     if extra:
                               # Append a ZIP64 field to the extra's
   19:                         extra_data = struct.pack(
   19:                                 '<HH' + 'Q'*len(extra),
   19:                                 1, 8*len(extra), *extra) + extra_data
       
   19:                         extract_version = max(45, zinfo.extract_version)
   19:                         create_version = max(45, zinfo.create_version)
                           else:
  573:                         extract_version = zinfo.extract_version
  573:                         create_version = zinfo.create_version
       
  592:                     try:
  592:                         filename, flag_bits = zinfo._encodeFilenameFlags()
  592:                         centdir = struct.pack(structCentralDir,
  592:                         stringCentralDir, create_version,
  592:                         zinfo.create_system, extract_version, zinfo.reserved,
  592:                         flag_bits, zinfo.compress_type, dostime, dosdate,
  592:                         zinfo.CRC, compress_size, file_size,
  592:                         len(filename), len(extra_data), len(zinfo.comment),
  592:                         0, zinfo.internal_attr, zinfo.external_attr,
  592:                         header_offset)
>>>>>>                     except DeprecationWarning:
>>>>>>                         print >>sys.stderr, (structCentralDir,
>>>>>>                         stringCentralDir, create_version,
>>>>>>                         zinfo.create_system, extract_version, zinfo.reserved,
>>>>>>                         zinfo.flag_bits, zinfo.compress_type, dostime, dosdate,
>>>>>>                         zinfo.CRC, compress_size, file_size,
>>>>>>                         len(zinfo.filename), len(extra_data), len(zinfo.comment),
>>>>>>                         0, zinfo.internal_attr, zinfo.external_attr,
>>>>>>                         header_offset)
>>>>>>                         raise
  592:                     self.fp.write(centdir)
  592:                     self.fp.write(filename)
  592:                     self.fp.write(extra_data)
  592:                     self.fp.write(zinfo.comment)
       
  245:                 pos2 = self.fp.tell()
                       # Write end-of-zip-archive record
  245:                 centDirCount = len(self.filelist)
  245:                 centDirSize = pos2 - pos1
  245:                 centDirOffset = pos1
  245:                 requires_zip64 = None
  245:                 if centDirCount > ZIP_FILECOUNT_LIMIT:
    2:                     requires_zip64 = "Files count"
  243:                 elif centDirOffset > ZIP64_LIMIT:
    7:                     requires_zip64 = "Central directory offset"
  236:                 elif centDirSize > ZIP64_LIMIT:
>>>>>>                     requires_zip64 = "Central directory size"
  245:                 if requires_zip64:
                           # Need to write the ZIP64 end-of-archive records
    9:                     if not self._allowZip64:
>>>>>>                         raise LargeZipFile(requires_zip64 +
>>>>>>                                            " would require ZIP64 extensions")
    9:                     zip64endrec = struct.pack(
    9:                             structEndArchive64, stringEndArchive64,
    9:                             44, 45, 45, 0, 0, centDirCount, centDirCount,
    9:                             centDirSize, centDirOffset)
    9:                     self.fp.write(zip64endrec)
       
    9:                     zip64locrec = struct.pack(
    9:                             structEndArchive64Locator,
    9:                             stringEndArchive64Locator, 0, pos2, 1)
    9:                     self.fp.write(zip64locrec)
    9:                     centDirCount = min(centDirCount, 0xFFFF)
    9:                     centDirSize = min(centDirSize, 0xFFFFFFFF)
    9:                     centDirOffset = min(centDirOffset, 0xFFFFFFFF)
       
  245:                 endrec = struct.pack(structEndArchive, stringEndArchive,
  245:                                     0, 0, centDirCount, centDirCount,
  245:                                     centDirSize, centDirOffset, len(self._comment))
  245:                 self.fp.write(endrec)
  245:                 self.fp.write(self._comment)
  245:                 self.fp.flush()
               finally:
  457:             fp = self.fp
  457:             self.fp = None
  457:             if not self._filePassed:
  287:                 fp.close()
       
       
    2: class PyZipFile(ZipFile):
    1:     """Class to create ZIP archives with Python library files and packages."""
       
    1:     def writepy(self, pathname, basename = ""):
               """Add all files from "pathname" to the ZIP archive.
       
               If pathname is a package directory, search the directory and
               all package subdirectories recursively for all *.py and enter
               the modules into the archive.  If pathname is a plain
               directory, listdir *.py and enter all modules.  Else, pathname
               must be a Python *.py file and the module will be put into the
               archive.  Added modules are always module.pyo or module.pyc.
               This method will compile the module.py into module.pyc if
               necessary.
               """
    7:         dir, name = os.path.split(pathname)
    7:         if os.path.isdir(pathname):
    4:             initname = os.path.join(pathname, "__init__.py")
    4:             if os.path.isfile(initname):
                       # This is a package directory, add it
    3:                 if basename:
    2:                     basename = "%s/%s" % (basename, name)
                       else:
    1:                     basename = name
    3:                 if self.debug:
>>>>>>                     print "Adding package in", pathname, "as", basename
    3:                 fname, arcname = self._get_codename(initname[0:-3], basename)
    3:                 if self.debug:
>>>>>>                     print "Adding", arcname
    3:                 self.write(fname, arcname)
    3:                 dirlist = os.listdir(pathname)
    3:                 dirlist.remove("__init__.py")
                       # Add all *.py files and package subdirectories
   90:                 for filename in dirlist:
   87:                     path = os.path.join(pathname, filename)
   87:                     root, ext = os.path.splitext(filename)
   87:                     if os.path.isdir(path):
    3:                         if os.path.isfile(os.path.join(path, "__init__.py")):
                                   # This is a package directory, add it
    2:                             self.writepy(path, basename)  # Recursive call
   84:                     elif ext == ".py":
   26:                         fname, arcname = self._get_codename(path[0:-3],
   26:                                          basename)
   26:                         if self.debug:
>>>>>>                             print "Adding", arcname
   26:                         self.write(fname, arcname)
                   else:
                       # This is NOT a package directory, add its files at top level
    1:                 if self.debug:
>>>>>>                     print "Adding files from directory", pathname
    4:                 for filename in os.listdir(pathname):
    3:                     path = os.path.join(pathname, filename)
    3:                     root, ext = os.path.splitext(filename)
    3:                     if ext == ".py":
    2:                         fname, arcname = self._get_codename(path[0:-3],
    2:                                          basename)
    2:                         if self.debug:
>>>>>>                             print "Adding", arcname
    2:                         self.write(fname, arcname)
               else:
    3:             if pathname[-3:] != ".py":
    1:                 raise RuntimeError, \
    1:                       'Files added with writepy() must end with ".py"'
    2:             fname, arcname = self._get_codename(pathname[0:-3], basename)
    2:             if self.debug:
>>>>>>                 print "Adding file", arcname
    2:             self.write(fname, arcname)
       
    1:     def _get_codename(self, pathname, basename):
               """Return (filename, archivename) for the path.
       
               Given a module name path, return the correct file path and
               archive name, compiling if necessary.  For example, given
               /python/lib/string, return (/python/lib/string.pyc, string).
               """
   33:         file_py  = pathname + ".py"
   33:         file_pyc = pathname + ".pyc"
   33:         file_pyo = pathname + ".pyo"
   33:         if os.path.isfile(file_pyo) and \
   31:                             os.stat(file_pyo).st_mtime >= os.stat(file_py).st_mtime:
   31:             fname = file_pyo    # Use .pyo file
    2:         elif not os.path.isfile(file_pyc) or \
>>>>>>              os.stat(file_pyc).st_mtime < os.stat(file_py).st_mtime:
    2:             import py_compile
    2:             if self.debug:
>>>>>>                 print "Compiling", file_py
    2:             try:
    2:                 py_compile.compile(file_py, file_pyc, None, True)
>>>>>>             except py_compile.PyCompileError,err:
>>>>>>                 print err.msg
    2:             fname = file_pyc
               else:
>>>>>>             fname = file_pyc
   33:         archivename = os.path.split(fname)[1]
   33:         if basename:
   30:             archivename = "%s/%s" % (basename, archivename)
   33:         return (fname, archivename)
       
       
    1: def main(args = None):
>>>>>>     import textwrap
>>>>>>     USAGE=textwrap.dedent("""\
               Usage:
                   zipfile.py -l zipfile.zip        # Show listing of a zipfile
                   zipfile.py -t zipfile.zip        # Test if a zipfile is valid
                   zipfile.py -e zipfile.zip target # Extract zipfile into target dir
                   zipfile.py -c zipfile.zip src ... # Create zipfile from sources
>>>>>>         """)
>>>>>>     if args is None:
>>>>>>         args = sys.argv[1:]
       
>>>>>>     if not args or args[0] not in ('-l', '-c', '-e', '-t'):
>>>>>>         print USAGE
>>>>>>         sys.exit(1)
       
>>>>>>     if args[0] == '-l':
>>>>>>         if len(args) != 2:
>>>>>>             print USAGE
>>>>>>             sys.exit(1)
>>>>>>         with ZipFile(args[1], 'r') as zf:
>>>>>>             zf.printdir()
       
>>>>>>     elif args[0] == '-t':
>>>>>>         if len(args) != 2:
>>>>>>             print USAGE
>>>>>>             sys.exit(1)
>>>>>>         with ZipFile(args[1], 'r') as zf:
>>>>>>             badfile = zf.testzip()
>>>>>>         if badfile:
>>>>>>             print("The following enclosed file is corrupted: {!r}".format(badfile))
>>>>>>         print "Done testing"
       
>>>>>>     elif args[0] == '-e':
>>>>>>         if len(args) != 3:
>>>>>>             print USAGE
>>>>>>             sys.exit(1)
       
>>>>>>         with ZipFile(args[1], 'r') as zf:
>>>>>>             zf.extractall(args[2])
       
>>>>>>     elif args[0] == '-c':
>>>>>>         if len(args) < 3:
>>>>>>             print USAGE
>>>>>>             sys.exit(1)
       
>>>>>>         def addToZip(zf, path, zippath):
>>>>>>             if os.path.isfile(path):
>>>>>>                 zf.write(path, zippath, ZIP_DEFLATED)
>>>>>>             elif os.path.isdir(path):
>>>>>>                 if zippath:
>>>>>>                     zf.write(path, zippath)
>>>>>>                 for nm in os.listdir(path):
>>>>>>                     addToZip(zf,
>>>>>>                             os.path.join(path, nm), os.path.join(zippath, nm))
                   # else: ignore
       
>>>>>>         with ZipFile(args[1], 'w', allowZip64=True) as zf:
>>>>>>             for path in args[2:]:
>>>>>>                 zippath = os.path.basename(path)
>>>>>>                 if not zippath:
>>>>>>                     zippath = os.path.basename(os.path.dirname(path))
>>>>>>                 if zippath in ('', os.curdir, os.pardir):
>>>>>>                     zippath = ''
>>>>>>                 addToZip(zf, path, zippath)
       
    1: if __name__ == "__main__":
>>>>>>     main()
