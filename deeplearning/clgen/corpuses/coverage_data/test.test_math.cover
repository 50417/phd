       # Python test set -- math module
       # XXXX Should not do tests around zero only
       
    2: from test.test_support import run_unittest, verbose
    2: import unittest
    2: import math
    2: import os
    2: import sys
    2: import random
    2: import struct
       
    2: eps = 1E-05
    2: NAN = float('nan')
    2: INF = float('inf')
    2: NINF = float('-inf')
       
       # decorator for skipping tests on non-IEEE 754 platforms
    2: requires_IEEE_754 = unittest.skipUnless(
    2:     float.__getformat__("double").startswith("IEEE"),
    2:     "test requires IEEE 754 doubles")
       
       # detect evidence of double-rounding: fsum is not always correctly
       # rounded on machines that suffer from double rounding.
    2: x, y = 1e16, 2.9999 # use temporary values to defeat peephole optimizer
    2: HAVE_DOUBLE_ROUNDING = (x + y == 1e16 + 4)
       
       # locate file with test values
    2: if __name__ == '__main__':
>>>>>>     file = sys.argv[0]
       else:
    2:     file = __file__
    2: test_dir = os.path.dirname(file) or os.curdir
    2: math_testcases = os.path.join(test_dir, 'math_testcases.txt')
    2: test_file = os.path.join(test_dir, 'cmath_testcases.txt')
       
    2: def to_ulps(x):
           """Convert a non-NaN float x to an integer, in such a way that
           adjacent floats are converted to adjacent integers.  Then
           abs(ulps(x) - ulps(y)) gives the difference in ulps between two
           floats.
       
           The results from this function will only make sense on platforms
           where C doubles are represented in IEEE 754 binary64 format.
       
           """
  368:     n = struct.unpack('<q', struct.pack('<d', x))[0]
  368:     if n < 0:
  128:         n = ~(n+2**63)
  368:     return n
       
    2: def ulps_check(expected, got, ulps=20):
           """Given non-NaN floats `expected` and `got`,
           check that they're equal to within the given number of ulps.
       
           Returns None on success and an error message on failure."""
       
  184:     ulps_error = to_ulps(got) - to_ulps(expected)
  184:     if abs(ulps_error) <= ulps:
  184:         return None
>>>>>>     return "error = {} ulps; permitted error = {} ulps".format(ulps_error,
>>>>>>                                                                ulps)
       
    2: def acc_check(expected, got, rel_err=2e-15, abs_err = 5e-323):
           """Determine whether non-NaN floats a and b are equal to within a
           (small) rounding error.  The default values for rel_err and
           abs_err are chosen to be suitable for platforms where a float is
           represented by an IEEE 754 double.  They allow an error of between
           9 and 19 ulps."""
       
           # need to special case infinities, since inf - inf gives nan
   69:     if math.isinf(expected) and got == expected:
    2:         return None
       
   67:     error = got - expected
       
   67:     permitted_error = max(abs_err, rel_err * abs(expected))
   67:     if abs(error) < permitted_error:
   67:         return None
>>>>>>     return "error = {}; permitted error = {}".format(error,
>>>>>>                                                      permitted_error)
       
    2: def parse_mtestfile(fname):
           """Parse a file with test values
       
           -- starts a comment
           blank lines, or lines containing only a comment, are ignored
           other lines are expected to have the form
             id fn arg -> expected [flag]*
       
           """
    1:     with open(fname) as fp:
  448:         for line in fp:
                   # strip comments, and skip blank lines
  447:             if '--' in line:
  106:                 line = line[:line.index('--')]
  447:             if not line.strip():
  157:                 continue
       
  290:             lhs, rhs = line.split('->')
  290:             id, fn, arg = lhs.split()
  290:             rhs_pieces = rhs.split()
  290:             exp = rhs_pieces[0]
  290:             flags = rhs_pieces[1:]
       
  290:             yield (id, fn, float(arg), float(exp), flags)
       
    2: def parse_testfile(fname):
           """Parse a file with test values
       
           Empty lines or lines starting with -- are ignored
           yields id, fn, arg_real, arg_imag, exp_real, exp_imag
           """
    2:     with open(fname) as fp:
 4732:         for line in fp:
                   # skip comment lines and blank lines
 4730:             if line.startswith('--') or not line.strip():
  252:                 continue
       
 3978:             lhs, rhs = line.split('->')
 3978:             id, fn, arg_real, arg_imag = lhs.split()
 3978:             rhs_pieces = rhs.split()
 3978:             exp_real, exp_imag = rhs_pieces[0], rhs_pieces[1]
 3978:             flags = rhs_pieces[2:]
       
 3978:             yield (id, fn,
 3978:                    float(arg_real), float(arg_imag),
 3978:                    float(exp_real), float(exp_imag),
 3978:                    flags
                         )
       
    4: class MathTests(unittest.TestCase):
       
    2:     def ftest(self, name, value, expected):
  512:         if abs(value-expected) > eps:
                   # Use %r instead of %f so the error message
                   # displays full precision. Otherwise discrepancies
                   # in the last few bits will lead to very confusing
                   # error messages
>>>>>>             self.fail('%s returned %r, expected %r' %
>>>>>>                       (name, value, expected))
       
    2:     def testConstants(self):
    1:         self.ftest('pi', math.pi, 3.1415926)
    1:         self.ftest('e', math.e, 2.7182818)
       
    2:     def testAcos(self):
    1:         self.assertRaises(TypeError, math.acos)
    1:         self.ftest('acos(-1)', math.acos(-1), math.pi)
    1:         self.ftest('acos(0)', math.acos(0), math.pi/2)
    1:         self.ftest('acos(1)', math.acos(1), 0)
    1:         self.assertRaises(ValueError, math.acos, INF)
    1:         self.assertRaises(ValueError, math.acos, NINF)
    1:         self.assertTrue(math.isnan(math.acos(NAN)))
       
    2:     def testAcosh(self):
    1:         self.assertRaises(TypeError, math.acosh)
    1:         self.ftest('acosh(1)', math.acosh(1), 0)
    1:         self.ftest('acosh(2)', math.acosh(2), 1.3169578969248168)
    1:         self.assertRaises(ValueError, math.acosh, 0)
    1:         self.assertRaises(ValueError, math.acosh, -1)
    1:         self.assertEqual(math.acosh(INF), INF)
    1:         self.assertRaises(ValueError, math.acosh, NINF)
    1:         self.assertTrue(math.isnan(math.acosh(NAN)))
       
    2:     def testAsin(self):
    1:         self.assertRaises(TypeError, math.asin)
    1:         self.ftest('asin(-1)', math.asin(-1), -math.pi/2)
    1:         self.ftest('asin(0)', math.asin(0), 0)
    1:         self.ftest('asin(1)', math.asin(1), math.pi/2)
    1:         self.assertRaises(ValueError, math.asin, INF)
    1:         self.assertRaises(ValueError, math.asin, NINF)
    1:         self.assertTrue(math.isnan(math.asin(NAN)))
       
    2:     def testAsinh(self):
    1:         self.assertRaises(TypeError, math.asinh)
    1:         self.ftest('asinh(0)', math.asinh(0), 0)
    1:         self.ftest('asinh(1)', math.asinh(1), 0.88137358701954305)
    1:         self.ftest('asinh(-1)', math.asinh(-1), -0.88137358701954305)
    1:         self.assertEqual(math.asinh(INF), INF)
    1:         self.assertEqual(math.asinh(NINF), NINF)
    1:         self.assertTrue(math.isnan(math.asinh(NAN)))
       
    2:     def testAtan(self):
    1:         self.assertRaises(TypeError, math.atan)
    1:         self.ftest('atan(-1)', math.atan(-1), -math.pi/4)
    1:         self.ftest('atan(0)', math.atan(0), 0)
    1:         self.ftest('atan(1)', math.atan(1), math.pi/4)
    1:         self.ftest('atan(inf)', math.atan(INF), math.pi/2)
    1:         self.ftest('atan(-inf)', math.atan(NINF), -math.pi/2)
    1:         self.assertTrue(math.isnan(math.atan(NAN)))
       
    2:     def testAtanh(self):
    1:         self.assertRaises(TypeError, math.atan)
    1:         self.ftest('atanh(0)', math.atanh(0), 0)
    1:         self.ftest('atanh(0.5)', math.atanh(0.5), 0.54930614433405489)
    1:         self.ftest('atanh(-0.5)', math.atanh(-0.5), -0.54930614433405489)
    1:         self.assertRaises(ValueError, math.atanh, 1)
    1:         self.assertRaises(ValueError, math.atanh, -1)
    1:         self.assertRaises(ValueError, math.atanh, INF)
    1:         self.assertRaises(ValueError, math.atanh, NINF)
    1:         self.assertTrue(math.isnan(math.atanh(NAN)))
       
    2:     def testAtan2(self):
    1:         self.assertRaises(TypeError, math.atan2)
    1:         self.ftest('atan2(-1, 0)', math.atan2(-1, 0), -math.pi/2)
    1:         self.ftest('atan2(-1, 1)', math.atan2(-1, 1), -math.pi/4)
    1:         self.ftest('atan2(0, 1)', math.atan2(0, 1), 0)
    1:         self.ftest('atan2(1, 1)', math.atan2(1, 1), math.pi/4)
    1:         self.ftest('atan2(1, 0)', math.atan2(1, 0), math.pi/2)
       
               # math.atan2(0, x)
    1:         self.ftest('atan2(0., -inf)', math.atan2(0., NINF), math.pi)
    1:         self.ftest('atan2(0., -2.3)', math.atan2(0., -2.3), math.pi)
    1:         self.ftest('atan2(0., -0.)', math.atan2(0., -0.), math.pi)
    1:         self.assertEqual(math.atan2(0., 0.), 0.)
    1:         self.assertEqual(math.atan2(0., 2.3), 0.)
    1:         self.assertEqual(math.atan2(0., INF), 0.)
    1:         self.assertTrue(math.isnan(math.atan2(0., NAN)))
               # math.atan2(-0, x)
    1:         self.ftest('atan2(-0., -inf)', math.atan2(-0., NINF), -math.pi)
    1:         self.ftest('atan2(-0., -2.3)', math.atan2(-0., -2.3), -math.pi)
    1:         self.ftest('atan2(-0., -0.)', math.atan2(-0., -0.), -math.pi)
    1:         self.assertEqual(math.atan2(-0., 0.), -0.)
    1:         self.assertEqual(math.atan2(-0., 2.3), -0.)
    1:         self.assertEqual(math.atan2(-0., INF), -0.)
    1:         self.assertTrue(math.isnan(math.atan2(-0., NAN)))
               # math.atan2(INF, x)
    1:         self.ftest('atan2(inf, -inf)', math.atan2(INF, NINF), math.pi*3/4)
    1:         self.ftest('atan2(inf, -2.3)', math.atan2(INF, -2.3), math.pi/2)
    1:         self.ftest('atan2(inf, -0.)', math.atan2(INF, -0.0), math.pi/2)
    1:         self.ftest('atan2(inf, 0.)', math.atan2(INF, 0.0), math.pi/2)
    1:         self.ftest('atan2(inf, 2.3)', math.atan2(INF, 2.3), math.pi/2)
    1:         self.ftest('atan2(inf, inf)', math.atan2(INF, INF), math.pi/4)
    1:         self.assertTrue(math.isnan(math.atan2(INF, NAN)))
               # math.atan2(NINF, x)
    1:         self.ftest('atan2(-inf, -inf)', math.atan2(NINF, NINF), -math.pi*3/4)
    1:         self.ftest('atan2(-inf, -2.3)', math.atan2(NINF, -2.3), -math.pi/2)
    1:         self.ftest('atan2(-inf, -0.)', math.atan2(NINF, -0.0), -math.pi/2)
    1:         self.ftest('atan2(-inf, 0.)', math.atan2(NINF, 0.0), -math.pi/2)
    1:         self.ftest('atan2(-inf, 2.3)', math.atan2(NINF, 2.3), -math.pi/2)
    1:         self.ftest('atan2(-inf, inf)', math.atan2(NINF, INF), -math.pi/4)
    1:         self.assertTrue(math.isnan(math.atan2(NINF, NAN)))
               # math.atan2(+finite, x)
    1:         self.ftest('atan2(2.3, -inf)', math.atan2(2.3, NINF), math.pi)
    1:         self.ftest('atan2(2.3, -0.)', math.atan2(2.3, -0.), math.pi/2)
    1:         self.ftest('atan2(2.3, 0.)', math.atan2(2.3, 0.), math.pi/2)
    1:         self.assertEqual(math.atan2(2.3, INF), 0.)
    1:         self.assertTrue(math.isnan(math.atan2(2.3, NAN)))
               # math.atan2(-finite, x)
    1:         self.ftest('atan2(-2.3, -inf)', math.atan2(-2.3, NINF), -math.pi)
    1:         self.ftest('atan2(-2.3, -0.)', math.atan2(-2.3, -0.), -math.pi/2)
    1:         self.ftest('atan2(-2.3, 0.)', math.atan2(-2.3, 0.), -math.pi/2)
    1:         self.assertEqual(math.atan2(-2.3, INF), -0.)
    1:         self.assertTrue(math.isnan(math.atan2(-2.3, NAN)))
               # math.atan2(NAN, x)
    1:         self.assertTrue(math.isnan(math.atan2(NAN, NINF)))
    1:         self.assertTrue(math.isnan(math.atan2(NAN, -2.3)))
    1:         self.assertTrue(math.isnan(math.atan2(NAN, -0.)))
    1:         self.assertTrue(math.isnan(math.atan2(NAN, 0.)))
    1:         self.assertTrue(math.isnan(math.atan2(NAN, 2.3)))
    1:         self.assertTrue(math.isnan(math.atan2(NAN, INF)))
    1:         self.assertTrue(math.isnan(math.atan2(NAN, NAN)))
       
    2:     def testCeil(self):
    1:         self.assertRaises(TypeError, math.ceil)
               # These types will be int in py3k.
    1:         self.assertEqual(float, type(math.ceil(1)))
    1:         self.assertEqual(float, type(math.ceil(1L)))
    1:         self.assertEqual(float, type(math.ceil(1.0)))
    1:         self.ftest('ceil(0.5)', math.ceil(0.5), 1)
    1:         self.ftest('ceil(1.0)', math.ceil(1.0), 1)
    1:         self.ftest('ceil(1.5)', math.ceil(1.5), 2)
    1:         self.ftest('ceil(-0.5)', math.ceil(-0.5), 0)
    1:         self.ftest('ceil(-1.0)', math.ceil(-1.0), -1)
    1:         self.ftest('ceil(-1.5)', math.ceil(-1.5), -1)
    1:         self.assertEqual(math.ceil(INF), INF)
    1:         self.assertEqual(math.ceil(NINF), NINF)
    1:         self.assertTrue(math.isnan(math.ceil(NAN)))
       
    2:         class TestCeil(object):
    1:             def __float__(self):
    1:                 return 41.3
    2:         class TestNoCeil(object):
    1:             pass
    1:         self.ftest('ceil(TestCeil())', math.ceil(TestCeil()), 42)
    1:         self.assertRaises(TypeError, math.ceil, TestNoCeil())
       
    1:         t = TestNoCeil()
    1:         t.__ceil__ = lambda *args: args
    1:         self.assertRaises(TypeError, math.ceil, t)
    1:         self.assertRaises(TypeError, math.ceil, t, 0)
       
    2:     @requires_IEEE_754
           def testCopysign(self):
    1:         self.assertEqual(math.copysign(1, 42), 1.0)
    1:         self.assertEqual(math.copysign(0., 42), 0.0)
    1:         self.assertEqual(math.copysign(1., -42), -1.0)
    1:         self.assertEqual(math.copysign(3, 0.), 3.0)
    1:         self.assertEqual(math.copysign(4., -0.), -4.0)
       
    1:         self.assertRaises(TypeError, math.copysign)
               # copysign should let us distinguish signs of zeros
    1:         self.assertEqual(math.copysign(1., 0.), 1.)
    1:         self.assertEqual(math.copysign(1., -0.), -1.)
    1:         self.assertEqual(math.copysign(INF, 0.), INF)
    1:         self.assertEqual(math.copysign(INF, -0.), NINF)
    1:         self.assertEqual(math.copysign(NINF, 0.), INF)
    1:         self.assertEqual(math.copysign(NINF, -0.), NINF)
               # and of infinities
    1:         self.assertEqual(math.copysign(1., INF), 1.)
    1:         self.assertEqual(math.copysign(1., NINF), -1.)
    1:         self.assertEqual(math.copysign(INF, INF), INF)
    1:         self.assertEqual(math.copysign(INF, NINF), NINF)
    1:         self.assertEqual(math.copysign(NINF, INF), INF)
    1:         self.assertEqual(math.copysign(NINF, NINF), NINF)
    1:         self.assertTrue(math.isnan(math.copysign(NAN, 1.)))
    1:         self.assertTrue(math.isnan(math.copysign(NAN, INF)))
    1:         self.assertTrue(math.isnan(math.copysign(NAN, NINF)))
    1:         self.assertTrue(math.isnan(math.copysign(NAN, NAN)))
               # copysign(INF, NAN) may be INF or it may be NINF, since
               # we don't know whether the sign bit of NAN is set on any
               # given platform.
    1:         self.assertTrue(math.isinf(math.copysign(INF, NAN)))
               # similarly, copysign(2., NAN) could be 2. or -2.
    1:         self.assertEqual(abs(math.copysign(2., NAN)), 2.)
       
    2:     def testCos(self):
    1:         self.assertRaises(TypeError, math.cos)
    1:         self.ftest('cos(-pi/2)', math.cos(-math.pi/2), 0)
    1:         self.ftest('cos(0)', math.cos(0), 1)
    1:         self.ftest('cos(pi/2)', math.cos(math.pi/2), 0)
    1:         self.ftest('cos(pi)', math.cos(math.pi), -1)
    1:         try:
    1:             self.assertTrue(math.isnan(math.cos(INF)))
>>>>>>             self.assertTrue(math.isnan(math.cos(NINF)))
    1:         except ValueError:
    1:             self.assertRaises(ValueError, math.cos, INF)
    1:             self.assertRaises(ValueError, math.cos, NINF)
    1:         self.assertTrue(math.isnan(math.cos(NAN)))
       
    2:     def testCosh(self):
    1:         self.assertRaises(TypeError, math.cosh)
    1:         self.ftest('cosh(0)', math.cosh(0), 1)
    1:         self.ftest('cosh(2)-2*cosh(1)**2', math.cosh(2)-2*math.cosh(1)**2, -1) # Thanks to Lambert
    1:         self.assertEqual(math.cosh(INF), INF)
    1:         self.assertEqual(math.cosh(NINF), INF)
    1:         self.assertTrue(math.isnan(math.cosh(NAN)))
       
    2:     def testDegrees(self):
    1:         self.assertRaises(TypeError, math.degrees)
    1:         self.ftest('degrees(pi)', math.degrees(math.pi), 180.0)
    1:         self.ftest('degrees(pi/2)', math.degrees(math.pi/2), 90.0)
    1:         self.ftest('degrees(-pi/4)', math.degrees(-math.pi/4), -45.0)
       
    2:     def testExp(self):
    1:         self.assertRaises(TypeError, math.exp)
    1:         self.ftest('exp(-1)', math.exp(-1), 1/math.e)
    1:         self.ftest('exp(0)', math.exp(0), 1)
    1:         self.ftest('exp(1)', math.exp(1), math.e)
    1:         self.assertEqual(math.exp(INF), INF)
    1:         self.assertEqual(math.exp(NINF), 0.)
    1:         self.assertTrue(math.isnan(math.exp(NAN)))
       
    2:     def testFabs(self):
    1:         self.assertRaises(TypeError, math.fabs)
    1:         self.ftest('fabs(-1)', math.fabs(-1), 1)
    1:         self.ftest('fabs(0)', math.fabs(0), 0)
    1:         self.ftest('fabs(1)', math.fabs(1), 1)
       
    2:     def testFactorial(self):
    1:         def fact(n):
   78:             result = 1
 4248:             for i in range(1, int(n)+1):
 4170:                 result *= i
   78:             return result
    1:         values = range(10) + [50, 100, 500]
    1:         random.shuffle(values)
   14:         for x in values:
   52:             for cast in (int, long, float):
   39:                 self.assertEqual(math.factorial(cast(x)), fact(x), (x, fact(x), math.factorial(x)))
    1:         self.assertRaises(ValueError, math.factorial, -1)
    1:         self.assertRaises(ValueError, math.factorial, math.pi)
       
    2:     def testFloor(self):
    1:         self.assertRaises(TypeError, math.floor)
               # These types will be int in py3k.
    1:         self.assertEqual(float, type(math.floor(1)))
    1:         self.assertEqual(float, type(math.floor(1L)))
    1:         self.assertEqual(float, type(math.floor(1.0)))
    1:         self.ftest('floor(0.5)', math.floor(0.5), 0)
    1:         self.ftest('floor(1.0)', math.floor(1.0), 1)
    1:         self.ftest('floor(1.5)', math.floor(1.5), 1)
    1:         self.ftest('floor(-0.5)', math.floor(-0.5), -1)
    1:         self.ftest('floor(-1.0)', math.floor(-1.0), -1)
    1:         self.ftest('floor(-1.5)', math.floor(-1.5), -2)
               # pow() relies on floor() to check for integers
               # This fails on some platforms - so check it here
    1:         self.ftest('floor(1.23e167)', math.floor(1.23e167), 1.23e167)
    1:         self.ftest('floor(-1.23e167)', math.floor(-1.23e167), -1.23e167)
    1:         self.assertEqual(math.ceil(INF), INF)
    1:         self.assertEqual(math.ceil(NINF), NINF)
    1:         self.assertTrue(math.isnan(math.floor(NAN)))
       
    2:         class TestFloor(object):
    1:             def __float__(self):
    1:                 return 42.3
    2:         class TestNoFloor(object):
    1:             pass
    1:         self.ftest('floor(TestFloor())', math.floor(TestFloor()), 42)
    1:         self.assertRaises(TypeError, math.floor, TestNoFloor())
       
    1:         t = TestNoFloor()
    1:         t.__floor__ = lambda *args: args
    1:         self.assertRaises(TypeError, math.floor, t)
    1:         self.assertRaises(TypeError, math.floor, t, 0)
       
    2:     def testFmod(self):
    1:         self.assertRaises(TypeError, math.fmod)
    1:         self.ftest('fmod(10,1)', math.fmod(10,1), 0)
    1:         self.ftest('fmod(10,0.5)', math.fmod(10,0.5), 0)
    1:         self.ftest('fmod(10,1.5)', math.fmod(10,1.5), 1)
    1:         self.ftest('fmod(-10,1)', math.fmod(-10,1), 0)
    1:         self.ftest('fmod(-10,0.5)', math.fmod(-10,0.5), 0)
    1:         self.ftest('fmod(-10,1.5)', math.fmod(-10,1.5), -1)
    1:         self.assertTrue(math.isnan(math.fmod(NAN, 1.)))
    1:         self.assertTrue(math.isnan(math.fmod(1., NAN)))
    1:         self.assertTrue(math.isnan(math.fmod(NAN, NAN)))
    1:         self.assertRaises(ValueError, math.fmod, 1., 0.)
    1:         self.assertRaises(ValueError, math.fmod, INF, 1.)
    1:         self.assertRaises(ValueError, math.fmod, NINF, 1.)
    1:         self.assertRaises(ValueError, math.fmod, INF, 0.)
    1:         self.assertEqual(math.fmod(3.0, INF), 3.0)
    1:         self.assertEqual(math.fmod(-3.0, INF), -3.0)
    1:         self.assertEqual(math.fmod(3.0, NINF), 3.0)
    1:         self.assertEqual(math.fmod(-3.0, NINF), -3.0)
    1:         self.assertEqual(math.fmod(0.0, 3.0), 0.0)
    1:         self.assertEqual(math.fmod(0.0, NINF), 0.0)
       
    2:     def testFrexp(self):
    1:         self.assertRaises(TypeError, math.frexp)
       
    1:         def testfrexp(name, result, expected):
    4:             (mant, exp), (emant, eexp) = result, expected
    4:             if abs(mant-emant) > eps or exp != eexp:
>>>>>>                 self.fail('%s returned %r, expected %r'%\
>>>>>>                           (name, (mant, exp), (emant,eexp)))
       
    1:         testfrexp('frexp(-1)', math.frexp(-1), (-0.5, 1))
    1:         testfrexp('frexp(0)', math.frexp(0), (0, 0))
    1:         testfrexp('frexp(1)', math.frexp(1), (0.5, 1))
    1:         testfrexp('frexp(2)', math.frexp(2), (0.5, 2))
       
    1:         self.assertEqual(math.frexp(INF)[0], INF)
    1:         self.assertEqual(math.frexp(NINF)[0], NINF)
    1:         self.assertTrue(math.isnan(math.frexp(NAN)[0]))
       
    2:     @requires_IEEE_754
    2:     @unittest.skipIf(HAVE_DOUBLE_ROUNDING,
    2:                          "fsum is not exact on machines with double rounding")
           def testFsum(self):
               # math.fsum relies on exact rounding for correct operation.
               # There's a known problem with IA32 floating-point that causes
               # inexact rounding in some situations, and will cause the
               # math.fsum tests below to fail; see issue #2937.  On non IEEE
               # 754 platforms, and on IEEE 754 platforms that exhibit the
               # problem described in issue #2937, we simply skip the whole
               # test.
       
               # Python version of math.fsum, for comparison.  Uses a
               # different algorithm based on frexp, ldexp and integer
               # arithmetic.
    1:         from sys import float_info
    1:         mant_dig = float_info.mant_dig
    1:         etiny = float_info.min_exp - mant_dig
       
    1:         def msum(iterable):
                   """Full precision summation.  Compute sum(iterable) without any
                   intermediate accumulation of error.  Based on the 'lsum' function
                   at http://code.activestate.com/recipes/393090/
       
                   """
 2000:             tmant, texp = 0, 0
522000:             for x in iterable:
520000:                 mant, exp = math.frexp(x)
520000:                 mant, exp = int(math.ldexp(mant, mant_dig)), exp - mant_dig
520000:                 if texp > exp:
 6752:                     tmant <<= texp-exp
 6752:                     texp = exp
                       else:
513248:                     mant <<= exp-texp
520000:                 tmant += mant
                   # Round tmant * 2**texp to a float.  The original recipe
                   # used float(str(tmant)) * 2.0**texp for this, but that's
                   # a little unsafe because str -> float conversion can't be
                   # relied upon to do correct rounding on all platforms.
 2000:             tail = max(len(bin(abs(tmant)))-2 - mant_dig, etiny - texp)
 2000:             if tail > 0:
 2000:                 h = 1 << (tail-1)
 2000:                 tmant = tmant // (2*h) + bool(tmant & h and tmant & 3*h-1)
 2000:                 texp += tail
 2000:             return math.ldexp(tmant, texp)
       
               test_values = [
    1:             ([], 0.0),
    1:             ([0.0], 0.0),
    1:             ([1e100, 1.0, -1e100, 1e-100, 1e50, -1.0, -1e50], 1e-100),
    1:             ([2.0**53, -0.5, -2.0**-54], 2.0**53-1.0),
    1:             ([2.0**53, 1.0, 2.0**-100], 2.0**53+2.0),
    1:             ([2.0**53+10.0, 1.0, 2.0**-100], 2.0**53+12.0),
    1:             ([2.0**53-4.0, 0.5, 2.0**-54], 2.0**53-3.0),
 1001:             ([1./n for n in range(1, 1001)],
    1:              float.fromhex('0x1.df11f45f4e61ap+2')),
 1001:             ([(-1.)**n/n for n in range(1, 1001)],
    1:              float.fromhex('-0x1.62a2af1bd3624p-1')),
 1001:             ([1.7**(i+1)-1.7**i for i in range(1000)] + [-1.7**1000], -1.0),
    1:             ([1e16, 1., 1e-16], 10000000000000002.0),
    1:             ([1e16-2., 1.-2.**-53, -(1e16-2.), -(1.-2.**-53)], 0.0),
                   # exercise code for resizing partials array
 1024:             ([2.**n - 2.**(n+50) + 2.**(n+52) for n in range(-1074, 972, 2)] +
    1:              [-2.**1022],
    1:              float.fromhex('0x1.5555555555555p+970')),
                   ]
       
   14:         for i, (vals, expected) in enumerate(test_values):
   13:             try:
   13:                 actual = math.fsum(vals)
>>>>>>             except OverflowError:
>>>>>>                 self.fail("test %d failed: got OverflowError, expected %r "
>>>>>>                           "for math.fsum(%.100r)" % (i, expected, vals))
>>>>>>             except ValueError:
>>>>>>                 self.fail("test %d failed: got ValueError, expected %r "
>>>>>>                           "for math.fsum(%.100r)" % (i, expected, vals))
   13:             self.assertEqual(actual, expected)
       
    1:         from random import random, gauss, shuffle
 1001:         for j in xrange(1000):
 1000:             vals = [7, 1e100, -7, -1e100, -9e-20, 8e-20] * 10
 1000:             s = 0
201000:             for i in xrange(200):
200000:                 v = gauss(0, random()) ** 7 - s
200000:                 s += v
200000:                 vals.append(v)
 1000:             shuffle(vals)
       
 1000:             s = msum(vals)
 1000:             self.assertEqual(msum(vals), math.fsum(vals))
       
    2:     def testHypot(self):
    1:         self.assertRaises(TypeError, math.hypot)
    1:         self.ftest('hypot(0,0)', math.hypot(0,0), 0)
    1:         self.ftest('hypot(3,4)', math.hypot(3,4), 5)
    1:         self.assertEqual(math.hypot(NAN, INF), INF)
    1:         self.assertEqual(math.hypot(INF, NAN), INF)
    1:         self.assertEqual(math.hypot(NAN, NINF), INF)
    1:         self.assertEqual(math.hypot(NINF, NAN), INF)
    1:         self.assertTrue(math.isnan(math.hypot(1.0, NAN)))
    1:         self.assertTrue(math.isnan(math.hypot(NAN, -2.0)))
       
    2:     def testLdexp(self):
    1:         self.assertRaises(TypeError, math.ldexp)
    1:         self.ftest('ldexp(0,1)', math.ldexp(0,1), 0)
    1:         self.ftest('ldexp(1,1)', math.ldexp(1,1), 2)
    1:         self.ftest('ldexp(1,-1)', math.ldexp(1,-1), 0.5)
    1:         self.ftest('ldexp(-1,1)', math.ldexp(-1,1), -2)
    1:         self.assertRaises(OverflowError, math.ldexp, 1., 1000000)
    1:         self.assertRaises(OverflowError, math.ldexp, -1., 1000000)
    1:         self.assertEqual(math.ldexp(1., -1000000), 0.)
    1:         self.assertEqual(math.ldexp(-1., -1000000), -0.)
    1:         self.assertEqual(math.ldexp(INF, 30), INF)
    1:         self.assertEqual(math.ldexp(NINF, -213), NINF)
    1:         self.assertTrue(math.isnan(math.ldexp(NAN, 0)))
       
               # large second argument
    7:         for n in [10**5, 10L**5, 10**10, 10L**10, 10**20, 10**40]:
    6:             self.assertEqual(math.ldexp(INF, -n), INF)
    6:             self.assertEqual(math.ldexp(NINF, -n), NINF)
    6:             self.assertEqual(math.ldexp(1., -n), 0.)
    6:             self.assertEqual(math.ldexp(-1., -n), -0.)
    6:             self.assertEqual(math.ldexp(0., -n), 0.)
    6:             self.assertEqual(math.ldexp(-0., -n), -0.)
    6:             self.assertTrue(math.isnan(math.ldexp(NAN, -n)))
       
    6:             self.assertRaises(OverflowError, math.ldexp, 1., n)
    6:             self.assertRaises(OverflowError, math.ldexp, -1., n)
    6:             self.assertEqual(math.ldexp(0., n), 0.)
    6:             self.assertEqual(math.ldexp(-0., n), -0.)
    6:             self.assertEqual(math.ldexp(INF, n), INF)
    6:             self.assertEqual(math.ldexp(NINF, n), NINF)
    6:             self.assertTrue(math.isnan(math.ldexp(NAN, n)))
       
    2:     def testLog(self):
    1:         self.assertRaises(TypeError, math.log)
    1:         self.ftest('log(1/e)', math.log(1/math.e), -1)
    1:         self.ftest('log(1)', math.log(1), 0)
    1:         self.ftest('log(e)', math.log(math.e), 1)
    1:         self.ftest('log(32,2)', math.log(32,2), 5)
    1:         self.ftest('log(10**40, 10)', math.log(10**40, 10), 40)
    1:         self.ftest('log(10**40, 10**20)', math.log(10**40, 10**20), 2)
    1:         self.assertEqual(math.log(INF), INF)
    1:         self.assertRaises(ValueError, math.log, NINF)
    1:         self.assertTrue(math.isnan(math.log(NAN)))
               # Log values should match for int and long (issue #18739).
 1000:         for n in range(1, 1000):
  999:             self.assertEqual(math.log(n), math.log(long(n)))
       
    2:     def testLog1p(self):
    1:         self.assertRaises(TypeError, math.log1p)
    1:         self.ftest('log1p(1/e -1)', math.log1p(1/math.e-1), -1)
    1:         self.ftest('log1p(0)', math.log1p(0), 0)
    1:         self.ftest('log1p(e-1)', math.log1p(math.e-1), 1)
    1:         self.ftest('log1p(1)', math.log1p(1), math.log(2))
    1:         self.assertEqual(math.log1p(INF), INF)
    1:         self.assertRaises(ValueError, math.log1p, NINF)
    1:         self.assertTrue(math.isnan(math.log1p(NAN)))
    1:         n= 2**90
    1:         self.assertAlmostEqual(math.log1p(n), 62.383246250395075)
    1:         self.assertAlmostEqual(math.log1p(n), math.log1p(float(n)))
       
    2:     def testLog10(self):
    1:         self.assertRaises(TypeError, math.log10)
    1:         self.ftest('log10(0.1)', math.log10(0.1), -1)
    1:         self.ftest('log10(1)', math.log10(1), 0)
    1:         self.ftest('log10(10)', math.log10(10), 1)
    1:         self.assertEqual(math.log(INF), INF)
    1:         self.assertRaises(ValueError, math.log10, NINF)
    1:         self.assertTrue(math.isnan(math.log10(NAN)))
               # Log values should match for int and long (issue #18739).
 1000:         for n in range(1, 1000):
  999:             self.assertEqual(math.log10(n), math.log10(long(n)))
       
    2:     def testModf(self):
    1:         self.assertRaises(TypeError, math.modf)
       
    1:         def testmodf(name, result, expected):
    2:             (v1, v2), (e1, e2) = result, expected
    2:             if abs(v1-e1) > eps or abs(v2-e2):
>>>>>>                 self.fail('%s returned %r, expected %r'%\
>>>>>>                           (name, (v1,v2), (e1,e2)))
       
    1:         testmodf('modf(1.5)', math.modf(1.5), (0.5, 1.0))
    1:         testmodf('modf(-1.5)', math.modf(-1.5), (-0.5, -1.0))
       
    1:         self.assertEqual(math.modf(INF), (0.0, INF))
    1:         self.assertEqual(math.modf(NINF), (-0.0, NINF))
       
    1:         modf_nan = math.modf(NAN)
    1:         self.assertTrue(math.isnan(modf_nan[0]))
    1:         self.assertTrue(math.isnan(modf_nan[1]))
       
    2:     def testPow(self):
    1:         self.assertRaises(TypeError, math.pow)
    1:         self.ftest('pow(0,1)', math.pow(0,1), 0)
    1:         self.ftest('pow(1,0)', math.pow(1,0), 1)
    1:         self.ftest('pow(2,1)', math.pow(2,1), 2)
    1:         self.ftest('pow(2,-1)', math.pow(2,-1), 0.5)
    1:         self.assertEqual(math.pow(INF, 1), INF)
    1:         self.assertEqual(math.pow(NINF, 1), NINF)
    1:         self.assertEqual((math.pow(1, INF)), 1.)
    1:         self.assertEqual((math.pow(1, NINF)), 1.)
    1:         self.assertTrue(math.isnan(math.pow(NAN, 1)))
    1:         self.assertTrue(math.isnan(math.pow(2, NAN)))
    1:         self.assertTrue(math.isnan(math.pow(0, NAN)))
    1:         self.assertEqual(math.pow(1, NAN), 1)
       
               # pow(0., x)
    1:         self.assertEqual(math.pow(0., INF), 0.)
    1:         self.assertEqual(math.pow(0., 3.), 0.)
    1:         self.assertEqual(math.pow(0., 2.3), 0.)
    1:         self.assertEqual(math.pow(0., 2.), 0.)
    1:         self.assertEqual(math.pow(0., 0.), 1.)
    1:         self.assertEqual(math.pow(0., -0.), 1.)
    1:         self.assertRaises(ValueError, math.pow, 0., -2.)
    1:         self.assertRaises(ValueError, math.pow, 0., -2.3)
    1:         self.assertRaises(ValueError, math.pow, 0., -3.)
    1:         self.assertRaises(ValueError, math.pow, 0., NINF)
    1:         self.assertTrue(math.isnan(math.pow(0., NAN)))
       
               # pow(INF, x)
    1:         self.assertEqual(math.pow(INF, INF), INF)
    1:         self.assertEqual(math.pow(INF, 3.), INF)
    1:         self.assertEqual(math.pow(INF, 2.3), INF)
    1:         self.assertEqual(math.pow(INF, 2.), INF)
    1:         self.assertEqual(math.pow(INF, 0.), 1.)
    1:         self.assertEqual(math.pow(INF, -0.), 1.)
    1:         self.assertEqual(math.pow(INF, -2.), 0.)
    1:         self.assertEqual(math.pow(INF, -2.3), 0.)
    1:         self.assertEqual(math.pow(INF, -3.), 0.)
    1:         self.assertEqual(math.pow(INF, NINF), 0.)
    1:         self.assertTrue(math.isnan(math.pow(INF, NAN)))
       
               # pow(-0., x)
    1:         self.assertEqual(math.pow(-0., INF), 0.)
    1:         self.assertEqual(math.pow(-0., 3.), -0.)
    1:         self.assertEqual(math.pow(-0., 2.3), 0.)
    1:         self.assertEqual(math.pow(-0., 2.), 0.)
    1:         self.assertEqual(math.pow(-0., 0.), 1.)
    1:         self.assertEqual(math.pow(-0., -0.), 1.)
    1:         self.assertRaises(ValueError, math.pow, -0., -2.)
    1:         self.assertRaises(ValueError, math.pow, -0., -2.3)
    1:         self.assertRaises(ValueError, math.pow, -0., -3.)
    1:         self.assertRaises(ValueError, math.pow, -0., NINF)
    1:         self.assertTrue(math.isnan(math.pow(-0., NAN)))
       
               # pow(NINF, x)
    1:         self.assertEqual(math.pow(NINF, INF), INF)
    1:         self.assertEqual(math.pow(NINF, 3.), NINF)
    1:         self.assertEqual(math.pow(NINF, 2.3), INF)
    1:         self.assertEqual(math.pow(NINF, 2.), INF)
    1:         self.assertEqual(math.pow(NINF, 0.), 1.)
    1:         self.assertEqual(math.pow(NINF, -0.), 1.)
    1:         self.assertEqual(math.pow(NINF, -2.), 0.)
    1:         self.assertEqual(math.pow(NINF, -2.3), 0.)
    1:         self.assertEqual(math.pow(NINF, -3.), -0.)
    1:         self.assertEqual(math.pow(NINF, NINF), 0.)
    1:         self.assertTrue(math.isnan(math.pow(NINF, NAN)))
       
               # pow(-1, x)
    1:         self.assertEqual(math.pow(-1., INF), 1.)
    1:         self.assertEqual(math.pow(-1., 3.), -1.)
    1:         self.assertRaises(ValueError, math.pow, -1., 2.3)
    1:         self.assertEqual(math.pow(-1., 2.), 1.)
    1:         self.assertEqual(math.pow(-1., 0.), 1.)
    1:         self.assertEqual(math.pow(-1., -0.), 1.)
    1:         self.assertEqual(math.pow(-1., -2.), 1.)
    1:         self.assertRaises(ValueError, math.pow, -1., -2.3)
    1:         self.assertEqual(math.pow(-1., -3.), -1.)
    1:         self.assertEqual(math.pow(-1., NINF), 1.)
    1:         self.assertTrue(math.isnan(math.pow(-1., NAN)))
       
               # pow(1, x)
    1:         self.assertEqual(math.pow(1., INF), 1.)
    1:         self.assertEqual(math.pow(1., 3.), 1.)
    1:         self.assertEqual(math.pow(1., 2.3), 1.)
    1:         self.assertEqual(math.pow(1., 2.), 1.)
    1:         self.assertEqual(math.pow(1., 0.), 1.)
    1:         self.assertEqual(math.pow(1., -0.), 1.)
    1:         self.assertEqual(math.pow(1., -2.), 1.)
    1:         self.assertEqual(math.pow(1., -2.3), 1.)
    1:         self.assertEqual(math.pow(1., -3.), 1.)
    1:         self.assertEqual(math.pow(1., NINF), 1.)
    1:         self.assertEqual(math.pow(1., NAN), 1.)
       
               # pow(x, 0) should be 1 for any x
    1:         self.assertEqual(math.pow(2.3, 0.), 1.)
    1:         self.assertEqual(math.pow(-2.3, 0.), 1.)
    1:         self.assertEqual(math.pow(NAN, 0.), 1.)
    1:         self.assertEqual(math.pow(2.3, -0.), 1.)
    1:         self.assertEqual(math.pow(-2.3, -0.), 1.)
    1:         self.assertEqual(math.pow(NAN, -0.), 1.)
       
               # pow(x, y) is invalid if x is negative and y is not integral
    1:         self.assertRaises(ValueError, math.pow, -1., 2.3)
    1:         self.assertRaises(ValueError, math.pow, -15., -3.1)
       
               # pow(x, NINF)
    1:         self.assertEqual(math.pow(1.9, NINF), 0.)
    1:         self.assertEqual(math.pow(1.1, NINF), 0.)
    1:         self.assertEqual(math.pow(0.9, NINF), INF)
    1:         self.assertEqual(math.pow(0.1, NINF), INF)
    1:         self.assertEqual(math.pow(-0.1, NINF), INF)
    1:         self.assertEqual(math.pow(-0.9, NINF), INF)
    1:         self.assertEqual(math.pow(-1.1, NINF), 0.)
    1:         self.assertEqual(math.pow(-1.9, NINF), 0.)
       
               # pow(x, INF)
    1:         self.assertEqual(math.pow(1.9, INF), INF)
    1:         self.assertEqual(math.pow(1.1, INF), INF)
    1:         self.assertEqual(math.pow(0.9, INF), 0.)
    1:         self.assertEqual(math.pow(0.1, INF), 0.)
    1:         self.assertEqual(math.pow(-0.1, INF), 0.)
    1:         self.assertEqual(math.pow(-0.9, INF), 0.)
    1:         self.assertEqual(math.pow(-1.1, INF), INF)
    1:         self.assertEqual(math.pow(-1.9, INF), INF)
       
               # pow(x, y) should work for x negative, y an integer
    1:         self.ftest('(-2.)**3.', math.pow(-2.0, 3.0), -8.0)
    1:         self.ftest('(-2.)**2.', math.pow(-2.0, 2.0), 4.0)
    1:         self.ftest('(-2.)**1.', math.pow(-2.0, 1.0), -2.0)
    1:         self.ftest('(-2.)**0.', math.pow(-2.0, 0.0), 1.0)
    1:         self.ftest('(-2.)**-0.', math.pow(-2.0, -0.0), 1.0)
    1:         self.ftest('(-2.)**-1.', math.pow(-2.0, -1.0), -0.5)
    1:         self.ftest('(-2.)**-2.', math.pow(-2.0, -2.0), 0.25)
    1:         self.ftest('(-2.)**-3.', math.pow(-2.0, -3.0), -0.125)
    1:         self.assertRaises(ValueError, math.pow, -2.0, -0.5)
    1:         self.assertRaises(ValueError, math.pow, -2.0, 0.5)
       
               # the following tests have been commented out since they don't
               # really belong here:  the implementation of ** for floats is
               # independent of the implementation of math.pow
               #self.assertEqual(1**NAN, 1)
               #self.assertEqual(1**INF, 1)
               #self.assertEqual(1**NINF, 1)
               #self.assertEqual(1**0, 1)
               #self.assertEqual(1.**NAN, 1)
               #self.assertEqual(1.**INF, 1)
               #self.assertEqual(1.**NINF, 1)
               #self.assertEqual(1.**0, 1)
       
    2:     def testRadians(self):
    1:         self.assertRaises(TypeError, math.radians)
    1:         self.ftest('radians(180)', math.radians(180), math.pi)
    1:         self.ftest('radians(90)', math.radians(90), math.pi/2)
    1:         self.ftest('radians(-45)', math.radians(-45), -math.pi/4)
       
    2:     def testSin(self):
    1:         self.assertRaises(TypeError, math.sin)
    1:         self.ftest('sin(0)', math.sin(0), 0)
    1:         self.ftest('sin(pi/2)', math.sin(math.pi/2), 1)
    1:         self.ftest('sin(-pi/2)', math.sin(-math.pi/2), -1)
    1:         try:
    1:             self.assertTrue(math.isnan(math.sin(INF)))
>>>>>>             self.assertTrue(math.isnan(math.sin(NINF)))
    1:         except ValueError:
    1:             self.assertRaises(ValueError, math.sin, INF)
    1:             self.assertRaises(ValueError, math.sin, NINF)
    1:         self.assertTrue(math.isnan(math.sin(NAN)))
       
    2:     def testSinh(self):
    1:         self.assertRaises(TypeError, math.sinh)
    1:         self.ftest('sinh(0)', math.sinh(0), 0)
    1:         self.ftest('sinh(1)**2-cosh(1)**2', math.sinh(1)**2-math.cosh(1)**2, -1)
    1:         self.ftest('sinh(1)+sinh(-1)', math.sinh(1)+math.sinh(-1), 0)
    1:         self.assertEqual(math.sinh(INF), INF)
    1:         self.assertEqual(math.sinh(NINF), NINF)
    1:         self.assertTrue(math.isnan(math.sinh(NAN)))
       
    2:     def testSqrt(self):
    1:         self.assertRaises(TypeError, math.sqrt)
    1:         self.ftest('sqrt(0)', math.sqrt(0), 0)
    1:         self.ftest('sqrt(1)', math.sqrt(1), 1)
    1:         self.ftest('sqrt(4)', math.sqrt(4), 2)
    1:         self.assertEqual(math.sqrt(INF), INF)
    1:         self.assertRaises(ValueError, math.sqrt, NINF)
    1:         self.assertTrue(math.isnan(math.sqrt(NAN)))
       
    2:     def testTan(self):
    1:         self.assertRaises(TypeError, math.tan)
    1:         self.ftest('tan(0)', math.tan(0), 0)
    1:         self.ftest('tan(pi/4)', math.tan(math.pi/4), 1)
    1:         self.ftest('tan(-pi/4)', math.tan(-math.pi/4), -1)
    1:         try:
    1:             self.assertTrue(math.isnan(math.tan(INF)))
>>>>>>             self.assertTrue(math.isnan(math.tan(NINF)))
    1:         except:
    1:             self.assertRaises(ValueError, math.tan, INF)
    1:             self.assertRaises(ValueError, math.tan, NINF)
    1:         self.assertTrue(math.isnan(math.tan(NAN)))
       
    2:     def testTanh(self):
    1:         self.assertRaises(TypeError, math.tanh)
    1:         self.ftest('tanh(0)', math.tanh(0), 0)
    1:         self.ftest('tanh(1)+tanh(-1)', math.tanh(1)+math.tanh(-1), 0)
    1:         self.ftest('tanh(inf)', math.tanh(INF), 1)
    1:         self.ftest('tanh(-inf)', math.tanh(NINF), -1)
    1:         self.assertTrue(math.isnan(math.tanh(NAN)))
               # check that tanh(-0.) == -0. on IEEE 754 systems
    1:         if float.__getformat__("double").startswith("IEEE"):
    1:             self.assertEqual(math.tanh(-0.), -0.)
    1:             self.assertEqual(math.copysign(1., math.tanh(-0.)),
    1:                              math.copysign(1., -0.))
       
    2:     def test_trunc(self):
    1:         self.assertEqual(math.trunc(1), 1)
    1:         self.assertEqual(math.trunc(-1), -1)
    1:         self.assertEqual(type(math.trunc(1)), int)
    1:         self.assertEqual(type(math.trunc(1.5)), int)
    1:         self.assertEqual(math.trunc(1.5), 1)
    1:         self.assertEqual(math.trunc(-1.5), -1)
    1:         self.assertEqual(math.trunc(1.999999), 1)
    1:         self.assertEqual(math.trunc(-1.999999), -1)
    1:         self.assertEqual(math.trunc(-0.999999), -0)
    1:         self.assertEqual(math.trunc(-100.999), -100)
       
    2:         class TestTrunc(object):
    1:             def __trunc__(self):
    1:                 return 23
       
    2:         class TestNoTrunc(object):
    1:             pass
       
    1:         self.assertEqual(math.trunc(TestTrunc()), 23)
       
    1:         self.assertRaises(TypeError, math.trunc)
    1:         self.assertRaises(TypeError, math.trunc, 1, 2)
    1:         self.assertRaises((AttributeError, TypeError), math.trunc,
    1:                           TestNoTrunc())
       
    2:     def testIsnan(self):
    1:         self.assertTrue(math.isnan(float("nan")))
    1:         self.assertTrue(math.isnan(float("inf")* 0.))
    1:         self.assertFalse(math.isnan(float("inf")))
    1:         self.assertFalse(math.isnan(0.))
    1:         self.assertFalse(math.isnan(1.))
       
    2:     def testIsinf(self):
    1:         self.assertTrue(math.isinf(float("inf")))
    1:         self.assertTrue(math.isinf(float("-inf")))
    1:         self.assertTrue(math.isinf(1E400))
    1:         self.assertTrue(math.isinf(-1E400))
    1:         self.assertFalse(math.isinf(float("nan")))
    1:         self.assertFalse(math.isinf(0.))
    1:         self.assertFalse(math.isinf(1.))
       
           # RED_FLAG 16-Oct-2000 Tim
           # While 2.0 is more consistent about exceptions than previous releases, it
           # still fails this part of the test on some platforms.  For now, we only
           # *run* test_exceptions() in verbose mode, so that this isn't normally
           # tested.
    2:     @unittest.skipUnless(verbose, 'requires verbose mode')
           def test_exceptions(self):
>>>>>>         try:
>>>>>>             x = math.exp(-1000000000)
>>>>>>         except:
                   # mathmodule.c is failing to weed out underflows from libm, or
                   # we've got an fp format with huge dynamic range
>>>>>>             self.fail("underflowing exp() should not have raised "
                               "an exception")
>>>>>>         if x != 0:
>>>>>>             self.fail("underflowing exp() should have returned 0")
       
               # If this fails, probably using a strict IEEE-754 conforming libm, and x
               # is +Inf afterwards.  But Python wants overflows detected by default.
>>>>>>         try:
>>>>>>             x = math.exp(1000000000)
>>>>>>         except OverflowError:
>>>>>>             pass
               else:
>>>>>>             self.fail("overflowing exp() didn't trigger OverflowError")
       
               # If this fails, it could be a puzzle.  One odd possibility is that
               # mathmodule.c's macros are getting confused while comparing
               # Inf (HUGE_VAL) to a NaN, and artificially setting errno to ERANGE
               # as a result (and so raising OverflowError instead).
>>>>>>         try:
>>>>>>             x = math.sqrt(-1.0)
>>>>>>         except ValueError:
>>>>>>             pass
               else:
>>>>>>             self.fail("sqrt(-1) didn't raise ValueError")
       
    2:     @requires_IEEE_754
           def test_testfile(self):
 1990:         for id, fn, ar, ai, er, ei, flags in parse_testfile(test_file):
                   # Skip if either the input or result is complex, or if
                   # flags is nonempty
 1989:             if ai != 0. or ei != 0. or flags:
   25:                 continue
  387:             if fn in ['rect', 'polar']:
                       # no real versions of rect, polar
   12:                 continue
  375:             func = getattr(math, fn)
  375:             try:
  375:                 result = func(ar)
>>>>>>             except ValueError:
>>>>>>                 message = ("Unexpected ValueError in " +
>>>>>>                            "test %s:%s(%r)\n" % (id, fn, ar))
>>>>>>                 self.fail(message)
>>>>>>             except OverflowError:
>>>>>>                 message = ("Unexpected OverflowError in " +
>>>>>>                            "test %s:%s(%r)\n" % (id, fn, ar))
>>>>>>                 self.fail(message)
  375:             self.ftest("%s:%s(%r)" % (id, fn, ar), result, er)
       
    2:     @unittest.skipUnless(float.__getformat__("double").startswith("IEEE"),
    2:                          "test requires IEEE 754 doubles")
           def test_mtestfile(self):
    1:         ALLOWED_ERROR = 20  # permitted error, in ulps
    1:         fail_fmt = "{}:{}({!r}): expected {!r}, got {!r}"
       
    1:         failures = []
  291:         for id, fn, arg, expected, flags in parse_mtestfile(math_testcases):
  290:             func = getattr(math, fn)
       
  290:             if 'invalid' in flags or 'divide-by-zero' in flags:
   14:                 expected = 'ValueError'
  276:             elif 'overflow' in flags:
   18:                 expected = 'OverflowError'
       
  290:             try:
  290:                 got = func(arg)
   32:             except ValueError:
   14:                 got = 'ValueError'
   18:             except OverflowError:
   18:                 got = 'OverflowError'
       
  290:             accuracy_failure = None
  290:             if isinstance(got, float) and isinstance(expected, float):
  258:                 if math.isnan(expected) and math.isnan(got):
    5:                     continue
  253:                 if not math.isnan(expected) and not math.isnan(got):
  253:                     if fn == 'lgamma':
                               # we use a weaker accuracy test for lgamma;
                               # lgamma only achieves an absolute error of
                               # a few multiples of the machine accuracy, in
                               # general.
   69:                         accuracy_failure = acc_check(expected, got,
   69:                                                   rel_err = 5e-15,
   69:                                                   abs_err = 5e-15)
  184:                     elif fn == 'erfc':
                               # erfc has less-than-ideal accuracy for large
                               # arguments (x ~ 25 or so), mainly due to the
                               # error involved in computing exp(-x*x).
                               #
                               # XXX Would be better to weaken this test only
                               # for large x, instead of for all x.
   43:                         accuracy_failure = ulps_check(expected, got, 2000)
       
                           else:
  141:                         accuracy_failure = ulps_check(expected, got, 20)
  253:                     if accuracy_failure is None:
  253:                         continue
       
   32:             if isinstance(got, str) and isinstance(expected, str):
   32:                 if got == expected:
   32:                     continue
       
>>>>>>             fail_msg = fail_fmt.format(id, fn, arg, expected, got)
>>>>>>             if accuracy_failure is not None:
>>>>>>                 fail_msg += ' ({})'.format(accuracy_failure)
>>>>>>             failures.append(fail_msg)
       
    1:         if failures:
>>>>>>             self.fail('Failures in test_mtestfile:\n  ' +
>>>>>>                       '\n  '.join(failures))
       
       
    2: def test_main():
    1:     from doctest import DocFileSuite
    1:     suite = unittest.TestSuite()
    1:     suite.addTest(unittest.makeSuite(MathTests))
    1:     suite.addTest(DocFileSuite("ieee754.txt"))
    1:     run_unittest(suite)
       
    2: if __name__ == '__main__':
>>>>>>     test_main()
