       # -*- coding: iso-8859-1 -*-
       #-------------------------------------------------------------------
       # tarfile.py
       #-------------------------------------------------------------------
       # Copyright (C) 2002 Lars Gustäbel <lars@gustaebel.de>
       # All rights reserved.
       #
       # Permission  is  hereby granted,  free  of charge,  to  any person
       # obtaining a  copy of  this software  and associated documentation
       # files  (the  "Software"),  to   deal  in  the  Software   without
       # restriction,  including  without limitation  the  rights to  use,
       # copy, modify, merge, publish, distribute, sublicense, and/or sell
       # copies  of  the  Software,  and to  permit  persons  to  whom the
       # Software  is  furnished  to  do  so,  subject  to  the  following
       # conditions:
       #
       # The above copyright  notice and this  permission notice shall  be
       # included in all copies or substantial portions of the Software.
       #
       # THE SOFTWARE IS PROVIDED "AS  IS", WITHOUT WARRANTY OF ANY  KIND,
       # EXPRESS OR IMPLIED, INCLUDING  BUT NOT LIMITED TO  THE WARRANTIES
       # OF  MERCHANTABILITY,  FITNESS   FOR  A  PARTICULAR   PURPOSE  AND
       # NONINFRINGEMENT.  IN  NO  EVENT SHALL  THE  AUTHORS  OR COPYRIGHT
       # HOLDERS  BE LIABLE  FOR ANY  CLAIM, DAMAGES  OR OTHER  LIABILITY,
       # WHETHER  IN AN  ACTION OF  CONTRACT, TORT  OR OTHERWISE,  ARISING
       # FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
       # OTHER DEALINGS IN THE SOFTWARE.
       #
       """Read from and write to tar format archives.
    1: """
       
    1: __version__ = "$Revision: 85213 $"
       # $Source$
       
    1: version     = "0.9.0"
    1: __author__  = "Lars Gustäbel (lars@gustaebel.de)"
    1: __date__    = "$Date$"
    1: __cvsid__   = "$Id$"
    1: __credits__ = "Gustavo Niemeyer, Niels Gustäbel, Richard Townsend."
       
       #---------
       # Imports
       #---------
    1: from __builtin__ import open as bltn_open
    1: import sys
    1: import os
    1: import shutil
    1: import stat
    1: import errno
    1: import time
    1: import struct
    1: import copy
    1: import re
    1: import operator
       
    1: try:
    1:     import grp, pwd
>>>>>> except ImportError:
>>>>>>     grp = pwd = None
       
       # from tarfile import *
    1: __all__ = ["TarFile", "TarInfo", "is_tarfile", "TarError"]
       
       #---------------------------------------------------------
       # tar constants
       #---------------------------------------------------------
    1: NUL = "\0"                      # the null character
    1: BLOCKSIZE = 512                 # length of processing blocks
    1: RECORDSIZE = BLOCKSIZE * 20     # length of records
    1: GNU_MAGIC = "ustar  \0"         # magic gnu tar string
    1: POSIX_MAGIC = "ustar\x0000"     # magic posix tar string
       
    1: LENGTH_NAME = 100               # maximum length of a filename
    1: LENGTH_LINK = 100               # maximum length of a linkname
    1: LENGTH_PREFIX = 155             # maximum length of the prefix field
       
    1: REGTYPE = "0"                   # regular file
    1: AREGTYPE = "\0"                 # regular file
    1: LNKTYPE = "1"                   # link (inside tarfile)
    1: SYMTYPE = "2"                   # symbolic link
    1: CHRTYPE = "3"                   # character special device
    1: BLKTYPE = "4"                   # block special device
    1: DIRTYPE = "5"                   # directory
    1: FIFOTYPE = "6"                  # fifo special device
    1: CONTTYPE = "7"                  # contiguous file
       
    1: GNUTYPE_LONGNAME = "L"          # GNU tar longname
    1: GNUTYPE_LONGLINK = "K"          # GNU tar longlink
    1: GNUTYPE_SPARSE = "S"            # GNU tar sparse file
       
    1: XHDTYPE = "x"                   # POSIX.1-2001 extended header
    1: XGLTYPE = "g"                   # POSIX.1-2001 global header
    1: SOLARIS_XHDTYPE = "X"           # Solaris extended header
       
    1: USTAR_FORMAT = 0                # POSIX.1-1988 (ustar) format
    1: GNU_FORMAT = 1                  # GNU tar format
    1: PAX_FORMAT = 2                  # POSIX.1-2001 (pax) format
    1: DEFAULT_FORMAT = GNU_FORMAT
       
       #---------------------------------------------------------
       # tarfile constants
       #---------------------------------------------------------
       # File types that tarfile supports:
    1: SUPPORTED_TYPES = (REGTYPE, AREGTYPE, LNKTYPE,
    1:                    SYMTYPE, DIRTYPE, FIFOTYPE,
    1:                    CONTTYPE, CHRTYPE, BLKTYPE,
    1:                    GNUTYPE_LONGNAME, GNUTYPE_LONGLINK,
    1:                    GNUTYPE_SPARSE)
       
       # File types that will be treated as a regular file.
    1: REGULAR_TYPES = (REGTYPE, AREGTYPE,
    1:                  CONTTYPE, GNUTYPE_SPARSE)
       
       # File types that are part of the GNU tar format.
    1: GNU_TYPES = (GNUTYPE_LONGNAME, GNUTYPE_LONGLINK,
    1:              GNUTYPE_SPARSE)
       
       # Fields from a pax header that override a TarInfo attribute.
    1: PAX_FIELDS = ("path", "linkpath", "size", "mtime",
    1:               "uid", "gid", "uname", "gname")
       
       # Fields in a pax header that are numbers, all other fields
       # are treated as strings.
    1: PAX_NUMBER_FIELDS = {
    1:     "atime": float,
    1:     "ctime": float,
    1:     "mtime": float,
    1:     "uid": int,
    1:     "gid": int,
    1:     "size": int
       }
       
       #---------------------------------------------------------
       # Bits used in the mode field, values in octal.
       #---------------------------------------------------------
    1: S_IFLNK = 0120000        # symbolic link
    1: S_IFREG = 0100000        # regular file
    1: S_IFBLK = 0060000        # block device
    1: S_IFDIR = 0040000        # directory
    1: S_IFCHR = 0020000        # character device
    1: S_IFIFO = 0010000        # fifo
       
    1: TSUID   = 04000          # set UID on execution
    1: TSGID   = 02000          # set GID on execution
    1: TSVTX   = 01000          # reserved
       
    1: TUREAD  = 0400           # read by owner
    1: TUWRITE = 0200           # write by owner
    1: TUEXEC  = 0100           # execute/search by owner
    1: TGREAD  = 0040           # read by group
    1: TGWRITE = 0020           # write by group
    1: TGEXEC  = 0010           # execute/search by group
    1: TOREAD  = 0004           # read by other
    1: TOWRITE = 0002           # write by other
    1: TOEXEC  = 0001           # execute/search by other
       
       #---------------------------------------------------------
       # initialization
       #---------------------------------------------------------
    1: ENCODING = sys.getfilesystemencoding()
    1: if ENCODING is None:
>>>>>>     ENCODING = sys.getdefaultencoding()
       
       #---------------------------------------------------------
       # Some useful functions
       #---------------------------------------------------------
       
    1: def stn(s, length):
           """Convert a python string to a null-terminated string buffer.
           """
 2774:     return s[:length] + (length - len(s)) * NUL
       
    1: def nts(s):
           """Convert a null-terminated string field to a python string.
           """
           # Use the string up to the first null char.
67358:     p = s.find("\0")
67358:     if p == -1:
 7245:         return s
60113:     return s[:p]
       
    1: def nti(s):
           """Convert a number field to a python number.
           """
           # There are two possible encodings for a number field, see
           # itn() below.
43191:     if s[0] != chr(0200):
43191:         try:
43191:             n = int(nts(s).strip() or "0", 8)
   18:         except ValueError:
   18:             raise InvalidHeaderError("invalid header")
           else:
>>>>>>         n = 0L
>>>>>>         for i in xrange(len(s) - 1):
>>>>>>             n <<= 8
>>>>>>             n += ord(s[i + 1])
43173:     return n
       
    1: def itn(n, digits=8, format=DEFAULT_FORMAT):
           """Convert a python number to a number field.
           """
           # POSIX 1003.1-1988 requires numbers to be encoded as a string of
           # octal digits followed by a null-byte, this allows values up to
           # (8**(digits-1))-1. GNU tar allows storing numbers greater than
           # that if necessary. A leading 0200 byte indicates this particular
           # encoding, the following digits-1 bytes are a big-endian
           # representation. This allows values up to (256**(digits-1))-1.
 3238:     if 0 <= n < 8 ** (digits - 1):
 3236:         s = "%0*o" % (digits - 1, n) + NUL
           else:
    2:         if format != GNU_FORMAT or n >= 256 ** (digits - 1):
    2:             raise ValueError("overflow in number field")
       
>>>>>>         if n < 0:
                   # XXX We mimic GNU tar's behaviour with negative numbers,
                   # this could raise OverflowError.
>>>>>>             n = struct.unpack("L", struct.pack("l", n))[0]
       
>>>>>>         s = ""
>>>>>>         for i in xrange(digits - 1):
>>>>>>             s = chr(n & 0377) + s
>>>>>>             n >>= 8
>>>>>>         s = chr(0200) + s
 3236:     return s
       
    1: def uts(s, encoding, errors):
           """Convert a unicode object to a string.
           """
 1593:     if errors == "utf-8":
               # An extra error handler similar to the -o invalid=UTF-8 option
               # in POSIX.1-2001. Replace untranslatable characters with their
               # UTF-8 representation.
 1542:         try:
 1542:             return s.encode(encoding, "strict")
    2:         except UnicodeEncodeError:
    2:             x = []
   10:             for c in s:
    8:                 try:
    8:                     x.append(c.encode(encoding, "strict"))
    4:                 except UnicodeEncodeError:
    4:                     x.append(c.encode("utf8"))
    2:             return "".join(x)
           else:
   51:         return s.encode(encoding, errors)
       
    1: def calc_chksums(buf):
           """Calculate the checksum for a member's header by summing up all
              characters except for the chksum field which is treated as if
              it was filled with spaces. According to the GNU tar sources,
              some tars (Sun and NeXT) calculate chksum with signed char,
              which will be different if there are chars in the buffer with
              the high bit set. So we calculate two checksums, unsigned and
              signed.
           """
 5238:     unsigned_chksum = 256 + sum(struct.unpack("148B", buf[:148]) + struct.unpack("356B", buf[156:512]))
 5238:     signed_chksum = 256 + sum(struct.unpack("148b", buf[:148]) + struct.unpack("356b", buf[156:512]))
 5238:     return unsigned_chksum, signed_chksum
       
    1: def copyfileobj(src, dst, length=None):
           """Copy length bytes from fileobj src to fileobj dst.
              If length is None, copy the entire content.
           """
  261:     if length == 0:
   51:         return
  210:     if length is None:
   42:         shutil.copyfileobj(src, dst)
   18:         return
       
  168:     BUFSIZE = 16 * 1024
  168:     blocks, remainder = divmod(length, BUFSIZE)
  168:     for b in xrange(blocks):
>>>>>>         buf = src.read(BUFSIZE)
>>>>>>         if len(buf) < BUFSIZE:
>>>>>>             raise IOError("end of file reached")
>>>>>>         dst.write(buf)
       
  168:     if remainder != 0:
  168:         buf = src.read(remainder)
  168:         if len(buf) < remainder:
>>>>>>             raise IOError("end of file reached")
  168:         dst.write(buf)
  168:     return
       
       filemode_table = (
    1:     ((S_IFLNK,      "l"),
    1:      (S_IFREG,      "-"),
    1:      (S_IFBLK,      "b"),
    1:      (S_IFDIR,      "d"),
    1:      (S_IFCHR,      "c"),
    1:      (S_IFIFO,      "p")),
       
    1:     ((TUREAD,       "r"),),
    1:     ((TUWRITE,      "w"),),
    1:     ((TUEXEC|TSUID, "s"),
    1:      (TSUID,        "S"),
    1:      (TUEXEC,       "x")),
       
    1:     ((TGREAD,       "r"),),
    1:     ((TGWRITE,      "w"),),
    1:     ((TGEXEC|TSGID, "s"),
    1:      (TSGID,        "S"),
    1:      (TGEXEC,       "x")),
       
    1:     ((TOREAD,       "r"),),
    1:     ((TOWRITE,      "w"),),
    1:     ((TOEXEC|TSVTX, "t"),
    1:      (TSVTX,        "T"),
    1:      (TOEXEC,       "x"))
       )
       
    1: def filemode(mode):
           """Convert a file's mode to a string of the form
              -rwxrwxrwx.
              Used by TarFile.list()
           """
   99:     perm = []
 1089:     for table in filemode_table:
 2571:         for bit, char in table:
 2061:             if mode & bit == bit:
  480:                 perm.append(char)
  480:                 break
               else:
  510:             perm.append("-")
   99:     return "".join(perm)
       
    2: class TarError(Exception):
    1:     """Base exception."""
    1:     pass
    2: class ExtractError(TarError):
    1:     """General exception for extract errors."""
    1:     pass
    2: class ReadError(TarError):
    1:     """Exception for unreadable tar archives."""
    1:     pass
    2: class CompressionError(TarError):
    1:     """Exception for unavailable compression methods."""
    1:     pass
    2: class StreamError(TarError):
    1:     """Exception for unsupported operations on stream-like TarFiles."""
    1:     pass
    2: class HeaderError(TarError):
    1:     """Base exception for header errors."""
    1:     pass
    2: class EmptyHeaderError(HeaderError):
    1:     """Exception for empty headers."""
    1:     pass
    2: class TruncatedHeaderError(HeaderError):
    1:     """Exception for truncated headers."""
    1:     pass
    2: class EOFHeaderError(HeaderError):
    1:     """Exception for end of file headers."""
    1:     pass
    2: class InvalidHeaderError(HeaderError):
    1:     """Exception for invalid headers."""
    1:     pass
    2: class SubsequentHeaderError(HeaderError):
    1:     """Exception for missing and invalid extended headers."""
    1:     pass
       
       #---------------------------
       # internal stream interface
       #---------------------------
    2: class _LowLevelFile:
           """Low-level file object. Supports reading and writing.
              It is used instead of a regular file object for streaming
              access.
    1:     """
       
    1:     def __init__(self, name, mode):
   96:         mode = {
   96:             "r": os.O_RDONLY,
   96:             "w": os.O_WRONLY | os.O_CREAT | os.O_TRUNC,
   96:         }[mode]
   96:         if hasattr(os, "O_BINARY"):
>>>>>>             mode |= os.O_BINARY
   96:         self.fd = os.open(name, mode, 0666)
       
    1:     def close(self):
   93:         os.close(self.fd)
       
    1:     def read(self, size):
  125:         return os.read(self.fd, size)
       
    1:     def write(self, s):
   96:         os.write(self.fd, s)
       
    2: class _Stream:
           """Class that serves as an adapter between TarFile and
              a stream-like object.  The stream-like object only
              needs to have a read() or write() method and is accessed
              blockwise.  Use of gzip or bzip2 compression is possible.
              A stream-like object could be for example: sys.stdin,
              sys.stdout, a socket, a tape device etc.
       
              _Stream is intended to be used only internally.
    1:     """
       
    1:     def __init__(self, name, mode, comptype, fileobj, bufsize):
               """Construct a _Stream object.
               """
  105:         self._extfileobj = True
  105:         if fileobj is None:
   96:             fileobj = _LowLevelFile(name, mode)
   93:             self._extfileobj = False
       
  102:         if comptype == '*':
                   # Enable transparent compression detection for the
                   # stream interface
    7:             fileobj = _StreamProxy(fileobj)
    7:             comptype = fileobj.getcomptype()
       
  102:         self.name     = name or ""
  102:         self.mode     = mode
  102:         self.comptype = comptype
  102:         self.fileobj  = fileobj
  102:         self.bufsize  = bufsize
  102:         self.buf      = ""
  102:         self.pos      = 0L
  102:         self.closed   = False
       
  102:         try:
  102:             if comptype == "gz":
   41:                 try:
   41:                     import zlib
>>>>>>                 except ImportError:
>>>>>>                     raise CompressionError("zlib module is not available")
   41:                 self.zlib = zlib
   41:                 self.crc = zlib.crc32("") & 0xffffffffL
   41:                 if mode == "r":
   16:                     self._init_read_gz()
                       else:
   25:                     self._init_write_gz()
       
   61:             elif comptype == "bz2":
   22:                 try:
   22:                     import bz2
>>>>>>                 except ImportError:
>>>>>>                     raise CompressionError("bz2 module is not available")
   22:                 if mode == "r":
   17:                     self.dbuf = ""
   17:                     self.cmp = bz2.BZ2Decompressor()
                       else:
    5:                     self.cmp = bz2.BZ2Compressor()
    3:         except:
    3:             if not self._extfileobj:
    3:                 self.fileobj.close()
    3:             self.closed = True
    3:             raise
       
    1:     def __del__(self):
   97:         if hasattr(self, "closed") and not self.closed:
>>>>>>             self.close()
       
    1:     def _init_write_gz(self):
               """Initialize for writing with gzip compression.
               """
   25:         self.cmp = self.zlib.compressobj(9, self.zlib.DEFLATED,
   25:                                             -self.zlib.MAX_WBITS,
   25:                                             self.zlib.DEF_MEM_LEVEL,
   25:                                             0)
   25:         timestamp = struct.pack("<L", long(time.time()))
   25:         self.__write("\037\213\010\010%s\002\377" % timestamp)
   25:         if type(self.name) is unicode:
    5:             self.name = self.name.encode("iso-8859-1", "replace")
   25:         if self.name.endswith(".gz"):
   20:             self.name = self.name[:-3]
   25:         self.__write(self.name + NUL)
       
    1:     def write(self, s):
               """Write string s to the stream.
               """
  543:         if self.comptype == "gz":
  306:             self.crc = self.zlib.crc32(s, self.crc) & 0xffffffffL
  543:         self.pos += len(s)
  543:         if self.comptype != "tar":
  317:             s = self.cmp.compress(s)
  543:         self.__write(s)
       
    1:     def __write(self, s):
               """Write string s to the stream if a whole new block
                  is ready to be written.
               """
  593:         self.buf += s
  593:         while len(self.buf) > self.bufsize:
>>>>>>             self.fileobj.write(self.buf[:self.bufsize])
>>>>>>             self.buf = self.buf[self.bufsize:]
       
    1:     def close(self):
               """Close the _Stream object. No operation should be
                  done on it afterwards.
               """
   99:         if self.closed:
>>>>>>             return
       
   99:         self.closed = True
   99:         try:
   99:             if self.mode == "w" and self.comptype != "tar":
   30:                 self.buf += self.cmp.flush()
       
   99:             if self.mode == "w" and self.buf:
   51:                 self.fileobj.write(self.buf)
   51:                 self.buf = ""
   51:                 if self.comptype == "gz":
                           # The native zlib crc is an unsigned 32-bit integer, but
                           # the Python wrapper implicitly casts that to a signed C
                           # long.  So, on a 32-bit box self.crc may "look negative",
                           # while the same crc on a 64-bit box may "look positive".
                           # To avoid irksome warnings from the `struct` module, force
                           # it to look positive on all boxes.
   25:                     self.fileobj.write(struct.pack("<L", self.crc & 0xffffffffL))
   25:                     self.fileobj.write(struct.pack("<L", self.pos & 0xffffFFFFL))
               finally:
   99:             if not self._extfileobj:
   90:                 self.fileobj.close()
       
    1:     def _init_read_gz(self):
               """Initialize for reading a gzip compressed fileobj.
               """
   16:         self.cmp = self.zlib.decompressobj(-self.zlib.MAX_WBITS)
   16:         self.dbuf = ""
       
               # taken from gzip.GzipFile with some alterations
   16:         if self.__read(2) != "\037\213":
    3:             raise ReadError("not a gzip file")
   13:         if self.__read(1) != "\010":
>>>>>>             raise CompressionError("unsupported compression method")
       
   13:         flag = ord(self.__read(1))
   13:         self.__read(6)
       
   13:         if flag & 4:
>>>>>>             xlen = ord(self.__read(1)) + 256 * ord(self.__read(1))
>>>>>>             self.read(xlen)
   13:         if flag & 8:
  243:             while True:
  243:                 s = self.__read(1)
  243:                 if not s or s == NUL:
   13:                     break
   13:         if flag & 16:
>>>>>>             while True:
>>>>>>                 s = self.__read(1)
>>>>>>                 if not s or s == NUL:
>>>>>>                     break
   13:         if flag & 2:
>>>>>>             self.__read(2)
       
    1:     def tell(self):
               """Return the stream's file pointer position.
               """
  869:         return self.pos
       
    1:     def seek(self, pos=0):
               """Set the stream's file pointer to pos. Negative seeking
                  is forbidden.
               """
  201:         if pos - self.pos >= 0:
  198:             blocks, remainder = divmod(pos - self.pos, self.bufsize)
  231:             for i in xrange(blocks):
   33:                 self.read(self.bufsize)
  198:             self.read(remainder)
               else:
    3:             raise StreamError("seeking backwards is not allowed")
  198:         return self.pos
       
    1:     def read(self, size=None):
               """Return the next size number of bytes from the stream.
                  If size is not defined, return all bytes of the stream
                  up to EOF.
               """
  813:         if size is None:
>>>>>>             t = []
>>>>>>             while True:
>>>>>>                 buf = self._read(self.bufsize)
>>>>>>                 if not buf:
>>>>>>                     break
>>>>>>                 t.append(buf)
>>>>>>             buf = "".join(t)
               else:
  813:             buf = self._read(size)
  811:         self.pos += len(buf)
  811:         return buf
       
    1:     def _read(self, size):
               """Return size bytes from the stream.
               """
  813:         if self.comptype == "tar":
  273:             return self.__read(size)
       
  540:         c = len(self.dbuf)
  540:         t = [self.dbuf]
  569:         while c < size:
   32:             buf = self.__read(self.bufsize)
   32:             if not buf:
    1:                 break
   31:             try:
   31:                 buf = self.cmp.decompress(buf)
    2:             except IOError:
    2:                 raise ReadError("invalid compressed data")
   29:             t.append(buf)
   29:             c += len(buf)
  538:         t = "".join(t)
  538:         self.dbuf = t[size:]
  538:         return t[:size]
       
    1:     def __read(self, size):
               """Return size bytes from stream. If internal buffer is empty,
                  read another block from the stream.
               """
  603:         c = len(self.buf)
  603:         t = [self.buf]
  720:         while c < size:
  136:             buf = self.fileobj.read(self.bufsize)
  136:             if not buf:
   19:                 break
  117:             t.append(buf)
  117:             c += len(buf)
  603:         t = "".join(t)
  603:         self.buf = t[size:]
  603:         return t[:size]
       # class _Stream
       
    2: class _StreamProxy(object):
           """Small proxy class that enables transparent compression
              detection for the Stream interface (mode 'r|*').
    1:     """
       
    1:     def __init__(self, fileobj):
    7:         self.fileobj = fileobj
    7:         self.buf = self.fileobj.read(BLOCKSIZE)
       
    1:     def read(self, size):
    7:         self.read = self.fileobj.read
    7:         return self.buf
       
    1:     def getcomptype(self):
    7:         if self.buf.startswith("\037\213\010"):
    2:             return "gz"
    5:         if self.buf[0:3] == "BZh" and self.buf[4:10] == "1AY&SY":
    3:             return "bz2"
    2:         return "tar"
       
    1:     def close(self):
    4:         self.fileobj.close()
       # class StreamProxy
       
    2: class _BZ2Proxy(object):
           """Small proxy class that enables external file object
              support for "r:bz2" and "w:bz2" modes. This is actually
              a workaround for a limitation in bz2 module's BZ2File
              class which (unlike gzip.GzipFile) has no support for
              a file object argument.
    1:     """
       
    1:     blocksize = 16 * 1024
       
    1:     def __init__(self, fileobj, mode):
  199:         self.fileobj = fileobj
  199:         self.mode = mode
  199:         self.name = getattr(self.fileobj, "name", None)
  199:         self.init()
       
    1:     def init(self):
  199:         import bz2
  199:         self.pos = 0
  199:         if self.mode == "r":
  195:             self.bz2obj = bz2.BZ2Decompressor()
  195:             self.fileobj.seek(0)
  195:             self.buf = ""
               else:
    4:             self.bz2obj = bz2.BZ2Compressor()
       
    1:     def read(self, size):
  195:         b = [self.buf]
  195:         x = len(self.buf)
  375:         while x < size:
  347:             raw = self.fileobj.read(self.blocksize)
  347:             if not raw:
  154:                 break
  193:             data = self.bz2obj.decompress(raw)
  180:             b.append(data)
  180:             x += len(data)
  182:         self.buf = "".join(b)
       
  182:         buf = self.buf[:size]
  182:         self.buf = self.buf[size:]
  182:         self.pos += len(buf)
  182:         return buf
       
    1:     def seek(self, pos):
>>>>>>         if pos < self.pos:
>>>>>>             self.init()
>>>>>>         self.read(pos - self.pos)
       
    1:     def tell(self):
  450:         return self.pos
       
    1:     def write(self, data):
    6:         self.pos += len(data)
    6:         raw = self.bz2obj.compress(data)
    6:         self.fileobj.write(raw)
       
    1:     def close(self):
  174:         if self.mode == "w":
    4:             raw = self.bz2obj.flush()
    4:             self.fileobj.write(raw)
       # class _BZ2Proxy
       
       #------------------------
       # Extraction file object
       #------------------------
    2: class _FileInFile(object):
           """A thin wrapper around an existing file object that
              provides a part of its data as an individual file
              object.
    1:     """
       
    1:     def __init__(self, fileobj, offset, size, sparse=None):
  252:         self.fileobj = fileobj
  252:         self.offset = offset
  252:         self.size = size
  252:         self.sparse = sparse
  252:         self.position = 0
       
    1:     def tell(self):
               """Return the current file position.
               """
>>>>>>         return self.position
       
    1:     def seek(self, position):
               """Seek to a position in the file.
               """
   33:         self.position = position
       
    1:     def read(self, size=None):
               """Read data from the file.
               """
  348:         if size is None:
  176:             size = self.size - self.position
               else:
  172:             size = min(size, self.size - self.position)
       
  348:         if self.sparse is None:
  341:             return self.readnormal(size)
               else:
    7:             return self.readsparse(size)
       
    1:     def __read(self, size):
  408:         buf = self.fileobj.read(size)
  408:         if len(buf) != size:
   48:             raise ReadError("unexpected end of data")
  360:         return buf
       
    1:     def readnormal(self, size):
               """Read operation for regular files.
               """
  341:         self.fileobj.seek(self.offset + self.position)
  338:         self.position += size
  338:         return self.__read(size)
       
    1:     def readsparse(self, size):
               """Read operation for sparse files.
               """
    7:         data = []
  154:         while size > 0:
  147:             buf = self.readsparsesection(size)
  147:             if not buf:
>>>>>>                 break
  147:             size -= len(buf)
  147:             data.append(buf)
    7:         return "".join(data)
       
    1:     def readsparsesection(self, size):
               """Read a single section of a sparse file.
               """
  147:         section = self.sparse.find(self.position)
       
  147:         if section is None:
>>>>>>             return ""
       
  147:         size = min(size, section.offset + section.size - self.position)
       
  147:         if isinstance(section, _data):
   70:             realpos = section.realpos + self.position - section.offset
   70:             self.fileobj.seek(self.offset + realpos)
   70:             self.position += size
   70:             return self.__read(size)
               else:
   77:             self.position += size
   77:             return NUL * size
       #class _FileInFile
       
       
    2: class ExFileObject(object):
           """File-like object for reading an archive member.
              Is returned by TarFile.extractfile().
    1:     """
    1:     blocksize = 1024
       
    1:     def __init__(self, tarfile, tarinfo):
  252:         self.fileobj = _FileInFile(tarfile.fileobj,
  252:                                    tarinfo.offset_data,
  252:                                    tarinfo.size,
  252:                                    getattr(tarinfo, "sparse", None))
  252:         self.name = tarinfo.name
  252:         self.mode = "r"
  252:         self.closed = False
  252:         self.size = tarinfo.size
       
  252:         self.position = 0
  252:         self.buffer = ""
       
    1:     def read(self, size=None):
               """Read at most size bytes from the file. If size is not
                  present or None, read all data until EOF is reached.
               """
  243:         if self.closed:
>>>>>>             raise ValueError("I/O operation on closed file")
       
  243:         buf = ""
  243:         if self.buffer:
    3:             if size is None:
    3:                 buf = self.buffer
    3:                 self.buffer = ""
                   else:
>>>>>>                 buf = self.buffer[:size]
>>>>>>                 self.buffer = self.buffer[size:]
       
  243:         if size is None:
  176:             buf += self.fileobj.read()
               else:
   67:             buf += self.fileobj.read(size - len(buf))
       
  192:         self.position += len(buf)
  192:         return buf
       
    1:     def readline(self, size=-1):
               """Read one entire line from the file. If size is present
                  and non-negative, return a string with at most that
                  size, which may be an incomplete line.
               """
 1335:         if self.closed:
>>>>>>             raise ValueError("I/O operation on closed file")
       
 1335:         if "\n" in self.buffer:
 1230:             pos = self.buffer.find("\n") + 1
               else:
  105:             buffers = [self.buffer]
  105:             while True:
  105:                 buf = self.fileobj.read(self.blocksize)
  105:                 buffers.append(buf)
  105:                 if not buf or "\n" in buf:
  105:                     self.buffer = "".join(buffers)
  105:                     pos = self.buffer.find("\n") + 1
  105:                     if pos == 0:
                               # no newline found.
   12:                         pos = len(self.buffer)
  105:                     break
       
 1335:         if size != -1:
>>>>>>             pos = min(size, pos)
       
 1335:         buf = self.buffer[:pos]
 1335:         self.buffer = self.buffer[pos:]
 1335:         self.position += len(buf)
 1335:         return buf
       
    1:     def readlines(self):
               """Return a list with all remaining lines.
               """
    9:         result = []
  981:         while True:
  981:             line = self.readline()
  981:             if not line: break
  972:             result.append(line)
    9:         return result
       
    1:     def tell(self):
               """Return the current file position.
               """
   24:         if self.closed:
>>>>>>             raise ValueError("I/O operation on closed file")
       
   24:         return self.position
       
    1:     def seek(self, pos, whence=os.SEEK_SET):
               """Seek to a position in the file.
               """
   33:         if self.closed:
>>>>>>             raise ValueError("I/O operation on closed file")
       
   33:         if whence == os.SEEK_SET:
   21:             self.position = min(max(pos, 0), self.size)
   12:         elif whence == os.SEEK_CUR:
    6:             if pos < 0:
    3:                 self.position = max(self.position + pos, 0)
                   else:
    3:                 self.position = min(self.position + pos, self.size)
    6:         elif whence == os.SEEK_END:
    6:             self.position = max(min(self.size + pos, self.size), 0)
               else:
>>>>>>             raise ValueError("Invalid argument")
       
   33:         self.buffer = ""
   33:         self.fileobj.seek(self.position)
       
    1:     def close(self):
               """Close the file object.
               """
   45:         self.closed = True
       
    1:     def __iter__(self):
               """Get an iterator over the file's lines.
               """
  345:         while True:
  345:             line = self.readline()
  345:             if not line:
    3:                 break
  342:             yield line
       #class ExFileObject
       
       #------------------
       # Exported Classes
       #------------------
    2: class TarInfo(object):
           """Informational class which holds the details about an
              archive member given by a tar header block.
              TarInfo objects are returned by TarFile.getmember(),
              TarFile.getmembers() and TarFile.gettarinfo() and are
              usually created internally.
    1:     """
       
    1:     def __init__(self, name=""):
               """Construct a TarInfo object. name is the optional name
                  of the member.
               """
 5213:         self.name = name        # member name
 5213:         self.mode = 0644        # file permissions
 5213:         self.uid = 0            # user id
 5213:         self.gid = 0            # group id
 5213:         self.size = 0           # file size
 5213:         self.mtime = 0          # modification time
 5213:         self.chksum = 0         # header checksum
 5213:         self.type = REGTYPE     # member type
 5213:         self.linkname = ""      # link name
 5213:         self.uname = ""         # user name
 5213:         self.gname = ""         # group name
 5213:         self.devmajor = 0       # device major number
 5213:         self.devminor = 0       # device minor number
       
 5213:         self.offset = 0         # the tar header starts here
 5213:         self.offset_data = 0    # the file's data starts here
       
 5213:         self.pax_headers = {}   # pax header information
       
           # In pax headers the "name" and "linkname" field are called
           # "path" and "linkpath".
    1:     def _getpath(self):
>>>>>>         return self.name
    1:     def _setpath(self, name):
  308:         self.name = name
    1:     path = property(_getpath, _setpath)
       
    1:     def _getlinkpath(self):
>>>>>>         return self.linkname
    1:     def _setlinkpath(self, linkname):
  104:         self.linkname = linkname
    1:     linkpath = property(_getlinkpath, _setlinkpath)
       
    1:     def __repr__(self):
>>>>>>         return "<%s %r at %#x>" % (self.__class__.__name__,self.name,id(self))
       
    1:     def get_info(self, encoding, errors):
               """Return the TarInfo's attributes as a dictionary.
               """
  428:         info = {
  428:             "name":     self.name,
  428:             "mode":     self.mode & 07777,
  428:             "uid":      self.uid,
  428:             "gid":      self.gid,
  428:             "size":     self.size,
  428:             "mtime":    self.mtime,
  428:             "chksum":   self.chksum,
  428:             "type":     self.type,
  428:             "linkname": self.linkname,
  428:             "uname":    self.uname,
  428:             "gname":    self.gname,
  428:             "devmajor": self.devmajor,
  428:             "devminor": self.devminor
               }
       
  428:         if info["type"] == DIRTYPE and not info["name"].endswith("/"):
  108:             info["name"] += "/"
       
 2122:         for key in ("name", "linkname", "uname", "gname"):
 1700:             if type(info[key]) is unicode:
   28:                 info[key] = info[key].encode(encoding, errors)
       
  422:         return info
       
    1:     def tobuf(self, format=DEFAULT_FORMAT, encoding=ENCODING, errors="strict"):
               """Return a tar header as a string of 512 byte blocks.
               """
  428:         info = self.get_info(encoding, errors)
       
  422:         if format == USTAR_FORMAT:
   13:             return self.create_ustar_header(info)
  409:         elif format == GNU_FORMAT:
  387:             return self.create_gnu_header(info)
   22:         elif format == PAX_FORMAT:
   22:             return self.create_pax_header(info, encoding, errors)
               else:
>>>>>>             raise ValueError("invalid format")
       
    1:     def create_ustar_header(self, info):
               """Return the object as a ustar header block.
               """
   13:         info["magic"] = POSIX_MAGIC
       
   13:         if len(info["linkname"]) > LENGTH_LINK:
    1:             raise ValueError("linkname is too long")
       
   12:         if len(info["name"]) > LENGTH_NAME:
    4:             info["prefix"], info["name"] = self._posix_split_name(info["name"])
       
    9:         return self._create_header(info, USTAR_FORMAT)
       
    1:     def create_gnu_header(self, info):
               """Return the object as a GNU header block sequence.
               """
  387:         info["magic"] = GNU_MAGIC
       
  387:         buf = ""
  387:         if len(info["linkname"]) > LENGTH_LINK:
   13:             buf += self._create_gnu_long_header(info["linkname"], GNUTYPE_LONGLINK)
       
  387:         if len(info["name"]) > LENGTH_NAME:
    7:             buf += self._create_gnu_long_header(info["name"], GNUTYPE_LONGNAME)
       
  387:         return buf + self._create_header(info, GNU_FORMAT)
       
    1:     def create_pax_header(self, info, encoding, errors):
               """Return the object as a ustar header block. If it cannot be
                  represented this way, prepend a pax extended header sequence
                  with supplement information.
               """
   22:         info["magic"] = POSIX_MAGIC
   22:         pax_headers = self.pax_headers.copy()
       
               # Test string fields for values that exceed the field length or cannot
               # be represented in ASCII encoding.
   22:         for name, hname, length in (
   22:                 ("name", "path", LENGTH_NAME), ("linkname", "linkpath", LENGTH_LINK),
  106:                 ("uname", "uname", 32), ("gname", "gname", 32)):
       
   85:             if hname in pax_headers:
                       # The pax header has priority.
    3:                 continue
       
   82:             val = info[name].decode(encoding, errors)
       
                   # Try to encode the string as ASCII.
   81:             try:
   81:                 val.encode("ascii")
    7:             except UnicodeEncodeError:
    7:                 pax_headers[hname] = val
    7:                 continue
       
   74:             if len(info[name]) > length:
   14:                 pax_headers[hname] = val
       
               # Test number fields for values that exceed the field limit or values
               # that like to be stored as float.
  105:         for name, digits in (("uid", 8), ("gid", 8), ("size", 12), ("mtime", 12)):
   84:             if name in pax_headers:
                       # The pax header has priority. Avoid overflow.
    1:                 info[name] = 0
    1:                 continue
       
   83:             val = info[name]
   83:             if not 0 <= val < 8 ** (digits - 1) or isinstance(val, float):
    1:                 pax_headers[name] = unicode(val)
    1:                 info[name] = 0
       
               # Create a pax extended header if necessary.
   21:         if pax_headers:
   20:             buf = self._create_pax_generic_header(pax_headers)
               else:
    1:             buf = ""
       
   21:         return buf + self._create_header(info, USTAR_FORMAT)
       
    1:     @classmethod
           def create_pax_global_header(cls, pax_headers):
               """Return the object as a pax global header block sequence.
               """
    7:         return cls._create_pax_generic_header(pax_headers, type=XGLTYPE)
       
    1:     def _posix_split_name(self, name):
               """Split a name longer than 100 chars into a prefix
                  and a name part.
               """
    4:         prefix = name[:LENGTH_PREFIX + 1]
  109:         while prefix and prefix[-1] != "/":
  105:             prefix = prefix[:-1]
       
    4:         name = name[len(prefix):]
    4:         prefix = prefix[:-1]
       
    4:         if not prefix or len(name) > LENGTH_NAME:
    3:             raise ValueError("name is too long")
    1:         return prefix, name
       
    1:     @staticmethod
           def _create_header(info, format):
               """Return a header block. info is a dictionary with file
                  information, format must be one of the *_FORMAT constants.
               """
               parts = [
  464:             stn(info.get("name", ""), 100),
  464:             itn(info.get("mode", 0) & 07777, 8, format),
  464:             itn(info.get("uid", 0), 8, format),
  462:             itn(info.get("gid", 0), 8, format),
  462:             itn(info.get("size", 0), 12, format),
  462:             itn(info.get("mtime", 0), 12, format),
  462:             "        ", # checksum field
  462:             info.get("type", REGTYPE),
  462:             stn(info.get("linkname", ""), 100),
  462:             stn(info.get("magic", POSIX_MAGIC), 8),
  462:             stn(info.get("uname", ""), 32),
  462:             stn(info.get("gname", ""), 32),
  462:             itn(info.get("devmajor", 0), 8, format),
  462:             itn(info.get("devminor", 0), 8, format),
  462:             stn(info.get("prefix", ""), 155)
               ]
       
  462:         buf = struct.pack("%ds" % BLOCKSIZE, "".join(parts))
  462:         chksum = calc_chksums(buf[-BLOCKSIZE:])[0]
  462:         buf = buf[:-364] + "%06o\0" % chksum + buf[-357:]
  462:         return buf
       
    1:     @staticmethod
           def _create_payload(payload):
               """Return the string payload filled with zero bytes
                  up to the next 512 byte border.
               """
   47:         blocks, remainder = divmod(len(payload), BLOCKSIZE)
   47:         if remainder > 0:
   43:             payload += (BLOCKSIZE - remainder) * NUL
   47:         return payload
       
    1:     @classmethod
           def _create_gnu_long_header(cls, name, type):
               """Return a GNUTYPE_LONGNAME or GNUTYPE_LONGLINK sequence
                  for name.
               """
   20:         name += NUL
       
   20:         info = {}
   20:         info["name"] = "././@LongLink"
   20:         info["type"] = type
   20:         info["size"] = len(name)
   20:         info["magic"] = GNU_MAGIC
       
               # create extended header + name blocks.
   20:         return cls._create_header(info, USTAR_FORMAT) + \
   20:                 cls._create_payload(name)
       
    1:     @classmethod
    1:     def _create_pax_generic_header(cls, pax_headers, type=XHDTYPE):
               """Return a POSIX.1-2001 extended or global header sequence
                  that contains a list of keyword, value pairs. The values
                  must be unicode objects.
               """
   27:         records = []
   64:         for keyword, value in pax_headers.iteritems():
   37:             keyword = keyword.encode("utf8")
   37:             value = value.encode("utf8")
   37:             l = len(keyword) + len(value) + 3   # ' ' + '=' + '\n'
   37:             n = p = 0
  110:             while True:
  110:                 n = l + len(str(p))
  110:                 if n == p:
   37:                     break
   73:                 p = n
   37:             records.append("%d %s=%s\n" % (p, keyword, value))
   27:         records = "".join(records)
       
               # We use a hardcoded "././@PaxHeader" name like star does
               # instead of the one that POSIX recommends.
   27:         info = {}
   27:         info["name"] = "././@PaxHeader"
   27:         info["type"] = type
   27:         info["size"] = len(records)
   27:         info["magic"] = POSIX_MAGIC
       
               # Create pax header + record blocks.
   27:         return cls._create_header(info, USTAR_FORMAT) + \
   27:                 cls._create_payload(records)
       
    1:     @classmethod
           def frombuf(cls, buf):
               """Construct a TarInfo object from a 512 byte string buffer.
               """
 5250:         if len(buf) == 0:
  191:             raise EmptyHeaderError("empty header")
 5059:         if len(buf) != BLOCKSIZE:
   78:             raise TruncatedHeaderError("truncated header")
 4981:         if buf.count(NUL) == BLOCKSIZE:
  187:             raise EOFHeaderError("end of file header")
       
 4794:         chksum = nti(buf[148:156])
 4776:         if chksum not in calc_chksums(buf):
    5:             raise InvalidHeaderError("bad checksum")
       
 4771:         obj = cls()
 4771:         obj.buf = buf
 4771:         obj.name = nts(buf[0:100])
 4771:         obj.mode = nti(buf[100:108])
 4771:         obj.uid = nti(buf[108:116])
 4771:         obj.gid = nti(buf[116:124])
 4771:         obj.size = nti(buf[124:136])
 4771:         obj.mtime = nti(buf[136:148])
 4771:         obj.chksum = chksum
 4771:         obj.type = buf[156:157]
 4771:         obj.linkname = nts(buf[157:257])
 4771:         obj.uname = nts(buf[265:297])
 4771:         obj.gname = nts(buf[297:329])
 4771:         obj.devmajor = nti(buf[329:337])
 4771:         obj.devminor = nti(buf[337:345])
 4771:         prefix = nts(buf[345:500])
       
               # Old V7 tar format represents a directory as a regular
               # file with a trailing slash.
 4771:         if obj.type == AREGTYPE and obj.name.endswith("/"):
   98:             obj.type = DIRTYPE
       
               # Remove redundant slashes from directories.
 4771:         if obj.isdir():
  352:             obj.name = obj.name.rstrip("/")
       
               # Reconstruct a ustar longname.
 4771:         if prefix and obj.type not in GNU_TYPES:
  196:             obj.name = prefix + "/" + obj.name
 4771:         return obj
       
    1:     @classmethod
           def fromtarfile(cls, tarfile):
               """Return the next TarInfo object from TarFile object
                  tarfile.
               """
 5703:         buf = tarfile.fileobj.read(BLOCKSIZE)
 5248:         obj = cls.frombuf(buf)
 4769:         obj.offset = tarfile.fileobj.tell() - BLOCKSIZE
 4769:         return obj._proc_member(tarfile)
       
           #--------------------------------------------------------------------------
           # The following are methods that are called depending on the type of a
           # member. The entry point is _proc_member() which can be overridden in a
           # subclass to add custom _proc_*() methods. A _proc_*() method MUST
           # implement the following
           # operations:
           # 1. Set self.offset_data to the position where the data blocks begin,
           #    if there is data that follows.
           # 2. Set tarfile.offset to the position where the next member's header will
           #    begin.
           # 3. Return self or another valid TarInfo object.
    1:     def _proc_member(self, tarfile):
               """Choose the right processing method depending on
                  the type and call it.
               """
 4769:         if self.type in (GNUTYPE_LONGNAME, GNUTYPE_LONGLINK):
  313:             return self._proc_gnulong(tarfile)
 4456:         elif self.type == GNUTYPE_SPARSE:
   98:             return self._proc_sparse(tarfile)
 4358:         elif self.type in (XHDTYPE, XGLTYPE, SOLARIS_XHDTYPE):
  806:             return self._proc_pax(tarfile)
               else:
 3552:             return self._proc_builtin(tarfile)
       
    1:     def _proc_builtin(self, tarfile):
               """Process a builtin type or an unknown type which
                  will be treated as a regular file.
               """
 3552:         self.offset_data = tarfile.fileobj.tell()
 3552:         offset = self.offset_data
 3552:         if self.isreg() or self.type not in SUPPORTED_TYPES:
                   # Skip the following data blocks.
 2199:             offset += self._block(self.size)
 3552:         tarfile.offset = offset
       
               # Patch the TarInfo object with saved global
               # header information.
 3552:         self._apply_pax_info(tarfile.pax_headers, tarfile.encoding, tarfile.errors)
       
 3552:         return self
       
    1:     def _proc_gnulong(self, tarfile):
               """Process the blocks that hold a GNU longname
                  or longlink member.
               """
  313:         buf = tarfile.fileobj.read(self._block(self.size))
       
               # Fetch the next header and process it.
  313:         try:
  313:             next = self.fromtarfile(tarfile)
    1:         except HeaderError:
    1:             raise SubsequentHeaderError("missing or bad subsequent header")
       
               # Patch the TarInfo object from the next header with
               # the longname information.
  312:         next.offset = self.offset
  312:         if self.type == GNUTYPE_LONGNAME:
  202:             next.name = nts(buf)
  110:         elif self.type == GNUTYPE_LONGLINK:
  110:             next.linkname = nts(buf)
       
  312:         return next
       
    1:     def _proc_sparse(self, tarfile):
               """Process a GNU sparse header plus extra headers.
               """
   98:         buf = self.buf
   98:         sp = _ringbuffer()
   98:         pos = 386
   98:         lastpos = 0L
   98:         realpos = 0L
               # There are 4 possible sparse structs in the
               # first header.
  490:         for i in xrange(4):
  392:             try:
  392:                 offset = nti(buf[pos:pos + 12])
  392:                 numbytes = nti(buf[pos + 12:pos + 24])
>>>>>>             except ValueError:
>>>>>>                 break
  392:             if offset > lastpos:
  392:                 sp.append(_hole(lastpos, offset - lastpos))
  392:             sp.append(_data(offset, numbytes, realpos))
  392:             realpos += numbytes
  392:             lastpos = offset + numbytes
  392:             pos += 24
       
   98:         isextended = ord(buf[482])
   98:         origsize = nti(buf[483:495])
       
               # If the isextended flag is given,
               # there are extra headers to process.
  196:         while isextended == 1:
   98:             buf = tarfile.fileobj.read(BLOCKSIZE)
   98:             pos = 0
 2156:             for i in xrange(21):
 2058:                 try:
 2058:                     offset = nti(buf[pos:pos + 12])
 2058:                     numbytes = nti(buf[pos + 12:pos + 24])
>>>>>>                 except ValueError:
>>>>>>                     break
 2058:                 if offset > lastpos:
  686:                     sp.append(_hole(lastpos, offset - lastpos))
 2058:                 sp.append(_data(offset, numbytes, realpos))
 2058:                 realpos += numbytes
 2058:                 lastpos = offset + numbytes
 2058:                 pos += 24
   98:             isextended = ord(buf[504])
       
   98:         if lastpos < origsize:
   98:             sp.append(_hole(lastpos, origsize - lastpos))
       
   98:         self.sparse = sp
       
   98:         self.offset_data = tarfile.fileobj.tell()
   98:         tarfile.offset = self.offset_data + self._block(self.size)
   98:         self.size = origsize
       
   98:         return self
       
    1:     def _proc_pax(self, tarfile):
               """Process an extended or global header as described in
                  POSIX.1-2001.
               """
               # Read the header information.
  806:         buf = tarfile.fileobj.read(self._block(self.size))
       
               # A pax header stores supplemental information for either
               # the following file (extended) or all following files
               # (global).
  806:         if self.type == XGLTYPE:
  295:             pax_headers = tarfile.pax_headers
               else:
  511:             pax_headers = tarfile.pax_headers.copy()
       
               # Parse pax header information. A record looks like that:
               # "%d %s=%s\n" % (length, keyword, value). length is the size
               # of the complete record including the length field itself and
               # the newline. keyword and value are both UTF-8 encoded strings.
  806:         regex = re.compile(r"(\d+) ([^=]+)=", re.U)
  806:         pos = 0
 3291:         while True:
 3291:             match = regex.match(buf, pos)
 3291:             if not match:
  806:                 break
       
 2485:             length, keyword = match.groups()
 2485:             length = int(length)
 2485:             value = buf[match.end(2) + 1:match.start(1) + length - 1]
       
 2485:             keyword = keyword.decode("utf8")
 2485:             value = value.decode("utf8")
       
 2485:             pax_headers[keyword] = value
 2485:             pos += length
       
               # Fetch the next header.
  806:         try:
  806:             next = self.fromtarfile(tarfile)
    1:         except HeaderError:
    1:             raise SubsequentHeaderError("missing or bad subsequent header")
       
  805:         if self.type in (XHDTYPE, SOLARIS_XHDTYPE):
                   # Patch the TarInfo object with the extended header info.
  510:             next._apply_pax_info(pax_headers, tarfile.encoding, tarfile.errors)
  509:             next.offset = self.offset
       
  509:             if "size" in pax_headers:
                       # If the extended header replaces the size field,
                       # we need to recalculate the offset where the next
                       # header starts.
   98:                 offset = next.offset_data
   98:                 if next.isreg() or next.type not in SUPPORTED_TYPES:
   98:                     offset += next._block(next.size)
   98:                 tarfile.offset = offset
       
  804:         return next
       
    1:     def _apply_pax_info(self, pax_headers, encoding, errors):
               """Replace fields with supplemental information from a previous
                  pax extended or global header.
               """
 7718:         for keyword, value in pax_headers.iteritems():
 3657:             if keyword not in PAX_FIELDS:
 1375:                 continue
       
 2282:             if keyword == "path":
  309:                 value = value.rstrip("/")
       
 2282:             if keyword in PAX_NUMBER_FIELDS:
  689:                 try:
  689:                     value = PAX_NUMBER_FIELDS[keyword](value)
>>>>>>                 except ValueError:
>>>>>>                     value = 0
                   else:
 1593:                 value = uts(value, encoding, errors)
       
 2281:             setattr(self, keyword, value)
       
 4061:         self.pax_headers = pax_headers.copy()
       
    1:     def _block(self, count):
               """Round up a byte count by BLOCKSIZE and return it,
                  e.g. _block(834) => 1024.
               """
 3514:         blocks, remainder = divmod(count, BLOCKSIZE)
 3514:         if remainder:
 2947:             blocks += 1
 3514:         return blocks * BLOCKSIZE
       
    1:     def isreg(self):
 4351:         return self.type in REGULAR_TYPES
    1:     def isfile(self):
>>>>>>         return self.isreg()
    1:     def isdir(self):
 5236:         return self.type == DIRTYPE
    1:     def issym(self):
  381:         return self.type == SYMTYPE
    1:     def islnk(self):
  417:         return self.type == LNKTYPE
    1:     def ischr(self):
  114:         return self.type == CHRTYPE
    1:     def isblk(self):
  111:         return self.type == BLKTYPE
    1:     def isfifo(self):
   15:         return self.type == FIFOTYPE
    1:     def issparse(self):
>>>>>>         return self.type == GNUTYPE_SPARSE
    1:     def isdev(self):
>>>>>>         return self.type in (CHRTYPE, BLKTYPE, FIFOTYPE)
       # class TarInfo
       
    2: class TarFile(object):
           """The TarFile Class provides an interface to tar archives.
    1:     """
       
    1:     debug = 0                   # May be set from 0 (no msgs) to 3 (all msgs)
       
    1:     dereference = False         # If true, add content of linked file to the
                                       # tar file, else the link.
       
    1:     ignore_zeros = False        # If true, skips empty or invalid blocks and
                                       # continues processing.
       
    1:     errorlevel = 1              # If 0, fatal errors only appear in debug
                                       # messages (if debug >= 0). If > 0, errors
                                       # are passed to the caller as exceptions.
       
    1:     format = DEFAULT_FORMAT     # The format to use when creating an archive.
       
    1:     encoding = ENCODING         # Encoding for 8-bit character strings.
       
    1:     errors = None               # Error handler for unicode conversion.
       
    1:     tarinfo = TarInfo           # The default TarInfo class to use.
       
    1:     fileobject = ExFileObject   # The default ExFileObject class to use.
       
    1:     def __init__(self, name=None, mode="r", fileobj=None, format=None,
    1:             tarinfo=None, dereference=None, ignore_zeros=None, encoding=None,
    1:             errors=None, pax_headers=None, debug=None, errorlevel=None):
               """Open an (uncompressed) tar archive `name'. `mode' is either 'r' to
                  read from an existing archive, 'a' to append data to an existing
                  file or 'w' to create a new file overwriting an existing one. `mode'
                  defaults to 'r'.
                  If `fileobj' is given, it is used for reading or writing data. If it
                  can be determined, `mode' is overridden by `fileobj's mode.
                  `fileobj' is not closed, when TarFile is closed.
               """
 1379:         modes = {"r": "rb", "a": "r+b", "w": "wb"}
 1379:         if mode not in modes:
>>>>>>             raise ValueError("mode must be 'r', 'a' or 'w'")
 1379:         self.mode = mode
 1379:         self._mode = modes[mode]
       
 1379:         if not fileobj:
  336:             if self.mode == "a" and not os.path.exists(name):
                       # Create nonexistent files in append mode.
    1:                 self.mode = "w"
    1:                 self._mode = "wb"
  336:             fileobj = bltn_open(name, self._mode)
  335:             self._extfileobj = False
               else:
 1043:             if name is None and hasattr(fileobj, "name"):
  280:                 name = fileobj.name
 1043:             if hasattr(fileobj, "mode"):
  942:                 self._mode = fileobj.mode
 1043:             self._extfileobj = True
 1378:         self.name = os.path.abspath(name) if name else None
 1378:         self.fileobj = fileobj
       
               # Init attributes.
 1378:         if format is not None:
   49:             self.format = format
 1378:         if tarinfo is not None:
>>>>>>             self.tarinfo = tarinfo
 1378:         if dereference is not None:
>>>>>>             self.dereference = dereference
 1378:         if ignore_zeros is not None:
   30:             self.ignore_zeros = ignore_zeros
 1378:         if encoding is not None:
  279:             self.encoding = encoding
       
 1378:         if errors is not None:
   36:             self.errors = errors
 1342:         elif mode == "r":
 1117:             self.errors = "utf-8"
               else:
  225:             self.errors = "strict"
       
 1378:         if pax_headers is not None and self.format == PAX_FORMAT:
    7:             self.pax_headers = pax_headers
               else:
 1371:             self.pax_headers = {}
       
 1378:         if debug is not None:
>>>>>>             self.debug = debug
 1378:         if errorlevel is not None:
    9:             self.errorlevel = errorlevel
       
               # Init datastructures.
 1378:         self.closed = False
 1378:         self.members = []       # list of members as TarInfo objects
 1378:         self._loaded = False    # flag if all members have been read
 1378:         self.offset = self.fileobj.tell()
                                       # current position in the archive file
 1378:         self.inodes = {}        # dictionary caching the inodes of
                                       # archive members already added
       
 1378:         try:
 1378:             if self.mode == "r":
 1141:                 self.firstmember = None
 1141:                 self.firstmember = self.next()
       
  661:             if self.mode == "a":
                       # Move to the end of the archive,
                       # before the first empty block.
   15:                 while True:
   15:                     self.fileobj.seek(self.offset)
   15:                     try:
   15:                         tarinfo = self.tarinfo.fromtarfile(self)
    4:                         self.members.append(tarinfo)
   11:                     except EOFHeaderError:
    4:                         self.fileobj.seek(self.offset)
    4:                         break
    7:                     except HeaderError, e:
    7:                         raise ReadError(str(e))
       
  654:             if self.mode in "aw":
  230:                 self._loaded = True
       
  230:                 if self.pax_headers:
    7:                     buf = self.tarinfo.create_pax_global_header(self.pax_headers.copy())
    7:                     self.fileobj.write(buf)
    1:                     self.offset += len(buf)
  730:         except:
  730:             if not self._extfileobj:
   22:                 self.fileobj.close()
  730:             self.closed = True
  730:             raise
       
    1:     def _getposix(self):
>>>>>>         return self.format == USTAR_FORMAT
    1:     def _setposix(self, value):
>>>>>>         import warnings
>>>>>>         warnings.warn("use the format attribute instead", DeprecationWarning,
>>>>>>                       2)
>>>>>>         if value:
>>>>>>             self.format = USTAR_FORMAT
               else:
>>>>>>             self.format = GNU_FORMAT
    1:     posix = property(_getposix, _setposix)
       
           #--------------------------------------------------------------------------
           # Below are the classmethods which act as alternate constructors to the
           # TarFile class. The open() method is the only one that is needed for
           # public use; it is the "super"-constructor and is able to select an
           # adequate "sub"-constructor for a particular compression using the mapping
           # from OPEN_METH.
           #
           # This concept allows one to subclass TarFile without losing the comfort of
           # the super-constructor. A sub-constructor is registered and made available
           # by adding it to the mapping in OPEN_METH.
       
    1:     @classmethod
    1:     def open(cls, name=None, mode="r", fileobj=None, bufsize=RECORDSIZE, **kwargs):
               """Open a tar archive for reading, writing or appending. Return
                  an appropriate TarFile class.
       
                  mode:
                  'r' or 'r:*' open for reading with transparent compression
                  'r:'         open for reading exclusively uncompressed
                  'r:gz'       open for reading with gzip compression
                  'r:bz2'      open for reading with bzip2 compression
                  'a' or 'a:'  open for appending, creating the file if necessary
                  'w' or 'w:'  open for writing without compression
                  'w:gz'       open for writing with gzip compression
                  'w:bz2'      open for writing with bzip2 compression
       
                  'r|*'        open a stream of tar blocks with transparent compression
                  'r|'         open an uncompressed stream of tar blocks for reading
                  'r|gz'       open a gzip compressed stream of tar blocks
                  'r|bz2'      open a bzip2 compressed stream of tar blocks
                  'w|'         open an uncompressed stream for writing
                  'w|gz'       open a gzip compressed stream for writing
                  'w|bz2'      open a bzip2 compressed stream for writing
               """
       
  859:         if not name and not fileobj:
>>>>>>             raise ValueError("nothing to open")
       
  859:         if mode in ("r", "r:*"):
                   # Find out which *open() is appropriate for opening the file.
  318:             def not_compressed(comptype):
  954:                 return cls.OPEN_METH[comptype] == 'taropen'
  931:             for comptype in sorted(cls.OPEN_METH, key=not_compressed):
  846:                 func = getattr(cls, cls.OPEN_METH[comptype])
  846:                 if fileobj is not None:
  295:                     saved_pos = fileobj.tell()
  846:                 try:
  846:                     return func(name, "r", fileobj, **kwargs)
  614:                 except (ReadError, CompressionError), e:
  613:                     if fileobj is not None:
  270:                         fileobj.seek(saved_pos)
>>>>>>                     continue
   85:             raise ReadError("file could not be opened successfully")
       
  541:         elif ":" in mode:
  369:             filemode, comptype = mode.split(":", 1)
  369:             filemode = filemode or "r"
  369:             comptype = comptype or "tar"
       
                   # Select the *open() function according to
                   # given compression.
  369:             if comptype in cls.OPEN_METH:
  369:                 func = getattr(cls, cls.OPEN_METH[comptype])
                   else:
>>>>>>                 raise CompressionError("unknown compression type %r" % comptype)
  369:             return func(name, filemode, fileobj, **kwargs)
       
  172:         elif "|" in mode:
  105:             filemode, comptype = mode.split("|", 1)
  105:             filemode = filemode or "r"
  105:             comptype = comptype or "tar"
       
  105:             if filemode not in ("r", "w"):
>>>>>>                 raise ValueError("mode must be 'r' or 'w'")
       
  105:             stream = _Stream(name, filemode, comptype, fileobj, bufsize)
   99:             try:
   99:                 t = cls(name, filemode, stream, **kwargs)
    8:             except:
    8:                 stream.close()
    8:                 raise
   91:             t._extfileobj = False
   91:             return t
       
   67:         elif mode in ("a", "w"):
   67:             return cls.taropen(name, mode, fileobj, **kwargs)
       
>>>>>>         raise ValueError("undiscernible mode")
       
    1:     @classmethod
    1:     def taropen(cls, name, mode="r", fileobj=None, **kwargs):
               """Open uncompressed tar archive name for reading or writing.
               """
 1280:         if mode not in ("r", "a", "w"):
    3:             raise ValueError("mode must be 'r', 'a' or 'w'")
 1277:         return cls(name, mode, fileobj, **kwargs)
       
    1:     @classmethod
    1:     def gzopen(cls, name, mode="r", fileobj=None, compresslevel=9, **kwargs):
               """Open gzip compressed tar archive name for reading or writing.
                  Appending is not allowed.
               """
  397:         if mode not in ("r", "w"):
    3:             raise ValueError("mode must be 'r' or 'w'")
       
  394:         try:
  394:             import gzip
  394:             gzip.GzipFile
>>>>>>         except (ImportError, AttributeError):
>>>>>>             raise CompressionError("gzip module is not available")
       
  394:         try:
  394:             fileobj = gzip.GzipFile(name, mode, compresslevel, fileobj)
    4:         except OSError:
>>>>>>             if fileobj is not None and mode == 'r':
>>>>>>                 raise ReadError("not a gzip file")
>>>>>>             raise
       
  390:         try:
  390:             t = cls.taropen(name, mode, fileobj, **kwargs)
  288:         except IOError:
  280:             fileobj.close()
  280:             if mode == 'r':
  280:                 raise ReadError("not a gzip file")
>>>>>>             raise
    8:         except:
    8:             fileobj.close()
    8:             raise
  102:         t._extfileobj = False
  102:         return t
       
    1:     @classmethod
    1:     def bz2open(cls, name, mode="r", fileobj=None, compresslevel=9, **kwargs):
               """Open bzip2 compressed tar archive name for reading or writing.
                  Appending is not allowed.
               """
  449:         if mode not in ("r", "w"):
    3:             raise ValueError("mode must be 'r' or 'w'.")
       
  446:         try:
  446:             import bz2
>>>>>>         except ImportError:
>>>>>>             raise CompressionError("bz2 module is not available")
       
  446:         if fileobj is not None:
  199:             fileobj = _BZ2Proxy(fileobj, mode)
               else:
  247:             fileobj = bz2.BZ2File(name, mode, compresslevel=compresslevel)
       
  445:         try:
  445:             t = cls.taropen(name, mode, fileobj, **kwargs)
  330:         except (IOError, EOFError):
  175:             fileobj.close()
  175:             if mode == 'r':
  173:                 raise ReadError("not a bzip2 file")
    2:             raise
  155:         except:
  155:             fileobj.close()
  155:             raise
  115:         t._extfileobj = False
  115:         return t
       
           # All *open() methods are registered here.
    1:     OPEN_METH = {
    1:         "tar": "taropen",   # uncompressed tar
    1:         "gz":  "gzopen",    # gzip compressed tar
    1:         "bz2": "bz2open"    # bzip2 compressed tar
           }
       
           #--------------------------------------------------------------------------
           # The public methods which TarFile provides:
       
    1:     def close(self):
               """Close the TarFile. In write-mode, two finishing zero blocks are
                  appended to the archive.
               """
  603:         if self.closed:
>>>>>>             return
       
  603:         self.closed = True
  603:         try:
  603:             if self.mode in "aw":
  222:                 self.fileobj.write(NUL * (BLOCKSIZE * 2))
  222:                 self.offset += (BLOCKSIZE * 2)
                       # fill up the end with zero-blocks
                       # (like option -b20 for tar does)
  222:                 blocks, remainder = divmod(self.offset, RECORDSIZE)
  222:                 if remainder > 0:
  222:                     self.fileobj.write(NUL * (RECORDSIZE - remainder))
               finally:
  603:             if not self._extfileobj:
  586:                 self.fileobj.close()
       
    1:     def getmember(self, name):
               """Return a TarInfo object for member `name'. If `name' can not be
                  found in the archive, KeyError is raised. If a member occurs more
                  than once in the archive, its last occurrence is assumed to be the
                  most up-to-date version.
               """
  103:         tarinfo = self._getmember(name)
  103:         if tarinfo is None:
>>>>>>             raise KeyError("filename %r not found" % name)
  103:         return tarinfo
       
    1:     def getmembers(self):
               """Return the members of the archive as a list of TarInfo objects. The
                  list has the same order as the members in the archive.
               """
  218:         self._check()
  218:         if not self._loaded:    # if we want to obtain a list of
  137:             self._load()        # all members, we first have to
                                       # scan the whole archive.
  218:         return self.members
       
    1:     def getnames(self):
               """Return the members of the archive as a list of their names. It has
                  the same order as the list returned by getmembers().
               """
  162:         return [tarinfo.name for tarinfo in self.getmembers()]
       
    1:     def gettarinfo(self, name=None, arcname=None, fileobj=None):
               """Create a TarInfo object from the result of os.stat or equivalent
                  on an existing file. The file is either named by `name', or
                  specified as a file object `fileobj' with a file descriptor. If
                  given, `arcname' specifies an alternative name for the file in the
                  archive, otherwise, the name is taken from the 'name' attribute of
                  'fileobj', or the 'name' argument.
               """
  335:         self._check("aw")
       
               # When fileobj is given, replace name by
               # fileobj's real name.
  335:         if fileobj is not None:
>>>>>>             name = fileobj.name
       
               # Building the name of the member in the archive.
               # Backward slashes are converted to forward slashes,
               # Absolute paths are turned to relative paths.
  335:         if arcname is None:
   21:             arcname = name
  335:         drv, arcname = os.path.splitdrive(arcname)
  335:         arcname = arcname.replace(os.sep, "/")
  335:         arcname = arcname.lstrip("/")
       
               # Now, fill the TarInfo object with
               # information specific for the file.
  335:         tarinfo = self.tarinfo()
  335:         tarinfo.tarfile = self  # Not needed
       
               # Use os.stat or os.lstat, depending on platform
               # and if symlinks shall be resolved.
  335:         if fileobj is None:
  335:             if hasattr(os, "lstat") and not self.dereference:
  334:                 statres = os.lstat(name)
                   else:
    1:                 statres = os.stat(name)
               else:
>>>>>>             statres = os.fstat(fileobj.fileno())
  335:         linkname = ""
       
  335:         stmd = statres.st_mode
  335:         if stat.S_ISREG(stmd):
  212:             inode = (statres.st_ino, statres.st_dev)
  212:             if not self.dereference and statres.st_nlink > 1 and \
   58:                     inode in self.inodes and arcname != self.inodes[inode]:
                       # Is it a hardlink to an already
                       # archived file?
    7:                 type = LNKTYPE
    7:                 linkname = self.inodes[inode]
                   else:
                       # The inode is added only if its valid.
                       # For win32 it is always 0.
  205:                 type = REGTYPE
  205:                 if inode[0]:
  205:                     self.inodes[inode] = arcname
  123:         elif stat.S_ISDIR(stmd):
  114:             type = DIRTYPE
    9:         elif stat.S_ISFIFO(stmd):
>>>>>>             type = FIFOTYPE
    9:         elif stat.S_ISLNK(stmd):
    9:             type = SYMTYPE
    9:             linkname = os.readlink(name)
>>>>>>         elif stat.S_ISCHR(stmd):
>>>>>>             type = CHRTYPE
>>>>>>         elif stat.S_ISBLK(stmd):
>>>>>>             type = BLKTYPE
               else:
>>>>>>             return None
       
               # Fill the TarInfo object with all
               # information we can get.
  335:         tarinfo.name = arcname
  335:         tarinfo.mode = stmd
  335:         tarinfo.uid = statres.st_uid
  335:         tarinfo.gid = statres.st_gid
  335:         if type == REGTYPE:
  205:             tarinfo.size = statres.st_size
               else:
  130:             tarinfo.size = 0L
  335:         tarinfo.mtime = statres.st_mtime
  335:         tarinfo.type = type
  335:         tarinfo.linkname = linkname
  335:         if pwd:
  335:             try:
  335:                 tarinfo.uname = pwd.getpwuid(tarinfo.uid)[0]
>>>>>>             except KeyError:
>>>>>>                 pass
  335:         if grp:
  335:             try:
  335:                 tarinfo.gname = grp.getgrgid(tarinfo.gid)[0]
>>>>>>             except KeyError:
>>>>>>                 pass
       
  335:         if type in (CHRTYPE, BLKTYPE):
>>>>>>             if hasattr(os, "major") and hasattr(os, "minor"):
>>>>>>                 tarinfo.devmajor = os.major(statres.st_rdev)
>>>>>>                 tarinfo.devminor = os.minor(statres.st_rdev)
  335:         return tarinfo
       
    1:     def list(self, verbose=True):
               """Print a table of contents to sys.stdout. If `verbose' is False, only
                  the names of the members are printed. If it is True, an `ls -l'-like
                  output is produced.
               """
    6:         self._check()
       
  204:         for tarinfo in self:
  198:             if verbose:
   99:                 print filemode(tarinfo.mode),
   99:                 print "%s/%s" % (tarinfo.uname or tarinfo.uid,
   99:                                  tarinfo.gname or tarinfo.gid),
   99:                 if tarinfo.ischr() or tarinfo.isblk():
    6:                     print "%10s" % ("%d,%d" \
    6:                                     % (tarinfo.devmajor, tarinfo.devminor)),
                       else:
   93:                     print "%10d" % tarinfo.size,
   99:                 print "%d-%02d-%02d %02d:%02d:%02d" \
   99:                       % time.localtime(tarinfo.mtime)[:6],
       
  198:             print tarinfo.name + ("/" if tarinfo.isdir() else ""),
       
  198:             if verbose:
   99:                 if tarinfo.issym():
    9:                     print "->", tarinfo.linkname,
   99:                 if tarinfo.islnk():
   12:                     print "link to", tarinfo.linkname,
  198:             print
       
    1:     def add(self, name, arcname=None, recursive=True, exclude=None, filter=None):
               """Add the file `name' to the archive. `name' may be any type of file
                  (directory, fifo, symbolic link, etc.). If given, `arcname'
                  specifies an alternative name for the file in the archive.
                  Directories are added recursively by default. This can be avoided by
                  setting `recursive' to False. `exclude' is a function that should
                  return True for each filename to be excluded. `filter' is a function
                  that expects a TarInfo object argument and returns the changed
                  TarInfo object, if it returns None the TarInfo object will be
                  excluded from the archive.
               """
  333:         self._check("aw")
       
  333:         if arcname is None:
   51:             arcname = name
       
               # Exclude pathnames.
  333:         if exclude is not None:
   12:             import warnings
   12:             warnings.warn("use the filter argument instead",
   12:                     DeprecationWarning, 2)
   12:             if exclude(name):
    9:                 self._dbg(2, "tarfile: Excluded %r" % name)
    9:                 return
       
               # Skip if somebody tries to archive the archive...
  324:         if self.name is not None and os.path.abspath(name) == self.name:
   10:             self._dbg(2, "tarfile: Skipped %r" % name)
   10:             return
       
  314:         self._dbg(1, name)
       
               # Create a TarInfo object from the file.
  314:         tarinfo = self.gettarinfo(name, arcname)
       
  314:         if tarinfo is None:
>>>>>>             self._dbg(1, "tarfile: Unsupported type %r" % name)
>>>>>>             return
       
               # Change or exclude the TarInfo object.
  314:         if filter is not None:
  214:             tarinfo = filter(tarinfo)
  214:             if tarinfo is None:
    3:                 self._dbg(2, "tarfile: Excluded %r" % name)
    3:                 return
       
               # Append the tar header and data to the archive.
  311:         if tarinfo.isreg():
  191:             with bltn_open(name, "rb") as f:
  191:                 self.addfile(tarinfo, f)
       
  120:         elif tarinfo.isdir():
  111:             self.addfile(tarinfo)
  111:             if recursive:
  324:                 for f in os.listdir(name):
  213:                     self.add(os.path.join(name, f), os.path.join(arcname, f),
  213:                             recursive, exclude, filter)
       
               else:
    9:             self.addfile(tarinfo)
       
    1:     def addfile(self, tarinfo, fileobj=None):
               """Add the TarInfo object `tarinfo' to the archive. If `fileobj' is
                  given, tarinfo.size bytes are read from it and added to the archive.
                  You can create TarInfo objects directly, or by using gettarinfo().
                  On Windows platforms, `fileobj' should always be opened with mode
                  'rb' to avoid irritation about the file size.
               """
  399:         self._check("aw")
       
  399:         tarinfo = copy.copy(tarinfo)
       
  399:         buf = tarinfo.tobuf(self.format, self.encoding, self.errors)
  392:         self.fileobj.write(buf)
  392:         self.offset += len(buf)
       
               # If there's data to follow, append it.
  392:         if fileobj is not None:
  219:             copyfileobj(fileobj, self.fileobj, tarinfo.size)
  219:             blocks, remainder = divmod(tarinfo.size, BLOCKSIZE)
  219:             if remainder > 0:
  144:                 self.fileobj.write(NUL * (BLOCKSIZE - remainder))
  144:                 blocks += 1
  219:             self.offset += blocks * BLOCKSIZE
       
  392:         self.members.append(tarinfo)
       
    1:     def extractall(self, path=".", members=None):
               """Extract all members from the archive to the current working
                  directory and set owner, modification time and permissions on
                  directories afterwards. `path' specifies a different directory
                  to extract to. `members' is optional and must be a subset of the
                  list returned by getmembers().
               """
   12:         directories = []
       
   12:         if members is None:
    9:             members = self
       
   36:         for tarinfo in members:
   24:             if tarinfo.isdir():
                       # Extract directories with a safe mode.
    9:                 directories.append(tarinfo)
    9:                 tarinfo = copy.copy(tarinfo)
    9:                 tarinfo.mode = 0700
   24:             self.extract(tarinfo, path)
       
               # Reverse sort directories.
   12:         directories.sort(key=operator.attrgetter('name'))
   12:         directories.reverse()
       
               # Set correct owner, mtime and filemode on directories.
   21:         for tarinfo in directories:
    9:             dirpath = os.path.join(path, tarinfo.name)
    9:             try:
    9:                 self.chown(tarinfo, dirpath)
    9:                 self.utime(tarinfo, dirpath)
    9:                 self.chmod(tarinfo, dirpath)
>>>>>>             except ExtractError, e:
>>>>>>                 if self.errorlevel > 1:
>>>>>>                     raise
                       else:
>>>>>>                     self._dbg(1, "tarfile: %s" % e)
       
    1:     def extract(self, member, path=""):
               """Extract a member from the archive to the current working directory,
                  using its full name. Its file information is extracted as accurately
                  as possible. `member' may be a filename or a TarInfo object. You can
                  specify a different directory using `path'.
               """
   66:         self._check("r")
       
   66:         if isinstance(member, basestring):
   18:             tarinfo = self.getmember(member)
               else:
   48:             tarinfo = member
       
               # Prepare the link target for makelink().
   66:         if tarinfo.islnk():
    6:             tarinfo._link_target = os.path.join(path, tarinfo.linkname)
       
   66:         try:
   66:             self._extract_member(tarinfo, os.path.join(path, tarinfo.name))
   24:         except EnvironmentError, e:
>>>>>>             if self.errorlevel > 0:
>>>>>>                 raise
                   else:
>>>>>>                 if e.filename is None:
>>>>>>                     self._dbg(1, "tarfile: %s" % e.strerror)
                       else:
>>>>>>                     self._dbg(1, "tarfile: %s %r" % (e.strerror, e.filename))
   24:         except ExtractError, e:
>>>>>>             if self.errorlevel > 1:
>>>>>>                 raise
                   else:
>>>>>>                 self._dbg(1, "tarfile: %s" % e)
       
    1:     def extractfile(self, member):
               """Extract a member from the archive as a file object. `member' may be
                  a filename or a TarInfo object. If `member' is a regular file, a
                  file-like object is returned. If `member' is a link, a file-like
                  object is constructed from the link's target. If `member' is none of
                  the above, None is returned.
                  The file-like object is read-only and provides the following
                  methods: read(), readline(), readlines(), seek() and tell()
               """
  324:         self._check("r")
       
  324:         if isinstance(member, basestring):
   30:             tarinfo = self.getmember(member)
               else:
  294:             tarinfo = member
       
  324:         if tarinfo.isreg():
  252:             return self.fileobject(self, tarinfo)
       
   72:         elif tarinfo.type not in SUPPORTED_TYPES:
                   # If a member's type is unknown, it is treated as a
                   # regular file.
>>>>>>             return self.fileobject(self, tarinfo)
       
   72:         elif tarinfo.islnk() or tarinfo.issym():
   36:             if isinstance(self.fileobj, _Stream):
                       # A small but ugly workaround for the case that someone tries
                       # to extract a (sym)link as a file-object from a non-seekable
                       # stream of tar blocks.
   21:                 raise StreamError("cannot extract (sym)link as file object")
                   else:
                       # A (sym)link's file object is its target's file object.
   15:                 return self.extractfile(self._find_link_target(tarinfo))
               else:
                   # If there's no data associated with the member (directory, chrdev,
                   # blkdev, etc.), return None instead of a file object.
   36:             return None
       
    1:     def _extract_member(self, tarinfo, targetpath):
               """Extract the TarInfo object tarinfo to a physical
                  file called targetpath.
               """
               # Fetch the TarInfo object for the given name
               # and build the destination pathname, replacing
               # forward slashes to platform specific separators.
   66:         targetpath = targetpath.rstrip("/")
   66:         targetpath = targetpath.replace("/", os.sep)
       
               # Create all upper directories.
   66:         upperdirs = os.path.dirname(targetpath)
   66:         if upperdirs and not os.path.exists(upperdirs):
                   # Create directories that are not part of the archive with
                   # default permissions.
    2:             os.makedirs(upperdirs)
       
   66:         if tarinfo.islnk() or tarinfo.issym():
   15:             self._dbg(1, "%s -> %s" % (tarinfo.name, tarinfo.linkname))
               else:
   51:             self._dbg(1, tarinfo.name)
       
   66:         if tarinfo.isreg():
   42:             self.makefile(tarinfo, targetpath)
   24:         elif tarinfo.isdir():
    9:             self.makedir(tarinfo, targetpath)
   15:         elif tarinfo.isfifo():
>>>>>>             self.makefifo(tarinfo, targetpath)
   15:         elif tarinfo.ischr() or tarinfo.isblk():
>>>>>>             self.makedev(tarinfo, targetpath)
   15:         elif tarinfo.islnk() or tarinfo.issym():
   15:             self.makelink(tarinfo, targetpath)
>>>>>>         elif tarinfo.type not in SUPPORTED_TYPES:
>>>>>>             self.makeunknown(tarinfo, targetpath)
               else:
>>>>>>             self.makefile(tarinfo, targetpath)
       
   42:         self.chown(tarinfo, targetpath)
   42:         if not tarinfo.issym():
   33:             self.chmod(tarinfo, targetpath)
   33:             self.utime(tarinfo, targetpath)
       
           #--------------------------------------------------------------------------
           # Below are the different file methods. They are called via
           # _extract_member() when extract() is called. They can be replaced in a
           # subclass to implement other functionality.
       
    1:     def makedir(self, tarinfo, targetpath):
               """Make a directory called targetpath.
               """
    9:         try:
                   # Use a safe mode for the directory, the real mode is set
                   # later in _extract_member().
    9:             os.mkdir(targetpath, 0700)
    6:         except EnvironmentError, e:
    6:             if e.errno != errno.EEXIST:
>>>>>>                 raise
       
    1:     def makefile(self, tarinfo, targetpath):
               """Make a file called targetpath.
               """
   42:         source = self.extractfile(tarinfo)
   42:         try:
   42:             with bltn_open(targetpath, "wb") as target:
   42:                 copyfileobj(source, target)
               finally:
   42:             source.close()
       
    1:     def makeunknown(self, tarinfo, targetpath):
               """Make a file from a TarInfo object with an unknown type
                  at targetpath.
               """
>>>>>>         self.makefile(tarinfo, targetpath)
>>>>>>         self._dbg(1, "tarfile: Unknown file type %r, " \
>>>>>>                      "extracted as regular file." % tarinfo.type)
       
    1:     def makefifo(self, tarinfo, targetpath):
               """Make a fifo called targetpath.
               """
>>>>>>         if hasattr(os, "mkfifo"):
>>>>>>             os.mkfifo(targetpath)
               else:
>>>>>>             raise ExtractError("fifo not supported by system")
       
    1:     def makedev(self, tarinfo, targetpath):
               """Make a character or block device called targetpath.
               """
>>>>>>         if not hasattr(os, "mknod") or not hasattr(os, "makedev"):
>>>>>>             raise ExtractError("special devices not supported by system")
       
>>>>>>         mode = tarinfo.mode
>>>>>>         if tarinfo.isblk():
>>>>>>             mode |= stat.S_IFBLK
               else:
>>>>>>             mode |= stat.S_IFCHR
       
>>>>>>         os.mknod(targetpath, mode,
>>>>>>                  os.makedev(tarinfo.devmajor, tarinfo.devminor))
       
    1:     def makelink(self, tarinfo, targetpath):
               """Make a (symbolic) link called targetpath. If it cannot be created
                 (platform limitation), we try to make a copy of the referenced file
                 instead of a link.
               """
   15:         if hasattr(os, "symlink") and hasattr(os, "link"):
                   # For systems that support symbolic and hard links.
   15:             if tarinfo.issym():
    9:                 if os.path.lexists(targetpath):
    6:                     os.unlink(targetpath)
    9:                 os.symlink(tarinfo.linkname, targetpath)
                   else:
                       # See extract().
    6:                 if os.path.exists(tarinfo._link_target):
    6:                     if os.path.lexists(targetpath):
    3:                         os.unlink(targetpath)
    6:                     os.link(tarinfo._link_target, targetpath)
                       else:
>>>>>>                     self._extract_member(self._find_link_target(tarinfo), targetpath)
               else:
>>>>>>             try:
>>>>>>                 self._extract_member(self._find_link_target(tarinfo), targetpath)
>>>>>>             except KeyError:
>>>>>>                 raise ExtractError("unable to resolve link inside archive")
       
    1:     def chown(self, tarinfo, targetpath):
               """Set owner of targetpath according to tarinfo.
               """
   51:         if pwd and hasattr(os, "geteuid") and os.geteuid() == 0:
                   # We have to be root to do so.
>>>>>>             try:
>>>>>>                 g = grp.getgrnam(tarinfo.gname)[2]
>>>>>>             except KeyError:
>>>>>>                 g = tarinfo.gid
>>>>>>             try:
>>>>>>                 u = pwd.getpwnam(tarinfo.uname)[2]
>>>>>>             except KeyError:
>>>>>>                 u = tarinfo.uid
>>>>>>             try:
>>>>>>                 if tarinfo.issym() and hasattr(os, "lchown"):
>>>>>>                     os.lchown(targetpath, u, g)
                       else:
>>>>>>                     if sys.platform != "os2emx":
>>>>>>                         os.chown(targetpath, u, g)
>>>>>>             except EnvironmentError, e:
>>>>>>                 raise ExtractError("could not change owner")
       
    1:     def chmod(self, tarinfo, targetpath):
               """Set file permissions of targetpath according to tarinfo.
               """
   42:         if hasattr(os, 'chmod'):
   42:             try:
   42:                 os.chmod(targetpath, tarinfo.mode)
>>>>>>             except EnvironmentError, e:
>>>>>>                 raise ExtractError("could not change mode")
       
    1:     def utime(self, tarinfo, targetpath):
               """Set modification time of targetpath according to tarinfo.
               """
   42:         if not hasattr(os, 'utime'):
>>>>>>             return
   42:         try:
   42:             os.utime(targetpath, (tarinfo.mtime, tarinfo.mtime))
>>>>>>         except EnvironmentError, e:
>>>>>>             raise ExtractError("could not change modification time")
       
           #--------------------------------------------------------------------------
    1:     def next(self):
               """Return the next member of the archive as a TarInfo object, when
                  TarFile is opened for reading. Return None if there is no more
                  available.
               """
 4857:         self._check("ra")
 4857:         if self.firstmember is not None:
  288:             m = self.firstmember
  288:             self.firstmember = None
  288:             return m
       
               # Advance the file pointer.
 4569:         if self.offset != self.fileobj.tell():
 1938:             self.fileobj.seek(self.offset - 1)
 1938:             if not self.fileobj.read(1):
   24:                 raise ReadError("unexpected end of data")
       
               # Read the next block.
 4545:         tarinfo = None
 4569:         while True:
 4569:             try:
 4569:                 tarinfo = self.tarinfo.fromtarfile(self)
  924:             except EOFHeaderError, e:
  183:                 if self.ignore_zeros:
   12:                     self._dbg(2, "0x%X: %s" % (self.offset, e))
   12:                     self.offset += BLOCKSIZE
   12:                     continue
  741:             except InvalidHeaderError, e:
   20:                 if self.ignore_zeros:
   12:                     self._dbg(2, "0x%X: %s" % (self.offset, e))
   12:                     self.offset += BLOCKSIZE
   12:                     continue
    8:                 elif self.offset == 0:
    8:                     raise ReadError(str(e))
  721:             except EmptyHeaderError:
  187:                 if self.offset == 0:
  175:                     raise ReadError("empty file")
  534:             except TruncatedHeaderError, e:
   76:                 if self.offset == 0:
   76:                     raise ReadError(str(e))
  458:             except SubsequentHeaderError, e:
    2:                 raise ReadError(str(e))
 3828:             break
       
 3828:         if tarinfo is not None:
 3645:             self.members.append(tarinfo)
               else:
  183:             self._loaded = True
       
 3828:         return tarinfo
       
           #--------------------------------------------------------------------------
           # Little helper methods:
       
    1:     def _getmember(self, name, tarinfo=None, normalize=False):
               """Find an archive member by name from bottom to top.
                  If tarinfo is given, it is used as the starting point.
               """
               # Ensure that all members have been loaded.
  118:         members = self.getmembers()
       
               # Limit the member search list up to tarinfo.
  118:         if tarinfo is not None:
    6:             members = members[:members.index(tarinfo)]
       
  118:         if normalize:
   15:             name = os.path.normpath(name)
       
 2629:         for member in reversed(members):
 2629:             if normalize:
  264:                 member_name = os.path.normpath(member.name)
                   else:
 2365:                 member_name = member.name
       
 2629:             if name == member_name:
  118:                 return member
       
    1:     def _load(self):
               """Read through the entire archive file and look for readable
                  members.
               """
 2688:         while True:
 2688:             tarinfo = self.next()
 2688:             if tarinfo is None:
  137:                 break
  137:         self._loaded = True
       
    1:     def _check(self, mode=None):
               """Check if TarFile is still open, and if the operation's mode
                  corresponds to TarFile's mode.
               """
 6653:         if self.closed:
    1:             raise IOError("%s is closed" % self.__class__.__name__)
 6652:         if mode is not None and self.mode not in mode:
>>>>>>             raise IOError("bad operation for mode %r" % self.mode)
       
    1:     def _find_link_target(self, tarinfo):
               """Find the target member of a symlink or hardlink member in the
                  archive.
               """
   15:         if tarinfo.issym():
                   # Always search the entire archive.
    9:             linkname = "/".join(filter(None, (os.path.dirname(tarinfo.name), tarinfo.linkname)))
    9:             limit = None
               else:
                   # Search the archive before the link, because a hard link is
                   # just a reference to an already archived file.
    6:             linkname = tarinfo.linkname
    6:             limit = tarinfo
       
   15:         member = self._getmember(linkname, tarinfo=limit, normalize=True)
   15:         if member is None:
>>>>>>             raise KeyError("linkname %r not found" % linkname)
   15:         return member
       
    1:     def __iter__(self):
               """Provide an iterator object.
               """
   61:         if self._loaded:
>>>>>>             return iter(self.members)
               else:
   61:             return TarIter(self)
       
    1:     def _dbg(self, level, msg):
               """Write debugging output to sys.stderr.
               """
  426:         if level <= self.debug:
>>>>>>             print >> sys.stderr, msg
       
    1:     def __enter__(self):
  115:         self._check()
  114:         return self
       
    1:     def __exit__(self, type, value, traceback):
  114:         if type is None:
  111:             self.close()
               else:
                   # An exception occurred. We must not call close() because
                   # it would try to write end-of-archive blocks and padding.
    3:             if not self._extfileobj:
    2:                 self.fileobj.close()
    3:             self.closed = True
       # class TarFile
       
    2: class TarIter:
           """Iterator Class.
       
              for tarinfo in TarFile(...):
                  suite...
    1:     """
       
    1:     def __init__(self, tarfile):
               """Construct a TarIter object.
               """
   61:         self.tarfile = tarfile
   61:         self.index = 0
    1:     def __iter__(self):
               """Return iterator object.
               """
>>>>>>         return self
    1:     def next(self):
               """Return the next item using TarFile's next() method.
                  When all members have been read, set TarFile as _loaded.
               """
               # Fix for SF #1100429: Under rare circumstances it can
               # happen that getmembers() is called during iteration,
               # which will cause TarIter to stop prematurely.
       
  830:         if self.index == 0 and self.tarfile.firstmember is not None:
   58:             tarinfo = self.tarfile.next()
  772:         elif self.index < len(self.tarfile.members):
   99:             tarinfo = self.tarfile.members[self.index]
  673:         elif not self.tarfile._loaded:
  673:             tarinfo = self.tarfile.next()
  649:             if not tarinfo:
   34:                 self.tarfile._loaded = True
   34:                 raise StopIteration
               else:
>>>>>>             raise StopIteration
  772:         self.index += 1
  772:         return tarinfo
       
       # Helper classes for sparse file support
    2: class _section:
           """Base class for _data and _hole.
    1:     """
    1:     def __init__(self, offset, size):
 3626:         self.offset = offset
 3626:         self.size = size
    1:     def __contains__(self, offset):
  287:         return self.offset <= offset < self.offset + self.size
       
    2: class _data(_section):
           """Represent a data section in a sparse file.
    1:     """
    1:     def __init__(self, offset, size, realpos):
 2450:         _section.__init__(self, offset, size)
 2450:         self.realpos = realpos
       
    2: class _hole(_section):
           """Represent a hole section in a sparse file.
    1:     """
    1:     pass
       
    2: class _ringbuffer(list):
           """Ringbuffer class which increases performance
              over a regular list.
    1:     """
    1:     def __init__(self):
   98:         self.idx = 0
    1:     def find(self, offset):
  147:         idx = self.idx
  287:         while True:
  287:             item = self[idx]
  287:             if offset in item:
  147:                 break
  140:             idx += 1
  140:             if idx == len(self):
>>>>>>                 idx = 0
  140:             if idx == self.idx:
                       # End of File
>>>>>>                 return None
  147:         self.idx = idx
  147:         return item
       
       #---------------------------------------------
       # zipfile compatible TarFile class
       #---------------------------------------------
    1: TAR_PLAIN = 0           # zipfile.ZIP_STORED
    1: TAR_GZIPPED = 8         # zipfile.ZIP_DEFLATED
    2: class TarFileCompat:
           """TarFile class compatible with standard module zipfile's
              ZipFile class.
    1:     """
    1:     def __init__(self, file, mode="r", compression=TAR_PLAIN):
>>>>>>         from warnings import warnpy3k
>>>>>>         warnpy3k("the TarFileCompat class has been removed in Python 3.0",
>>>>>>                 stacklevel=2)
>>>>>>         if compression == TAR_PLAIN:
>>>>>>             self.tarfile = TarFile.taropen(file, mode)
>>>>>>         elif compression == TAR_GZIPPED:
>>>>>>             self.tarfile = TarFile.gzopen(file, mode)
               else:
>>>>>>             raise ValueError("unknown compression constant")
>>>>>>         if mode[0:1] == "r":
>>>>>>             members = self.tarfile.getmembers()
>>>>>>             for m in members:
>>>>>>                 m.filename = m.name
>>>>>>                 m.file_size = m.size
>>>>>>                 m.date_time = time.gmtime(m.mtime)[:6]
    1:     def namelist(self):
>>>>>>         return map(lambda m: m.name, self.infolist())
    1:     def infolist(self):
>>>>>>         return filter(lambda m: m.type in REGULAR_TYPES,
>>>>>>                       self.tarfile.getmembers())
    1:     def printdir(self):
>>>>>>         self.tarfile.list()
    1:     def testzip(self):
>>>>>>         return
    1:     def getinfo(self, name):
>>>>>>         return self.tarfile.getmember(name)
    1:     def read(self, name):
>>>>>>         return self.tarfile.extractfile(self.tarfile.getmember(name)).read()
    1:     def write(self, filename, arcname=None, compress_type=None):
>>>>>>         self.tarfile.add(filename, arcname)
    1:     def writestr(self, zinfo, bytes):
>>>>>>         try:
>>>>>>             from cStringIO import StringIO
>>>>>>         except ImportError:
>>>>>>             from StringIO import StringIO
>>>>>>         import calendar
>>>>>>         tinfo = TarInfo(zinfo.filename)
>>>>>>         tinfo.size = len(bytes)
>>>>>>         tinfo.mtime = calendar.timegm(zinfo.date_time)
>>>>>>         self.tarfile.addfile(tinfo, StringIO(bytes))
    1:     def close(self):
>>>>>>         self.tarfile.close()
       #class TarFileCompat
       
       #--------------------
       # exported functions
       #--------------------
    1: def is_tarfile(name):
           """Return True if name points to a tar archive that we
              are able to handle, else return False.
           """
    2:     try:
    2:         t = open(name)
    2:         t.close()
    2:         return True
>>>>>>     except TarError:
>>>>>>         return False
       
    1: open = TarFile.open
