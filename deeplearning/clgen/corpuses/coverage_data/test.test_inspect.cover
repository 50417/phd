    1: import re
    1: import sys
    1: import types
    1: import unittest
    1: import inspect
    1: import linecache
    1: import datetime
    1: import textwrap
    1: from UserList import UserList
    1: from UserDict import UserDict
       
    1: from test.support import run_unittest, check_py3k_warnings, have_unicode
       
    1: with check_py3k_warnings(
    1:         ("tuple parameter unpacking has been removed", SyntaxWarning),
    1:         quiet=True):
    1:     from test import inspect_fodder as mod
    1:     from test import inspect_fodder2 as mod2
       
       # C module for test_findsource_binary
    1: try:
    1:     import unicodedata
>>>>>> except ImportError:
>>>>>>     unicodedata = None
       
       # Functions tested in this suite:
       # ismodule, isclass, ismethod, isfunction, istraceback, isframe, iscode,
       # isbuiltin, isroutine, isgenerator, isgeneratorfunction, getmembers,
       # getdoc, getfile, getmodule, getsourcefile, getcomments, getsource,
       # getclasstree, getargspec, getargvalues, formatargspec, formatargvalues,
       # currentframe, stack, trace, isdatadescriptor
       
       # NOTE: There are some additional tests relating to interaction with
       #       zipimport in the test_zipimport_support test module.
       
    1: modfile = mod.__file__
    1: if modfile.endswith(('c', 'o')):
    1:     modfile = modfile[:-1]
       
    1: import __builtin__
       
    1: try:
    1:     1 // 0
    1: except:
    1:     tb = sys.exc_traceback
       
    1: git = mod.StupidGit()
       
    2: class IsTestBase(unittest.TestCase):
    1:     predicates = set([inspect.isbuiltin, inspect.isclass, inspect.iscode,
    1:                       inspect.isframe, inspect.isfunction, inspect.ismethod,
    1:                       inspect.ismodule, inspect.istraceback,
    1:                       inspect.isgenerator, inspect.isgeneratorfunction])
       
    1:     def istest(self, predicate, exp):
   18:         obj = eval(exp)
   18:         self.assertTrue(predicate(obj), '%s(%s)' % (predicate.__name__, exp))
       
  184:         for other in self.predicates - set([predicate]):
  166:             if predicate == inspect.isgeneratorfunction and\
    9:                other == inspect.isfunction:
    1:                 continue
  165:             self.assertFalse(other(obj), 'not %s(%s)' % (other.__name__, exp))
       
    1: def generator_function_example(self):
>>>>>>     for i in xrange(2):
>>>>>>         yield i
       
    2: class TestPredicates(IsTestBase):
    1:     def test_sixteen(self):
   88:         count = len(filter(lambda x:x.startswith('is'), dir(inspect)))
               # This test is here for remember you to update Doc/library/inspect.rst
               # which claims there are 16 such functions
    1:         expected = 16
    1:         err_msg = "There are %d (not %d) is* functions" % (count, expected)
    1:         self.assertEqual(count, expected, err_msg)
       
       
    1:     def test_excluding_predicates(self):
    1:         self.istest(inspect.isbuiltin, 'sys.exit')
    1:         self.istest(inspect.isbuiltin, '[].append')
    1:         self.istest(inspect.iscode, 'mod.spam.func_code')
    1:         self.istest(inspect.isframe, 'tb.tb_frame')
    1:         self.istest(inspect.isfunction, 'mod.spam')
    1:         self.istest(inspect.ismethod, 'mod.StupidGit.abuse')
    1:         self.istest(inspect.ismethod, 'git.argue')
    1:         self.istest(inspect.ismodule, 'mod')
    1:         self.istest(inspect.istraceback, 'tb')
    1:         self.istest(inspect.isdatadescriptor, '__builtin__.file.closed')
    1:         self.istest(inspect.isdatadescriptor, '__builtin__.file.softspace')
    1:         self.istest(inspect.isgenerator, '(x for x in xrange(2))')
    1:         self.istest(inspect.isgeneratorfunction, 'generator_function_example')
    1:         if hasattr(types, 'GetSetDescriptorType'):
    1:             self.istest(inspect.isgetsetdescriptor,
    1:                         'type(tb.tb_frame).f_locals')
               else:
>>>>>>             self.assertFalse(inspect.isgetsetdescriptor(type(tb.tb_frame).f_locals))
    1:         if hasattr(types, 'MemberDescriptorType'):
    1:             self.istest(inspect.ismemberdescriptor, 'datetime.timedelta.days')
               else:
>>>>>>             self.assertFalse(inspect.ismemberdescriptor(datetime.timedelta.days))
       
    1:     def test_isroutine(self):
    1:         self.assertTrue(inspect.isroutine(mod.spam))
    1:         self.assertTrue(inspect.isroutine([].count))
       
    1:     def test_isclass(self):
    1:         self.istest(inspect.isclass, 'mod.StupidGit')
    1:         self.assertTrue(inspect.isclass(list))
       
    2:         class newstyle(object): pass
    1:         self.assertTrue(inspect.isclass(newstyle))
       
    2:         class CustomGetattr(object):
    1:             def __getattr__(self, attr):
>>>>>>                 return None
    1:         self.assertFalse(inspect.isclass(CustomGetattr()))
       
    1:     def test_get_slot_members(self):
    2:         class C(object):
    1:             __slots__ = ("a", "b")
       
    1:         x = C()
    1:         x.a = 42
    1:         members = dict(inspect.getmembers(x))
    1:         self.assertIn('a', members)
    1:         self.assertNotIn('b', members)
       
    1:     def test_isabstract(self):
    1:         from abc import ABCMeta, abstractmethod
       
    2:         class AbstractClassExample(object):
    1:             __metaclass__ = ABCMeta
       
    1:             @abstractmethod
                   def foo(self):
>>>>>>                 pass
       
    2:         class ClassExample(AbstractClassExample):
    1:             def foo(self):
>>>>>>                 pass
       
    1:         a = ClassExample()
       
               # Test general behaviour.
    1:         self.assertTrue(inspect.isabstract(AbstractClassExample))
    1:         self.assertFalse(inspect.isabstract(ClassExample))
    1:         self.assertFalse(inspect.isabstract(a))
    1:         self.assertFalse(inspect.isabstract(int))
    1:         self.assertFalse(inspect.isabstract(5))
       
       
    2: class TestInterpreterStack(IsTestBase):
    1:     def __init__(self, *args, **kwargs):
    5:         unittest.TestCase.__init__(self, *args, **kwargs)
       
    5:         git.abuse(7, 8, 9)
       
    1:     def test_abuse_done(self):
    1:         self.istest(inspect.istraceback, 'git.ex[2]')
    1:         self.istest(inspect.isframe, 'mod.fr')
       
    1:     def test_stack(self):
    1:         self.assertTrue(len(mod.st) >= 5)
    1:         self.assertEqual(mod.st[0][1:],
    1:              (modfile, 16, 'eggs', ['    st = inspect.stack()\n'], 0))
    1:         self.assertEqual(mod.st[1][1:],
    1:              (modfile, 9, 'spam', ['    eggs(b + d, c + f)\n'], 0))
    1:         self.assertEqual(mod.st[2][1:],
    1:              (modfile, 43, 'argue', ['            spam(a, b, c)\n'], 0))
    1:         self.assertEqual(mod.st[3][1:],
    1:              (modfile, 39, 'abuse', ['        self.argue(a, b, c)\n'], 0))
       
    1:     def test_trace(self):
    1:         self.assertEqual(len(git.tr), 3)
    1:         self.assertEqual(git.tr[0][1:], (modfile, 43, 'argue',
    1:                                          ['            spam(a, b, c)\n'], 0))
    1:         self.assertEqual(git.tr[1][1:], (modfile, 9, 'spam',
    1:                                          ['    eggs(b + d, c + f)\n'], 0))
    1:         self.assertEqual(git.tr[2][1:], (modfile, 18, 'eggs',
    1:                                          ['    q = y // 0\n'], 0))
       
    1:     def test_frame(self):
    1:         args, varargs, varkw, locals = inspect.getargvalues(mod.fr)
    1:         self.assertEqual(args, ['x', 'y'])
    1:         self.assertEqual(varargs, None)
    1:         self.assertEqual(varkw, None)
    1:         self.assertEqual(locals, {'x': 11, 'p': 11, 'y': 14})
    1:         self.assertEqual(inspect.formatargvalues(args, varargs, varkw, locals),
    1:                          '(x=11, y=14)')
       
    1:     def test_previous_frame(self):
    1:         args, varargs, varkw, locals = inspect.getargvalues(mod.fr.f_back)
    1:         self.assertEqual(args, ['a', 'b', 'c', 'd', ['e', ['f']]])
    1:         self.assertEqual(varargs, 'g')
    1:         self.assertEqual(varkw, 'h')
    1:         self.assertEqual(inspect.formatargvalues(args, varargs, varkw, locals),
    1:              '(a=7, b=8, c=9, d=3, (e=4, (f=5,)), *g=(), **h={})')
       
    2: class GetSourceBase(unittest.TestCase):
           # Subclasses must override.
    1:     fodderFile = None
       
    1:     def __init__(self, *args, **kwargs):
   31:         unittest.TestCase.__init__(self, *args, **kwargs)
       
   31:         with open(inspect.getsourcefile(self.fodderFile)) as fp:
   31:             self.source = fp.read()
       
    1:     def sourcerange(self, top, bottom):
   19:         lines = self.source.split("\n")
   19:         return "\n".join(lines[top-1:bottom]) + "\n"
       
    1:     def assertSourceEqual(self, obj, top, bottom):
   19:         self.assertEqual(inspect.getsource(obj),
   19:                          self.sourcerange(top, bottom))
       
    2: class TestRetrievingSourceCode(GetSourceBase):
    1:     fodderFile = mod
       
    1:     def test_getclasses(self):
    1:         classes = inspect.getmembers(mod, inspect.isclass)
    1:         self.assertEqual(classes,
    1:                          [('FesteringGob', mod.FesteringGob),
    1:                           ('MalodorousPervert', mod.MalodorousPervert),
    1:                           ('ParrotDroppings', mod.ParrotDroppings),
    1:                           ('StupidGit', mod.StupidGit),
    1:                           ('Tit', mod.MalodorousPervert),
                                ])
    6:         tree = inspect.getclasstree([cls[1] for cls in classes])
    1:         self.assertEqual(tree,
    1:                          [(mod.ParrotDroppings, ()),
    1:                           [(mod.FesteringGob, (mod.MalodorousPervert,
    1:                                                   mod.ParrotDroppings))
                                  ],
    1:                           (mod.StupidGit, ()),
    1:                           [(mod.MalodorousPervert, (mod.StupidGit,)),
    1:                            [(mod.FesteringGob, (mod.MalodorousPervert,
    1:                                                    mod.ParrotDroppings))
                                   ]
                                  ]
                                 ])
    6:         tree = inspect.getclasstree([cls[1] for cls in classes], True)
    1:         self.assertEqual(tree,
    1:                          [(mod.ParrotDroppings, ()),
    1:                           (mod.StupidGit, ()),
    1:                           [(mod.MalodorousPervert, (mod.StupidGit,)),
    1:                            [(mod.FesteringGob, (mod.MalodorousPervert,
    1:                                                    mod.ParrotDroppings))
                                   ]
                                  ]
                                 ])
       
    1:     def test_getfunctions(self):
    1:         functions = inspect.getmembers(mod, inspect.isfunction)
    1:         self.assertEqual(functions, [('eggs', mod.eggs),
    1:                                      ('spam', mod.spam)])
       
    1:     @unittest.skipIf(sys.flags.optimize >= 2,
    1:                      "Docstrings are omitted with -O2 and above")
           def test_getdoc(self):
    1:         self.assertEqual(inspect.getdoc(mod), 'A module docstring.')
    1:         self.assertEqual(inspect.getdoc(mod.StupidGit),
    1:                          'A longer,\n\nindented\n\ndocstring.')
    1:         self.assertEqual(inspect.getdoc(git.abuse),
    1:                          'Another\n\ndocstring\n\ncontaining\n\ntabs')
       
    1:     def test_cleandoc(self):
    1:         self.assertEqual(inspect.cleandoc('An\n    indented\n    docstring.'),
    1:                          'An\nindented\ndocstring.')
       
    1:     def test_getcomments(self):
    1:         self.assertEqual(inspect.getcomments(mod), '# line 1\n')
    1:         self.assertEqual(inspect.getcomments(mod.StupidGit), '# line 20\n')
       
    1:     def test_getmodule(self):
               # Check actual module
    1:         self.assertEqual(inspect.getmodule(mod), mod)
               # Check class (uses __module__ attribute)
    1:         self.assertEqual(inspect.getmodule(mod.StupidGit), mod)
               # Check a method (no __module__ attribute, falls back to filename)
    1:         self.assertEqual(inspect.getmodule(mod.StupidGit.abuse), mod)
               # Do it again (check the caching isn't broken)
    1:         self.assertEqual(inspect.getmodule(mod.StupidGit.abuse), mod)
               # Check a builtin
    1:         self.assertEqual(inspect.getmodule(str), sys.modules["__builtin__"])
               # Check filename override
    1:         self.assertEqual(inspect.getmodule(None, modfile), mod)
       
    1:     def test_getsource(self):
    1:         self.assertSourceEqual(git.abuse, 29, 39)
    1:         self.assertSourceEqual(mod.StupidGit, 21, 46)
       
    1:     def test_getsourcefile(self):
    1:         self.assertEqual(inspect.getsourcefile(mod.spam), modfile)
    1:         self.assertEqual(inspect.getsourcefile(git.abuse), modfile)
    1:         fn = "_non_existing_filename_used_for_sourcefile_test.py"
    1:         co = compile("None", fn, "exec")
    1:         self.assertEqual(inspect.getsourcefile(co), None)
    1:         linecache.cache[co.co_filename] = (1, None, "None", co.co_filename)
    1:         self.assertEqual(inspect.getsourcefile(co), fn)
       
    1:     def test_getfile(self):
    1:         self.assertEqual(inspect.getfile(mod.StupidGit), mod.__file__)
       
    1:     def test_getmodule_recursion(self):
    1:         from types import ModuleType
    1:         name = '__inspect_dummy'
    1:         m = sys.modules[name] = ModuleType(name)
    1:         m.__file__ = "<string>" # hopefully not a real filename...
    1:         m.__loader__ = "dummy"  # pretend the filename is understood by a loader
    1:         exec "def x(): pass" in m.__dict__
    1:         self.assertEqual(inspect.getsourcefile(m.x.func_code), '<string>')
    1:         del sys.modules[name]
    1:         inspect.getmodule(compile('a=10','','single'))
       
    1:     def test_proceed_with_fake_filename(self):
               '''doctest monkeypatches linecache to enable inspection'''
    1:         fn, source = '<test>', 'def x(): pass\n'
    1:         getlines = linecache.getlines
    1:         def monkey(filename, module_globals=None):
    1:             if filename == fn:
    1:                 return source.splitlines(True)
                   else:
>>>>>>                 return getlines(filename, module_globals)
    1:         linecache.getlines = monkey
    1:         try:
    1:             ns = {}
    1:             exec compile(source, fn, 'single') in ns
    1:             inspect.getsource(ns["x"])
               finally:
    1:             linecache.getlines = getlines
       
    2: class TestDecorators(GetSourceBase):
    1:     fodderFile = mod2
       
    1:     def test_wrapped_decorator(self):
    1:         self.assertSourceEqual(mod2.wrapped, 14, 17)
       
    1:     def test_replacing_decorator(self):
    1:         self.assertSourceEqual(mod2.gone, 9, 10)
       
    2: class TestOneliners(GetSourceBase):
    1:     fodderFile = mod2
    1:     def test_oneline_lambda(self):
               # Test inspect.getsource with a one-line lambda function.
    1:         self.assertSourceEqual(mod2.oll, 25, 25)
       
    1:     def test_threeline_lambda(self):
               # Test inspect.getsource with a three-line lambda function,
               # where the second and third lines are _not_ indented.
    1:         self.assertSourceEqual(mod2.tll, 28, 30)
       
    1:     def test_twoline_indented_lambda(self):
               # Test inspect.getsource with a two-line lambda function,
               # where the second line _is_ indented.
    1:         self.assertSourceEqual(mod2.tlli, 33, 34)
       
    1:     def test_onelinefunc(self):
               # Test inspect.getsource with a regular one-line function.
    1:         self.assertSourceEqual(mod2.onelinefunc, 37, 37)
       
    1:     def test_manyargs(self):
               # Test inspect.getsource with a regular function where
               # the arguments are on two lines and _not_ indented and
               # the body on the second line with the last arguments.
    1:         self.assertSourceEqual(mod2.manyargs, 40, 41)
       
    1:     def test_twolinefunc(self):
               # Test inspect.getsource with a regular function where
               # the body is on two lines, following the argument list and
               # continued on the next line by a \\.
    1:         self.assertSourceEqual(mod2.twolinefunc, 44, 45)
       
    1:     def test_lambda_in_list(self):
               # Test inspect.getsource with a one-line lambda function
               # defined in a list, indented.
    1:         self.assertSourceEqual(mod2.a[1], 49, 49)
       
    1:     def test_anonymous(self):
               # Test inspect.getsource with a lambda function defined
               # as argument to another function.
    1:         self.assertSourceEqual(mod2.anonymous, 55, 55)
       
    2: class TestBuggyCases(GetSourceBase):
    1:     fodderFile = mod2
       
    1:     def test_with_comment(self):
    1:         self.assertSourceEqual(mod2.with_comment, 58, 59)
       
    1:     def test_multiline_sig(self):
    1:         self.assertSourceEqual(mod2.multiline_sig[0], 63, 64)
       
    1:     def test_nested_class(self):
    1:         self.assertSourceEqual(mod2.func69().func71, 71, 72)
       
    1:     def test_one_liner_followed_by_non_name(self):
    1:         self.assertSourceEqual(mod2.func77, 77, 77)
       
    1:     def test_one_liner_dedent_non_name(self):
    1:         self.assertSourceEqual(mod2.cls82.func83, 83, 83)
       
    1:     def test_with_comment_instead_of_docstring(self):
    1:         self.assertSourceEqual(mod2.func88, 88, 90)
       
    1:     def test_method_in_dynamic_class(self):
    1:         self.assertSourceEqual(mod2.method_in_dynamic_class, 95, 97)
       
    1:     @unittest.skipIf(
    1:         not hasattr(unicodedata, '__file__') or
    1:             unicodedata.__file__[-4:] in (".pyc", ".pyo"),
    1:         "unicodedata is not an external binary module")
           def test_findsource_binary(self):
    1:         self.assertRaises(IOError, inspect.getsource, unicodedata)
    1:         self.assertRaises(IOError, inspect.findsource, unicodedata)
       
    1:     def test_findsource_code_in_linecache(self):
    1:         lines = ["x=1"]
    1:         co = compile(lines[0], "_dynamically_created_file", "exec")
    1:         self.assertRaises(IOError, inspect.findsource, co)
    1:         self.assertRaises(IOError, inspect.getsource, co)
    1:         linecache.cache[co.co_filename] = (1, None, lines, co.co_filename)
    1:         self.assertEqual(inspect.findsource(co), (lines,0))
    1:         self.assertEqual(inspect.getsource(co), lines[0])
       
    1:     def test_findsource_without_filename(self):
    3:         for fname in ['', '<string>']:
    2:             co = compile('x=1', fname, "exec")
    2:             self.assertRaises(IOError, inspect.findsource, co)
    2:             self.assertRaises(IOError, inspect.getsource, co)
       
       
    2: class _BrokenDataDescriptor(object):
           """
           A broken data descriptor. See bug #1785.
    1:     """
    1:     def __get__(*args):
>>>>>>         raise AssertionError("should not __get__ data descriptors")
       
    1:     def __set__(*args):
>>>>>>         raise RuntimeError
       
    1:     def __getattr__(*args):
>>>>>>         raise AssertionError("should not __getattr__ data descriptors")
       
       
    2: class _BrokenMethodDescriptor(object):
           """
           A broken method descriptor. See bug #1785.
    1:     """
    1:     def __get__(*args):
>>>>>>         raise AssertionError("should not __get__ method descriptors")
       
    1:     def __getattr__(*args):
    8:         raise AssertionError("should not __getattr__ method descriptors")
       
       
       # Helper for testing classify_class_attrs.
    1: def attrs_wo_objs(cls):
  160:     return [t[:3] for t in inspect.classify_class_attrs(cls)]
       
       
    2: class TestClassesAndFunctions(unittest.TestCase):
    1:     def test_classic_mro(self):
               # Test classic-class method resolution order.
    2:         class A:    pass
    2:         class B(A): pass
    2:         class C(A): pass
    2:         class D(B, C): pass
       
    1:         expected = (D, B, A, C)
    1:         got = inspect.getmro(D)
    1:         self.assertEqual(expected, got)
       
    1:     def test_newstyle_mro(self):
               # The same w/ new-class MRO.
    2:         class A(object):    pass
    2:         class B(A): pass
    2:         class C(A): pass
    2:         class D(B, C): pass
       
    1:         expected = (D, B, C, A, object)
    1:         got = inspect.getmro(D)
    1:         self.assertEqual(expected, got)
       
    1:     def assertArgSpecEquals(self, routine, args_e, varargs_e = None,
    1:                             varkw_e = None, defaults_e = None,
    1:                             formatted = None):
    8:         args, varargs, varkw, defaults = inspect.getargspec(routine)
    8:         self.assertEqual(args, args_e)
    8:         self.assertEqual(varargs, varargs_e)
    8:         self.assertEqual(varkw, varkw_e)
    8:         self.assertEqual(defaults, defaults_e)
    8:         if formatted is not None:
    3:             self.assertEqual(inspect.formatargspec(args, varargs, varkw, defaults),
    3:                              formatted)
       
    1:     def test_getargspec(self):
    1:         self.assertArgSpecEquals(mod.eggs, ['x', 'y'], formatted = '(x, y)')
       
    1:         self.assertArgSpecEquals(mod.spam,
    1:                                  ['a', 'b', 'c', 'd', ['e', ['f']]],
    1:                                  'g', 'h', (3, (4, (5,))),
    1:                                  '(a, b, c, d=3, (e, (f,))=(4, (5,)), *g, **h)')
       
    1:         with check_py3k_warnings(("tuple parameter unpacking has been removed",
    1:                                   SyntaxWarning),
    1:                                  quiet=True):
    1:             exec(textwrap.dedent('''
                       def spam_deref(a, b, c, d=3, (e, (f,))=(4, (5,)), *g, **h):
                           def eggs():
                               return a + b + c + d + e + f + g + h
                           return eggs
    1:             '''))
    1:         self.assertArgSpecEquals(spam_deref,
    1:                                  ['a', 'b', 'c', 'd', ['e', ['f']]],
    1:                                  'g', 'h', (3, (4, (5,))),
    1:                                  '(a, b, c, d=3, (e, (f,))=(4, (5,)), *g, **h)')
       
    1:     def test_getargspec_method(self):
    2:         class A(object):
    1:             def m(self):
>>>>>>                 pass
    1:         self.assertArgSpecEquals(A.m, ['self'])
       
    1:     def test_getargspec_sublistofone(self):
    1:         with check_py3k_warnings(
    1:                 ("tuple parameter unpacking has been removed", SyntaxWarning),
    1:                 ("parenthesized argument names are invalid", SyntaxWarning)):
    1:             exec 'def sublistOfOne((foo,)): return 1'
    1:             self.assertArgSpecEquals(sublistOfOne, [['foo']])
       
    1:             exec 'def sublistOfOne((foo,)): return (lambda: foo)'
    1:             self.assertArgSpecEquals(sublistOfOne, [['foo']])
       
    1:             exec 'def fakeSublistOfOne((foo)): return 1'
    1:             self.assertArgSpecEquals(fakeSublistOfOne, ['foo'])
       
    1:             exec 'def sublistOfOne((foo)): return (lambda: foo)'
    1:             self.assertArgSpecEquals(sublistOfOne, ['foo'])
       
       
    1:     def _classify_test(self, newstyle):
               """Helper for testing that classify_class_attrs finds a bunch of
               different kinds of attributes on a given class.
               """
    2:         if newstyle:
    1:             base = object
               else:
    2:             class base:
    1:                 pass
       
    4:         class A(base):
    2:             def s(): pass
    2:             s = staticmethod(s)
       
    2:             def c(cls): pass
    2:             c = classmethod(c)
       
    2:             def getp(self): pass
    2:             p = property(getp)
       
    2:             def m(self): pass
       
    2:             def m1(self): pass
       
    2:             datablob = '1'
       
    2:             dd = _BrokenDataDescriptor()
    2:             md = _BrokenMethodDescriptor()
       
    2:         attrs = attrs_wo_objs(A)
    2:         self.assertIn(('s', 'static method', A), attrs, 'missing static method')
    2:         self.assertIn(('c', 'class method', A), attrs, 'missing class method')
    2:         self.assertIn(('p', 'property', A), attrs, 'missing property')
    2:         self.assertIn(('m', 'method', A), attrs, 'missing plain method')
    2:         self.assertIn(('m1', 'method', A), attrs, 'missing plain method')
    2:         self.assertIn(('datablob', 'data', A), attrs, 'missing data')
    2:         self.assertIn(('md', 'method', A), attrs, 'missing method descriptor')
    2:         self.assertIn(('dd', 'data', A), attrs, 'missing data descriptor')
       
    4:         class B(A):
    2:             def m(self): pass
       
    2:         attrs = attrs_wo_objs(B)
    2:         self.assertIn(('s', 'static method', A), attrs, 'missing static method')
    2:         self.assertIn(('c', 'class method', A), attrs, 'missing class method')
    2:         self.assertIn(('p', 'property', A), attrs, 'missing property')
    2:         self.assertIn(('m', 'method', B), attrs, 'missing plain method')
    2:         self.assertIn(('m1', 'method', A), attrs, 'missing plain method')
    2:         self.assertIn(('datablob', 'data', A), attrs, 'missing data')
    2:         self.assertIn(('md', 'method', A), attrs, 'missing method descriptor')
    2:         self.assertIn(('dd', 'data', A), attrs, 'missing data descriptor')
       
       
    4:         class C(A):
    2:             def m(self): pass
    2:             def c(self): pass
       
    2:         attrs = attrs_wo_objs(C)
    2:         self.assertIn(('s', 'static method', A), attrs, 'missing static method')
    2:         self.assertIn(('c', 'method', C), attrs, 'missing plain method')
    2:         self.assertIn(('p', 'property', A), attrs, 'missing property')
    2:         self.assertIn(('m', 'method', C), attrs, 'missing plain method')
    2:         self.assertIn(('m1', 'method', A), attrs, 'missing plain method')
    2:         self.assertIn(('datablob', 'data', A), attrs, 'missing data')
    2:         self.assertIn(('md', 'method', A), attrs, 'missing method descriptor')
    2:         self.assertIn(('dd', 'data', A), attrs, 'missing data descriptor')
       
    4:         class D(B, C):
    2:             def m1(self): pass
       
    2:         attrs = attrs_wo_objs(D)
    2:         self.assertIn(('s', 'static method', A), attrs, 'missing static method')
    2:         if newstyle:
    1:             self.assertIn(('c', 'method', C), attrs, 'missing plain method')
               else:
    1:             self.assertIn(('c', 'class method', A), attrs, 'missing class method')
    2:         self.assertIn(('p', 'property', A), attrs, 'missing property')
    2:         self.assertIn(('m', 'method', B), attrs, 'missing plain method')
    2:         self.assertIn(('m1', 'method', D), attrs, 'missing plain method')
    2:         self.assertIn(('datablob', 'data', A), attrs, 'missing data')
    2:         self.assertIn(('md', 'method', A), attrs, 'missing method descriptor')
    2:         self.assertIn(('dd', 'data', A), attrs, 'missing data descriptor')
       
       
    1:     def test_classify_oldstyle(self):
               """classify_class_attrs finds static methods, class methods,
               properties, normal methods, and data attributes on an old-style
               class.
               """
    1:         self._classify_test(False)
       
       
    1:     def test_classify_newstyle(self):
               """Just like test_classify_oldstyle, but for a new-style class.
               """
    1:         self._classify_test(True)
       
    1:     def test_classify_builtin_types(self):
               # Simple sanity check that all built-in types can have their
               # attributes classified.
  145:         for name in dir(__builtin__):
  144:             builtin = getattr(__builtin__, name)
  144:             if isinstance(builtin, type):
   76:                 inspect.classify_class_attrs(builtin)
       
    1:     def test_getmembers_method(self):
               # Old-style classes
    2:         class B:
    1:             def f(self):
>>>>>>                 pass
       
    1:         self.assertIn(('f', B.f), inspect.getmembers(B))
               # contrary to spec, ismethod() is also True for unbound methods
               # (see #1785)
    1:         self.assertIn(('f', B.f), inspect.getmembers(B, inspect.ismethod))
    1:         b = B()
    1:         self.assertIn(('f', b.f), inspect.getmembers(b))
    1:         self.assertIn(('f', b.f), inspect.getmembers(b, inspect.ismethod))
       
               # New-style classes
    2:         class B(object):
    1:             def f(self):
>>>>>>                 pass
       
    1:         self.assertIn(('f', B.f), inspect.getmembers(B))
    1:         self.assertIn(('f', B.f), inspect.getmembers(B, inspect.ismethod))
    1:         b = B()
    1:         self.assertIn(('f', b.f), inspect.getmembers(b))
    1:         self.assertIn(('f', b.f), inspect.getmembers(b, inspect.ismethod))
       
       
    2: class TestGetcallargsFunctions(unittest.TestCase):
       
           # tuple parameters are named '.1', '.2', etc.
    1:     is_tuplename = re.compile(r'^\.\d+$').match
       
    1:     def assertEqualCallArgs(self, func, call_params_string, locs=None):
  236:         locs = dict(locs or {}, func=func)
  236:         r1 = eval('func(%s)' % call_params_string, None, locs)
  236:         r2 = eval('inspect.getcallargs(func, %s)' % call_params_string, None,
  236:                   locs)
  236:         self.assertEqual(r1, r2)
       
    1:     def assertEqualException(self, func, call_param_string, locs=None):
  152:         locs = dict(locs or {}, func=func)
  152:         try:
  152:             eval('func(%s)' % call_param_string, None, locs)
  152:         except Exception, ex1:
  152:             pass
               else:
>>>>>>             self.fail('Exception not raised')
  152:         try:
  152:             eval('inspect.getcallargs(func, %s)' % call_param_string, None,
  152:                  locs)
  152:         except Exception, ex2:
  152:             pass
               else:
>>>>>>             self.fail('Exception not raised')
  152:         self.assertIs(type(ex1), type(ex2))
  152:         self.assertEqual(str(ex1), str(ex2))
       
    1:     def makeCallable(self, signature):
               """Create a function that returns its locals(), excluding the
               autogenerated '.1', '.2', etc. tuple param names (if any)."""
   33:         with check_py3k_warnings(
   33:             ("tuple parameter unpacking has been removed", SyntaxWarning),
   33:             quiet=True):
   33:             code = ("lambda %s: dict(i for i in locals().items() "
                           "if not is_tuplename(i[0]))")
   33:             return eval(code % signature, {'is_tuplename' : self.is_tuplename})
       
    1:     def test_plain(self):
    4:         f = self.makeCallable('a, b=1')
    4:         self.assertEqualCallArgs(f, '2')
    4:         self.assertEqualCallArgs(f, '2, 3')
    4:         self.assertEqualCallArgs(f, 'a=2')
    4:         self.assertEqualCallArgs(f, 'b=3, a=2')
    4:         self.assertEqualCallArgs(f, '2, b=3')
               # expand *iterable / **mapping
    4:         self.assertEqualCallArgs(f, '*(2,)')
    4:         self.assertEqualCallArgs(f, '*[2]')
    4:         self.assertEqualCallArgs(f, '*(2, 3)')
    4:         self.assertEqualCallArgs(f, '*[2, 3]')
    4:         self.assertEqualCallArgs(f, '**{"a":2}')
    4:         self.assertEqualCallArgs(f, 'b=3, **{"a":2}')
    4:         self.assertEqualCallArgs(f, '2, **{"b":3}')
    4:         self.assertEqualCallArgs(f, '**{"b":3, "a":2}')
               # expand UserList / UserDict
    4:         self.assertEqualCallArgs(f, '*UserList([2])')
    4:         self.assertEqualCallArgs(f, '*UserList([2, 3])')
    4:         self.assertEqualCallArgs(f, '**UserDict(a=2)')
    4:         self.assertEqualCallArgs(f, '2, **UserDict(b=3)')
    4:         self.assertEqualCallArgs(f, 'b=2, **UserDict(a=3)')
               # unicode keyword args
    4:         self.assertEqualCallArgs(f, '**{u"a":2}')
    4:         self.assertEqualCallArgs(f, 'b=3, **{u"a":2}')
    4:         self.assertEqualCallArgs(f, '2, **{u"b":3}')
    4:         self.assertEqualCallArgs(f, '**{u"b":3, u"a":2}')
       
    1:     def test_varargs(self):
    4:         f = self.makeCallable('a, b=1, *c')
    4:         self.assertEqualCallArgs(f, '2')
    4:         self.assertEqualCallArgs(f, '2, 3')
    4:         self.assertEqualCallArgs(f, '2, 3, 4')
    4:         self.assertEqualCallArgs(f, '*(2,3,4)')
    4:         self.assertEqualCallArgs(f, '2, *[3,4]')
    4:         self.assertEqualCallArgs(f, '2, 3, *UserList([4])')
       
    1:     def test_varkw(self):
    4:         f = self.makeCallable('a, b=1, **c')
    4:         self.assertEqualCallArgs(f, 'a=2')
    4:         self.assertEqualCallArgs(f, '2, b=3, c=4')
    4:         self.assertEqualCallArgs(f, 'b=3, a=2, c=4')
    4:         self.assertEqualCallArgs(f, 'c=4, **{"a":2, "b":3}')
    4:         self.assertEqualCallArgs(f, '2, c=4, **{"b":3}')
    4:         self.assertEqualCallArgs(f, 'b=2, **{"a":3, "c":4}')
    4:         self.assertEqualCallArgs(f, '**UserDict(a=2, b=3, c=4)')
    4:         self.assertEqualCallArgs(f, '2, c=4, **UserDict(b=3)')
    4:         self.assertEqualCallArgs(f, 'b=2, **UserDict(a=3, c=4)')
               # unicode keyword args
    4:         self.assertEqualCallArgs(f, 'c=4, **{u"a":2, u"b":3}')
    4:         self.assertEqualCallArgs(f, '2, c=4, **{u"b":3}')
    4:         self.assertEqualCallArgs(f, 'b=2, **{u"a":3, u"c":4}')
       
    1:     def test_varkw_only(self):
               # issue11256:
    4:         f = self.makeCallable('**c')
    4:         self.assertEqualCallArgs(f, '')
    4:         self.assertEqualCallArgs(f, 'a=1')
    4:         self.assertEqualCallArgs(f, 'a=1, b=2')
    4:         self.assertEqualCallArgs(f, 'c=3, **{"a": 1, "b": 2}')
    4:         self.assertEqualCallArgs(f, '**UserDict(a=1, b=2)')
    4:         self.assertEqualCallArgs(f, 'c=3, **UserDict(a=1, b=2)')
       
    1:     def test_tupleargs(self):
    4:         f = self.makeCallable('(b,c), (d,(e,f))=(0,[1,2])')
    4:         self.assertEqualCallArgs(f, '(2,3)')
    4:         self.assertEqualCallArgs(f, '[2,3]')
    4:         self.assertEqualCallArgs(f, 'UserList([2,3])')
    4:         self.assertEqualCallArgs(f, '(2,3), (4,(5,6))')
    4:         self.assertEqualCallArgs(f, '(2,3), (4,[5,6])')
    4:         self.assertEqualCallArgs(f, '(2,3), [4,UserList([5,6])]')
       
    1:     def test_multiple_features(self):
    4:         f = self.makeCallable('a, b=2, (c,(d,e))=(3,[4,5]), *f, **g')
    4:         self.assertEqualCallArgs(f, '2, 3, (4,[5,6]), 7')
    4:         self.assertEqualCallArgs(f, '2, 3, *[(4,[5,6]), 7], x=8')
    4:         self.assertEqualCallArgs(f, '2, 3, x=8, *[(4,[5,6]), 7]')
    4:         self.assertEqualCallArgs(f, '2, x=8, *[3, (4,[5,6]), 7], y=9')
    4:         self.assertEqualCallArgs(f, 'x=8, *[2, 3, (4,[5,6])], y=9')
    4:         self.assertEqualCallArgs(f, 'x=8, *UserList([2, 3, (4,[5,6])]), '
                                        '**{"y":9, "z":10}')
    4:         self.assertEqualCallArgs(f, '2, x=8, *UserList([3, (4,[5,6])]), '
                                        '**UserDict(y=9, z=10)')
       
    1:     def test_errors(self):
    4:         f0 = self.makeCallable('')
    4:         f1 = self.makeCallable('a, b')
    4:         f2 = self.makeCallable('a, b=1')
               # f0 takes no arguments
    4:         self.assertEqualException(f0, '1')
    4:         self.assertEqualException(f0, 'x=1')
    4:         self.assertEqualException(f0, '1,x=1')
               # f1 takes exactly 2 arguments
    4:         self.assertEqualException(f1, '')
    4:         self.assertEqualException(f1, '1')
    4:         self.assertEqualException(f1, 'a=2')
    4:         self.assertEqualException(f1, 'b=3')
               # f2 takes at least 1 argument
    4:         self.assertEqualException(f2, '')
    4:         self.assertEqualException(f2, 'b=3')
   12:         for f in f1, f2:
                   # f1/f2 takes exactly/at most 2 arguments
    8:             self.assertEqualException(f, '2, 3, 4')
    8:             self.assertEqualException(f, '1, 2, 3, a=1')
    8:             self.assertEqualException(f, '2, 3, 4, c=5')
    8:             self.assertEqualException(f, '2, 3, 4, a=1, c=5')
                   # f got an unexpected keyword argument
    8:             self.assertEqualException(f, 'c=2')
    8:             self.assertEqualException(f, '2, c=3')
    8:             self.assertEqualException(f, '2, 3, c=4')
    8:             self.assertEqualException(f, '2, c=4, b=3')
    8:             if have_unicode:
    8:                 self.assertEqualException(f, '**{u"\u03c0\u03b9": 4}')
                   # f got multiple values for keyword argument
    8:             self.assertEqualException(f, '1, a=2')
    8:             self.assertEqualException(f, '1, **{"a":2}')
    8:             self.assertEqualException(f, '1, 2, b=3')
                   # XXX: Python inconsistency
                   # - for functions and bound methods: unexpected keyword 'c'
                   # - for unbound methods: multiple values for keyword 'a'
                   #self.assertEqualException(f, '1, c=3, a=2')
    4:         f = self.makeCallable('(a,b)=(0,1)')
    4:         self.assertEqualException(f, '1')
    4:         self.assertEqualException(f, '[1]')
    4:         self.assertEqualException(f, '(1,2,3)')
               # issue11256:
    4:         f3 = self.makeCallable('**c')
    4:         self.assertEqualException(f3, '1, 2')
    4:         self.assertEqualException(f3, '1, 2, a=1, b=2')
       
       
    2: class TestGetcallargsFunctionsCellVars(TestGetcallargsFunctions):
       
    1:     def makeCallable(self, signature):
               """Create a function that returns its locals(), excluding the
               autogenerated '.1', '.2', etc. tuple param names (if any)."""
   11:         with check_py3k_warnings(
   11:             ("tuple parameter unpacking has been removed", SyntaxWarning),
   11:             quiet=True):
                   code = """lambda %s: (
                           (lambda: a+b+c+d+d+e+f+g+h), # make parameters cell vars
                           dict(i for i in locals().items()
                                if not is_tuplename(i[0]))
   11:                 )[1]"""
   11:             return eval(code % signature, {'is_tuplename' : self.is_tuplename})
       
       
    2: class TestGetcallargsMethods(TestGetcallargsFunctions):
       
    1:     def setUp(self):
   28:         class Foo(object):
   14:             pass
   14:         self.cls = Foo
   14:         self.inst = Foo()
       
    1:     def makeCallable(self, signature):
   22:         assert 'self' not in signature
   22:         mk = super(TestGetcallargsMethods, self).makeCallable
   22:         self.cls.method = mk('self, ' + signature)
   22:         return self.inst.method
       
    2: class TestGetcallargsUnboundMethods(TestGetcallargsMethods):
       
    1:     def makeCallable(self, signature):
   11:         super(TestGetcallargsUnboundMethods, self).makeCallable(signature)
   11:         return self.cls.method
       
    1:     def assertEqualCallArgs(self, func, call_params_string, locs=None):
   59:         return super(TestGetcallargsUnboundMethods, self).assertEqualCallArgs(
   59:             *self._getAssertEqualParams(func, call_params_string, locs))
       
    1:     def assertEqualException(self, func, call_params_string, locs=None):
   38:         return super(TestGetcallargsUnboundMethods, self).assertEqualException(
   38:             *self._getAssertEqualParams(func, call_params_string, locs))
       
    1:     def _getAssertEqualParams(self, func, call_params_string, locs=None):
   97:         assert 'inst' not in call_params_string
   97:         locs = dict(locs or {}, inst=self.inst)
   97:         return (func, 'inst,' + call_params_string, locs)
       
    1: def test_main():
    1:     run_unittest(
    1:         TestDecorators, TestRetrievingSourceCode, TestOneliners, TestBuggyCases,
    1:         TestInterpreterStack, TestClassesAndFunctions, TestPredicates,
    1:         TestGetcallargsFunctions, TestGetcallargsFunctionsCellVars,
    1:         TestGetcallargsMethods, TestGetcallargsUnboundMethods)
       
    1: if __name__ == "__main__":
>>>>>>     test_main()
