       # -*- coding: iso-8859-1 -*-
       """Get useful information from live Python objects.
       
       This module encapsulates the interface provided by the internal special
       attributes (func_*, co_*, im_*, tb_*, etc.) in a friendlier fashion.
       It also provides some help for examining source code and class layout.
       
       Here are some of the useful functions provided by this module:
       
           ismodule(), isclass(), ismethod(), isfunction(), isgeneratorfunction(),
               isgenerator(), istraceback(), isframe(), iscode(), isbuiltin(),
               isroutine() - check object types
           getmembers() - get members of an object that satisfy a given condition
       
           getfile(), getsourcefile(), getsource() - find an object's source code
           getdoc(), getcomments() - get documentation on an object
           getmodule() - determine the module that an object came from
           getclasstree() - arrange classes so as to represent their hierarchy
       
           getargspec(), getargvalues(), getcallargs() - get info about function arguments
           formatargspec(), formatargvalues() - format an argument spec
           getouterframes(), getinnerframes() - get info about frames
           currentframe() - get the current stack frame
           stack(), trace() - get info about frames on the stack or in a traceback
>>>>>> """
       
       # This module is in the public domain.  No warranties.
       
>>>>>> __author__ = 'Ka-Ping Yee <ping@lfw.org>'
>>>>>> __date__ = '1 Jan 2001'
       
>>>>>> import sys
>>>>>> import os
>>>>>> import types
>>>>>> import string
>>>>>> import re
>>>>>> import dis
>>>>>> import imp
>>>>>> import tokenize
>>>>>> import linecache
>>>>>> from operator import attrgetter
>>>>>> from collections import namedtuple
       
       # These constants are from Include/code.h.
>>>>>> CO_OPTIMIZED, CO_NEWLOCALS, CO_VARARGS, CO_VARKEYWORDS = 0x1, 0x2, 0x4, 0x8
>>>>>> CO_NESTED, CO_GENERATOR, CO_NOFREE = 0x10, 0x20, 0x40
       # See Include/object.h
>>>>>> TPFLAGS_IS_ABSTRACT = 1 << 20
       
       # ----------------------------------------------------------- type-checking
>>>>>> def ismodule(object):
           """Return true if the object is a module.
       
           Module objects provide these attributes:
               __doc__         documentation string
               __file__        filename (missing for built-in modules)"""
47801:     return isinstance(object, types.ModuleType)
       
>>>>>> def isclass(object):
           """Return true if the object is a class.
       
           Class objects provide these attributes:
               __doc__         documentation string
               __module__      name of module in which this class was defined"""
 9433:     return isinstance(object, (type, types.ClassType))
       
>>>>>> def ismethod(object):
           """Return true if the object is an instance method.
       
           Instance method objects provide these attributes:
               __doc__         documentation string
               __name__        name with which this method was defined
               im_class        class object in which this method belongs
               im_func         function object containing implementation of method
               im_self         instance to which this method is bound, or None"""
 7255:     return isinstance(object, types.MethodType)
       
>>>>>> def ismethoddescriptor(object):
           """Return true if the object is a method descriptor.
       
           But not if ismethod() or isclass() or isfunction() are true.
       
           This is new in Python 2.2, and, for example, is true of int.__add__.
           An object passing this test has a __get__ attribute but not a __set__
           attribute, but beyond that the set of attributes varies.  __name__ is
           usually sensible, and __doc__ often is.
       
           Methods implemented via descriptors that also pass one of the other
           tests return false from the ismethoddescriptor() test, simply because
           the other tests promise more -- you can, e.g., count on having the
           im_func attribute (etc) when an object passes ismethod()."""
 3402:     return (hasattr(object, "__get__")
 2755:             and not hasattr(object, "__set__") # else it's a data descriptor
 2384:             and not ismethod(object)           # mutual exclusion
 2384:             and not isfunction(object)
 2237:             and not isclass(object))
       
>>>>>> def isdatadescriptor(object):
           """Return true if the object is a data descriptor.
       
           Data descriptors have both a __get__ and a __set__ attribute.  Examples are
           properties (defined in Python) and getsets and members (defined in C).
           Typically, data descriptors will also have __name__ and __doc__ attributes
           (properties, getsets, and members have both of these attributes), but this
           is not guaranteed."""
 1289:     return (hasattr(object, "__set__") and hasattr(object, "__get__"))
       
>>>>>> if hasattr(types, 'MemberDescriptorType'):
           # CPython and equivalent
>>>>>>     def ismemberdescriptor(object):
               """Return true if the object is a member descriptor.
       
               Member descriptors are specialized descriptors defined in extension
               modules."""
  313:         return isinstance(object, types.MemberDescriptorType)
       else:
           # Other implementations
>>>>>>     def ismemberdescriptor(object):
               """Return true if the object is a member descriptor.
       
               Member descriptors are specialized descriptors defined in extension
               modules."""
>>>>>>         return False
       
>>>>>> if hasattr(types, 'GetSetDescriptorType'):
           # CPython and equivalent
>>>>>>     def isgetsetdescriptor(object):
               """Return true if the object is a getset descriptor.
       
               getset descriptors are specialized descriptors defined in extension
               modules."""
  313:         return isinstance(object, types.GetSetDescriptorType)
       else:
           # Other implementations
>>>>>>     def isgetsetdescriptor(object):
               """Return true if the object is a getset descriptor.
       
               getset descriptors are specialized descriptors defined in extension
               modules."""
>>>>>>         return False
       
>>>>>> def isfunction(object):
           """Return true if the object is a user-defined function.
       
           Function objects provide these attributes:
               __doc__         documentation string
               __name__        name with which this function was defined
               func_code       code object containing compiled function bytecode
               func_defaults   tuple of any default values for arguments
               func_doc        (same as __doc__)
               func_globals    global namespace in which this function was defined
               func_name       (same as __name__)"""
 9975:     return isinstance(object, types.FunctionType)
       
>>>>>> def isgeneratorfunction(object):
           """Return true if the object is a user-defined generator function.
       
           Generator function objects provide the same attributes as functions.
           See help(isfunction) for a list of attributes."""
   18:     return bool((isfunction(object) or ismethod(object)) and
    4:                 object.func_code.co_flags & CO_GENERATOR)
       
>>>>>> def isgenerator(object):
           """Return true if the object is a generator.
       
           Generator objects provide these attributes:
               __iter__        defined to support iteration over container
               close           raises a new GeneratorExit exception inside the
                               generator to terminate the iteration
               gi_code         code object
               gi_frame        frame object or possibly None once the generator has
                               been exhausted
               gi_running      set to 1 when generator is executing, 0 otherwise
               next            return the next item from the container
               send            resumes the generator and "sends" a value that becomes
                               the result of the current yield-expression
               throw           used to raise an exception inside the generator"""
   18:     return isinstance(object, types.GeneratorType)
       
>>>>>> def istraceback(object):
           """Return true if the object is a traceback.
       
           Traceback objects provide these attributes:
               tb_frame        frame object at this level
               tb_lasti        index of last attempted instruction in bytecode
               tb_lineno       current line number in Python source code
               tb_next         next inner traceback object (called by this level)"""
 2897:     return isinstance(object, types.TracebackType)
       
>>>>>> def isframe(object):
           """Return true if the object is a frame object.
       
           Frame objects provide these attributes:
               f_back          next outer frame object (this frame's caller)
               f_builtins      built-in namespace seen by this frame
               f_code          code object being executed in this frame
               f_exc_traceback traceback if raised in this frame, or None
               f_exc_type      exception type if raised in this frame, or None
               f_exc_value     exception value if raised in this frame, or None
               f_globals       global namespace seen by this frame
               f_lasti         index of last attempted instruction in bytecode
               f_lineno        current line number in Python source code
               f_locals        local namespace seen by this frame
               f_restricted    0 or 1 if frame is in restricted execution mode
               f_trace         tracing function for this frame, or None"""
 2897:     return isinstance(object, types.FrameType)
       
>>>>>> def iscode(object):
           """Return true if the object is a code object.
       
           Code objects provide these attributes:
               co_argcount     number of arguments (not including * or ** args)
               co_code         string of raw compiled bytecode
               co_consts       tuple of constants used in the bytecode
               co_filename     name of file in which this code object was created
               co_firstlineno  number of first line in Python source code
               co_flags        bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg
               co_lnotab       encoded mapping of line numbers to bytecode indices
               co_name         name with which this code object was defined
               co_names        tuple of names of local variables
               co_nlocals      number of local variables
               co_stacksize    virtual machine stack space required
               co_varnames     tuple of names of arguments and local variables"""
 3337:     return isinstance(object, types.CodeType)
       
>>>>>> def isbuiltin(object):
           """Return true if the object is a built-in function or method.
       
           Built-in functions and methods provide these attributes:
               __doc__         documentation string
               __name__        original name of this function or method
               __self__        instance to which a method is bound, or None"""
  462:     return isinstance(object, types.BuiltinFunctionType)
       
>>>>>> def isroutine(object):
           """Return true if the object is any kind of function or method."""
  427:     return (isbuiltin(object)
  426:             or isfunction(object)
  408:             or ismethod(object)
  295:             or ismethoddescriptor(object))
       
>>>>>> def isabstract(object):
           """Return true if the object is an abstract base class (ABC)."""
   13:     return bool(isinstance(object, type) and object.__flags__ & TPFLAGS_IS_ABSTRACT)
       
>>>>>> def getmembers(object, predicate=None):
           """Return all members of an object as (name, value) pairs sorted by name.
           Optionally, only return members that satisfy a given predicate."""
   51:     results = []
  534:     for key in dir(object):
  483:         try:
  483:             value = getattr(object, key)
    1:         except AttributeError:
    1:             continue
  482:         if not predicate or predicate(value):
  159:             results.append((key, value))
   51:     results.sort()
   51:     return results
       
>>>>>> Attribute = namedtuple('Attribute', 'name kind defining_class object')
       
>>>>>> def classify_class_attrs(cls):
           """Return list of attribute-descriptor tuples.
       
           For each name in dir(cls), the return list contains a 4-tuple
           with these elements:
       
               0. The name (a string).
       
               1. The kind of attribute this is, one of these strings:
                      'class method'    created via classmethod()
                      'static method'   created via staticmethod()
                      'property'        created via property()
                      'method'          any other flavor of method
                      'data'            not a method
       
               2. The class which defined this attribute (a class).
       
               3. The object as obtained directly from the defining class's
                  __dict__, not via getattr.  This is especially important for
                  data attributes:  C.data is just a data object, but
                  C.__dict__['data'] may be a data descriptor with additional
                  info, like a __doc__ string.
           """
       
  106:     mro = getmro(cls)
  106:     names = dir(cls)
  106:     result = []
 3005:     for name in names:
               # Get the object associated with the name, and where it was defined.
               # Getting an obj from the __dict__ sometimes reveals more than
               # using getattr.  Static and class methods are dramatic examples.
               # Furthermore, some objects may raise an Exception when fetched with
               # getattr(). This is the case with some descriptors (bug #1785).
               # Thus, we only use getattr() as a last resort.
 2899:         homecls = None
 8417:         for base in (cls,) + mro:
 8417:             if name in base.__dict__:
 2899:                 obj = base.__dict__[name]
 2899:                 homecls = base
 2899:                 break
               else:
>>>>>>             obj = getattr(cls, name)
>>>>>>             homecls = getattr(obj, "__objclass__", homecls)
       
               # Classify the object.
 2899:         if isinstance(obj, staticmethod):
   13:             kind = "static method"
 2886:         elif isinstance(obj, classmethod):
   10:             kind = "class method"
 2876:         elif isinstance(obj, property):
   16:             kind = "property"
 2860:         elif ismethoddescriptor(obj):
 2095:             kind = "method"
  765:         elif isdatadescriptor(obj):
  371:             kind = "data"
               else:
  394:             obj_via_getattr = getattr(cls, name)
  394:             if (ismethod(obj_via_getattr) or
  247:                 ismethoddescriptor(obj_via_getattr)):
  147:                 kind = "method"
                   else:
  247:                 kind = "data"
  394:             obj = obj_via_getattr
       
 2899:         result.append(Attribute(name, kind, homecls, obj))
       
  106:     return result
       
       # ----------------------------------------------------------- class helpers
>>>>>> def _searchbases(cls, accum):
           # Simulate the "classic class" search order.
   49:     if cls in accum:
    4:         return
   45:     accum.append(cls)
   71:     for base in cls.__bases__:
   26:         _searchbases(base, accum)
       
>>>>>> def getmro(cls):
           "Return tuple of base classes (including cls) in method resolution order."
  130:     if hasattr(cls, "__mro__"):
  107:         return cls.__mro__
           else:
   23:         result = []
   23:         _searchbases(cls, result)
   23:         return tuple(result)
       
       # -------------------------------------------------- source code extraction
>>>>>> def indentsize(line):
           """Return the indent size, in spaces, at the start of a line of text."""
   21:     expline = string.expandtabs(line)
   21:     return len(expline) - len(string.lstrip(expline))
       
>>>>>> def getdoc(object):
           """Get the documentation string for an object.
       
           All tabs are expanded to spaces.  To clean up docstrings that are
           indented to line up with blocks of code, any whitespace than can be
           uniformly removed from the second line onwards is removed."""
  365:     try:
  365:         doc = object.__doc__
>>>>>>     except AttributeError:
>>>>>>         return None
  365:     if not isinstance(doc, types.StringTypes):
   22:         return None
  343:     return cleandoc(doc)
       
>>>>>> def cleandoc(doc):
           """Clean up indentation from docstrings.
       
           Any whitespace that can be uniformly removed from the second line
           onwards is removed."""
  345:     try:
  345:         lines = string.split(string.expandtabs(doc), '\n')
>>>>>>     except UnicodeError:
>>>>>>         return None
           else:
               # Find minimum indentation of any non-blank lines after first line.
  345:         margin = sys.maxint
  826:         for line in lines[1:]:
  481:             content = len(string.lstrip(line))
  481:             if content:
  347:                 indent = len(line) - content
  347:                 margin = min(margin, indent)
               # Remove indentation.
  345:         if lines:
  345:             lines[0] = lines[0].lstrip()
  345:         if margin < sys.maxint:
  597:             for i in range(1, len(lines)): lines[i] = lines[i][margin:]
               # Remove any trailing or leading blank lines.
  355:         while lines and not lines[-1]:
   10:             lines.pop()
  347:         while lines and not lines[0]:
    2:             lines.pop(0)
  345:         return string.join(lines, '\n')
       
>>>>>> def getfile(object):
           """Work out which source or compiled file an object was defined in."""
 1567:     if ismodule(object):
  940:         if hasattr(object, '__file__'):
  920:             return object.__file__
   20:         raise TypeError('{!r} is a built-in module'.format(object))
  627:     if isclass(object):
   32:         object = sys.modules.get(object.__module__)
   32:         if hasattr(object, '__file__'):
   32:             return object.__file__
>>>>>>         raise TypeError('{!r} is a built-in class'.format(object))
  595:     if ismethod(object):
   20:         object = object.im_func
  595:     if isfunction(object):
  214:         object = object.func_code
  595:     if istraceback(object):
>>>>>>         object = object.tb_frame
  595:     if isframe(object):
  335:         object = object.f_code
  595:     if iscode(object):
  570:         return object.co_filename
   25:     raise TypeError('{!r} is not a module, class, method, '
   25:                     'function, traceback, frame, or code object'.format(object))
       
>>>>>> ModuleInfo = namedtuple('ModuleInfo', 'name suffix mode module_type')
       
>>>>>> def getmoduleinfo(path):
           """Get the module name, suffix, mode, and module type for a given file."""
   24:     filename = os.path.basename(path)
   24:     suffixes = map(lambda info:
   96:                    (-len(info[0]), info[0], info[1], info[2]),
   24:                     imp.get_suffixes())
   24:     suffixes.sort() # try longest suffixes first, in case they overlap
   84:     for neglen, suffix, mode, mtype in suffixes:
   75:         if filename[neglen:] == suffix:
   15:             return ModuleInfo(filename[:neglen], suffix, mode, mtype)
       
>>>>>> def getmodulename(path):
           """Return the module name for a given file, or None."""
   21:     info = getmoduleinfo(path)
   21:     if info: return info[0]
       
>>>>>> def getsourcefile(object):
           """Return the filename that can be used to locate an object's source.
           Return None if no way can be identified to get the source.
           """
 1277:     filename = getfile(object)
 1234:     if string.lower(filename[-4:]) in ('.pyc', '.pyo'):
  787:         filename = filename[:-4] + '.py'
 5922:     for suffix, mode, kind in imp.get_suffixes():
 4750:         if 'b' in mode and string.lower(filename[-len(suffix):]) == suffix:
                   # Looks like a binary file.  We want to only return a text file.
   62:             return None
 1172:     if os.path.exists(filename):
 1027:         return filename
           # only return a non-existent filename if the module has a PEP 302 loader
  145:     if hasattr(getmodule(object, filename), '__loader__'):
   72:         return filename
           # or it is in the linecache
   73:     if filename in linecache.cache:
    3:         return filename
       
>>>>>> def getabsfile(object, _filename=None):
           """Return an absolute path to the source or compiled file for an object.
       
           The idea is for each object to have a unique origin, so this routine
           normalizes the result as much as possible."""
  820:     if _filename is None:
  788:         _filename = getsourcefile(object) or getfile(object)
  786:     return os.path.normcase(os.path.abspath(_filename))
       
>>>>>> modulesbyfile = {}
>>>>>> _filesbymodname = {}
       
>>>>>> def getmodule(object, _filename=None):
           """Return the module an object was defined in, or None if not found."""
 4362:     if ismodule(object):
   77:         return object
 4285:     if hasattr(object, '__module__'):
 4125:         return sys.modules.get(object.__module__)
           # Try the filename to modulename cache
  160:     if _filename is not None and _filename in modulesbyfile:
  105:         return sys.modules.get(modulesbyfile[_filename])
           # Try the cache again with the absolute file name
   55:     try:
   55:         file = getabsfile(object, _filename)
   22:     except TypeError:
   22:         return None
   33:     if file in modulesbyfile:
    4:         return sys.modules.get(modulesbyfile[file])
           # Update the filename to module name cache and check yet again
           # Copy sys.modules in order to cope with changes while iterating
35033:     for modname, module in sys.modules.items():
35004:         if ismodule(module) and hasattr(module, '__file__'):
21403:             f = module.__file__
21403:             if f == _filesbymodname.get(modname, None):
                       # Have already mapped this module, so skip it
20664:                 continue
  739:             _filesbymodname[modname] = f
  739:             f = getabsfile(module)
                   # Always map to the name the module knows itself by
                   modulesbyfile[f] = modulesbyfile[
  739:                 os.path.realpath(f)] = module.__name__
   29:     if file in modulesbyfile:
    2:         return sys.modules.get(modulesbyfile[file])
           # Check the main module
   27:     main = sys.modules['__main__']
   27:     if not hasattr(object, '__name__'):
   27:         return None
>>>>>>     if hasattr(main, object.__name__):
>>>>>>         mainobject = getattr(main, object.__name__)
>>>>>>         if mainobject is object:
>>>>>>             return main
           # Check builtins
>>>>>>     builtin = sys.modules['__builtin__']
>>>>>>     if hasattr(builtin, object.__name__):
>>>>>>         builtinobject = getattr(builtin, object.__name__)
>>>>>>         if builtinobject is object:
>>>>>>             return builtin
       
>>>>>> def findsource(object):
           """Return the entire source file and starting line number for an object.
       
           The argument may be a module, class, method, function, traceback, frame,
           or code object.  The source code is returned as a list of all the lines
           in the file and the line number indexes a line in that list.  An IOError
           is raised if the source code cannot be retrieved."""
       
  172:     file = getfile(object)
  170:     sourcefile = getsourcefile(object)
  170:     if not sourcefile and file[:1] + file[-1:] != '<>':
    6:         raise IOError('source code not available')
  164:     file = sourcefile if sourcefile else file
       
  164:     module = getmodule(object, file)
  164:     if module:
  154:         lines = linecache.getlines(file, module.__dict__)
           else:
   10:         lines = linecache.getlines(file)
  164:     if not lines:
    7:         raise IOError('could not get source code')
       
  157:     if ismodule(object):
   10:         return lines, 0
       
  147:     if isclass(object):
   11:         name = object.__name__
   11:         pat = re.compile(r'^(\s*)class\s*' + name + r'\b')
               # make some effort to find the best matching class definition:
               # use the one with the least indentation, which is the one
               # that's most probably not inside a function definition.
   11:         candidates = []
 2069:         for i in range(len(lines)):
 2064:             match = pat.match(lines[i])
 2064:             if match:
                       # if it's at toplevel, it's already the best one
   13:                 if lines[i][0] == 'c':
    6:                     return lines, i
                       # else add whitespace to candidate list
    7:                 candidates.append((match.group(1), i))
    5:         if candidates:
                   # this will sort by whitespace, and by line number,
                   # less whitespace first
    5:             candidates.sort()
    5:             return lines, candidates[0][1]
               else:
>>>>>>             raise IOError('could not find class definition')
       
  136:     if ismethod(object):
    3:         object = object.im_func
  136:     if isfunction(object):
   29:         object = object.func_code
  136:     if istraceback(object):
>>>>>>         object = object.tb_frame
  136:     if isframe(object):
  105:         object = object.f_code
  136:     if iscode(object):
  136:         if not hasattr(object, 'co_firstlineno'):
>>>>>>             raise IOError('could not find function definition')
  136:         lnum = object.co_firstlineno - 1
  136:         pat = re.compile(r'^(\s*def\s)|(.*(?<!\w)lambda(:|\s))|^(\s*@)')
  136:         while lnum > 0:
  128:             if pat.match(lines[lnum]): break
>>>>>>             lnum = lnum - 1
  136:         return lines, lnum
>>>>>>     raise IOError('could not find code object')
       
>>>>>> def getcomments(object):
           """Get lines of comments immediately preceding an object's source code.
       
           Returns None when source can't be found.
           """
   24:     try:
   24:         lines, lnum = findsource(object)
    2:     except (IOError, TypeError):
    2:         return None
       
   22:     if ismodule(object):
               # Look for a comment block at the top of the file.
    2:         start = 0
    2:         if lines and lines[0][:2] == '#!': start = 1
    2:         while start < len(lines) and string.strip(lines[start]) in ('', '#'):
>>>>>>             start = start + 1
    2:         if start < len(lines) and lines[start][:1] == '#':
    2:             comments = []
    2:             end = start
    5:             while end < len(lines) and lines[end][:1] == '#':
    3:                 comments.append(string.expandtabs(lines[end]))
    3:                 end = end + 1
    2:             return string.join(comments, '')
       
           # Look for a preceding block of comments at the same indentation.
   20:     elif lnum > 0:
   20:         indent = indentsize(lines[lnum])
   20:         end = lnum - 1
   20:         if end >= 0 and string.lstrip(lines[end])[:1] == '#' and \
    1:             indentsize(lines[end]) == indent:
    1:             comments = [string.lstrip(string.expandtabs(lines[end]))]
    1:             if end > 0:
    1:                 end = end - 1
    1:                 comment = string.lstrip(string.expandtabs(lines[end]))
    1:                 while comment[:1] == '#' and indentsize(lines[end]) == indent:
>>>>>>                     comments[:0] = [comment]
>>>>>>                     end = end - 1
>>>>>>                     if end < 0: break
>>>>>>                     comment = string.lstrip(string.expandtabs(lines[end]))
    1:             while comments and string.strip(comments[0]) == '#':
>>>>>>                 comments[:1] = []
    1:             while comments and string.strip(comments[-1]) == '#':
>>>>>>                 comments[-1:] = []
    1:             return string.join(comments, '')
       
>>>>>> class EndOfBlock(Exception): pass
       
>>>>>> class BlockFinder:
           """Provide a tokeneater() method to detect the end of a code block."""
>>>>>>     def __init__(self):
   21:         self.indent = 0
   21:         self.islambda = False
   21:         self.started = False
   21:         self.passline = False
   21:         self.last = 1
       
>>>>>>     def tokeneater(self, type, token, srow_scol, erow_ecol, line):
  352:         srow, scol = srow_scol
  352:         erow, ecol = erow_ecol
  352:         if not self.started:
                   # look for the first "def", "class" or "lambda"
   50:             if token in ("def", "class", "lambda"):
   20:                 if token == "lambda":
    6:                     self.islambda = True
   20:                 self.started = True
   50:             self.passline = True    # skip to the end of the line
  302:         elif type == tokenize.NEWLINE:
   39:             self.passline = False   # stop skipping when a NEWLINE is seen
   39:             self.last = srow
   39:             if self.islambda:       # lambdas always end at the first NEWLINE
    6:                 raise EndOfBlock
  263:         elif self.passline:
  148:             pass
  115:         elif type == tokenize.INDENT:
   12:             self.indent = self.indent + 1
   12:             self.passline = True
  103:         elif type == tokenize.DEDENT:
   11:             self.indent = self.indent - 1
                   # the end of matching indent/dedent pairs end a block
                   # (note that this only works for "def"/"class" blocks,
                   #  not e.g. for "if: else:" or "try: finally:" blocks)
   11:             if self.indent <= 0:
    7:                 raise EndOfBlock
   92:         elif self.indent == 0 and type not in (tokenize.COMMENT, tokenize.NL):
                   # any other token on the same indentation level end the previous
                   # block as well, except the pseudo-tokens COMMENT and NL.
    5:             raise EndOfBlock
       
>>>>>> def getblock(lines):
           """Extract the block of code at the top of the given list of lines."""
   21:     blockfinder = BlockFinder()
   21:     try:
   21:         tokenize.tokenize(iter(lines).next, blockfinder.tokeneater)
   20:     except (EndOfBlock, IndentationError):
   20:         pass
   21:     return lines[:blockfinder.last]
       
>>>>>> def getsourcelines(object):
           """Return a list of source lines and starting line number for an object.
       
           The argument may be a module, class, method, function, traceback, frame,
           or code object.  The source code is returned as a list of the lines
           corresponding to the object and the line number indicates where in the
           original source file the first line of code was found.  An IOError is
           raised if the source code cannot be retrieved."""
   33:     lines, lnum = findsource(object)
       
   29:     if ismodule(object): return lines, 0
   21:     else: return getblock(lines[lnum:]), lnum + 1
       
>>>>>> def getsource(object):
           """Return the text of the source code for an object.
       
           The argument may be a module, class, method, function, traceback, frame,
           or code object.  The source code is returned as a single string.  An
           IOError is raised if the source code cannot be retrieved."""
   33:     lines, lnum = getsourcelines(object)
   29:     return string.join(lines, '')
       
       # --------------------------------------------------- class tree extraction
>>>>>> def walktree(classes, children, parent):
           """Recursive helper function for getclasstree()."""
   17:     results = []
   17:     classes.sort(key=attrgetter('__module__', '__name__'))
   44:     for c in classes:
   27:         results.append((c, c.__bases__))
   27:         if c in children:
   12:             results.append(walktree(children[c], children, c))
   17:     return results
       
>>>>>> def getclasstree(classes, unique=0):
           """Arrange the given list of classes into a hierarchy of nested lists.
       
           Where a nested list appears, it contains classes derived from the class
           whose entry immediately precedes the list.  Each entry is a 2-tuple
           containing a class and a tuple of its base classes.  If the 'unique'
           argument is true, exactly one entry appears in the returned structure
           for each class in the given list.  Otherwise, classes using multiple
           inheritance and their descendants will appear multiple times."""
    5:     children = {}
    5:     roots = []
   30:     for c in classes:
   25:         if c.__bases__:
   28:             for parent in c.__bases__:
   19:                 if not parent in children:
   12:                     children[parent] = []
   19:                 if c not in children[parent]:
   17:                     children[parent].append(c)
   19:                 if unique and parent in classes: break
    7:         elif c not in roots:
    7:             roots.append(c)
   17:     for parent in children:
   12:         if parent not in classes:
    3:             roots.append(parent)
    5:     return walktree(roots, children, None)
       
       # ------------------------------------------------ argument list extraction
>>>>>> Arguments = namedtuple('Arguments', 'args varargs keywords')
       
>>>>>> def getargs(co):
           """Get information about the arguments accepted by a code object.
       
           Three things are returned: (args, varargs, varkw), where 'args' is
           a list of argument names (possibly containing nested lists), and
           'varargs' and 'varkw' are the names of the * and ** arguments or None."""
       
  550:     if not iscode(co):
>>>>>>         raise TypeError('{!r} is not a code object'.format(co))
       
  550:     nargs = co.co_argcount
  550:     names = co.co_varnames
  550:     args = list(names[:nargs])
  550:     step = 0
       
           # The following acrobatics are for anonymous (tuple) arguments.
 1648:     for i in range(nargs):
 1098:         if args[i][:1] in ('', '.'):
   93:             stack, remain, count = [], [], []
  477:             while step < len(co.co_code):
  477:                 op = ord(co.co_code[step])
  477:                 step = step + 1
  477:                 if op >= dis.HAVE_ARGUMENT:
  477:                     opname = dis.opname[op]
  477:                     value = ord(co.co_code[step]) + ord(co.co_code[step+1])*256
  477:                     step = step + 2
  477:                     if opname in ('UNPACK_TUPLE', 'UNPACK_SEQUENCE'):
  148:                         remain.append(value)
  148:                         count.append(value)
  329:                     elif opname in ('STORE_FAST', 'STORE_DEREF'):
  236:                         if opname == 'STORE_FAST':
  176:                             stack.append(names[value])
                               else:
   60:                             stack.append(co.co_cellvars[value])
       
                               # Special case for sublists of length 1: def foo((bar))
                               # doesn't generate the UNPACK_TUPLE bytecode, so if
                               # `remain` is empty here, we have such a sublist.
  236:                         if not remain:
>>>>>>                             stack[0] = [stack[0]]
>>>>>>                             break
                               else:
  236:                             remain[-1] = remain[-1] - 1
  291:                             while remain[-1] == 0:
  148:                                 remain.pop()
  148:                                 size = count.pop()
  148:                                 stack[-size:] = [stack[-size:]]
  148:                                 if not remain: break
   55:                                 remain[-1] = remain[-1] - 1
  236:                             if not remain: break
   93:             args[i] = stack[0]
       
  550:     varargs = None
  550:     if co.co_flags & CO_VARARGS:
   55:         varargs = co.co_varnames[nargs]
   55:         nargs = nargs + 1
  550:     varkw = None
  550:     if co.co_flags & CO_VARKEYWORDS:
  112:         varkw = co.co_varnames[nargs]
  550:     return Arguments(args, varargs, varkw)
       
>>>>>> ArgSpec = namedtuple('ArgSpec', 'args varargs keywords defaults')
       
>>>>>> def getargspec(func):
           """Get the names and default values of a function's arguments.
       
           A tuple of four things is returned: (args, varargs, varkw, defaults).
           'args' is a list of the argument names (it may contain nested lists).
           'varargs' and 'varkw' are the names of the * and ** arguments or None.
           'defaults' is an n-tuple of the default values of the last n arguments.
           """
       
  548:     if ismethod(func):
  195:         func = func.im_func
  548:     if not isfunction(func):
>>>>>>         raise TypeError('{!r} is not a Python function'.format(func))
  548:     args, varargs, varkw = getargs(func.func_code)
  548:     return ArgSpec(args, varargs, varkw, func.func_defaults)
       
>>>>>> ArgInfo = namedtuple('ArgInfo', 'args varargs keywords locals')
       
>>>>>> def getargvalues(frame):
           """Get information about arguments passed into a particular frame.
       
           A tuple of four things is returned: (args, varargs, varkw, locals).
           'args' is a list of the argument names (it may contain nested lists).
           'varargs' and 'varkw' are the names of the * and ** arguments or None.
           'locals' is the locals dictionary of the given frame."""
    2:     args, varargs, varkw = getargs(frame.f_code)
    2:     return ArgInfo(args, varargs, varkw, frame.f_locals)
       
>>>>>> def joinseq(seq):
    6:     if len(seq) == 1:
    3:         return '(' + seq[0] + ',)'
           else:
    3:         return '(' + string.join(seq, ', ') + ')'
       
>>>>>> def strseq(object, convert, join=joinseq):
           """Recursively walk a sequence, stringifying each element."""
  184:     if type(object) in (list, tuple):
   15:         return join(map(lambda o, c=convert, j=join: strseq(o, c, j), object))
           else:
  178:         return convert(object)
       
>>>>>> def formatargspec(args, varargs=None, varkw=None, defaults=None,
>>>>>>                   formatarg=str,
    2:                   formatvarargs=lambda name: '*' + name,
    3:                   formatvarkw=lambda name: '**' + name,
    4:                   formatvalue=lambda value: '=' + repr(value),
>>>>>>                   join=joinseq):
           """Format an argument spec from the 4 values returned by getargspec.
       
           The first four arguments are (args, varargs, varkw, defaults).  The
           other four arguments are the corresponding optional formatting functions
           that are called to turn names and values into strings.  The ninth
           argument is an optional function to format the sequence of arguments."""
  155:     specs = []
  155:     if defaults:
    3:         firstdefault = len(args) - len(defaults)
  323:     for i, arg in enumerate(args):
  168:         spec = strseq(arg, formatarg, join)
  168:         if defaults and i >= firstdefault:
    6:             spec = spec + formatvalue(defaults[i - firstdefault])
  168:         specs.append(spec)
  155:     if varargs is not None:
    2:         specs.append(formatvarargs(varargs))
  155:     if varkw is not None:
    3:         specs.append(formatvarkw(varkw))
  155:     return '(' + string.join(specs, ', ') + ')'
       
       def formatargvalues(args, varargs, varkw, locals,
>>>>>>                     formatarg=str,
    1:                     formatvarargs=lambda name: '*' + name,
    1:                     formatvarkw=lambda name: '**' + name,
   10:                     formatvalue=lambda value: '=' + repr(value),
>>>>>>                     join=joinseq):
           """Format an argument spec from the 4 values returned by getargvalues.
       
           The first four arguments are (args, varargs, varkw, locals).  The
           next four arguments are the corresponding optional formatting functions
           that are called to turn names and values into strings.  The ninth
           argument is an optional function to format the sequence of arguments."""
    2:     def convert(name, locals=locals,
    2:                 formatarg=formatarg, formatvalue=formatvalue):
    8:         return formatarg(name) + formatvalue(locals[name])
    2:     specs = []
    9:     for i in range(len(args)):
    7:         specs.append(strseq(args[i], convert, join))
    2:     if varargs:
    1:         specs.append(formatvarargs(varargs) + formatvalue(locals[varargs]))
    2:     if varkw:
    1:         specs.append(formatvarkw(varkw) + formatvalue(locals[varkw]))
    2:     return '(' + string.join(specs, ', ') + ')'
       
>>>>>> def getcallargs(func, *positional, **named):
           """Get the mapping of arguments to values.
       
           A dict is returned, with keys the function argument names (including the
           names of the * and ** arguments, if any), and values the respective bound
           values from 'positional' and 'named'."""
  388:     args, varargs, varkw, defaults = getargspec(func)
  388:     f_name = func.__name__
  388:     arg2value = {}
       
           # The following closures are basically because of tuple parameter unpacking.
  388:     assigned_tuple_params = []
  388:     def assign(arg, value):
 1246:         if isinstance(arg, str):
 1106:             arg2value[arg] = value
               else:
  140:             assigned_tuple_params.append(arg)
  140:             value = iter(value)
  404:             for i, subarg in enumerate(arg):
  272:                 try:
  272:                     subvalue = next(value)
    4:                 except StopIteration:
    4:                     raise ValueError('need more than %d %s to unpack' %
    4:                                      (i, 'values' if i > 1 else 'value'))
  268:                 assign(subarg,subvalue)
  132:             try:
  132:                 next(value)
  128:             except StopIteration:
  128:                 pass
                   else:
    4:                 raise ValueError('too many values to unpack')
  388:     def is_assigned(arg):
 1098:         if isinstance(arg,str):
  970:             return arg in arg2value
  128:         return arg in assigned_tuple_params
  388:     if ismethod(func) and func.im_self is not None:
               # implicit 'self' (or 'cls' for classmethods) argument
   97:         positional = (func.im_self,) + positional
  388:     num_pos = len(positional)
  388:     num_total = num_pos + len(named)
  388:     num_args = len(args)
  388:     num_defaults = len(defaults) if defaults else 0
  958:     for arg, value in zip(args, positional):
  582:         assign(arg, value)
  376:     if varargs:
   52:         if num_pos > num_args:
   32:             assign(varargs, positional[-(num_pos-num_args):])
               else:
   20:             assign(varargs, ())
  324:     elif 0 < num_args < num_pos:
   40:         raise TypeError('%s() takes %s %d %s (%d given)' % (
   40:             f_name, 'at most' if defaults else 'exactly', num_args,
   40:             'arguments' if num_args > 1 else 'argument', num_total))
  284:     elif num_args == 0 and num_total:
   20:         if varkw:
   14:             if num_pos:
                       # XXX: We should use num_pos, but Python also uses num_total:
    4:                 raise TypeError('%s() takes exactly 0 arguments '
    4:                                 '(%d given)' % (f_name, num_total))
               else:
    6:             raise TypeError('%s() takes no arguments (%d given)' %
    6:                             (f_name, num_total))
 1078:     for arg in args:
  776:         if isinstance(arg, str) and arg in named:
  200:             if is_assigned(arg):
   24:                 raise TypeError("%s() got multiple values for keyword "
   24:                                 "argument '%s'" % (f_name, arg))
                   else:
  176:                 assign(arg, named.pop(arg))
  302:     if defaults:    # fill in any missing values with the defaults
  508:         for arg, value in zip(args[-num_defaults:], defaults):
  268:             if not is_assigned(arg):
   68:                 assign(arg, value)
  302:     if varkw:
  100:         assign(varkw, named)
  202:     elif named:
   42:         unexpected = next(iter(named))
   42:         try:
   42:             unicode
>>>>>>         except NameError:
>>>>>>             pass
               else:
   42:             if isinstance(unexpected, unicode):
    8:                 unexpected = unexpected.encode(sys.getdefaultencoding(), 'replace')
   42:         raise TypeError("%s() got an unexpected keyword argument '%s'" %
   42:                         (f_name, unexpected))
  890:     unassigned = num_args - len([arg for arg in args if is_assigned(arg)])
  260:     if unassigned:
   24:         num_required = num_args - num_defaults
   24:         raise TypeError('%s() takes %s %d %s (%d given)' % (
   24:             f_name, 'at least' if defaults else 'exactly', num_required,
   24:             'arguments' if num_required > 1 else 'argument', num_total))
  236:     return arg2value
       
       # -------------------------------------------------- stack frame extraction
       
>>>>>> Traceback = namedtuple('Traceback', 'filename lineno function code_context index')
       
>>>>>> def getframeinfo(frame, context=1):
           """Get information about a frame or traceback object.
       
           A tuple of five things is returned: the filename, the line number of
           the current line, the function name, a list of lines of context from
           the source code, and the index of the current line within that list.
           The optional second argument specifies the number of lines of context
           to return, which are centered around the current line."""
  110:     if istraceback(frame):
   15:         lineno = frame.tb_lineno
   15:         frame = frame.tb_frame
           else:
   95:         lineno = frame.f_lineno
  110:     if not isframe(frame):
>>>>>>         raise TypeError('{!r} is not a frame or traceback object'.format(frame))
       
  110:     filename = getsourcefile(frame) or getfile(frame)
  110:     if context > 0:
  110:         start = lineno - 1 - context//2
  110:         try:
  110:             lines, lnum = findsource(frame)
    5:         except IOError:
    5:             lines = index = None
               else:
  105:             start = max(start, 1)
  105:             start = max(0, min(start, len(lines) - context))
  105:             lines = lines[start:start+context]
  105:             index = lineno - 1 - start
           else:
>>>>>>         lines = index = None
       
  110:     return Traceback(filename, lineno, frame.f_code.co_name, lines, index)
       
>>>>>> def getlineno(frame):
           """Get the line number from a frame object, allowing for optimization."""
           # FrameType.f_lineno is now a descriptor that grovels co_lnotab
>>>>>>     return frame.f_lineno
       
>>>>>> def getouterframes(frame, context=1):
           """Get a list of records for a frame and all higher (calling) frames.
       
           Each record contains a frame object, filename, line number, function
           name, a list of lines of context, and index within the context."""
    5:     framelist = []
  100:     while frame:
   95:         framelist.append((frame,) + getframeinfo(frame, context))
   95:         frame = frame.f_back
    5:     return framelist
       
>>>>>> def getinnerframes(tb, context=1):
           """Get a list of records for a traceback's frame and all lower frames.
       
           Each record contains a frame object, filename, line number, function
           name, a list of lines of context, and index within the context."""
    5:     framelist = []
   20:     while tb:
   15:         framelist.append((tb.tb_frame,) + getframeinfo(tb, context))
   15:         tb = tb.tb_next
    5:     return framelist
       
>>>>>> if hasattr(sys, '_getframe'):
>>>>>>     currentframe = sys._getframe
       else:
>>>>>>     currentframe = lambda _=None: None
       
>>>>>> def stack(context=1):
           """Return a list of records for the stack above the caller's frame."""
    5:     return getouterframes(sys._getframe(1), context)
       
>>>>>> def trace(context=1):
           """Return a list of records for the stack below the current exception."""
    5:     return getinnerframes(sys.exc_info()[2], context)
