       #!/usr/bin/env python
       # -*- coding: latin-1 -*-
       """Generate Python documentation in HTML or text for interactive use.
       
       In the Python interpreter, do "from pydoc import help" to provide online
       help.  Calling help(thing) on a Python object documents the object.
       
       Or, at the shell command line outside of Python:
       
       Run "pydoc <name>" to show documentation on something.  <name> may be
       the name of a function, module, package, or a dotted reference to a
       class or function within a module or module in a package.  If the
       argument contains a path segment delimiter (e.g. slash on Unix,
       backslash on Windows) it is treated as the path to a Python source file.
       
       Run "pydoc -k <keyword>" to search for a keyword in the synopsis lines
       of all available modules.
       
       Run "pydoc -p <port>" to start an HTTP server on a given port on the
       local machine to generate documentation web pages.  Port number 0 can be
       used to get an arbitrary unused port.
       
       For platforms without a command line, "pydoc -g" starts the HTTP server
       and also pops up a little window for controlling it.
       
       Run "pydoc -w <name>" to write out the HTML documentation for a module
       to a file named "<name>.html".
       
       Module docs for core modules are assumed to be in
       
           https://docs.python.org/library/
       
       This can be overridden by setting the PYTHONDOCS environment variable
       to a different URL or to a local directory containing the Library
       Reference Manual pages.
    1: """
       
    1: __author__ = "Ka-Ping Yee <ping@lfw.org>"
    1: __date__ = "26 February 2001"
       
    1: __version__ = "$Revision: 88564 $"
       __credits__ = """Guido van Rossum, for an excellent programming language.
       Tommy Burnette, the original creator of manpy.
       Paul Prescod, for all his work on onlinehelp.
       Richard Chamberlain, for the first implementation of textdoc.
    1: """
       
       # Known bugs that can't be fixed here:
       #   - imp.load_module() cannot be prevented from clobbering existing
       #     loaded modules, so calling synopsis() on a binary module file
       #     changes the contents of any existing module with the same name.
       #   - If the __file__ attribute on a module is a relative path and
       #     the current directory is changed with os.chdir(), an incorrect
       #     path will be displayed.
       
    1: import sys, imp, os, re, types, inspect, __builtin__, pkgutil, warnings
    1: from repr import Repr
    1: from string import expandtabs, find, join, lower, split, strip, rfind, rstrip
    1: from traceback import extract_tb
    1: try:
    1:     from collections import deque
>>>>>> except ImportError:
           # Python 2.3 compatibility
>>>>>>     class deque(list):
>>>>>>         def popleft(self):
>>>>>>             return self.pop(0)
       
       # --------------------------------------------------------- common routines
       
    1: def pathdirs():
           """Convert sys.path into a list of absolute, existing, unique paths."""
>>>>>>     dirs = []
>>>>>>     normdirs = []
>>>>>>     for dir in sys.path:
>>>>>>         dir = os.path.abspath(dir or '.')
>>>>>>         normdir = os.path.normcase(dir)
>>>>>>         if normdir not in normdirs and os.path.isdir(dir):
>>>>>>             dirs.append(dir)
>>>>>>             normdirs.append(normdir)
>>>>>>     return dirs
       
    1: def getdoc(object):
           """Get the doc string or comments for an object."""
  362:     result = inspect.getdoc(object) or inspect.getcomments(object)
  362:     result = _encode(result)
  362:     return result and re.sub('^ *\n', '', rstrip(result)) or ''
       
    1: def splitdoc(doc):
           """Split a doc string into a synopsis line (if any) and the rest."""
    8:     lines = split(strip(doc), '\n')
    8:     if len(lines) == 1:
    7:         return lines[0], ''
    1:     elif len(lines) >= 2 and not rstrip(lines[1]):
>>>>>>         return lines[0], join(lines[2:], '\n')
    1:     return '', join(lines, '\n')
       
    1: def classname(object, modname):
           """Get a class name and qualify it with a module name if necessary."""
   82:     name = object.__name__
   82:     if object.__module__ != modname:
   22:         name = object.__module__ + '.' + name
   82:     return name
       
    1: def isdata(object):
           """Check if an object is of a type that probably means it's data."""
   86:     return not (inspect.ismodule(object) or inspect.isclass(object) or
   67:                 inspect.isroutine(object) or inspect.isframe(object) or
   63:                 inspect.istraceback(object) or inspect.iscode(object))
       
    1: def replace(text, *pairs):
           """Do a series of global replacements on a string."""
 7387:     while pairs:
 5737:         text = join(split(text, pairs[0]), pairs[1])
 5737:         pairs = pairs[2:]
 1650:     return text
       
    1: def cram(text, maxlen):
           """Omit part of a string if needed to make it fit in a maximum length."""
   45:     if len(text) > maxlen:
>>>>>>         pre = max(0, (maxlen-3)//2)
>>>>>>         post = max(0, maxlen-3-pre)
>>>>>>         return text[:pre] + '...' + text[len(text)-post:]
   45:     return text
       
    1: _re_stripid = re.compile(r' at 0x[0-9a-f]{6,16}(>+)$', re.IGNORECASE)
    1: def stripid(text):
           """Remove the hexadecimal id from a Python object representation."""
           # The behaviour of %p is implementation-dependent in terms of case.
   35:     return _re_stripid.sub(r'\1', text)
       
    1: def _is_some_method(obj):
>>>>>>     return inspect.ismethod(obj) or inspect.ismethoddescriptor(obj)
       
    1: def allmethods(cl):
>>>>>>     methods = {}
>>>>>>     for key, value in inspect.getmembers(cl, _is_some_method):
>>>>>>         methods[key] = 1
>>>>>>     for base in cl.__bases__:
>>>>>>         methods.update(allmethods(base)) # all your base are belong to us
>>>>>>     for key in methods.keys():
>>>>>>         methods[key] = getattr(cl, key)
>>>>>>     return methods
       
    1: def _split_list(s, predicate):
           """Split sequence s via predicate, and return pair ([true], [false]).
       
           The return value is a 2-tuple of lists,
               ([x for x in s if predicate(x)],
                [x for x in s if not predicate(x)])
           """
       
  205:     yes = []
  205:     no = []
 1450:     for x in s:
 1245:         if predicate(x):
  755:             yes.append(x)
               else:
  490:             no.append(x)
  205:     return yes, no
       
    1: def visiblename(name, all=None, obj=None):
           """Decide whether to show documentation on a variable."""
           # Certain special names are redundant.
           _hidden_names = ('__builtins__', '__doc__', '__file__', '__path__',
  601:                      '__module__', '__name__', '__slots__', '__package__')
  601:     if name in _hidden_names: return 0
           # Private names are hidden, but special names are displayed.
  524:     if name.startswith('__') and name.endswith('__'): return 1
           # Namedtuples have public fields and methods with a single leading underscore
  241:     if name.startswith('_') and hasattr(obj, '_fields'):
    5:         return 1
  236:     if all is not None:
               # only document that which the programmer exported in __all__
>>>>>>         return name in all
           else:
  236:         return not name.startswith('_')
       
    1: def classify_class_attrs(object):
           """Wrap inspect.classify_class_attrs, with fixup for data descriptors."""
   22:     def fixup(data):
  519:         name, kind, cls, value = data
  519:         if inspect.isdatadescriptor(value):
   41:             kind = 'data descriptor'
  519:         return name, kind, cls, value
   22:     return map(fixup, inspect.classify_class_attrs(object))
       
       # ----------------------------------------------------- Unicode support helpers
       
    1: try:
    1:     _unicode = unicode
>>>>>> except NameError:
           # If Python is built without Unicode support, the unicode type
           # will not exist. Fake one that nothing will match, and make
           # the _encode function that do nothing.
>>>>>>     class _unicode(object):
>>>>>>         pass
>>>>>>     _encoding = 'ascii'
>>>>>>     def _encode(text, encoding='ascii'):
>>>>>>         return text
       else:
    1:     import locale
    1:     _encoding = locale.getpreferredencoding()
       
    1:     def _encode(text, encoding=None):
  376:         if isinstance(text, unicode):
    7:             return text.encode(encoding or _encoding, 'xmlcharrefreplace')
               else:
  369:             return text
       
    1: def _binstr(obj):
           # Ensure that we have an encoded (binary) string representation of obj,
           # even if it is a unicode string.
   30:     if isinstance(obj, _unicode):
   24:         return obj.encode(_encoding, 'xmlcharrefreplace')
    6:     return str(obj)
       
       # ----------------------------------------------------- module manipulation
       
    1: def ispackage(path):
           """Guess whether a path refers to a package directory."""
>>>>>>     if os.path.isdir(path):
>>>>>>         for ext in ('.py', '.pyc', '.pyo'):
>>>>>>             if os.path.isfile(os.path.join(path, '__init__' + ext)):
>>>>>>                 return True
>>>>>>     return False
       
    1: def source_synopsis(file):
    4:     line = file.readline()
    4:     while line[:1] == '#' or not strip(line):
>>>>>>         line = file.readline()
>>>>>>         if not line: break
    4:     line = strip(line)
    4:     if line[:4] == 'r"""': line = line[1:]
    4:     if line[:3] == '"""':
    1:         line = line[3:]
    1:         if line[-1:] == '\\': line = line[:-1]
    2:         while not strip(line):
    1:             line = file.readline()
    1:             if not line: break
    1:         result = strip(split(line, '"""')[0])
    3:     else: result = None
    4:     return result
       
    1: def synopsis(filename, cache={}):
           """Get the one-line summary out of a module file."""
    3:     mtime = os.stat(filename).st_mtime
    3:     lastupdate, result = cache.get(filename, (None, None))
    3:     if lastupdate is None or lastupdate < mtime:
    3:         info = inspect.getmoduleinfo(filename)
    3:         try:
    3:             file = open(filename)
>>>>>>         except IOError:
                   # module can't be opened, so skip it
>>>>>>             return None
    3:         if info and 'b' in info[2]: # binary modules have to be imported
    1:             try: module = imp.load_module('__temp__', file, filename, info[1:])
>>>>>>             except: return None
    1:             result = module.__doc__.splitlines()[0] if module.__doc__ else None
    1:             del sys.modules['__temp__']
               else: # text modules can be directly examined
    2:             result = source_synopsis(file)
    2:             file.close()
    3:         cache[filename] = (mtime, result)
    3:     return result
       
    2: class ErrorDuringImport(Exception):
    1:     """Errors that occurred while trying to import something to document it."""
    1:     def __init__(self, filename, exc_info):
>>>>>>         exc, value, tb = exc_info
>>>>>>         self.filename = filename
>>>>>>         self.exc = exc
>>>>>>         self.value = value
>>>>>>         self.tb = tb
       
    1:     def __str__(self):
>>>>>>         exc = self.exc
>>>>>>         if type(exc) is types.ClassType:
>>>>>>             exc = exc.__name__
>>>>>>         return 'problem in %s - %s: %s' % (self.filename, exc, self.value)
       
    1: def importfile(path):
           """Import a Python source file or compiled file given its path."""
>>>>>>     magic = imp.get_magic()
>>>>>>     file = open(path, 'r')
>>>>>>     if file.read(len(magic)) == magic:
>>>>>>         kind = imp.PY_COMPILED
           else:
>>>>>>         kind = imp.PY_SOURCE
>>>>>>     file.close()
>>>>>>     filename = os.path.basename(path)
>>>>>>     name, ext = os.path.splitext(filename)
>>>>>>     file = open(path, 'r')
>>>>>>     try:
>>>>>>         module = imp.load_module(name, file, path, (ext, 'r', kind))
>>>>>>     except:
>>>>>>         raise ErrorDuringImport(path, sys.exc_info())
>>>>>>     file.close()
>>>>>>     return module
       
    1: def safeimport(path, forceload=0, cache={}):
           """Import a module; handle errors; return None if the module isn't found.
       
           If the module *is* found but an exception occurs, it's wrapped in an
           ErrorDuringImport exception and reraised.  Unlike __import__, if a
           package path is specified, the module at the end of the path is returned,
           not the package at the beginning.  If the optional 'forceload' argument
           is 1, we reload the module from disk (unless it's a dynamic extension)."""
   28:     try:
               # If forceload is 1 and the module has been previously loaded from
               # disk, we always have to reload the module.  Checking the file's
               # mtime isn't good enough (e.g. the module could contain a class
               # that inherits from another module that has changed).
   28:         if forceload and path in sys.modules:
>>>>>>             if path not in sys.builtin_module_names:
                       # Avoid simply calling reload() because it leaves names in
                       # the currently loaded module lying around if they're not
                       # defined in the new source file.  Instead, remove the
                       # module from sys.modules and re-import.  Also remove any
                       # submodules because they won't appear in the newly loaded
                       # module's namespace if they're already in sys.modules.
>>>>>>                 subs = [m for m in sys.modules if m.startswith(path + '.')]
>>>>>>                 for key in [path] + subs:
                           # Prevent garbage collection.
>>>>>>                     cache[key] = sys.modules[key]
>>>>>>                     del sys.modules[key]
   28:         module = __import__(path)
   20:     except:
               # Did the error occur before or after the module was found?
   20:         (exc, value, tb) = info = sys.exc_info()
   20:         if path in sys.modules:
                   # An error occurred while executing the imported module.
>>>>>>             raise ErrorDuringImport(sys.modules[path].__file__, info)
   20:         elif exc is SyntaxError:
                   # A SyntaxError occurred before we could execute the module.
>>>>>>             raise ErrorDuringImport(value.filename, info)
   20:         elif exc is ImportError and extract_tb(tb)[-1][2]=='safeimport':
                   # The import error occurred directly in this function,
                   # which means there is no such module in the path.
   20:             return None
               else:
                   # Some other error occurred during the importing process.
>>>>>>             raise ErrorDuringImport(path, sys.exc_info())
    8:     for part in split(path, '.')[1:]:
>>>>>>         try: module = getattr(module, part)
>>>>>>         except AttributeError: return None
    8:     return module
       
       # ---------------------------------------------------- formatter base class
       
    2: class Doc:
    1:     def document(self, object, name=None, *args):
               """Generate documentation for an object."""
  298:         args = (object, name) + args
               # 'try' clause is to attempt to handle the possibility that inspect
               # identifies something in a way that pydoc itself has issues handling;
               # think 'super' and how it is a descriptor (which raises the exception
               # by lacking a __name__ attribute) and an instance.
  298:         if inspect.isgetsetdescriptor(object): return self.docdata(*args)
  298:         if inspect.ismemberdescriptor(object): return self.docdata(*args)
  298:         try:
  298:             if inspect.ismodule(object): return self.docmodule(*args)
  291:             if inspect.isclass(object): return self.docclass(*args)
  269:             if inspect.isroutine(object): return self.docroutine(*args)
>>>>>>         except AttributeError:
>>>>>>             pass
    7:         if isinstance(object, property): return self.docproperty(*args)
    7:         return self.docother(*args)
       
    1:     def fail(self, object, name=None, *args):
               """Raise an exception for unimplemented types."""
>>>>>>         message = "don't know how to document object%s of type %s" % (
>>>>>>             name and ' ' + repr(name), type(object).__name__)
>>>>>>         raise TypeError, message
       
    1:     docmodule = docclass = docroutine = docother = docproperty = docdata = fail
       
           def getdocloc(self, object,
    1:                   basedir=os.path.join(sys.exec_prefix, "lib",
    1:                                        "python"+sys.version[0:3])):
               """Return the location of module docs or None"""
       
   14:         try:
   14:             file = inspect.getabsfile(object)
    6:         except TypeError:
    6:             file = '(built-in)'
       
   14:         docloc = os.environ.get("PYTHONDOCS",
   14:                                 "https://docs.python.org/library")
   14:         basedir = os.path.normcase(basedir)
   14:         if (isinstance(object, type(os)) and
   14:             (object.__name__ in ('errno', 'exceptions', 'gc', 'imp',
                                        'marshal', 'posix', 'signal', 'sys',
   14:                                  'thread', 'zipimport') or
   14:              (file.startswith(basedir) and
    8:               not file.startswith(os.path.join(basedir, 'site-packages')))) and
    8:             object.__name__ not in ('xml.etree', 'test.pydoc_mod')):
    2:             if docloc.startswith(("http://", "https://")):
    2:                 docloc = "%s/%s" % (docloc.rstrip("/"), object.__name__.lower())
                   else:
>>>>>>                 docloc = os.path.join(docloc, object.__name__.lower() + ".html")
               else:
   12:             docloc = None
   14:         return docloc
       
       # -------------------------------------------- HTML documentation generator
       
    2: class HTMLRepr(Repr):
    1:     """Class for safely making an HTML representation of a Python object."""
    1:     def __init__(self):
    1:         Repr.__init__(self)
    1:         self.maxlist = self.maxtuple = 20
    1:         self.maxdict = 10
    1:         self.maxstring = self.maxother = 100
       
    1:     def escape(self, text):
  863:         return replace(text, '&', '&amp;', '<', '&lt;', '>', '&gt;')
       
    1:     def repr(self, object):
    8:         return Repr.repr(self, object)
       
    1:     def repr1(self, x, level):
    8:         if hasattr(type(x), '__name__'):
    8:             methodname = 'repr_' + join(split(type(x).__name__), '_')
    8:             if hasattr(self, methodname):
    8:                 return getattr(self, methodname)(x, level)
>>>>>>         return self.escape(cram(stripid(repr(x)), self.maxother))
       
    1:     def repr_string(self, x, level):
    8:         test = cram(x, self.maxstring)
    8:         testrepr = repr(test)
    8:         if '\\' in test and '\\' not in replace(testrepr, r'\\', ''):
                   # Backslashes are only literal in the string and are never
                   # needed to make any special characters, so show a raw string.
>>>>>>             return 'r' + testrepr[0] + self.escape(test) + testrepr[0]
    8:         return re.sub(r'((\\[\\abfnrtv\'"]|\\[0-9]..|\\x..|\\u....)+)',
    8:                       r'<font color="#c040c0">\1</font>',
    8:                       self.escape(testrepr))
       
    1:     repr_str = repr_string
       
    1:     def repr_instance(self, x, level):
>>>>>>         try:
>>>>>>             return self.escape(cram(stripid(repr(x)), self.maxstring))
>>>>>>         except:
>>>>>>             return self.escape('<%s instance>' % x.__class__.__name__)
       
    1:     repr_unicode = repr_string
       
    2: class HTMLDoc(Doc):
    1:     """Formatter class for HTML documentation."""
       
           # ------------------------------------------- HTML formatting utilities
       
    1:     _repr_instance = HTMLRepr()
    1:     repr = _repr_instance.repr
    1:     escape = _repr_instance.escape
       
    1:     def page(self, title, contents):
               """Format an HTML page."""
    6:         return _encode('''
       <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
       <html><head><title>Python: %s</title>
       <meta charset="utf-8">
       </head><body bgcolor="#f0f0f8">
       %s
    6: </body></html>''' % (title, contents), 'ascii')
       
    1:     def heading(self, title, fgcol, bgcol, extras=''):
               """Format a page heading."""
               return '''
       <table width="100%%" cellspacing=0 cellpadding=2 border=0 summary="heading">
       <tr bgcolor="%s">
       <td valign=bottom>&nbsp;<br>
       <font color="%s" face="helvetica, arial">&nbsp;<br>%s</font></td
       ><td align=right valign=bottom
       ><font color="%s" face="helvetica, arial">%s</font></td></tr></table>
    7:     ''' % (bgcol, fgcol, title, fgcol, extras or '&nbsp;')
       
    1:     def section(self, title, fgcol, bgcol, contents, width=6,
    1:                 prelude='', marginalia=None, gap='&nbsp;'):
               """Format a section with a heading."""
   16:         if marginalia is None:
   16:             marginalia = '<tt>' + '&nbsp;' * width + '</tt>'
               result = '''<p>
       <table width="100%%" cellspacing=0 cellpadding=2 border=0 summary="section">
       <tr bgcolor="%s">
       <td colspan=3 valign=bottom>&nbsp;<br>
       <font color="%s" face="helvetica, arial">%s</font></td></tr>
   16:     ''' % (bgcol, fgcol, title)
   16:         if prelude:
    1:             result = result + '''
       <tr bgcolor="%s"><td rowspan=2>%s</td>
       <td colspan=2>%s</td></tr>
    1: <tr><td>%s</td>''' % (bgcol, marginalia, prelude, gap)
               else:
   15:             result = result + '''
   15: <tr><td bgcolor="%s">%s</td><td>%s</td>''' % (bgcol, marginalia, gap)
       
   16:         return result + '\n<td width="100%%">%s</td></tr></table>' % contents
       
    1:     def bigsection(self, title, *args):
               """Format a section with a big heading."""
   13:         title = '<big><strong>%s</strong></big>' % title
   13:         return self.section(title, *args)
       
    1:     def preformat(self, text):
               """Format literal preformatted text."""
  787:         text = self.escape(expandtabs(text))
  787:         return replace(text, '\n\n', '\n \n', '\n\n', '\n \n',
  787:                              ' ', '&nbsp;', '\n', '<br>\n')
       
    1:     def multicolumn(self, list, format, cols=4):
               """Format a list of items into a multi-column list."""
>>>>>>         result = ''
>>>>>>         rows = (len(list)+cols-1)//cols
>>>>>>         for col in range(cols):
>>>>>>             result = result + '<td width="%d%%" valign=top>' % (100//cols)
>>>>>>             for i in range(rows*col, rows*col+rows):
>>>>>>                 if i < len(list):
>>>>>>                     result = result + format(list[i]) + '<br>\n'
>>>>>>             result = result + '</td>'
>>>>>>         return '<table width="100%%" summary="list"><tr>%s</tr></table>' % result
       
    1:     def grey(self, text): return '<font color="#909090">%s</font>' % text
       
    1:     def namelink(self, name, *dicts):
               """Make a link for an identifier, given name-to-URL mappings."""
 1394:         for dict in dicts:
  713:             if name in dict:
   17:                 return '<a href="%s">%s</a>' % (dict[name], name)
  681:         return name
       
    1:     def classlink(self, object, modname):
               """Make a link for a class."""
    6:         name, module = object.__name__, sys.modules.get(object.__module__)
    6:         if hasattr(module, name) and getattr(module, name) is object:
    6:             return '<a href="%s.html#%s">%s</a>' % (
    6:                 module.__name__, name, classname(object, modname))
>>>>>>         return classname(object, modname)
       
    1:     def modulelink(self, object):
               """Make a link for a module."""
>>>>>>         return '<a href="%s.html">%s</a>' % (object.__name__, object.__name__)
       
    1:     def modpkglink(self, data):
               """Make a link for a module or package to display in an index."""
>>>>>>         name, path, ispackage, shadowed = data
>>>>>>         if shadowed:
>>>>>>             return self.grey(name)
>>>>>>         if path:
>>>>>>             url = '%s.%s.html' % (path, name)
               else:
>>>>>>             url = '%s.html' % name
>>>>>>         if ispackage:
>>>>>>             text = '<strong>%s</strong>&nbsp;(package)' % name
               else:
>>>>>>             text = name
>>>>>>         return '<a href="%s">%s</a>' % (url, text)
       
    1:     def markup(self, text, escape=None, funcs={}, classes={}, methods={}):
               """Mark up some plain text, given a context of symbols to look for.
               Each context dictionary maps object names to anchor names."""
   19:         escape = escape or self.escape
   19:         results = []
   19:         here = 0
   19:         pattern = re.compile(r'\b((http|ftp)://\S+[\w/]|'
                                       r'RFC[- ]?(\d+)|'
                                       r'PEP[- ]?(\d+)|'
                                       r'(self\.)?(\w+))')
   87:         while True:
   87:             match = pattern.search(text, here)
   87:             if not match: break
   68:             start, end = match.span()
   68:             results.append(escape(text[here:start]))
       
   68:             all, scheme, rfc, pep, selfdot, name = match.groups()
   68:             if scheme:
>>>>>>                 url = escape(all).replace('"', '&quot;')
>>>>>>                 results.append('<a href="%s">%s</a>' % (url, url))
   68:             elif rfc:
>>>>>>                 url = 'http://www.rfc-editor.org/rfc/rfc%d.txt' % int(rfc)
>>>>>>                 results.append('<a href="%s">%s</a>' % (url, escape(all)))
   68:             elif pep:
>>>>>>                 url = 'http://www.python.org/dev/peps/pep-%04d/' % int(pep)
>>>>>>                 results.append('<a href="%s">%s</a>' % (url, escape(all)))
   68:             elif selfdot:
                       # Create a link for methods like 'self.method(...)'
                       # and use <strong> for attributes like 'self.attr'
    1:                 if text[end:end+1] == '(':
    1:                     results.append('self.' + self.namelink(name, methods))
                       else:
>>>>>>                     results.append('self.<strong>%s</strong>' % name)
   67:             elif text[end:end+1] == '(':
    1:                 results.append(self.namelink(name, methods, funcs, classes))
                   else:
   66:                 results.append(self.namelink(name, classes))
   68:             here = end
   19:         results.append(escape(text[here:]))
   19:         return join(results, '')
       
           # ---------------------------------------------- type-specific routines
       
    1:     def formattree(self, tree, modname, parent=None):
               """Produce HTML for a class tree as given by inspect.getclasstree()."""
    2:         result = ''
    7:         for entry in tree:
    5:             if type(entry) is type(()):
    4:                 c, bases = entry
    4:                 result = result + '<dt><font face="helvetica, arial">'
    4:                 result = result + self.classlink(c, modname)
    4:                 if bases and bases != (parent,):
>>>>>>                     parents = []
>>>>>>                     for base in bases:
>>>>>>                         parents.append(self.classlink(base, modname))
>>>>>>                     result = result + '(' + join(parents, ', ') + ')'
    4:                 result = result + '\n</font></dt>'
    1:             elif type(entry) is type([]):
    1:                 result = result + '<dd>\n%s</dd>\n' % self.formattree(
    1:                     entry, modname, c)
    2:         return '<dl>\n%s</dl>\n' % result
       
    1:     def docmodule(self, object, name=None, mod=None, *ignored):
               """Produce HTML documentation for a module object."""
    2:         name = object.__name__ # ignore the passed-in name
    2:         try:
    2:             all = object.__all__
    2:         except AttributeError:
    2:             all = None
    2:         parts = split(name, '.')
    2:         links = []
    3:         for i in range(len(parts)-1):
    1:             links.append(
    1:                 '<a href="%s.html"><font color="#ffffff">%s</font></a>' %
    1:                 (join(parts[:i+1], '.'), parts[i]))
    2:         linkedname = join(links + parts[-1:], '.')
    2:         head = '<big><big><strong>%s</strong></big></big>' % linkedname
    2:         try:
    2:             path = inspect.getabsfile(object)
    1:             url = path
    1:             if sys.platform == 'win32':
>>>>>>                 import nturl2path
>>>>>>                 url = nturl2path.pathname2url(path)
    1:             filelink = '<a href="file:%s">%s</a>' % (url, path)
    1:         except TypeError:
    1:             filelink = '(built-in)'
    2:         info = []
    2:         if hasattr(object, '__version__'):
    2:             version = _binstr(object.__version__)
    2:             if version[:11] == '$' + 'Revision: ' and version[-1:] == '$':
>>>>>>                 version = strip(version[11:-1])
    2:             info.append('version %s' % self.escape(version))
    2:         if hasattr(object, '__date__'):
    1:             info.append(self.escape(_binstr(object.__date__)))
    2:         if info:
    2:             head = head + ' (%s)' % join(info, ', ')
    2:         docloc = self.getdocloc(object)
    2:         if docloc is not None:
>>>>>>             docloc = '<br><a href="%(docloc)s">Module Docs</a>' % locals()
               else:
    2:             docloc = ''
    2:         result = self.heading(
    2:             head, '#ffffff', '#7799ee',
    2:             '<a href=".">index</a><br>' + filelink + docloc)
       
    2:         modules = inspect.getmembers(object, inspect.ismodule)
       
    2:         classes, cdict = [], {}
    5:         for key, value in inspect.getmembers(object, inspect.isclass):
                   # if __all__ exists, believe it.  Otherwise use old heuristic.
    3:             if (all is not None or
    3:                 (inspect.getmodule(value) or object) is object):
    3:                 if visiblename(key, all, object):
    3:                     classes.append((key, value))
    3:                     cdict[key] = cdict[value] = '#' + key
    5:         for key, value in classes:
    5:             for base in value.__bases__:
    2:                 key, modname = base.__name__, base.__module__
    2:                 module = sys.modules.get(modname)
    2:                 if modname != name and module and hasattr(module, key):
    2:                     if getattr(module, key) is base:
    2:                         if not key in cdict:
    1:                             cdict[key] = cdict[base] = modname + '.html#' + key
    2:         funcs, fdict = [], {}
    4:         for key, value in inspect.getmembers(object, inspect.isroutine):
                   # if __all__ exists, believe it.  Otherwise use old heuristic.
    2:             if (all is not None or
    2:                 inspect.isbuiltin(value) or inspect.getmodule(value) is object):
    2:                 if visiblename(key, all, object):
    2:                     funcs.append((key, value))
    2:                     fdict[key] = '#-' + key
    2:                     if inspect.isfunction(value): fdict[value] = fdict[key]
    2:         data = []
   16:         for key, value in inspect.getmembers(object, isdata):
   14:             if visiblename(key, all, object):
    7:                 data.append((key, value))
       
    2:         doc = self.markup(getdoc(object), self.preformat, fdict, cdict)
    2:         doc = doc and '<tt>%s</tt>' % doc
    2:         result = result + '<p>%s</p>\n' % doc
       
    2:         if hasattr(object, '__path__'):
>>>>>>             modpkgs = []
>>>>>>             for importer, modname, ispkg in pkgutil.iter_modules(object.__path__):
>>>>>>                 modpkgs.append((modname, name, ispkg, 0))
>>>>>>             modpkgs.sort()
>>>>>>             contents = self.multicolumn(modpkgs, self.modpkglink)
>>>>>>             result = result + self.bigsection(
>>>>>>                 'Package Contents', '#ffffff', '#aa55cc', contents)
    2:         elif modules:
>>>>>>             contents = self.multicolumn(
>>>>>>                 modules, lambda key_value, s=self: s.modulelink(key_value[1]))
>>>>>>             result = result + self.bigsection(
>>>>>>                 'Modules', '#ffffff', '#aa55cc', contents)
       
    2:         if classes:
    4:             classlist = map(lambda key_value: key_value[1], classes)
                   contents = [
    1:                 self.formattree(inspect.getclasstree(classlist, 1), name)]
    4:             for key, value in classes:
    3:                 contents.append(self.document(value, key, name, fdict, cdict))
    1:             result = result + self.bigsection(
    1:                 'Classes', '#ffffff', '#ee77aa', join(contents))
    2:         if funcs:
    1:             contents = []
    3:             for key, value in funcs:
    2:                 contents.append(self.document(value, key, name, fdict, cdict))
    1:             result = result + self.bigsection(
    1:                 'Functions', '#ffffff', '#eeaa77', join(contents))
    2:         if data:
    2:             contents = []
    9:             for key, value in data:
    7:                 contents.append(self.document(value, key))
    2:             result = result + self.bigsection(
    2:                 'Data', '#ffffff', '#55aa55', join(contents, '<br>\n'))
    2:         if hasattr(object, '__author__'):
    2:             contents = self.markup(_binstr(object.__author__), self.preformat)
    2:             result = result + self.bigsection(
    2:                 'Author', '#ffffff', '#7799ee', contents)
    2:         if hasattr(object, '__credits__'):
    2:             contents = self.markup(_binstr(object.__credits__), self.preformat)
    2:             result = result + self.bigsection(
    2:                 'Credits', '#ffffff', '#7799ee', contents)
       
    2:         return result
       
    1:     def docclass(self, object, name=None, mod=None, funcs={}, classes={},
                        *ignored):
               """Produce HTML documentation for a class object."""
    3:         realname = object.__name__
    3:         name = name or realname
    3:         bases = object.__bases__
       
    3:         contents = []
    3:         push = contents.append
       
               # Cute little class to pump out a horizontal rule between sections.
    6:         class HorizontalRule:
    3:             def __init__(self):
    3:                 self.needone = 0
    3:             def maybe(self):
    5:                 if self.needone:
    2:                     push('<hr>\n')
    5:                 self.needone = 1
    3:         hr = HorizontalRule()
       
               # List the mro, if non-trivial.
    3:         mro = deque(inspect.getmro(object))
    3:         if len(mro) > 2:
>>>>>>             hr.maybe()
>>>>>>             push('<dl><dt>Method resolution order:</dt>\n')
>>>>>>             for base in mro:
>>>>>>                 push('<dd>%s</dd>\n' % self.classlink(base,
>>>>>>                                                       object.__module__))
>>>>>>             push('</dl>\n')
       
    3:         def spill(msg, attrs, predicate):
    9:             ok, attrs = _split_list(attrs, predicate)
    9:             if ok:
    2:                 hr.maybe()
    2:                 push(msg)
    6:                 for name, kind, homecls, value in ok:
    4:                     try:
    4:                         value = getattr(object, name)
>>>>>>                     except Exception:
                               # Some descriptors may meet a failure in their __get__.
                               # (bug #1785)
>>>>>>                         push(self._docdescriptor(name, value, mod))
                           else:
    4:                         push(self.document(value, name, mod,
    4:                                         funcs, classes, mdict, object))
    4:                     push('\n')
    9:             return attrs
       
    3:         def spilldescriptors(msg, attrs, predicate):
    3:             ok, attrs = _split_list(attrs, predicate)
    3:             if ok:
    2:                 hr.maybe()
    2:                 push(msg)
    6:                 for name, kind, homecls, value in ok:
    4:                     push(self._docdescriptor(name, value, mod))
    3:             return attrs
       
    3:         def spilldata(msg, attrs, predicate):
    3:             ok, attrs = _split_list(attrs, predicate)
    3:             if ok:
    1:                 hr.maybe()
    1:                 push(msg)
    2:                 for name, kind, homecls, value in ok:
    1:                     base = self.docother(getattr(object, name), name, mod)
    1:                     if (hasattr(value, '__call__') or
    1:                             inspect.isdatadescriptor(value)):
>>>>>>                         doc = getattr(value, "__doc__", None)
                           else:
    1:                         doc = None
    1:                     if doc is None:
    1:                         push('<dl><dt>%s</dl>\n' % base)
                           else:
>>>>>>                         doc = self.markup(getdoc(value), self.preformat,
>>>>>>                                           funcs, classes, mdict)
>>>>>>                         doc = '<dd><tt>%s</tt>' % doc
>>>>>>                         push('<dl><dt>%s%s</dl>\n' % (base, doc))
    1:                     push('\n')
    3:             return attrs
       
   46:         attrs = filter(lambda data: visiblename(data[0], obj=object),
    3:                        classify_class_attrs(object))
    3:         mdict = {}
   40:         for key, kind, homecls, value in attrs:
   37:             mdict[key] = anchor = '#' + name + '-' + key
   37:             try:
   37:                 value = getattr(object, name)
   37:             except Exception:
                       # Some descriptors may meet a failure in their __get__.
                       # (bug #1785)
   37:                 pass
   37:             try:
                       # The value may not be hashable (e.g., a data attr with
                       # a dict or list value).
   37:                 mdict[value] = anchor
>>>>>>             except TypeError:
>>>>>>                 pass
       
    8:         while attrs:
    5:             if mro:
    5:                 thisclass = mro.popleft()
                   else:
>>>>>>                 thisclass = attrs[0][2]
   70:             attrs, inherited = _split_list(attrs, lambda t: t[2] is thisclass)
       
    5:             if thisclass is __builtin__.object:
    2:                 attrs = inherited
    2:                 continue
    3:             elif thisclass is object:
    3:                 tag = 'defined here'
                   else:
>>>>>>                 tag = 'inherited from %s' % self.classlink(thisclass,
>>>>>>                                                            object.__module__)
    3:             tag += ':<br>\n'
       
                   # Sort attrs by name.
    3:             try:
   12:                 attrs.sort(key=lambda t: t[0])
>>>>>>             except TypeError:
>>>>>>                 attrs.sort(lambda t1, t2: cmp(t1[0], t2[0]))    # 2.3 compat
       
                   # Pump out the attrs, segregated by kind.
    3:             attrs = spill('Methods %s' % tag, attrs,
   12:                           lambda t: t[1] == 'method')
    3:             attrs = spill('Class methods %s' % tag, attrs,
    8:                           lambda t: t[1] == 'class method')
    3:             attrs = spill('Static methods %s' % tag, attrs,
    8:                           lambda t: t[1] == 'static method')
    3:             attrs = spilldescriptors('Data descriptors %s' % tag, attrs,
    8:                                      lambda t: t[1] == 'data descriptor')
    3:             attrs = spilldata('Data and other attributes %s' % tag, attrs,
    4:                               lambda t: t[1] == 'data')
    3:             assert attrs == []
    3:             attrs = inherited
       
    3:         contents = ''.join(contents)
       
    3:         if name == realname:
    3:             title = '<a name="%s">class <strong>%s</strong></a>' % (
    3:                 name, realname)
               else:
>>>>>>             title = '<strong>%s</strong> = <a name="%s">class %s</a>' % (
>>>>>>                 name, name, realname)
    3:         if bases:
    2:             parents = []
    4:             for base in bases:
    2:                 parents.append(self.classlink(base, object.__module__))
    2:             title = title + '(%s)' % join(parents, ', ')
    3:         doc = self.markup(getdoc(object), self.preformat, funcs, classes, mdict)
    3:         doc = doc and '<tt>%s<br>&nbsp;</tt>' % doc
       
    3:         return self.section(title, '#000000', '#ffc8d8', contents, 3, doc)
       
    1:     def formatvalue(self, object):
               """Format an argument default value as text."""
>>>>>>         return self.grey('=' + self.repr(object))
       
    1:     def docroutine(self, object, name=None, mod=None,
    1:                    funcs={}, classes={}, methods={}, cl=None):
               """Produce HTML documentation for a function or method object."""
    6:         realname = object.__name__
    6:         name = name or realname
    6:         anchor = (cl and cl.__name__ or '') + '-' + name
    6:         note = ''
    6:         skipdocs = 0
    6:         if inspect.ismethod(object):
    4:             imclass = object.im_class
    4:             if cl:
    4:                 if imclass is not cl:
>>>>>>                     note = ' from ' + self.classlink(imclass, mod)
                   else:
>>>>>>                 if object.im_self is not None:
>>>>>>                     note = ' method of %s instance' % self.classlink(
>>>>>>                         object.im_self.__class__, mod)
                       else:
>>>>>>                     note = ' unbound %s method' % self.classlink(imclass,mod)
    4:             object = object.im_func
       
    6:         if name == realname:
    6:             title = '<a name="%s"><strong>%s</strong></a>' % (anchor, realname)
               else:
>>>>>>             if (cl and realname in cl.__dict__ and
>>>>>>                 cl.__dict__[realname] is object):
>>>>>>                 reallink = '<a href="#%s">%s</a>' % (
>>>>>>                     cl.__name__ + '-' + realname, realname)
>>>>>>                 skipdocs = 1
                   else:
>>>>>>                 reallink = realname
>>>>>>             title = '<a name="%s"><strong>%s</strong></a> = %s' % (
>>>>>>                 anchor, name, reallink)
    6:         if inspect.isfunction(object):
    6:             args, varargs, varkw, defaults = inspect.getargspec(object)
    6:             argspec = inspect.formatargspec(
    6:                 args, varargs, varkw, defaults, formatvalue=self.formatvalue)
    6:             if realname == '<lambda>':
>>>>>>                 title = '<strong>%s</strong> <em>lambda</em> ' % name
>>>>>>                 argspec = argspec[1:-1] # remove parentheses
               else:
>>>>>>             argspec = '(...)'
       
    6:         decl = title + argspec + (note and self.grey(
>>>>>>                '<font face="helvetica, arial">%s</font>' % note))
       
    6:         if skipdocs:
>>>>>>             return '<dl><dt>%s</dt></dl>\n' % decl
               else:
    6:             doc = self.markup(
    6:                 getdoc(object), self.preformat, funcs, classes, methods)
    6:             doc = doc and '<dd><tt>%s</tt></dd>' % doc
    6:             return '<dl><dt>%s</dt>%s</dl>\n' % (decl, doc)
       
    1:     def _docdescriptor(self, name, value, mod):
    4:         results = []
    4:         push = results.append
       
    4:         if name:
    4:             push('<dl><dt><strong>%s</strong></dt>\n' % name)
    4:         if value.__doc__ is not None:
    4:             doc = self.markup(getdoc(value), self.preformat)
    4:             push('<dd><tt>%s</tt></dd>\n' % doc)
    4:         push('</dl>\n')
       
    4:         return ''.join(results)
       
    1:     def docproperty(self, object, name=None, mod=None, cl=None):
               """Produce html documentation for a property."""
>>>>>>         return self._docdescriptor(name, object, mod)
       
    1:     def docother(self, object, name=None, mod=None, *ignored):
               """Produce HTML documentation for a data object."""
    8:         lhs = name and '<strong>%s</strong> = ' % name or ''
    8:         return lhs + self.repr(object)
       
    1:     def docdata(self, object, name=None, mod=None, cl=None):
               """Produce html documentation for a data descriptor."""
>>>>>>         return self._docdescriptor(name, object, mod)
       
    1:     def index(self, dir, shadowed=None):
               """Generate an HTML index for a directory of modules."""
>>>>>>         modpkgs = []
>>>>>>         if shadowed is None: shadowed = {}
>>>>>>         for importer, name, ispkg in pkgutil.iter_modules([dir]):
>>>>>>             modpkgs.append((name, '', ispkg, name in shadowed))
>>>>>>             shadowed[name] = 1
       
>>>>>>         modpkgs.sort()
>>>>>>         contents = self.multicolumn(modpkgs, self.modpkglink)
>>>>>>         return self.bigsection(dir, '#ffffff', '#ee77aa', contents)
       
       # -------------------------------------------- text documentation generator
       
    2: class TextRepr(Repr):
    1:     """Class for safely making a text representation of a Python object."""
    1:     def __init__(self):
    1:         Repr.__init__(self)
    1:         self.maxlist = self.maxtuple = 20
    1:         self.maxdict = 10
    1:         self.maxstring = self.maxother = 100
       
    1:     def repr1(self, x, level):
   38:         if hasattr(type(x), '__name__'):
   38:             methodname = 'repr_' + join(split(type(x).__name__), '_')
   38:             if hasattr(self, methodname):
    7:                 return getattr(self, methodname)(x, level)
   31:         return cram(stripid(repr(x)), self.maxother)
       
    1:     def repr_string(self, x, level):
    6:         test = cram(x, self.maxstring)
    6:         testrepr = repr(test)
    6:         if '\\' in test and '\\' not in replace(testrepr, r'\\', ''):
                   # Backslashes are only literal in the string and are never
                   # needed to make any special characters, so show a raw string.
>>>>>>             return 'r' + testrepr[0] + test + testrepr[0]
    6:         return testrepr
       
    1:     repr_str = repr_string
       
    1:     def repr_instance(self, x, level):
>>>>>>         try:
>>>>>>             return cram(stripid(repr(x)), self.maxstring)
>>>>>>         except:
>>>>>>             return '<%s instance>' % x.__class__.__name__
       
    2: class TextDoc(Doc):
    1:     """Formatter class for text documentation."""
       
           # ------------------------------------------- text formatting utilities
       
    1:     _repr_instance = TextRepr()
    1:     repr = _repr_instance.repr
       
    1:     def bold(self, text):
               """Format a string in bold by overstriking."""
 3480:         return join(map(lambda ch: ch + '\b' + ch, text), '')
       
    1:     def indent(self, text, prefix='    '):
               """Indent text by prepending a given prefix to each line."""
  353:         if not text: return ''
  350:         lines = split(text, '\n')
 3143:         lines = map(lambda line, prefix=prefix: prefix + line, lines)
  350:         if lines: lines[-1] = rstrip(lines[-1])
  350:         return join(lines, '\n')
       
    1:     def section(self, title, contents):
               """Format a section with a given heading."""
   52:         return self.bold(title) + '\n' + rstrip(self.indent(contents)) + '\n\n'
       
           # ---------------------------------------------- type-specific routines
       
    1:     def formattree(self, tree, modname, parent=None, prefix=''):
               """Render in text a class tree as returned by inspect.getclasstree()."""
    8:         result = ''
   28:         for entry in tree:
   20:             if type(entry) is type(()):
   14:                 c, bases = entry
   14:                 result = result + prefix + classname(c, modname)
   14:                 if bases and bases != (parent,):
    6:                     parents = map(lambda c, m=modname: classname(c, m), bases)
    2:                     result = result + '(%s)' % join(parents, ', ')
   14:                 result = result + '\n'
    6:             elif type(entry) is type([]):
    6:                 result = result + self.formattree(
    6:                     entry, modname, c, prefix + '    ')
    8:         return result
       
    1:     def docmodule(self, object, name=None, mod=None):
               """Produce text documentation for a given module object."""
    8:         name = object.__name__ # ignore the passed-in name
    8:         synop, desc = splitdoc(getdoc(object))
    8:         result = self.section('NAME', name + (synop and ' - ' + synop))
       
    8:         try:
    8:             all = object.__all__
    8:         except AttributeError:
    8:             all = None
       
    8:         try:
    8:             file = inspect.getabsfile(object)
    5:         except TypeError:
    5:             file = '(built-in)'
    8:         result = result + self.section('FILE', file)
       
    8:         docloc = self.getdocloc(object)
    8:         if docloc is not None:
    1:             result = result + self.section('MODULE DOCS', docloc)
       
    8:         if desc:
    1:             result = result + self.section('DESCRIPTION', desc)
       
    8:         classes = []
   20:         for key, value in inspect.getmembers(object, inspect.isclass):
                   # if __all__ exists, believe it.  Otherwise use old heuristic.
   12:             if (all is not None
   12:                 or (inspect.getmodule(value) or object) is object):
   12:                 if visiblename(key, all, object):
   12:                     classes.append((key, value))
    8:         funcs = []
   10:         for key, value in inspect.getmembers(object, inspect.isroutine):
                   # if __all__ exists, believe it.  Otherwise use old heuristic.
    2:             if (all is not None or
    2:                 inspect.isbuiltin(value) or inspect.getmodule(value) is object):
    2:                 if visiblename(key, all, object):
    2:                     funcs.append((key, value))
    8:         data = []
   57:         for key, value in inspect.getmembers(object, isdata):
   49:             if visiblename(key, all, object):
   23:                 data.append((key, value))
       
    8:         modpkgs = []
    8:         modpkgs_names = set()
    8:         if hasattr(object, '__path__'):
    5:             for importer, modname, ispkg in pkgutil.iter_modules(object.__path__):
    4:                 modpkgs_names.add(modname)
    4:                 if ispkg:
>>>>>>                     modpkgs.append(modname + ' (package)')
                       else:
    4:                     modpkgs.append(modname)
       
    1:             modpkgs.sort()
    1:             result = result + self.section(
    1:                 'PACKAGE CONTENTS', join(modpkgs, '\n'))
       
               # Detect submodules as sometimes created by C extensions
    8:         submodules = []
   12:         for key, value in inspect.getmembers(object, inspect.ismodule):
    4:             if value.__name__.startswith(name + '.') and key not in modpkgs_names:
    1:                 submodules.append(key)
    8:         if submodules:
    1:             submodules.sort()
    1:             result = result + self.section(
    1:                 'SUBMODULES', join(submodules, '\n'))
       
    8:         if classes:
   14:             classlist = map(lambda key_value: key_value[1], classes)
    2:             contents = [self.formattree(
    2:                 inspect.getclasstree(classlist, 1), name)]
   14:             for key, value in classes:
   12:                 contents.append(self.document(value, key, name))
    2:             result = result + self.section('CLASSES', join(contents, '\n'))
       
    8:         if funcs:
    1:             contents = []
    3:             for key, value in funcs:
    2:                 contents.append(self.document(value, key, name))
    1:             result = result + self.section('FUNCTIONS', join(contents, '\n'))
       
    8:         if data:
    6:             contents = []
   29:             for key, value in data:
   23:                 contents.append(self.docother(value, key, name, maxlen=70))
    6:             result = result + self.section('DATA', join(contents, '\n'))
       
    8:         if hasattr(object, '__version__'):
    6:             version = _binstr(object.__version__)
    6:             if version[:11] == '$' + 'Revision: ' and version[-1:] == '$':
>>>>>>                 version = strip(version[11:-1])
    6:             result = result + self.section('VERSION', version)
    8:         if hasattr(object, '__date__'):
    5:             result = result + self.section('DATE', _binstr(object.__date__))
    8:         if hasattr(object, '__author__'):
    6:             result = result + self.section('AUTHOR', _binstr(object.__author__))
    8:         if hasattr(object, '__credits__'):
    6:             result = result + self.section('CREDITS', _binstr(object.__credits__))
    8:         return result
       
    1:     def docclass(self, object, name=None, mod=None, *ignored):
               """Produce text documentation for a given class object."""
   19:         realname = object.__name__
   19:         name = name or realname
   19:         bases = object.__bases__
       
   19:         def makename(c, m=object.__module__):
   40:             return classname(c, m)
       
   19:         if name == realname:
   18:             title = 'class ' + self.bold(realname)
               else:
    1:             title = self.bold(name) + ' = class ' + realname
   19:         if bases:
   14:             parents = map(makename, bases)
   14:             title = title + '(%s)' % join(parents, ', ')
       
   19:         doc = getdoc(object)
   19:         contents = doc and [doc + '\n'] or []
   19:         push = contents.append
       
               # List the mro, if non-trivial.
   19:         mro = deque(inspect.getmro(object))
   19:         if len(mro) > 2:
    7:             push("Method resolution order:")
   31:             for base in mro:
   24:                 push('    ' + makename(base))
    7:             push('')
       
               # Cute little class to pump out a horizontal rule between sections.
   38:         class HorizontalRule:
   19:             def __init__(self):
   19:                 self.needone = 0
   19:             def maybe(self):
   53:                 if self.needone:
   37:                     push('-' * 70)
   53:                 self.needone = 1
   19:         hr = HorizontalRule()
       
   19:         def spill(msg, attrs, predicate):
   87:             ok, attrs = _split_list(attrs, predicate)
   87:             if ok:
   35:                 hr.maybe()
   35:                 push(msg)
  287:                 for name, kind, homecls, value in ok:
  252:                     try:
  252:                         value = getattr(object, name)
>>>>>>                     except Exception:
                               # Some descriptors may meet a failure in their __get__.
                               # (bug #1785)
>>>>>>                         push(self._docdescriptor(name, value, mod))
                           else:
  252:                         push(self.document(value,
  252:                                         name, mod, object))
   87:             return attrs
       
   19:         def spilldescriptors(msg, attrs, predicate):
   29:             ok, attrs = _split_list(attrs, predicate)
   29:             if ok:
    9:                 hr.maybe()
    9:                 push(msg)
   33:                 for name, kind, homecls, value in ok:
   24:                     push(self._docdescriptor(name, value, mod))
   29:             return attrs
       
   19:         def spilldata(msg, attrs, predicate):
   29:             ok, attrs = _split_list(attrs, predicate)
   29:             if ok:
    9:                 hr.maybe()
    9:                 push(msg)
   20:                 for name, kind, homecls, value in ok:
   11:                     if (hasattr(value, '__call__') or
    2:                             inspect.isdatadescriptor(value)):
    9:                         doc = getdoc(value)
                           else:
    2:                         doc = None
   11:                     push(self.docother(getattr(object, name),
   11:                                        name, mod, maxlen=70, doc=doc) + '\n')
   29:             return attrs
       
  495:         attrs = filter(lambda data: visiblename(data[0], obj=object),
   19:                        classify_class_attrs(object))
   59:         while attrs:
   40:             if mro:
   40:                 thisclass = mro.popleft()
                   else:
>>>>>>                 thisclass = attrs[0][2]
  777:             attrs, inherited = _split_list(attrs, lambda t: t[2] is thisclass)
       
   40:             if thisclass is __builtin__.object:
   11:                 attrs = inherited
   11:                 continue
   29:             elif thisclass is object:
   16:                 tag = "defined here"
                   else:
   13:                 tag = "inherited from %s" % classname(thisclass,
   13:                                                       object.__module__)
       
                   # Sort attrs by name.
   29:             attrs.sort()
       
                   # Pump out the attrs, segregated by kind.
   29:             attrs = spill("Methods %s:\n" % tag, attrs,
  316:                           lambda t: t[1] == 'method')
   29:             attrs = spill("Class methods %s:\n" % tag, attrs,
   74:                           lambda t: t[1] == 'class method')
   29:             attrs = spill("Static methods %s:\n" % tag, attrs,
   69:                           lambda t: t[1] == 'static method')
   29:             attrs = spilldescriptors("Data descriptors %s:\n" % tag, attrs,
   64:                                      lambda t: t[1] == 'data descriptor')
   29:             attrs = spilldata("Data and other attributes %s:\n" % tag, attrs,
   40:                               lambda t: t[1] == 'data')
   29:             assert attrs == []
   29:             attrs = inherited
       
   19:         contents = '\n'.join(contents)
   19:         if not contents:
    2:             return title + '\n'
   17:         return title + '\n' + self.indent(rstrip(contents), ' |  ') + '\n'
       
    1:     def formatvalue(self, object):
               """Format an argument default value as text."""
    2:         return '=' + self.repr(object)
       
    1:     def docroutine(self, object, name=None, mod=None, cl=None):
               """Produce text documentation for a function or method object."""
  256:         realname = object.__name__
  256:         name = name or realname
  256:         note = ''
  256:         skipdocs = 0
  256:         if inspect.ismethod(object):
  109:             imclass = object.im_class
  109:             if cl:
  109:                 if imclass is not cl:
    5:                     note = ' from ' + classname(imclass, mod)
                   else:
>>>>>>                 if object.im_self is not None:
>>>>>>                     note = ' method of %s instance' % classname(
>>>>>>                         object.im_self.__class__, mod)
                       else:
>>>>>>                     note = ' unbound %s method' % classname(imclass,mod)
  109:             object = object.im_func
       
  256:         if name == realname:
  254:             title = self.bold(realname)
               else:
    2:             if (cl and realname in cl.__dict__ and
>>>>>>                 cl.__dict__[realname] is object):
>>>>>>                 skipdocs = 1
    2:             title = self.bold(name) + ' = ' + realname
  256:         if inspect.isfunction(object):
  116:             args, varargs, varkw, defaults = inspect.getargspec(object)
  116:             argspec = inspect.formatargspec(
  116:                 args, varargs, varkw, defaults, formatvalue=self.formatvalue)
  116:             if realname == '<lambda>':
>>>>>>                 title = self.bold(name) + ' lambda '
>>>>>>                 argspec = argspec[1:-1] # remove parentheses
               else:
  140:             argspec = '(...)'
  256:         decl = title + argspec + note
       
  256:         if skipdocs:
>>>>>>             return decl + '\n'
               else:
  256:             doc = getdoc(object) or ''
  256:             return decl + '\n' + (doc and rstrip(self.indent(doc)) + '\n')
       
    1:     def _docdescriptor(self, name, value, mod):
   24:         results = []
   24:         push = results.append
       
   24:         if name:
   24:             push(self.bold(name))
   24:             push('\n')
   24:         doc = getdoc(value) or ''
   24:         if doc:
   24:             push(self.indent(doc))
   24:             push('\n')
   24:         return ''.join(results)
       
    1:     def docproperty(self, object, name=None, mod=None, cl=None):
               """Produce text documentation for a property."""
>>>>>>         return self._docdescriptor(name, object, mod)
       
    1:     def docdata(self, object, name=None, mod=None, cl=None):
               """Produce text documentation for a data descriptor."""
>>>>>>         return self._docdescriptor(name, object, mod)
       
    1:     def docother(self, object, name=None, mod=None, parent=None, maxlen=None, doc=None):
               """Produce text documentation for a data object."""
   34:         repr = self.repr(object)
   34:         if maxlen:
   34:             line = (name and name + ' = ' or '') + repr
   34:             chop = maxlen - len(line)
   34:             if chop < 0: repr = repr[:chop] + '...'
   34:         line = (name and self.bold(name) + ' = ' or '') + repr
   34:         if doc is not None:
    9:             line += '\n' + self.indent(str(doc))
   34:         return line
       
       # --------------------------------------------------------- user interfaces
       
    1: def pager(text):
           """The first time this is called, determine what kind of pager to use."""
           global pager
    1:     pager = getpager()
    1:     pager(text)
       
    1: def getpager():
           """Decide what method to use for paging through text."""
    2:     if type(sys.stdout) is not types.FileType:
    2:         return plainpager
>>>>>>     if not hasattr(sys.stdin, "isatty"):
>>>>>>         return plainpager
>>>>>>     if not sys.stdin.isatty() or not sys.stdout.isatty():
>>>>>>         return plainpager
>>>>>>     if 'PAGER' in os.environ:
>>>>>>         if sys.platform == 'win32': # pipes completely broken in Windows
>>>>>>             return lambda text: tempfilepager(plain(text), os.environ['PAGER'])
>>>>>>         elif os.environ.get('TERM') in ('dumb', 'emacs'):
>>>>>>             return lambda text: pipepager(plain(text), os.environ['PAGER'])
               else:
>>>>>>             return lambda text: pipepager(text, os.environ['PAGER'])
>>>>>>     if os.environ.get('TERM') in ('dumb', 'emacs'):
>>>>>>         return plainpager
>>>>>>     if sys.platform == 'win32' or sys.platform.startswith('os2'):
>>>>>>         return lambda text: tempfilepager(plain(text), 'more <')
>>>>>>     if hasattr(os, 'system') and os.system('(less) 2>/dev/null') == 0:
>>>>>>         return lambda text: pipepager(text, 'less')
       
>>>>>>     import tempfile
>>>>>>     (fd, filename) = tempfile.mkstemp()
>>>>>>     os.close(fd)
>>>>>>     try:
>>>>>>         if hasattr(os, 'system') and os.system('more "%s"' % filename) == 0:
>>>>>>             return lambda text: pipepager(text, 'more')
               else:
>>>>>>             return ttypager
           finally:
>>>>>>         os.unlink(filename)
       
    1: def plain(text):
           """Remove boldface formatting from text."""
    4:     return re.sub('.\b', '', text)
       
    1: def pipepager(text, cmd):
           """Page through text by feeding it to another program."""
    1:     pipe = os.popen(cmd, 'w')
    1:     try:
    1:         pipe.write(_encode(text))
    1:         pipe.close()
>>>>>>     except IOError:
>>>>>>         pass # Ignore broken pipes caused by quitting the pager program.
       
    1: def tempfilepager(text, cmd):
           """Page through text by invoking a program on a temporary file."""
    1:     import tempfile
    1:     filename = tempfile.mktemp()
    1:     file = open(filename, 'w')
    1:     file.write(_encode(text))
    1:     file.close()
    1:     try:
    1:         os.system(cmd + ' "' + filename + '"')
           finally:
    1:         os.unlink(filename)
       
    1: def ttypager(text):
           """Page through text on a text terminal."""
    1:     lines = plain(_encode(plain(text), getattr(sys.stdout, 'encoding', _encoding))).split('\n')
    1:     try:
    1:         import tty
    1:         fd = sys.stdin.fileno()
>>>>>>         old = tty.tcgetattr(fd)
>>>>>>         tty.setcbreak(fd)
>>>>>>         getchar = lambda: sys.stdin.read(1)
    1:     except (ImportError, AttributeError):
    1:         tty = None
    2:         getchar = lambda: sys.stdin.readline()[:-1][:1]
       
    1:     try:
    1:         try:
    1:             h = int(os.environ.get('LINES', 0))
>>>>>>         except ValueError:
>>>>>>             h = 0
    1:         if h <= 1:
    1:             h = 25
    1:         r = inc = h - 1
    1:         sys.stdout.write(join(lines[:inc], '\n') + '\n')
    2:         while lines[r:]:
    1:             sys.stdout.write('-- more --')
    1:             sys.stdout.flush()
    1:             c = getchar()
       
    1:             if c in ('q', 'Q'):
>>>>>>                 sys.stdout.write('\r          \r')
>>>>>>                 break
    1:             elif c in ('\r', '\n'):
>>>>>>                 sys.stdout.write('\r          \r' + lines[r] + '\n')
>>>>>>                 r = r + 1
>>>>>>                 continue
    1:             if c in ('b', 'B', '\x1b'):
>>>>>>                 r = r - inc - inc
>>>>>>                 if r < 0: r = 0
    1:             sys.stdout.write('\n' + join(lines[r:r+inc], '\n') + '\n')
    1:             r = r + inc
       
           finally:
    1:         if tty:
>>>>>>             tty.tcsetattr(fd, tty.TCSAFLUSH, old)
       
    1: def plainpager(text):
           """Simply print unformatted text.  This is the ultimate fallback."""
    2:     sys.stdout.write(_encode(plain(text), getattr(sys.stdout, 'encoding', _encoding)))
       
    1: def describe(thing):
           """Produce a short description of the given thing."""
   20:     if inspect.ismodule(thing):
    7:         if thing.__name__ in sys.builtin_module_names:
>>>>>>             return 'built-in module ' + thing.__name__
    7:         if hasattr(thing, '__path__'):
>>>>>>             return 'package ' + thing.__name__
               else:
    7:             return 'module ' + thing.__name__
   13:     if inspect.isbuiltin(thing):
>>>>>>         return 'built-in function ' + thing.__name__
   13:     if inspect.isgetsetdescriptor(thing):
>>>>>>         return 'getset descriptor %s.%s.%s' % (
>>>>>>             thing.__objclass__.__module__, thing.__objclass__.__name__,
>>>>>>             thing.__name__)
   13:     if inspect.ismemberdescriptor(thing):
>>>>>>         return 'member descriptor %s.%s.%s' % (
>>>>>>             thing.__objclass__.__module__, thing.__objclass__.__name__,
>>>>>>             thing.__name__)
   13:     if inspect.isclass(thing):
    5:         return 'class ' + thing.__name__
    8:     if inspect.isfunction(thing):
>>>>>>         return 'function ' + thing.__name__
    8:     if inspect.ismethod(thing):
>>>>>>         return 'method ' + thing.__name__
    8:     if type(thing) is types.InstanceType:
    4:         return 'instance of ' + thing.__class__.__name__
    4:     return type(thing).__name__
       
    1: def locate(path, forceload=0):
           """Locate an object by name or dotted path, importing as necessary."""
   58:     parts = [part for part in split(path, '.') if part]
   20:     module, n = None, 0
   28:     while n < len(parts):
   28:         nextmodule = safeimport(join(parts[:n+1], '.'), forceload)
   28:         if nextmodule: module, n = nextmodule, n + 1
   20:         else: break
   20:     if module:
    8:         object = module
           else:
   12:         object = __builtin__
   36:     for part in parts[n:]:
   28:         try:
   28:             object = getattr(object, part)
   12:         except AttributeError:
   12:             return None
    8:     return object
       
       # --------------------------------------- interactive interpreter interface
       
    1: text = TextDoc()
    1: html = HTMLDoc()
       
    2: class _OldStyleClass: pass
    1: _OLD_INSTANCE_TYPE = type(_OldStyleClass())
       
    1: def resolve(thing, forceload=0):
           """Given an object or a path to an object, get the object and its name."""
   22:     if isinstance(thing, str):
   10:         object = locate(thing, forceload)
   10:         if object is None:
    6:             raise ImportError, 'no Python documentation found for %r' % thing
    4:         return object, thing
           else:
   12:         name = getattr(thing, '__name__', None)
   12:         return thing, name if isinstance(name, str) else None
       
    1: def render_doc(thing, title='Python Library Documentation: %s', forceload=0):
           """Render text documentation, given an object or a path to an object."""
   21:     object, name = resolve(thing, forceload)
   15:     desc = describe(object)
   15:     module = inspect.getmodule(object)
   15:     if name and '.' in name:
    4:         desc += ' in ' + name[:name.rfind('.')]
   11:     elif module and module is not object:
    6:         desc += ' in module ' + module.__name__
   15:     if type(object) is _OLD_INSTANCE_TYPE:
               # If the passed object is an instance of an old-style class,
               # document its available methods instead of its value.
    3:         object = object.__class__
   12:     elif not (inspect.ismodule(object) or
    6:               inspect.isclass(object) or
    3:               inspect.isroutine(object) or
    1:               inspect.isgetsetdescriptor(object) or
    1:               inspect.ismemberdescriptor(object) or
    1:               isinstance(object, property)):
               # If the passed object is a piece of data or an instance,
               # document its available methods instead of its value.
    1:         object = type(object)
    1:         desc += ' object'
   15:     return title % desc + '\n\n' + text.document(object, name)
       
    1: def doc(thing, title='Python Library Documentation: %s', forceload=0):
           """Display text documentation, given an object or a path to an object."""
    1:     try:
    1:         pager(render_doc(thing, title, forceload))
>>>>>>     except (ImportError, ErrorDuringImport), value:
>>>>>>         print value
       
    1: def writedoc(thing, forceload=0):
           """Write HTML documentation to a file in the current directory."""
    1:     try:
    1:         object, name = resolve(thing, forceload)
    1:         page = html.page(describe(object), html.document(object, name))
    1:         file = open(name + '.html', 'w')
    1:         file.write(page)
    1:         file.close()
    1:         print 'wrote', name + '.html'
>>>>>>     except (ImportError, ErrorDuringImport), value:
>>>>>>         print value
       
    1: def writedocs(dir, pkgpath='', done=None):
           """Write out HTML documentation for all modules in a directory tree."""
>>>>>>     if done is None: done = {}
>>>>>>     for importer, modname, ispkg in pkgutil.walk_packages([dir], pkgpath):
>>>>>>         writedoc(modname)
>>>>>>     return
       
    2: class Helper:
       
           # These dictionaries map a topic name to either an alias, or a tuple
           # (label, seealso-items).  The "label" is the label of the corresponding
           # section in the .rst file under Doc/ and an index into the dictionary
           # in pydoc_data/topics.py.
           #
           # CAUTION: if you change one of these dictionaries, be sure to adapt the
           #          list of needed labels in Doc/tools/pyspecific.py and
           #          regenerate the pydoc_data/topics.py file by running
           #              make pydoc-topics
           #          in Doc/ and copying the output file into the Lib/ directory.
       
    1:     keywords = {
    1:         'and': 'BOOLEAN',
    1:         'as': 'with',
    1:         'assert': ('assert', ''),
    1:         'break': ('break', 'while for'),
    1:         'class': ('class', 'CLASSES SPECIALMETHODS'),
    1:         'continue': ('continue', 'while for'),
    1:         'def': ('function', ''),
    1:         'del': ('del', 'BASICMETHODS'),
    1:         'elif': 'if',
    1:         'else': ('else', 'while for'),
    1:         'except': 'try',
    1:         'exec': ('exec', ''),
    1:         'finally': 'try',
    1:         'for': ('for', 'break continue while'),
    1:         'from': 'import',
    1:         'global': ('global', 'NAMESPACES'),
    1:         'if': ('if', 'TRUTHVALUE'),
    1:         'import': ('import', 'MODULES'),
    1:         'in': ('in', 'SEQUENCEMETHODS2'),
    1:         'is': 'COMPARISON',
    1:         'lambda': ('lambda', 'FUNCTIONS'),
    1:         'not': 'BOOLEAN',
    1:         'or': 'BOOLEAN',
    1:         'pass': ('pass', ''),
    1:         'print': ('print', ''),
    1:         'raise': ('raise', 'EXCEPTIONS'),
    1:         'return': ('return', 'FUNCTIONS'),
    1:         'try': ('try', 'EXCEPTIONS'),
    1:         'while': ('while', 'break continue if TRUTHVALUE'),
    1:         'with': ('with', 'CONTEXTMANAGERS EXCEPTIONS yield'),
    1:         'yield': ('yield', ''),
           }
           # Either add symbols to this dictionary or to the symbols dictionary
           # directly: Whichever is easier. They are merged later.
    1:     _symbols_inverse = {
    1:         'STRINGS' : ("'", "'''", "r'", "u'", '"""', '"', 'r"', 'u"'),
               'OPERATORS' : ('+', '-', '*', '**', '/', '//', '%', '<<', '>>', '&',
    1:                        '|', '^', '~', '<', '>', '<=', '>=', '==', '!=', '<>'),
    1:         'COMPARISON' : ('<', '>', '<=', '>=', '==', '!=', '<>'),
    1:         'UNARY' : ('-', '~'),
               'AUGMENTEDASSIGNMENT' : ('+=', '-=', '*=', '/=', '%=', '&=', '|=',
    1:                                 '^=', '<<=', '>>=', '**=', '//='),
    1:         'BITWISE' : ('<<', '>>', '&', '|', '^', '~'),
    1:         'COMPLEX' : ('j', 'J')
           }
    1:     symbols = {
    1:         '%': 'OPERATORS FORMATTING',
    1:         '**': 'POWER',
    1:         ',': 'TUPLES LISTS FUNCTIONS',
    1:         '.': 'ATTRIBUTES FLOAT MODULES OBJECTS',
    1:         '...': 'ELLIPSIS',
    1:         ':': 'SLICINGS DICTIONARYLITERALS',
    1:         '@': 'def class',
    1:         '\\': 'STRINGS',
    1:         '_': 'PRIVATENAMES',
    1:         '__': 'PRIVATENAMES SPECIALMETHODS',
    1:         '`': 'BACKQUOTES',
    1:         '(': 'TUPLES FUNCTIONS CALLS',
    1:         ')': 'TUPLES FUNCTIONS CALLS',
    1:         '[': 'LISTS SUBSCRIPTS SLICINGS',
    1:         ']': 'LISTS SUBSCRIPTS SLICINGS'
           }
    8:     for topic, symbols_ in _symbols_inverse.iteritems():
   64:         for symbol in symbols_:
   57:             topics = symbols.get(symbol, topic)
   57:             if topic not in topics:
   16:                 topics = topics + ' ' + topic
   57:             symbols[symbol] = topics
       
    1:     topics = {
    1:         'TYPES': ('types', 'STRINGS UNICODE NUMBERS SEQUENCES MAPPINGS '
                         'FUNCTIONS CLASSES MODULES FILES inspect'),
    1:         'STRINGS': ('strings', 'str UNICODE SEQUENCES STRINGMETHODS FORMATTING '
                           'TYPES'),
    1:         'STRINGMETHODS': ('string-methods', 'STRINGS FORMATTING'),
    1:         'FORMATTING': ('formatstrings', 'OPERATORS'),
    1:         'UNICODE': ('strings', 'encodings unicode SEQUENCES STRINGMETHODS '
                           'FORMATTING TYPES'),
    1:         'NUMBERS': ('numbers', 'INTEGER FLOAT COMPLEX TYPES'),
    1:         'INTEGER': ('integers', 'int range'),
    1:         'FLOAT': ('floating', 'float math'),
    1:         'COMPLEX': ('imaginary', 'complex cmath'),
    1:         'SEQUENCES': ('typesseq', 'STRINGMETHODS FORMATTING xrange LISTS'),
    1:         'MAPPINGS': 'DICTIONARIES',
    1:         'FUNCTIONS': ('typesfunctions', 'def TYPES'),
    1:         'METHODS': ('typesmethods', 'class def CLASSES TYPES'),
    1:         'CODEOBJECTS': ('bltin-code-objects', 'compile FUNCTIONS TYPES'),
    1:         'TYPEOBJECTS': ('bltin-type-objects', 'types TYPES'),
    1:         'FRAMEOBJECTS': 'TYPES',
    1:         'TRACEBACKS': 'TYPES',
    1:         'NONE': ('bltin-null-object', ''),
    1:         'ELLIPSIS': ('bltin-ellipsis-object', 'SLICINGS'),
    1:         'FILES': ('bltin-file-objects', ''),
    1:         'SPECIALATTRIBUTES': ('specialattrs', ''),
    1:         'CLASSES': ('types', 'class SPECIALMETHODS PRIVATENAMES'),
    1:         'MODULES': ('typesmodules', 'import'),
    1:         'PACKAGES': 'import',
    1:         'EXPRESSIONS': ('operator-summary', 'lambda or and not in is BOOLEAN '
                               'COMPARISON BITWISE SHIFTING BINARY FORMATTING POWER '
                               'UNARY ATTRIBUTES SUBSCRIPTS SLICINGS CALLS TUPLES '
                               'LISTS DICTIONARIES BACKQUOTES'),
    1:         'OPERATORS': 'EXPRESSIONS',
    1:         'PRECEDENCE': 'EXPRESSIONS',
    1:         'OBJECTS': ('objects', 'TYPES'),
    1:         'SPECIALMETHODS': ('specialnames', 'BASICMETHODS ATTRIBUTEMETHODS '
                                  'CALLABLEMETHODS SEQUENCEMETHODS1 MAPPINGMETHODS '
                                  'SEQUENCEMETHODS2 NUMBERMETHODS CLASSES'),
    1:         'BASICMETHODS': ('customization', 'cmp hash repr str SPECIALMETHODS'),
    1:         'ATTRIBUTEMETHODS': ('attribute-access', 'ATTRIBUTES SPECIALMETHODS'),
    1:         'CALLABLEMETHODS': ('callable-types', 'CALLS SPECIALMETHODS'),
    1:         'SEQUENCEMETHODS1': ('sequence-types', 'SEQUENCES SEQUENCEMETHODS2 '
                                    'SPECIALMETHODS'),
    1:         'SEQUENCEMETHODS2': ('sequence-methods', 'SEQUENCES SEQUENCEMETHODS1 '
                                    'SPECIALMETHODS'),
    1:         'MAPPINGMETHODS': ('sequence-types', 'MAPPINGS SPECIALMETHODS'),
    1:         'NUMBERMETHODS': ('numeric-types', 'NUMBERS AUGMENTEDASSIGNMENT '
                                 'SPECIALMETHODS'),
    1:         'EXECUTION': ('execmodel', 'NAMESPACES DYNAMICFEATURES EXCEPTIONS'),
    1:         'NAMESPACES': ('naming', 'global ASSIGNMENT DELETION DYNAMICFEATURES'),
    1:         'DYNAMICFEATURES': ('dynamic-features', ''),
    1:         'SCOPING': 'NAMESPACES',
    1:         'FRAMES': 'NAMESPACES',
    1:         'EXCEPTIONS': ('exceptions', 'try except finally raise'),
    1:         'COERCIONS': ('coercion-rules','CONVERSIONS'),
    1:         'CONVERSIONS': ('conversions', 'COERCIONS'),
    1:         'IDENTIFIERS': ('identifiers', 'keywords SPECIALIDENTIFIERS'),
    1:         'SPECIALIDENTIFIERS': ('id-classes', ''),
    1:         'PRIVATENAMES': ('atom-identifiers', ''),
    1:         'LITERALS': ('atom-literals', 'STRINGS BACKQUOTES NUMBERS '
                            'TUPLELITERALS LISTLITERALS DICTIONARYLITERALS'),
    1:         'TUPLES': 'SEQUENCES',
    1:         'TUPLELITERALS': ('exprlists', 'TUPLES LITERALS'),
    1:         'LISTS': ('typesseq-mutable', 'LISTLITERALS'),
    1:         'LISTLITERALS': ('lists', 'LISTS LITERALS'),
    1:         'DICTIONARIES': ('typesmapping', 'DICTIONARYLITERALS'),
    1:         'DICTIONARYLITERALS': ('dict', 'DICTIONARIES LITERALS'),
    1:         'BACKQUOTES': ('string-conversions', 'repr str STRINGS LITERALS'),
    1:         'ATTRIBUTES': ('attribute-references', 'getattr hasattr setattr '
                              'ATTRIBUTEMETHODS'),
    1:         'SUBSCRIPTS': ('subscriptions', 'SEQUENCEMETHODS1'),
    1:         'SLICINGS': ('slicings', 'SEQUENCEMETHODS2'),
    1:         'CALLS': ('calls', 'EXPRESSIONS'),
    1:         'POWER': ('power', 'EXPRESSIONS'),
    1:         'UNARY': ('unary', 'EXPRESSIONS'),
    1:         'BINARY': ('binary', 'EXPRESSIONS'),
    1:         'SHIFTING': ('shifting', 'EXPRESSIONS'),
    1:         'BITWISE': ('bitwise', 'EXPRESSIONS'),
    1:         'COMPARISON': ('comparisons', 'EXPRESSIONS BASICMETHODS'),
    1:         'BOOLEAN': ('booleans', 'EXPRESSIONS TRUTHVALUE'),
    1:         'ASSERTION': 'assert',
    1:         'ASSIGNMENT': ('assignment', 'AUGMENTEDASSIGNMENT'),
    1:         'AUGMENTEDASSIGNMENT': ('augassign', 'NUMBERMETHODS'),
    1:         'DELETION': 'del',
    1:         'PRINTING': 'print',
    1:         'RETURNING': 'return',
    1:         'IMPORTING': 'import',
    1:         'CONDITIONAL': 'if',
    1:         'LOOPING': ('compound', 'for while break continue'),
    1:         'TRUTHVALUE': ('truth', 'if while and or not BASICMETHODS'),
    1:         'DEBUGGING': ('debugger', 'pdb'),
    1:         'CONTEXTMANAGERS': ('context-managers', 'with'),
           }
       
    1:     def __init__(self, input=None, output=None):
    1:         self._input = input
    1:         self._output = output
       
    1:     input  = property(lambda self: self._input or sys.stdin)
    2:     output = property(lambda self: self._output or sys.stdout)
       
    1:     def __repr__(self):
>>>>>>         if inspect.stack()[1][3] == '?':
>>>>>>             self()
>>>>>>             return ''
>>>>>>         return '<pydoc.Helper instance>'
       
    1:     _GoInteractive = object()
    1:     def __call__(self, request=_GoInteractive):
    1:         if request is not self._GoInteractive:
    1:             self.help(request)
               else:
>>>>>>             self.intro()
>>>>>>             self.interact()
>>>>>>             self.output.write('''
       You are now leaving help and returning to the Python interpreter.
       If you want to ask for help on a particular object directly from the
       interpreter, you can type "help(object)".  Executing "help('string')"
       has the same effect as typing a particular string at the help> prompt.
>>>>>> ''')
       
    1:     def interact(self):
>>>>>>         self.output.write('\n')
>>>>>>         while True:
>>>>>>             try:
>>>>>>                 request = self.getline('help> ')
>>>>>>                 if not request: break
>>>>>>             except (KeyboardInterrupt, EOFError):
>>>>>>                 break
>>>>>>             request = strip(replace(request, '"', '', "'", ''))
>>>>>>             if lower(request) in ('q', 'quit'): break
>>>>>>             self.help(request)
       
    1:     def getline(self, prompt):
               """Read one line, using raw_input when available."""
>>>>>>         if self.input is sys.stdin:
>>>>>>             return raw_input(prompt)
               else:
>>>>>>             self.output.write(prompt)
>>>>>>             self.output.flush()
>>>>>>             return self.input.readline()
       
    1:     def help(self, request):
    1:         if type(request) is type(''):
>>>>>>             request = request.strip()
>>>>>>             if request == 'help': self.intro()
>>>>>>             elif request == 'keywords': self.listkeywords()
>>>>>>             elif request == 'symbols': self.listsymbols()
>>>>>>             elif request == 'topics': self.listtopics()
>>>>>>             elif request == 'modules': self.listmodules()
>>>>>>             elif request[:8] == 'modules ':
>>>>>>                 self.listmodules(split(request)[1])
>>>>>>             elif request in self.symbols: self.showsymbol(request)
>>>>>>             elif request in self.keywords: self.showtopic(request)
>>>>>>             elif request in self.topics: self.showtopic(request)
>>>>>>             elif request: doc(request, 'Help on %s:')
    1:         elif isinstance(request, Helper): self()
    1:         else: doc(request, 'Help on %s:')
    1:         self.output.write('\n')
       
    1:     def intro(self):
>>>>>>         self.output.write('''
       Welcome to Python %s!  This is the online help utility.
       
       If this is your first time using Python, you should definitely check out
       the tutorial on the Internet at http://docs.python.org/%s/tutorial/.
       
       Enter the name of any module, keyword, or topic to get help on writing
       Python programs and using Python modules.  To quit this help utility and
       return to the interpreter, just type "quit".
       
       To get a list of available modules, keywords, or topics, type "modules",
       "keywords", or "topics".  Each module also comes with a one-line summary
       of what it does; to list the modules whose summaries contain a given word
       such as "spam", type "modules spam".
>>>>>> ''' % tuple([sys.version[:3]]*2))
       
    1:     def list(self, items, columns=4, width=80):
>>>>>>         items = items[:]
>>>>>>         items.sort()
>>>>>>         colw = width / columns
>>>>>>         rows = (len(items) + columns - 1) / columns
>>>>>>         for row in range(rows):
>>>>>>             for col in range(columns):
>>>>>>                 i = col * rows + row
>>>>>>                 if i < len(items):
>>>>>>                     self.output.write(items[i])
>>>>>>                     if col < columns - 1:
>>>>>>                         self.output.write(' ' + ' ' * (colw-1 - len(items[i])))
>>>>>>             self.output.write('\n')
       
    1:     def listkeywords(self):
>>>>>>         self.output.write('''
       Here is a list of the Python keywords.  Enter any keyword to get more help.
       
>>>>>> ''')
>>>>>>         self.list(self.keywords.keys())
       
    1:     def listsymbols(self):
>>>>>>         self.output.write('''
       Here is a list of the punctuation symbols which Python assigns special meaning
       to. Enter any symbol to get more help.
       
>>>>>> ''')
>>>>>>         self.list(self.symbols.keys())
       
    1:     def listtopics(self):
>>>>>>         self.output.write('''
       Here is a list of available topics.  Enter any topic name to get more help.
       
>>>>>> ''')
>>>>>>         self.list(self.topics.keys())
       
    1:     def showtopic(self, topic, more_xrefs=''):
>>>>>>         try:
>>>>>>             import pydoc_data.topics
>>>>>>         except ImportError:
>>>>>>             self.output.write('''
       Sorry, topic and keyword documentation is not available because the
       module "pydoc_data.topics" could not be found.
>>>>>> ''')
>>>>>>             return
>>>>>>         target = self.topics.get(topic, self.keywords.get(topic))
>>>>>>         if not target:
>>>>>>             self.output.write('no documentation found for %s\n' % repr(topic))
>>>>>>             return
>>>>>>         if type(target) is type(''):
>>>>>>             return self.showtopic(target, more_xrefs)
       
>>>>>>         label, xrefs = target
>>>>>>         try:
>>>>>>             doc = pydoc_data.topics.topics[label]
>>>>>>         except KeyError:
>>>>>>             self.output.write('no documentation found for %s\n' % repr(topic))
>>>>>>             return
>>>>>>         pager(strip(doc) + '\n')
>>>>>>         if more_xrefs:
>>>>>>             xrefs = (xrefs or '') + ' ' + more_xrefs
>>>>>>         if xrefs:
>>>>>>             import StringIO, formatter
>>>>>>             buffer = StringIO.StringIO()
>>>>>>             formatter.DumbWriter(buffer).send_flowing_data(
>>>>>>                 'Related help topics: ' + join(split(xrefs), ', ') + '\n')
>>>>>>             self.output.write('\n%s\n' % buffer.getvalue())
       
    1:     def showsymbol(self, symbol):
>>>>>>         target = self.symbols[symbol]
>>>>>>         topic, _, xrefs = target.partition(' ')
>>>>>>         self.showtopic(topic, xrefs)
       
    1:     def listmodules(self, key=''):
>>>>>>         if key:
>>>>>>             self.output.write('''
       Here is a list of matching modules.  Enter any module name to get more help.
       
>>>>>> ''')
>>>>>>             apropos(key)
               else:
>>>>>>             self.output.write('''
       Please wait a moment while I gather a list of all available modules...
       
>>>>>> ''')
>>>>>>             modules = {}
>>>>>>             def callback(path, modname, desc, modules=modules):
>>>>>>                 if modname and modname[-9:] == '.__init__':
>>>>>>                     modname = modname[:-9] + ' (package)'
>>>>>>                 if find(modname, '.') < 0:
>>>>>>                     modules[modname] = 1
>>>>>>             def onerror(modname):
>>>>>>                 callback(None, modname, None)
>>>>>>             ModuleScanner().run(callback, onerror=onerror)
>>>>>>             self.list(modules.keys())
>>>>>>             self.output.write('''
       Enter any module name to get more help.  Or, type "modules spam" to search
       for modules whose descriptions contain the word "spam".
>>>>>> ''')
       
    1: help = Helper()
       
    2: class Scanner:
    1:     """A generic tree iterator."""
    1:     def __init__(self, roots, children, descendp):
>>>>>>         self.roots = roots[:]
>>>>>>         self.state = []
>>>>>>         self.children = children
>>>>>>         self.descendp = descendp
       
    1:     def next(self):
>>>>>>         if not self.state:
>>>>>>             if not self.roots:
>>>>>>                 return None
>>>>>>             root = self.roots.pop(0)
>>>>>>             self.state = [(root, self.children(root))]
>>>>>>         node, children = self.state[-1]
>>>>>>         if not children:
>>>>>>             self.state.pop()
>>>>>>             return self.next()
>>>>>>         child = children.pop(0)
>>>>>>         if self.descendp(child):
>>>>>>             self.state.append((child, self.children(child)))
>>>>>>         return child
       
       
    2: class ModuleScanner:
    1:     """An interruptible scanner that searches module synopses."""
       
    1:     def run(self, callback, key=None, completer=None, onerror=None):
    3:         if key: key = lower(key)
    3:         self.quit = False
    3:         seen = {}
       
   63:         for modname in sys.builtin_module_names:
   60:             if modname != '__main__':
   57:                 seen[modname] = 1
   57:                 if key is None:
>>>>>>                     callback(None, modname, '')
                       else:
   57:                     desc = split(__import__(modname).__doc__ or '', '\n')[0]
   57:                     if find(lower(modname + ' - ' + desc), key) >= 0:
>>>>>>                         callback(None, modname, desc)
       
    5:         for importer, modname, ispkg in pkgutil.walk_packages(onerror=onerror):
    2:             if self.quit:
>>>>>>                 break
    2:             if key is None:
>>>>>>                 callback(None, modname, '')
                   else:
    2:                 loader = importer.find_module(modname)
    2:                 if hasattr(loader,'get_source'):
    2:                     import StringIO
    2:                     desc = source_synopsis(
    2:                         StringIO.StringIO(loader.get_source(modname))
    2:                     ) or ''
    2:                     if hasattr(loader,'get_filename'):
    2:                         path = loader.get_filename(modname)
                           else:
>>>>>>                         path = None
                       else:
>>>>>>                     module = loader.load_module(modname)
>>>>>>                     desc = module.__doc__.splitlines()[0] if module.__doc__ else ''
>>>>>>                     path = getattr(module,'__file__',None)
    2:                 if find(lower(modname + ' - ' + desc), key) >= 0:
    1:                     callback(path, modname, desc)
       
    3:         if completer:
>>>>>>             completer()
       
    1: def apropos(key):
           """Print all the one-line module summaries that contain a substring."""
    3:     def callback(path, modname, desc):
    1:         if modname[-9:] == '.__init__':
>>>>>>             modname = modname[:-9] + ' (package)'
    1:         print modname, desc and '- ' + desc
    3:     def onerror(modname):
    2:         pass
    3:     with warnings.catch_warnings():
    3:         warnings.filterwarnings('ignore') # ignore problems during import
    3:         ModuleScanner().run(callback, key, onerror=onerror)
       
       # --------------------------------------------------- web browser interface
       
    1: def serve(port, callback=None, completer=None):
>>>>>>     import BaseHTTPServer, mimetools, select
       
           # Patch up mimetools.Message so it doesn't break if rfc822 is reloaded.
>>>>>>     class Message(mimetools.Message):
>>>>>>         def __init__(self, fp, seekable=1):
>>>>>>             Message = self.__class__
>>>>>>             Message.__bases__[0].__bases__[0].__init__(self, fp, seekable)
>>>>>>             self.encodingheader = self.getheader('content-transfer-encoding')
>>>>>>             self.typeheader = self.getheader('content-type')
>>>>>>             self.parsetype()
>>>>>>             self.parseplist()
       
>>>>>>     class DocHandler(BaseHTTPServer.BaseHTTPRequestHandler):
>>>>>>         def send_document(self, title, contents):
>>>>>>             try:
>>>>>>                 self.send_response(200)
>>>>>>                 self.send_header('Content-Type', 'text/html')
>>>>>>                 self.end_headers()
>>>>>>                 self.wfile.write(html.page(title, contents))
>>>>>>             except IOError: pass
       
>>>>>>         def do_GET(self):
>>>>>>             path = self.path
>>>>>>             if path[-5:] == '.html': path = path[:-5]
>>>>>>             if path[:1] == '/': path = path[1:]
>>>>>>             if path and path != '.':
>>>>>>                 try:
>>>>>>                     obj = locate(path, forceload=1)
>>>>>>                 except ErrorDuringImport, value:
>>>>>>                     self.send_document(path, html.escape(str(value)))
>>>>>>                     return
>>>>>>                 if obj:
>>>>>>                     self.send_document(describe(obj), html.document(obj, path))
                       else:
>>>>>>                     self.send_document(path,
>>>>>> 'no Python documentation found for %s' % repr(path))
                   else:
>>>>>>                 heading = html.heading(
>>>>>> '<big><big><strong>Python: Index of Modules</strong></big></big>',
>>>>>> '#ffffff', '#7799ee')
>>>>>>                 def bltinlink(name):
>>>>>>                     return '<a href="%s.html">%s</a>' % (name, name)
>>>>>>                 names = filter(lambda x: x != '__main__',
>>>>>>                                sys.builtin_module_names)
>>>>>>                 contents = html.multicolumn(names, bltinlink)
>>>>>>                 indices = ['<p>' + html.bigsection(
>>>>>>                     'Built-in Modules', '#ffffff', '#ee77aa', contents)]
       
>>>>>>                 seen = {}
>>>>>>                 for dir in sys.path:
>>>>>>                     indices.append(html.index(dir, seen))
>>>>>>                 contents = heading + join(indices) + '''<p align=right>
       <font color="#909090" face="helvetica, arial"><strong>
>>>>>> pydoc</strong> by Ka-Ping Yee &lt;ping@lfw.org&gt;</font>'''
>>>>>>                 self.send_document('Index of Modules', contents)
       
>>>>>>         def log_message(self, *args): pass
       
>>>>>>     class DocServer(BaseHTTPServer.HTTPServer):
>>>>>>         def __init__(self, port, callback):
>>>>>>             host = 'localhost'
>>>>>>             self.address = (host, port)
>>>>>>             self.callback = callback
>>>>>>             self.base.__init__(self, self.address, self.handler)
       
>>>>>>         def serve_until_quit(self):
>>>>>>             import select
>>>>>>             self.quit = False
>>>>>>             while not self.quit:
>>>>>>                 rd, wr, ex = select.select([self.socket.fileno()], [], [], 1)
>>>>>>                 if rd: self.handle_request()
       
>>>>>>         def server_activate(self):
>>>>>>             self.base.server_activate(self)
>>>>>>             self.url = 'http://%s:%d/' % (self.address[0], self.server_port)
>>>>>>             if self.callback: self.callback(self)
       
>>>>>>     DocServer.base = BaseHTTPServer.HTTPServer
>>>>>>     DocServer.handler = DocHandler
>>>>>>     DocHandler.MessageClass = Message
>>>>>>     try:
>>>>>>         try:
>>>>>>             DocServer(port, callback).serve_until_quit()
>>>>>>         except (KeyboardInterrupt, select.error):
>>>>>>             pass
           finally:
>>>>>>         if completer: completer()
       
       # ----------------------------------------------------- graphical interface
       
    1: def gui():
           """Graphical interface (starts web server and pops up a control window)."""
>>>>>>     class GUI:
>>>>>>         def __init__(self, window, port=7464):
>>>>>>             self.window = window
>>>>>>             self.server = None
>>>>>>             self.scanner = None
       
>>>>>>             import Tkinter
>>>>>>             self.server_frm = Tkinter.Frame(window)
>>>>>>             self.title_lbl = Tkinter.Label(self.server_frm,
>>>>>>                 text='Starting server...\n ')
>>>>>>             self.open_btn = Tkinter.Button(self.server_frm,
>>>>>>                 text='open browser', command=self.open, state='disabled')
>>>>>>             self.quit_btn = Tkinter.Button(self.server_frm,
>>>>>>                 text='quit serving', command=self.quit, state='disabled')
       
>>>>>>             self.search_frm = Tkinter.Frame(window)
>>>>>>             self.search_lbl = Tkinter.Label(self.search_frm, text='Search for')
>>>>>>             self.search_ent = Tkinter.Entry(self.search_frm)
>>>>>>             self.search_ent.bind('<Return>', self.search)
>>>>>>             self.stop_btn = Tkinter.Button(self.search_frm,
>>>>>>                 text='stop', pady=0, command=self.stop, state='disabled')
>>>>>>             if sys.platform == 'win32':
                       # Trying to hide and show this button crashes under Windows.
>>>>>>                 self.stop_btn.pack(side='right')
       
>>>>>>             self.window.title('pydoc')
>>>>>>             self.window.protocol('WM_DELETE_WINDOW', self.quit)
>>>>>>             self.title_lbl.pack(side='top', fill='x')
>>>>>>             self.open_btn.pack(side='left', fill='x', expand=1)
>>>>>>             self.quit_btn.pack(side='right', fill='x', expand=1)
>>>>>>             self.server_frm.pack(side='top', fill='x')
       
>>>>>>             self.search_lbl.pack(side='left')
>>>>>>             self.search_ent.pack(side='right', fill='x', expand=1)
>>>>>>             self.search_frm.pack(side='top', fill='x')
>>>>>>             self.search_ent.focus_set()
       
>>>>>>             font = ('helvetica', sys.platform == 'win32' and 8 or 10)
>>>>>>             self.result_lst = Tkinter.Listbox(window, font=font, height=6)
>>>>>>             self.result_lst.bind('<Button-1>', self.select)
>>>>>>             self.result_lst.bind('<Double-Button-1>', self.goto)
>>>>>>             self.result_scr = Tkinter.Scrollbar(window,
>>>>>>                 orient='vertical', command=self.result_lst.yview)
>>>>>>             self.result_lst.config(yscrollcommand=self.result_scr.set)
       
>>>>>>             self.result_frm = Tkinter.Frame(window)
>>>>>>             self.goto_btn = Tkinter.Button(self.result_frm,
>>>>>>                 text='go to selected', command=self.goto)
>>>>>>             self.hide_btn = Tkinter.Button(self.result_frm,
>>>>>>                 text='hide results', command=self.hide)
>>>>>>             self.goto_btn.pack(side='left', fill='x', expand=1)
>>>>>>             self.hide_btn.pack(side='right', fill='x', expand=1)
       
>>>>>>             self.window.update()
>>>>>>             self.minwidth = self.window.winfo_width()
>>>>>>             self.minheight = self.window.winfo_height()
                   self.bigminheight = (self.server_frm.winfo_reqheight() +
                                        self.search_frm.winfo_reqheight() +
>>>>>>                                  self.result_lst.winfo_reqheight() +
>>>>>>                                  self.result_frm.winfo_reqheight())
>>>>>>             self.bigwidth, self.bigheight = self.minwidth, self.bigminheight
>>>>>>             self.expanded = 0
>>>>>>             self.window.wm_geometry('%dx%d' % (self.minwidth, self.minheight))
>>>>>>             self.window.wm_minsize(self.minwidth, self.minheight)
>>>>>>             self.window.tk.willdispatch()
       
>>>>>>             import threading
>>>>>>             threading.Thread(
>>>>>>                 target=serve, args=(port, self.ready, self.quit)).start()
       
>>>>>>         def ready(self, server):
>>>>>>             self.server = server
>>>>>>             self.title_lbl.config(
>>>>>>                 text='Python documentation server at\n' + server.url)
>>>>>>             self.open_btn.config(state='normal')
>>>>>>             self.quit_btn.config(state='normal')
       
>>>>>>         def open(self, event=None, url=None):
>>>>>>             url = url or self.server.url
>>>>>>             try:
>>>>>>                 import webbrowser
>>>>>>                 webbrowser.open(url)
>>>>>>             except ImportError: # pre-webbrowser.py compatibility
>>>>>>                 if sys.platform == 'win32':
>>>>>>                     os.system('start "%s"' % url)
                       else:
>>>>>>                     rc = os.system('netscape -remote "openURL(%s)" &' % url)
>>>>>>                     if rc: os.system('netscape "%s" &' % url)
       
>>>>>>         def quit(self, event=None):
>>>>>>             if self.server:
>>>>>>                 self.server.quit = 1
>>>>>>             self.window.quit()
       
>>>>>>         def search(self, event=None):
>>>>>>             key = self.search_ent.get()
>>>>>>             self.stop_btn.pack(side='right')
>>>>>>             self.stop_btn.config(state='normal')
>>>>>>             self.search_lbl.config(text='Searching for "%s"...' % key)
>>>>>>             self.search_ent.forget()
>>>>>>             self.search_lbl.pack(side='left')
>>>>>>             self.result_lst.delete(0, 'end')
>>>>>>             self.goto_btn.config(state='disabled')
>>>>>>             self.expand()
       
>>>>>>             import threading
>>>>>>             if self.scanner:
>>>>>>                 self.scanner.quit = 1
>>>>>>             self.scanner = ModuleScanner()
>>>>>>             def onerror(modname):
>>>>>>                 pass
>>>>>>             threading.Thread(target=self.scanner.run,
>>>>>>                              args=(self.update, key, self.done),
>>>>>>                              kwargs=dict(onerror=onerror)).start()
       
>>>>>>         def update(self, path, modname, desc):
>>>>>>             if modname[-9:] == '.__init__':
>>>>>>                 modname = modname[:-9] + ' (package)'
>>>>>>             self.result_lst.insert('end',
>>>>>>                 modname + ' - ' + (desc or '(no description)'))
       
>>>>>>         def stop(self, event=None):
>>>>>>             if self.scanner:
>>>>>>                 self.scanner.quit = 1
>>>>>>                 self.scanner = None
       
>>>>>>         def done(self):
>>>>>>             self.scanner = None
>>>>>>             self.search_lbl.config(text='Search for')
>>>>>>             self.search_lbl.pack(side='left')
>>>>>>             self.search_ent.pack(side='right', fill='x', expand=1)
>>>>>>             if sys.platform != 'win32': self.stop_btn.forget()
>>>>>>             self.stop_btn.config(state='disabled')
       
>>>>>>         def select(self, event=None):
>>>>>>             self.goto_btn.config(state='normal')
       
>>>>>>         def goto(self, event=None):
>>>>>>             selection = self.result_lst.curselection()
>>>>>>             if selection:
>>>>>>                 modname = split(self.result_lst.get(selection[0]))[0]
>>>>>>                 self.open(url=self.server.url + modname + '.html')
       
>>>>>>         def collapse(self):
>>>>>>             if not self.expanded: return
>>>>>>             self.result_frm.forget()
>>>>>>             self.result_scr.forget()
>>>>>>             self.result_lst.forget()
>>>>>>             self.bigwidth = self.window.winfo_width()
>>>>>>             self.bigheight = self.window.winfo_height()
>>>>>>             self.window.wm_geometry('%dx%d' % (self.minwidth, self.minheight))
>>>>>>             self.window.wm_minsize(self.minwidth, self.minheight)
>>>>>>             self.expanded = 0
       
>>>>>>         def expand(self):
>>>>>>             if self.expanded: return
>>>>>>             self.result_frm.pack(side='bottom', fill='x')
>>>>>>             self.result_scr.pack(side='right', fill='y')
>>>>>>             self.result_lst.pack(side='top', fill='both', expand=1)
>>>>>>             self.window.wm_geometry('%dx%d' % (self.bigwidth, self.bigheight))
>>>>>>             self.window.wm_minsize(self.minwidth, self.bigminheight)
>>>>>>             self.expanded = 1
       
>>>>>>         def hide(self, event=None):
>>>>>>             self.stop()
>>>>>>             self.collapse()
       
>>>>>>     import Tkinter
>>>>>>     try:
>>>>>>         root = Tkinter.Tk()
               # Tk will crash if pythonw.exe has an XP .manifest
               # file and the root has is not destroyed explicitly.
               # If the problem is ever fixed in Tk, the explicit
               # destroy can go.
>>>>>>         try:
>>>>>>             gui = GUI(root)
>>>>>>             root.mainloop()
               finally:
>>>>>>             root.destroy()
>>>>>>     except KeyboardInterrupt:
>>>>>>         pass
       
       # -------------------------------------------------- command-line interface
       
    1: def ispath(x):
>>>>>>     return isinstance(x, str) and find(x, os.sep) >= 0
       
    1: def cli():
           """Command-line interface (looks at sys.argv to decide what to do)."""
>>>>>>     import getopt
>>>>>>     class BadUsage: pass
       
           # Scripts don't get the current directory in their path by default
           # unless they are run with the '-m' switch
>>>>>>     if '' not in sys.path:
>>>>>>         scriptdir = os.path.dirname(sys.argv[0])
>>>>>>         if scriptdir in sys.path:
>>>>>>             sys.path.remove(scriptdir)
>>>>>>         sys.path.insert(0, '.')
       
>>>>>>     try:
>>>>>>         opts, args = getopt.getopt(sys.argv[1:], 'gk:p:w')
>>>>>>         writing = 0
       
>>>>>>         for opt, val in opts:
>>>>>>             if opt == '-g':
>>>>>>                 gui()
>>>>>>                 return
>>>>>>             if opt == '-k':
>>>>>>                 apropos(val)
>>>>>>                 return
>>>>>>             if opt == '-p':
>>>>>>                 try:
>>>>>>                     port = int(val)
>>>>>>                 except ValueError:
>>>>>>                     raise BadUsage
>>>>>>                 def ready(server):
>>>>>>                     print 'pydoc server ready at %s' % server.url
>>>>>>                 def stopped():
>>>>>>                     print 'pydoc server stopped'
>>>>>>                 serve(port, ready, stopped)
>>>>>>                 return
>>>>>>             if opt == '-w':
>>>>>>                 writing = 1
       
>>>>>>         if not args: raise BadUsage
>>>>>>         for arg in args:
>>>>>>             if ispath(arg) and not os.path.exists(arg):
>>>>>>                 print 'file %r does not exist' % arg
>>>>>>                 break
>>>>>>             try:
>>>>>>                 if ispath(arg) and os.path.isfile(arg):
>>>>>>                     arg = importfile(arg)
>>>>>>                 if writing:
>>>>>>                     if ispath(arg) and os.path.isdir(arg):
>>>>>>                         writedocs(arg)
                           else:
>>>>>>                         writedoc(arg)
                       else:
>>>>>>                     help.help(arg)
>>>>>>             except ErrorDuringImport, value:
>>>>>>                 print value
       
>>>>>>     except (getopt.error, BadUsage):
>>>>>>         cmd = os.path.basename(sys.argv[0])
               print """pydoc - the Python documentation tool
       
       %s <name> ...
           Show text documentation on something.  <name> may be the name of a
           Python keyword, topic, function, module, or package, or a dotted
           reference to a class or function within a module or module in a
           package.  If <name> contains a '%s', it is used as the path to a
           Python source file to document. If name is 'keywords', 'topics',
           or 'modules', a listing of these things is displayed.
       
       %s -k <keyword>
           Search for a keyword in the synopsis lines of all available modules.
       
       %s -p <port>
           Start an HTTP server on the given port on the local machine.  Port
           number 0 can be used to get an arbitrary unused port.
       
       %s -g
           Pop up a graphical interface for finding and serving documentation.
       
       %s -w <name> ...
           Write out the HTML documentation for a module to a file in the current
           directory.  If <name> contains a '%s', it is treated as a filename; if
           it names a directory, documentation is written for all the contents.
>>>>>> """ % (cmd, os.sep, cmd, cmd, cmd, cmd, os.sep)
       
    1: if __name__ == '__main__': cli()
