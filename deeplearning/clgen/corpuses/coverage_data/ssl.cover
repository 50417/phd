       # Wrapper module for _ssl, providing some additional facilities
       # implemented in Python.  Written by Bill Janssen.
       
       """This module provides some more Pythonic support for SSL.
       
       Object types:
       
         SSLSocket -- subtype of socket.socket which does SSL over the socket
       
       Exceptions:
       
         SSLError -- exception raised for I/O errors
       
       Functions:
       
         cert_time_to_seconds -- convert time string used for certificate
                                 notBefore and notAfter functions to integer
                                 seconds past the Epoch (the time values
                                 returned from time.time())
       
         fetch_server_certificate (HOST, PORT) -- fetch the certificate provided
                                 by the server running on HOST at port PORT.  No
                                 validation of the certificate is performed.
       
       Integer constants:
       
       SSL_ERROR_ZERO_RETURN
       SSL_ERROR_WANT_READ
       SSL_ERROR_WANT_WRITE
       SSL_ERROR_WANT_X509_LOOKUP
       SSL_ERROR_SYSCALL
       SSL_ERROR_SSL
       SSL_ERROR_WANT_CONNECT
       
       SSL_ERROR_EOF
       SSL_ERROR_INVALID_ERROR_CODE
       
       The following group define certificate requirements that one side is
       allowing/requiring from the other side:
       
       CERT_NONE - no certificates from the other side are required (or will
                   be looked at if provided)
       CERT_OPTIONAL - certificates are not required, but if provided will be
                       validated, and if validation fails, the connection will
                       also fail
       CERT_REQUIRED - certificates are required, and will be validated, and
                       if validation fails, the connection will also fail
       
       The following constants identify various SSL protocol variants:
       
       PROTOCOL_SSLv2
       PROTOCOL_SSLv3
       PROTOCOL_SSLv23
       PROTOCOL_TLS
       PROTOCOL_TLSv1
       PROTOCOL_TLSv1_1
       PROTOCOL_TLSv1_2
       
       The following constants identify various SSL alert message descriptions as per
       http://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-6
       
       ALERT_DESCRIPTION_CLOSE_NOTIFY
       ALERT_DESCRIPTION_UNEXPECTED_MESSAGE
       ALERT_DESCRIPTION_BAD_RECORD_MAC
       ALERT_DESCRIPTION_RECORD_OVERFLOW
       ALERT_DESCRIPTION_DECOMPRESSION_FAILURE
       ALERT_DESCRIPTION_HANDSHAKE_FAILURE
       ALERT_DESCRIPTION_BAD_CERTIFICATE
       ALERT_DESCRIPTION_UNSUPPORTED_CERTIFICATE
       ALERT_DESCRIPTION_CERTIFICATE_REVOKED
       ALERT_DESCRIPTION_CERTIFICATE_EXPIRED
       ALERT_DESCRIPTION_CERTIFICATE_UNKNOWN
       ALERT_DESCRIPTION_ILLEGAL_PARAMETER
       ALERT_DESCRIPTION_UNKNOWN_CA
       ALERT_DESCRIPTION_ACCESS_DENIED
       ALERT_DESCRIPTION_DECODE_ERROR
       ALERT_DESCRIPTION_DECRYPT_ERROR
       ALERT_DESCRIPTION_PROTOCOL_VERSION
       ALERT_DESCRIPTION_INSUFFICIENT_SECURITY
       ALERT_DESCRIPTION_INTERNAL_ERROR
       ALERT_DESCRIPTION_USER_CANCELLED
       ALERT_DESCRIPTION_NO_RENEGOTIATION
       ALERT_DESCRIPTION_UNSUPPORTED_EXTENSION
       ALERT_DESCRIPTION_CERTIFICATE_UNOBTAINABLE
       ALERT_DESCRIPTION_UNRECOGNIZED_NAME
       ALERT_DESCRIPTION_BAD_CERTIFICATE_STATUS_RESPONSE
       ALERT_DESCRIPTION_BAD_CERTIFICATE_HASH_VALUE
       ALERT_DESCRIPTION_UNKNOWN_PSK_IDENTITY
    2: """
       
    2: import textwrap
    2: import re
    2: import sys
    2: import os
    2: from collections import namedtuple
    2: from contextlib import closing
       
    2: import _ssl             # if we can't import it, let the error propagate
       
    2: from _ssl import OPENSSL_VERSION_NUMBER, OPENSSL_VERSION_INFO, OPENSSL_VERSION
    2: from _ssl import _SSLContext
    2: from _ssl import (
           SSLError, SSLZeroReturnError, SSLWantReadError, SSLWantWriteError,
           SSLSyscallError, SSLEOFError,
           )
    2: from _ssl import CERT_NONE, CERT_OPTIONAL, CERT_REQUIRED
    2: from _ssl import txt2obj as _txt2obj, nid2obj as _nid2obj
    2: from _ssl import RAND_status, RAND_add
    2: try:
    2:     from _ssl import RAND_egd
>>>>>> except ImportError:
           # LibreSSL does not provide RAND_egd
>>>>>>     pass
       
    2: def _import_symbols(prefix):
  850:     for n in dir(_ssl):
  840:         if n.startswith(prefix):
  100:             globals()[n] = getattr(_ssl, n)
       
    2: _import_symbols('OP_')
    2: _import_symbols('ALERT_DESCRIPTION_')
    2: _import_symbols('SSL_ERROR_')
    2: _import_symbols('PROTOCOL_')
    2: _import_symbols('VERIFY_')
       
    2: from _ssl import HAS_SNI, HAS_ECDH, HAS_NPN, HAS_ALPN
       
    2: from _ssl import _OPENSSL_API_VERSION
       
  176: _PROTOCOL_NAMES = {value: name for name, value in globals().items()
  172:                    if name.startswith('PROTOCOL_')
   10:                        and name != 'PROTOCOL_SSLv23'}
    2: PROTOCOL_SSLv23 = PROTOCOL_TLS
       
    2: try:
    2:     _SSLv2_IF_EXISTS = PROTOCOL_SSLv2
>>>>>> except NameError:
>>>>>>     _SSLv2_IF_EXISTS = None
       
    2: from socket import socket, _fileobject, _delegate_methods, error as socket_error
    2: if sys.platform == "win32":
>>>>>>     from _ssl import enum_certificates, enum_crls
       
    2: from socket import socket, AF_INET, SOCK_STREAM, create_connection
    2: from socket import SOL_SOCKET, SO_TYPE
    2: import base64        # for DER-to-PEM translation
    2: import errno
    2: import warnings
       
    2: if _ssl.HAS_TLS_UNIQUE:
    2:     CHANNEL_BINDING_TYPES = ['tls-unique']
       else:
>>>>>>     CHANNEL_BINDING_TYPES = []
       
       
       # Disable weak or insecure ciphers by default
       # (OpenSSL's default setting is 'DEFAULT:!aNULL:!eNULL')
       # Enable a better set of ciphers by default
       # This list has been explicitly chosen to:
       #   * Prefer cipher suites that offer perfect forward secrecy (DHE/ECDHE)
       #   * Prefer ECDHE over DHE for better performance
       #   * Prefer AEAD over CBC for better performance and security
       #   * Prefer AES-GCM over ChaCha20 because most platforms have AES-NI
       #     (ChaCha20 needs OpenSSL 1.1.0 or patched 1.0.2)
       #   * Prefer any AES-GCM and ChaCha20 over any AES-CBC for better
       #     performance and security
       #   * Then Use HIGH cipher suites as a fallback
       #   * Disable NULL authentication, NULL encryption, 3DES and MD5 MACs
       #     for security reasons
       _DEFAULT_CIPHERS = (
    2:     'ECDH+AESGCM:ECDH+CHACHA20:DH+AESGCM:DH+CHACHA20:ECDH+AES256:DH+AES256:'
           'ECDH+AES128:DH+AES:ECDH+HIGH:DH+HIGH:RSA+AESGCM:RSA+AES:RSA+HIGH:'
           '!aNULL:!eNULL:!MD5:!3DES'
           )
       
       # Restricted and more secure ciphers for the server side
       # This list has been explicitly chosen to:
       #   * Prefer cipher suites that offer perfect forward secrecy (DHE/ECDHE)
       #   * Prefer ECDHE over DHE for better performance
       #   * Prefer AEAD over CBC for better performance and security
       #   * Prefer AES-GCM over ChaCha20 because most platforms have AES-NI
       #   * Prefer any AES-GCM and ChaCha20 over any AES-CBC for better
       #     performance and security
       #   * Then Use HIGH cipher suites as a fallback
       #   * Disable NULL authentication, NULL encryption, MD5 MACs, DSS, RC4, and
       #     3DES for security reasons
       _RESTRICTED_SERVER_CIPHERS = (
    2:     'ECDH+AESGCM:ECDH+CHACHA20:DH+AESGCM:DH+CHACHA20:ECDH+AES256:DH+AES256:'
           'ECDH+AES128:DH+AES:ECDH+HIGH:DH+HIGH:RSA+AESGCM:RSA+AES:RSA+HIGH:'
           '!aNULL:!eNULL:!MD5:!DSS:!RC4:!3DES'
       )
       
       
    4: class CertificateError(ValueError):
    2:     pass
       
       
    2: def _dnsname_match(dn, hostname, max_wildcards=1):
           """Matching according to RFC 6125, section 6.4.3
       
           http://tools.ietf.org/html/rfc6125#section-6.4.3
           """
   59:     pats = []
   59:     if not dn:
>>>>>>         return False
       
   59:     pieces = dn.split(r'.')
   59:     leftmost = pieces[0]
   59:     remainder = pieces[1:]
       
   59:     wildcards = leftmost.count('*')
   59:     if wildcards > max_wildcards:
               # Issue #17980: avoid denials of service by refusing more
               # than one wildcard per fragment.  A survery of established
               # policy among SSL implementations showed it to be a
               # reasonable choice.
    1:         raise CertificateError(
    1:             "too many wildcards in certificate DNS name: " + repr(dn))
       
           # speed up common case w/o wildcards
   58:     if not wildcards:
   36:         return dn.lower() == hostname.lower()
       
           # RFC 6125, section 6.4.3, subitem 1.
           # The client SHOULD NOT attempt to match a presented identifier in which
           # the wildcard character comprises a label other than the left-most label.
   22:     if leftmost == '*':
               # When '*' is a fragment by itself, it matches a non-empty dotless
               # fragment.
    9:         pats.append('[^.]+')
   13:     elif leftmost.startswith('xn--') or hostname.startswith('xn--'):
               # RFC 6125, section 6.4.3, subitem 3.
               # The client SHOULD NOT attempt to match a presented identifier
               # where the wildcard character is embedded within an A-label or
               # U-label of an internationalized domain name.
    3:         pats.append(re.escape(leftmost))
           else:
               # Otherwise, '*' matches any dotless string, e.g. www*
   10:         pats.append(re.escape(leftmost).replace(r'\*', '[^.]*'))
       
           # add the remaining fragments, ignore any wildcards
   63:     for frag in remainder:
   41:         pats.append(re.escape(frag))
       
   22:     pat = re.compile(r'\A' + r'\.'.join(pats) + r'\Z', re.IGNORECASE)
   22:     return pat.match(hostname)
       
       
    2: def match_hostname(cert, hostname):
           """Verify that *cert* (in decoded format as returned by
           SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125
           rules are followed, but IP addresses are not accepted for *hostname*.
       
           CertificateError is raised on failure. On success, the function
           returns nothing.
           """
   60:     if not cert:
    2:         raise ValueError("empty or no certificate, match_hostname needs a "
                                "SSL socket or SSL context with either "
                                "CERT_OPTIONAL or CERT_REQUIRED")
   58:     dnsnames = []
   58:     san = cert.get('subjectAltName', ())
   69:     for key, value in san:
   17:         if key == 'DNS':
   13:             if _dnsname_match(value, hostname):
    6:                 return
    7:             dnsnames.append(value)
   52:     if not dnsnames:
               # The subject is only checked when there is no dNSName entry
               # in subjectAltName
  119:         for sub in cert.get('subject', ()):
  158:             for key, value in sub:
                       # XXX according to RFC 2818, the most specific Common Name
                       # must be used.
   87:                 if key == 'commonName':
   46:                     if _dnsname_match(value, hostname):
   15:                         return
   30:                     dnsnames.append(value)
   36:     if len(dnsnames) > 1:
    2:         raise CertificateError("hostname %r "
                   "doesn't match either of %s"
    2:             % (hostname, ', '.join(map(repr, dnsnames))))
   34:     elif len(dnsnames) == 1:
   32:         raise CertificateError("hostname %r "
                   "doesn't match %r"
   32:             % (hostname, dnsnames[0]))
           else:
    2:         raise CertificateError("no appropriate commonName or "
                   "subjectAltName fields were found")
       
       
    2: DefaultVerifyPaths = namedtuple("DefaultVerifyPaths",
    2:     "cafile capath openssl_cafile_env openssl_cafile openssl_capath_env "
           "openssl_capath")
       
    2: def get_default_verify_paths():
           """Return paths to default cafile and capath.
           """
    2:     parts = _ssl.get_default_verify_paths()
       
           # environment vars shadow paths
    2:     cafile = os.environ.get(parts[0], parts[1])
    2:     capath = os.environ.get(parts[2], parts[3])
       
    2:     return DefaultVerifyPaths(cafile if os.path.isfile(cafile) else None,
    2:                               capath if os.path.isdir(capath) else None,
    2:                               *parts)
       
       
    4: class _ASN1Object(namedtuple("_ASN1Object", "nid shortname longname oid")):
           """ASN.1 object identifier lookup
    2:     """
    2:     __slots__ = ()
       
    2:     def __new__(cls, oid):
    8:         return super(_ASN1Object, cls).__new__(cls, *_txt2obj(oid, name=False))
       
    2:     @classmethod
           def fromnid(cls, nid):
               """Create _ASN1Object from OpenSSL numeric ID
               """
 1003:         return super(_ASN1Object, cls).__new__(cls, *_nid2obj(nid))
       
    2:     @classmethod
           def fromname(cls, name):
               """Create _ASN1Object from short name, long name or OID
               """
    4:         return super(_ASN1Object, cls).__new__(cls, *_txt2obj(name, name=True))
       
       
    4: class Purpose(_ASN1Object):
           """SSLContext purpose flags with X509v3 Extended Key Usage objects
    2:     """
       
    2: Purpose.SERVER_AUTH = Purpose('1.3.6.1.5.5.7.3.1')
    2: Purpose.CLIENT_AUTH = Purpose('1.3.6.1.5.5.7.3.2')
       
       
    4: class SSLContext(_SSLContext):
           """An SSLContext holds various SSL-related configuration options and
    2:     data, such as certificates and possibly a private key."""
       
    2:     __slots__ = ('protocol', '__weakref__')
    2:     _windows_cert_stores = ("CA", "ROOT")
       
    2:     def __new__(cls, protocol, *args, **kwargs):
  351:         self = _SSLContext.__new__(cls, protocol)
  349:         if protocol != _SSLv2_IF_EXISTS:
  321:             self.set_ciphers(_DEFAULT_CIPHERS)
  349:         return self
       
    2:     def __init__(self, protocol):
  349:         self.protocol = protocol
       
    2:     def wrap_socket(self, sock, server_side=False,
    2:                     do_handshake_on_connect=True,
    2:                     suppress_ragged_eofs=True,
    2:                     server_hostname=None):
  211:         return SSLSocket(sock=sock, server_side=server_side,
  211:                          do_handshake_on_connect=do_handshake_on_connect,
  211:                          suppress_ragged_eofs=suppress_ragged_eofs,
  211:                          server_hostname=server_hostname,
  211:                          _context=self)
       
    2:     def set_npn_protocols(self, npn_protocols):
>>>>>>         protos = bytearray()
>>>>>>         for protocol in npn_protocols:
>>>>>>             b = protocol.encode('ascii')
>>>>>>             if len(b) == 0 or len(b) > 255:
>>>>>>                 raise SSLError('NPN protocols must be 1 to 255 in length')
>>>>>>             protos.append(len(b))
>>>>>>             protos.extend(b)
       
>>>>>>         self._set_npn_protocols(protos)
       
    2:     def set_alpn_protocols(self, alpn_protocols):
>>>>>>         protos = bytearray()
>>>>>>         for protocol in alpn_protocols:
>>>>>>             b = protocol.encode('ascii')
>>>>>>             if len(b) == 0 or len(b) > 255:
>>>>>>                 raise SSLError('ALPN protocols must be 1 to 255 in length')
>>>>>>             protos.append(len(b))
>>>>>>             protos.extend(b)
       
>>>>>>         self._set_alpn_protocols(protos)
       
    2:     def _load_windows_store_certs(self, storename, purpose):
>>>>>>         certs = bytearray()
>>>>>>         try:
>>>>>>             for cert, encoding, trust in enum_certificates(storename):
                       # CA certs are never PKCS#7 encoded
>>>>>>                 if encoding == "x509_asn":
>>>>>>                     if trust is True or purpose.oid in trust:
>>>>>>                         certs.extend(cert)
>>>>>>         except OSError:
>>>>>>             warnings.warn("unable to enumerate Windows certificate store")
>>>>>>         if certs:
>>>>>>             self.load_verify_locations(cadata=certs)
>>>>>>         return certs
       
    2:     def load_default_certs(self, purpose=Purpose.SERVER_AUTH):
   20:         if not isinstance(purpose, _ASN1Object):
    2:             raise TypeError(purpose)
   18:         if sys.platform == "win32":
>>>>>>             for storename in self._windows_cert_stores:
>>>>>>                 self._load_windows_store_certs(storename, purpose)
   18:         self.set_default_verify_paths()
       
       
    2: def create_default_context(purpose=Purpose.SERVER_AUTH, cafile=None,
    2:                            capath=None, cadata=None):
           """Create a SSLContext object with default settings.
       
           NOTE: The protocol and settings may change anytime without prior
                 deprecation. The values represent a fair balance between maximum
                 compatibility and security.
           """
   28:     if not isinstance(purpose, _ASN1Object):
>>>>>>         raise TypeError(purpose)
       
   28:     context = SSLContext(PROTOCOL_TLS)
       
           # SSLv2 considered harmful.
   28:     context.options |= OP_NO_SSLv2
       
           # SSLv3 has problematic security and is only required for really old
           # clients such as IE6 on Windows XP
   28:     context.options |= OP_NO_SSLv3
       
           # disable compression to prevent CRIME attacks (OpenSSL 1.0+)
   28:     context.options |= getattr(_ssl, "OP_NO_COMPRESSION", 0)
       
   28:     if purpose == Purpose.SERVER_AUTH:
               # verify certs and host name in client mode
   19:         context.verify_mode = CERT_REQUIRED
   19:         context.check_hostname = True
    9:     elif purpose == Purpose.CLIENT_AUTH:
               # Prefer the server's ciphers by default so that we get stronger
               # encryption
    9:         context.options |= getattr(_ssl, "OP_CIPHER_SERVER_PREFERENCE", 0)
       
               # Use single use keys in order to improve forward secrecy
    9:         context.options |= getattr(_ssl, "OP_SINGLE_DH_USE", 0)
    9:         context.options |= getattr(_ssl, "OP_SINGLE_ECDH_USE", 0)
       
               # disallow ciphers with known vulnerabilities
    9:         context.set_ciphers(_RESTRICTED_SERVER_CIPHERS)
       
   28:     if cafile or capath or cadata:
    7:         context.load_verify_locations(cafile, capath, cadata)
   21:     elif context.verify_mode != CERT_NONE:
               # no explicit cafile, capath or cadata but the verify mode is
               # CERT_OPTIONAL or CERT_REQUIRED. Let's try to load default system
               # root CA certificates for the given purpose. This may fail silently.
   12:         context.load_default_certs(purpose)
   28:     return context
       
    2: def _create_unverified_context(protocol=PROTOCOL_TLS, cert_reqs=None,
    2:                            check_hostname=False, purpose=Purpose.SERVER_AUTH,
    2:                            certfile=None, keyfile=None,
    2:                            cafile=None, capath=None, cadata=None):
           """Create a SSLContext object for Python stdlib modules
       
           All Python stdlib modules shall use this function to create SSLContext
           objects in order to keep common settings in one place. The configuration
           is less restrict than create_default_context()'s to increase backward
           compatibility.
           """
   40:     if not isinstance(purpose, _ASN1Object):
>>>>>>         raise TypeError(purpose)
       
   40:     context = SSLContext(protocol)
           # SSLv2 considered harmful.
   40:     context.options |= OP_NO_SSLv2
           # SSLv3 has problematic security and is only required for really old
           # clients such as IE6 on Windows XP
   40:     context.options |= OP_NO_SSLv3
       
   40:     if cert_reqs is not None:
    1:         context.verify_mode = cert_reqs
   40:     context.check_hostname = check_hostname
       
   40:     if keyfile and not certfile:
>>>>>>         raise ValueError("certfile must be specified")
   40:     if certfile or keyfile:
>>>>>>         context.load_cert_chain(certfile, keyfile)
       
           # load CA root certs
   40:     if cafile or capath or cadata:
>>>>>>         context.load_verify_locations(cafile, capath, cadata)
   40:     elif context.verify_mode != CERT_NONE:
               # no explicit cafile, capath or cadata but the verify mode is
               # CERT_OPTIONAL or CERT_REQUIRED. Let's try to load default system
               # root CA certificates for the given purpose. This may fail silently.
    1:         context.load_default_certs(purpose)
       
   40:     return context
       
       # Backwards compatibility alias, even though it's not a public name.
    2: _create_stdlib_context = _create_unverified_context
       
       # PEP 493: Verify HTTPS by default, but allow envvar to override that
    2: _https_verify_envvar = 'PYTHONHTTPSVERIFY'
       
    2: def _get_https_context_factory():
    2:     if not sys.flags.ignore_environment:
    2:         config_setting = os.environ.get(_https_verify_envvar)
    2:         if config_setting == '0':
>>>>>>             return _create_unverified_context
    2:     return create_default_context
       
    2: _create_default_https_context = _get_https_context_factory()
       
       # PEP 493: "private" API to configure HTTPS defaults without monkeypatching
    2: def _https_verify_certificates(enable=True):
           """Verify server HTTPS certificates by default?"""
           global _create_default_https_context
    4:     if enable:
    2:         _create_default_https_context = create_default_context
           else:
    2:         _create_default_https_context = _create_unverified_context
       
       
    4: class SSLSocket(socket):
           """This class implements a subtype of socket.socket that wraps
           the underlying OS socket in an SSL context when necessary, and
    2:     provides read and write methods over that channel."""
       
    2:     def __init__(self, sock=None, keyfile=None, certfile=None,
    2:                  server_side=False, cert_reqs=CERT_NONE,
    2:                  ssl_version=PROTOCOL_TLS, ca_certs=None,
    2:                  do_handshake_on_connect=True,
    2:                  family=AF_INET, type=SOCK_STREAM, proto=0, fileno=None,
    2:                  suppress_ragged_eofs=True, npn_protocols=None, ciphers=None,
    2:                  server_hostname=None,
    2:                  _context=None):
       
  327:         self._makefile_refs = 0
  327:         if _context:
  211:             self._context = _context
               else:
  116:             if server_side and not certfile:
    2:                 raise ValueError("certfile must be specified for server-side "
                                        "operations")
  114:             if keyfile and not certfile:
    1:                 raise ValueError("certfile must be specified")
  113:             if certfile and not keyfile:
   83:                 keyfile = certfile
  113:             self._context = SSLContext(ssl_version)
  113:             self._context.verify_mode = cert_reqs
  113:             if ca_certs:
    3:                 self._context.load_verify_locations(ca_certs)
  113:             if certfile:
   85:                 self._context.load_cert_chain(certfile, keyfile)
  107:             if npn_protocols:
>>>>>>                 self._context.set_npn_protocols(npn_protocols)
  107:             if ciphers:
>>>>>>                 self._context.set_ciphers(ciphers)
  107:             self.keyfile = keyfile
  107:             self.certfile = certfile
  107:             self.cert_reqs = cert_reqs
  107:             self.ssl_version = ssl_version
  107:             self.ca_certs = ca_certs
  107:             self.ciphers = ciphers
               # Can't use sock.type as other flags (such as SOCK_NONBLOCK) get
               # mixed in.
  318:         if sock.getsockopt(SOL_SOCKET, SO_TYPE) != SOCK_STREAM:
    2:             raise NotImplementedError("only stream sockets are supported")
  316:         socket.__init__(self, _sock=sock._sock)
               # The initializer for socket overrides the methods send(), recv(), etc.
               # in the instancce, which we don't need -- but we want to provide the
               # methods defined in SSLSocket.
 2212:         for attr in _delegate_methods:
 1896:             try:
 1896:                 delattr(self, attr)
>>>>>>             except AttributeError:
>>>>>>                 pass
  316:         if server_side and server_hostname:
    1:             raise ValueError("server_hostname can only be specified "
                                    "in client mode")
  315:         if self._context.check_hostname and not server_hostname:
    1:             raise ValueError("check_hostname requires server_hostname")
  314:         self.server_side = server_side
  314:         self.server_hostname = server_hostname
  314:         self.do_handshake_on_connect = do_handshake_on_connect
  314:         self.suppress_ragged_eofs = suppress_ragged_eofs
       
               # See if we are connected
  314:         try:
  314:             self.getpeername()
   78:         except socket_error as e:
   78:             if e.errno != errno.ENOTCONN:
>>>>>>                 raise
   78:             connected = False
               else:
  236:             connected = True
       
  314:         self._closed = False
  314:         self._sslobj = None
  314:         self._connected = connected
  314:         if connected:
                   # create the SSL object
  236:             try:
  236:                 self._sslobj = self._context._wrap_socket(self._sock, server_side,
  236:                                                           server_hostname, ssl_sock=self)
  236:                 if do_handshake_on_connect:
  162:                     timeout = self.gettimeout()
  162:                     if timeout == 0.0:
                               # non-blocking
>>>>>>                         raise ValueError("do_handshake_on_connect should not be specified for non-blocking sockets")
  162:                     self.do_handshake()
       
   37:             except (OSError, ValueError):
    4:                 self.close()
    4:                 raise
       
    2:     @property
           def context(self):
  309:         return self._context
       
    2:     @context.setter
           def context(self, ctx):
    1:         self._context = ctx
    1:         self._sslobj.context = ctx
       
    2:     def dup(self):
>>>>>>         raise NotImplemented("Can't dup() %s instances" %
>>>>>>                              self.__class__.__name__)
       
    2:     def _checkClosed(self, msg=None):
               # raise an exception here if you wish to check for spurious closes
11113:         pass
       
    2:     def _check_connected(self):
  513:         if not self._connected:
                   # getpeername() will raise ENOTCONN if the socket is really
                   # not connected; note that we can be connected even without
                   # _connected being set, e.g. if connect() first returned
                   # EAGAIN.
    2:             self.getpeername()
       
    2:     def read(self, len=1024, buffer=None):
               """Read up to LEN bytes and return them.
               Return zero-length string on EOF."""
       
 3078:         self._checkClosed()
 3078:         if not self._sslobj:
    1:             raise ValueError("Read on closed or unwrapped SSL socket.")
 3077:         try:
 3077:             if buffer is not None:
    3:                 v = self._sslobj.read(len, buffer)
                   else:
 3074:                 v = self._sslobj.read(len)
 3029:             return v
   48:         except SSLError as x:
   42:             if x.args[0] == SSL_ERROR_EOF and self.suppress_ragged_eofs:
   20:                 if buffer is not None:
>>>>>>                     return 0
                       else:
   20:                     return b''
                   else:
   22:                 raise
       
    2:     def write(self, data):
               """Write DATA to the underlying SSL channel.  Returns
               number of bytes of DATA actually transmitted."""
       
  241:         self._checkClosed()
  241:         if not self._sslobj:
    1:             raise ValueError("Write on closed or unwrapped SSL socket.")
  240:         return self._sslobj.write(data)
       
    2:     def getpeercert(self, binary_form=False):
               """Returns a formatted version of the data in the
               certificate provided by the other end of the SSL channel.
               Return None if no certificate was provided, {} if a
               certificate was provided, but not validated."""
       
   59:         self._checkClosed()
   59:         self._check_connected()
   58:         return self._sslobj.peer_certificate(binary_form)
       
    2:     def selected_npn_protocol(self):
   67:         self._checkClosed()
   67:         if not self._sslobj or not _ssl.HAS_NPN:
   67:             return None
               else:
>>>>>>             return self._sslobj.selected_npn_protocol()
       
    2:     def selected_alpn_protocol(self):
   67:         self._checkClosed()
   67:         if not self._sslobj or not _ssl.HAS_ALPN:
   67:             return None
               else:
>>>>>>             return self._sslobj.selected_alpn_protocol()
       
    2:     def cipher(self):
   69:         self._checkClosed()
   69:         if not self._sslobj:
>>>>>>             return None
               else:
   69:             return self._sslobj.cipher()
       
    2:     def compression(self):
   27:         self._checkClosed()
   27:         if not self._sslobj:
>>>>>>             return None
               else:
   27:             return self._sslobj.compression()
       
    2:     def send(self, data, flags=0):
 2483:         self._checkClosed()
 2483:         if self._sslobj:
 2482:             if flags != 0:
>>>>>>                 raise ValueError(
>>>>>>                     "non-zero flags not allowed in calls to send() on %s" %
>>>>>>                     self.__class__)
 2482:             try:
 2482:                 v = self._sslobj.write(data)
   27:             except SSLError as x:
   27:                 if x.args[0] == SSL_ERROR_WANT_READ:
   27:                     return 0
>>>>>>                 elif x.args[0] == SSL_ERROR_WANT_WRITE:
>>>>>>                     return 0
                       else:
>>>>>>                     raise
                   else:
 2455:                 return v
               else:
    1:             return self._sock.send(data, flags)
       
    2:     def sendto(self, data, flags_or_addr, addr=None):
    2:         self._checkClosed()
    2:         if self._sslobj:
    1:             raise ValueError("sendto not allowed on instances of %s" %
    1:                              self.__class__)
    1:         elif addr is None:
    1:             return self._sock.sendto(data, flags_or_addr)
               else:
>>>>>>             return self._sock.sendto(data, flags_or_addr, addr)
       
       
    2:     def sendall(self, data, flags=0):
 2202:         self._checkClosed()
 2202:         if self._sslobj:
 2202:             if flags != 0:
>>>>>>                 raise ValueError(
>>>>>>                     "non-zero flags not allowed in calls to sendall() on %s" %
>>>>>>                     self.__class__)
 2202:             amount = len(data)
 2202:             count = 0
 4404:             while (count < amount):
 2202:                 v = self.send(data[count:])
 2202:                 count += v
 2202:             return amount
               else:
>>>>>>             return socket.sendall(self, data, flags)
       
    2:     def recv(self, buflen=1024, flags=0):
 2799:         self._checkClosed()
 2799:         if self._sslobj:
 2798:             if flags != 0:
>>>>>>                 raise ValueError(
>>>>>>                     "non-zero flags not allowed in calls to recv() on %s" %
>>>>>>                     self.__class__)
 2798:             return self.read(buflen)
               else:
    1:             return self._sock.recv(buflen, flags)
       
    2:     def recv_into(self, buffer, nbytes=None, flags=0):
    3:         self._checkClosed()
    3:         if buffer and (nbytes is None):
    2:             nbytes = len(buffer)
    1:         elif nbytes is None:
    1:             nbytes = 1024
    3:         if self._sslobj:
    2:             if flags != 0:
>>>>>>                 raise ValueError(
>>>>>>                   "non-zero flags not allowed in calls to recv_into() on %s" %
>>>>>>                   self.__class__)
    2:             return self.read(nbytes, buffer)
               else:
    1:             return self._sock.recv_into(buffer, nbytes, flags)
       
    2:     def recvfrom(self, buflen=1024, flags=0):
    2:         self._checkClosed()
    2:         if self._sslobj:
    1:             raise ValueError("recvfrom not allowed on instances of %s" %
    1:                              self.__class__)
               else:
    1:             return self._sock.recvfrom(buflen, flags)
       
    2:     def recvfrom_into(self, buffer, nbytes=None, flags=0):
    2:         self._checkClosed()
    2:         if self._sslobj:
    1:             raise ValueError("recvfrom_into not allowed on instances of %s" %
    1:                              self.__class__)
               else:
    1:             return self._sock.recvfrom_into(buffer, nbytes, flags)
       
       
    2:     def pending(self):
    4:         self._checkClosed()
    4:         if self._sslobj:
    4:             return self._sslobj.pending()
               else:
>>>>>>             return 0
       
    2:     def shutdown(self, how):
    8:         self._checkClosed()
    8:         self._sslobj = None
    8:         socket.shutdown(self, how)
       
    2:     def close(self):
  338:         if self._makefile_refs < 1:
  276:             self._sslobj = None
  276:             socket.close(self)
               else:
   62:             self._makefile_refs -= 1
       
    2:     def unwrap(self):
   85:         if self._sslobj:
   85:             s = self._sslobj.shutdown()
   32:             self._sslobj = None
   32:             return s
               else:
>>>>>>             raise ValueError("No SSL wrapper around " + str(self))
       
    2:     def _real_close(self):
>>>>>>         self._sslobj = None
>>>>>>         socket._real_close(self)
       
    2:     def do_handshake(self, block=False):
               """Perform a TLS/SSL handshake."""
  454:         self._check_connected()
  453:         timeout = self.gettimeout()
  453:         try:
  453:             if timeout == 0.0 and block:
>>>>>>                 self.settimeout(None)
  453:             self._sslobj.do_handshake()
               finally:
  453:             self.settimeout(timeout)
       
  240:         if self.context.check_hostname:
   12:             if not self.server_hostname:
>>>>>>                 raise ValueError("check_hostname needs server_hostname "
                                        "argument")
   12:             match_hostname(self.getpeercert(), self.server_hostname)
       
    2:     def _real_connect(self, addr, connect_ex):
   67:         if self.server_side:
    1:             raise ValueError("can't connect in server-side mode")
               # Here we assume that the socket is client-side, and not
               # connected at the time of the call.  We connect it, then wrap it.
   66:         if self._connected:
>>>>>>             raise ValueError("attempt to connect already-connected SSLSocket!")
   66:         self._sslobj = self.context._wrap_socket(self._sock, False, self.server_hostname, ssl_sock=self)
   66:         try:
   66:             if connect_ex:
>>>>>>                 rc = socket.connect_ex(self, addr)
                   else:
   66:                 rc = None
   66:                 socket.connect(self, addr)
   66:             if not rc:
   66:                 self._connected = True
   66:                 if self.do_handshake_on_connect:
   65:                     self.do_handshake()
   39:             return rc
   27:         except (OSError, ValueError):
    1:             self._sslobj = None
    1:             raise
       
    2:     def connect(self, addr):
               """Connects to remote ADDR, and then wraps the connection in
               an SSL channel."""
   67:         self._real_connect(addr, False)
       
    2:     def connect_ex(self, addr):
               """Connects to remote ADDR, and then wraps the connection in
               an SSL channel."""
>>>>>>         return self._real_connect(addr, True)
       
    2:     def accept(self):
               """Accepts a new connection from a remote client, and returns
               a tuple containing that new connection wrapped with a server-side
               SSL channel, and the address of the remote client."""
       
    1:         newsock, addr = socket.accept(self)
    1:         newsock = self.context.wrap_socket(newsock,
    1:                     do_handshake_on_connect=self.do_handshake_on_connect,
    1:                     suppress_ragged_eofs=self.suppress_ragged_eofs,
    1:                     server_side=True)
    1:         return newsock, addr
       
    2:     def makefile(self, mode='r', bufsize=-1):
       
               """Make and return a file-like object that
               works with the SSL connection.  Just use the code
               from the socket module."""
       
   62:         self._makefile_refs += 1
               # close=True so as to decrement the reference count when done with
               # the file-like object.
   62:         return _fileobject(self, mode, bufsize, close=True)
       
    2:     def get_channel_binding(self, cb_type="tls-unique"):
               """Get channel binding data for current connection.  Raise ValueError
               if the requested `cb_type` is not supported.  Return bytes of the data
               or None if the data is not available (e.g. before the handshake).
               """
    7:         if cb_type not in CHANNEL_BINDING_TYPES:
    1:             raise ValueError("Unsupported channel binding type")
    6:         if cb_type != "tls-unique":
>>>>>>             raise NotImplementedError(
>>>>>>                             "{0} channel binding type not implemented"
>>>>>>                             .format(cb_type))
    6:         if self._sslobj is None:
    2:             return None
    4:         return self._sslobj.tls_unique_cb()
       
    2:     def version(self):
               """
               Return a string identifying the protocol version used by the
               current SSL channel, or None if there is no established channel.
               """
   30:         if self._sslobj is None:
    2:             return None
   28:         return self._sslobj.version()
       
       
    2: def wrap_socket(sock, keyfile=None, certfile=None,
    2:                 server_side=False, cert_reqs=CERT_NONE,
    2:                 ssl_version=PROTOCOL_TLS, ca_certs=None,
    2:                 do_handshake_on_connect=True,
    2:                 suppress_ragged_eofs=True,
    2:                 ciphers=None):
       
  116:     return SSLSocket(sock=sock, keyfile=keyfile, certfile=certfile,
  116:                      server_side=server_side, cert_reqs=cert_reqs,
  116:                      ssl_version=ssl_version, ca_certs=ca_certs,
  116:                      do_handshake_on_connect=do_handshake_on_connect,
  116:                      suppress_ragged_eofs=suppress_ragged_eofs,
  116:                      ciphers=ciphers)
       
       # some utility functions
       
    2: def cert_time_to_seconds(cert_time):
           """Return the time in seconds since the Epoch, given the timestring
           representing the "notBefore" or "notAfter" date from a certificate
           in ``"%b %d %H:%M:%S %Y %Z"`` strptime format (C locale).
       
           "notBefore" or "notAfter" dates must use UTC (RFC 5280).
       
           Month is one of: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec
           UTC should be specified as GMT (see ASN1_TIME_print())
           """
   22:     from time import strptime
   22:     from calendar import timegm
       
           months = (
               "Jan","Feb","Mar","Apr","May","Jun",
   22:         "Jul","Aug","Sep","Oct","Nov","Dec"
           )
   22:     time_format = ' %d %H:%M:%S %Y GMT' # NOTE: no month, fixed GMT
   22:     try:
   22:         month_number = months.index(cert_time[:3].title()) + 1
    1:     except ValueError:
    1:         raise ValueError('time data %r does not match '
    1:                          'format "%%b%s"' % (cert_time, time_format))
           else:
               # found valid month
   21:         tt = strptime(cert_time[3:], time_format)
               # return an integer, the previous mktime()-based implementation
               # returned a float (fractional seconds are always zero here).
   14:         return timegm((tt[0], month_number) + tt[2:6])
       
    2: PEM_HEADER = "-----BEGIN CERTIFICATE-----"
    2: PEM_FOOTER = "-----END CERTIFICATE-----"
       
    2: def DER_cert_to_PEM_cert(der_cert_bytes):
           """Takes a certificate in binary DER format and returns the
           PEM version of it as a string."""
       
    1:     f = base64.standard_b64encode(der_cert_bytes).decode('ascii')
           return (PEM_HEADER + '\n' +
                   textwrap.fill(f, 64) + '\n' +
    1:             PEM_FOOTER + '\n')
       
    2: def PEM_cert_to_DER_cert(pem_cert_string):
           """Takes a certificate in ASCII PEM format and returns the
           DER-encoded version of it as a byte sequence"""
       
    5:     if not pem_cert_string.startswith(PEM_HEADER):
>>>>>>         raise ValueError("Invalid PEM encoding; must start with %s"
>>>>>>                          % PEM_HEADER)
    5:     if not pem_cert_string.strip().endswith(PEM_FOOTER):
>>>>>>         raise ValueError("Invalid PEM encoding; must end with %s"
>>>>>>                          % PEM_FOOTER)
    5:     d = pem_cert_string.strip()[len(PEM_HEADER):-len(PEM_FOOTER)]
    5:     return base64.decodestring(d.encode('ASCII', 'strict'))
       
    2: def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):
           """Retrieve the certificate from the server at the specified address,
           and return it as a PEM-encoded string.
           If 'ca_certs' is specified, validate the server cert against it.
           If 'ssl_version' is specified, use it in the connection attempt."""
       
>>>>>>     host, port = addr
>>>>>>     if ca_certs is not None:
>>>>>>         cert_reqs = CERT_REQUIRED
           else:
>>>>>>         cert_reqs = CERT_NONE
>>>>>>     context = _create_stdlib_context(ssl_version,
>>>>>>                                      cert_reqs=cert_reqs,
>>>>>>                                      cafile=ca_certs)
>>>>>>     with closing(create_connection(addr)) as sock:
>>>>>>         with closing(context.wrap_socket(sock)) as sslsock:
>>>>>>             dercert = sslsock.getpeercert(True)
>>>>>>     return DER_cert_to_PEM_cert(dercert)
       
    2: def get_protocol_name(protocol_code):
>>>>>>     return _PROTOCOL_NAMES.get(protocol_code, '<unknown>')
       
       
       # a replacement for the old socket.ssl function
       
    2: def sslwrap_simple(sock, keyfile=None, certfile=None):
           """A replacement for the old socket.ssl function.  Designed
           for compability with Python 2.5 and earlier.  Will disappear in
           Python 3.0."""
    2:     if hasattr(sock, "_sock"):
    1:         sock = sock._sock
       
    2:     ctx = SSLContext(PROTOCOL_SSLv23)
    2:     if keyfile or certfile:
>>>>>>         ctx.load_cert_chain(certfile, keyfile)
    2:     ssl_sock = ctx._wrap_socket(sock, server_side=False)
    2:     try:
    2:         sock.getpeername()
    2:     except socket_error:
               # no, no connection yet
    2:         pass
           else:
               # yes, do the handshake
>>>>>>         ssl_sock.do_handshake()
       
    2:     return ssl_sock
