       """
       Common tests shared by test_str, test_unicode, test_userstring and test_string.
    1: """
       
    1: import unittest, string, sys, struct
    1: from test import test_support
    1: from UserList import UserList
       
    2: class Sequence:
   12:     def __init__(self, seq='wxyz'): self.seq = seq
   17:     def __len__(self): return len(self.seq)
   92:     def __getitem__(self, i): return self.seq[i]
       
    2: class BadSeq1(Sequence):
    6:     def __init__(self): self.seq = [7, 'hello', 123L]
       
    2: class BadSeq2(Sequence):
    6:     def __init__(self): self.seq = ['a', 'b', 'c']
    6:     def __len__(self): return 8
       
    2: class CommonTest(unittest.TestCase):
           # This testcase contains test that can be used in all
           # stringlike classes. Currently this is str, unicode
           # UserString and the string module.
       
           # The type to be tested
           # Change in subclasses to change the behaviour of fixtesttype()
    1:     type2test = None
       
           # All tests pass their arguments to the testing methods
           # as str objects. fixtesttype() can be used to propagate
           # these arguments to the appropriate type
    1:     def fixtype(self, obj):
69915:         if isinstance(obj, str):
51917:             return self.__class__.type2test(obj)
17998:         elif isinstance(obj, list):
 3343:             return [self.fixtype(x) for x in obj]
17343:         elif isinstance(obj, tuple):
16386:             return tuple([self.fixtype(x) for x in obj])
 9586:         elif isinstance(obj, dict):
    2:             return dict([
    2:                (self.fixtype(key), self.fixtype(value))
    3:                for (key, value) in obj.iteritems()
                   ])
               else:
 9584:             return obj
       
    1:     def test_fixtype(self):
    6:         self.assertIs(type(self.fixtype("123")), self.type2test)
       
           # check that object.method(*args) returns result
    1:     def checkequal(self, result, object, methodname, *args):
 2685:         result = self.fixtype(result)
 2685:         object = self.fixtype(object)
 2685:         args = self.fixtype(args)
 2685:         realresult = getattr(object, methodname)(*args)
 2685:         self.assertEqual(
 2685:             result,
 2685:             realresult
               )
               # if the original is returned make sure that
               # this doesn't happen with subclasses
 2685:         if object == realresult:
  362:             class subtype(self.__class__.type2test):
  181:                 pass
  181:             object = subtype(object)
  181:             realresult = getattr(object, methodname)(*args)
  181:             self.assertTrue(object is not realresult)
       
           # check that object.method(*args) raises exc
    1:     def checkraises(self, exc, obj, methodname, *args):
  222:         obj = self.fixtype(obj)
  222:         args = self.fixtype(args)
  222:         with self.assertRaises(exc) as cm:
  222:             getattr(obj, methodname)(*args)
  222:         self.assertNotEqual(cm.exception.args[0], '')
       
           # call object.method(*args) without any checks
    1:     def checkcall(self, object, methodname, *args):
12002:         object = self.fixtype(object)
12002:         args = self.fixtype(args)
12002:         getattr(object, methodname)(*args)
       
    1:     def test_hash(self):
               # SF bug 1054139:  += optimization was not invalidating cached hash value
    4:         a = self.type2test('DNSSEC')
    4:         b = self.type2test('')
   28:         for c in a:
   24:             b += c
   24:             hash(b)
    4:         self.assertEqual(hash(a), hash(b))
       
    1:     def test_capitalize(self):
    6:         self.checkequal(' hello ', ' hello ', 'capitalize')
    6:         self.checkequal('Hello ', 'Hello ','capitalize')
    6:         self.checkequal('Hello ', 'hello ','capitalize')
    6:         self.checkequal('Aaaa', 'aaaa', 'capitalize')
    6:         self.checkequal('Aaaa', 'AaAa', 'capitalize')
       
    6:         self.checkraises(TypeError, 'hello', 'capitalize', 42)
       
    1:     def test_count(self):
    6:         self.checkequal(3, 'aaa', 'count', 'a')
    6:         self.checkequal(0, 'aaa', 'count', 'b')
    6:         self.checkequal(3, 'aaa', 'count', 'a')
    6:         self.checkequal(0, 'aaa', 'count', 'b')
    6:         self.checkequal(3, 'aaa', 'count', 'a')
    6:         self.checkequal(0, 'aaa', 'count', 'b')
    6:         self.checkequal(0, 'aaa', 'count', 'b')
    6:         self.checkequal(2, 'aaa', 'count', 'a', 1)
    6:         self.checkequal(0, 'aaa', 'count', 'a', 10)
    6:         self.checkequal(1, 'aaa', 'count', 'a', -1)
    6:         self.checkequal(3, 'aaa', 'count', 'a', -10)
    6:         self.checkequal(1, 'aaa', 'count', 'a', 0, 1)
    6:         self.checkequal(3, 'aaa', 'count', 'a', 0, 10)
    6:         self.checkequal(2, 'aaa', 'count', 'a', 0, -1)
    6:         self.checkequal(0, 'aaa', 'count', 'a', 0, -10)
    6:         self.checkequal(3, 'aaa', 'count', '', 1)
    6:         self.checkequal(1, 'aaa', 'count', '', 3)
    6:         self.checkequal(0, 'aaa', 'count', '', 10)
    6:         self.checkequal(2, 'aaa', 'count', '', -1)
    6:         self.checkequal(4, 'aaa', 'count', '', -10)
       
    6:         self.checkequal(1, '', 'count', '')
    6:         self.checkequal(0, '', 'count', '', 1, 1)
    6:         self.checkequal(0, '', 'count', '', sys.maxint, 0)
       
    6:         self.checkequal(0, '', 'count', 'xx')
    6:         self.checkequal(0, '', 'count', 'xx', 1, 1)
    6:         self.checkequal(0, '', 'count', 'xx', sys.maxint, 0)
       
    6:         self.checkraises(TypeError, 'hello', 'count')
    6:         self.checkraises(TypeError, 'hello', 'count', 42)
       
               # For a variety of combinations,
               #    verify that str.count() matches an equivalent function
               #    replacing all occurrences and then differencing the string lengths
    6:         charset = ['', 'a', 'b']
    6:         digits = 7
    6:         base = len(charset)
    6:         teststrings = set()
13128:         for i in xrange(base ** digits):
13122:             entry = []
104976:             for j in xrange(digits):
91854:                 i, m = divmod(i, base)
91854:                 entry.append(charset[m])
13122:             teststrings.add(''.join(entry))
    6:         teststrings = list(teststrings)
 1536:         for i in teststrings:
 1530:             i = self.fixtype(i)
 1530:             n = len(i)
391680:             for j in teststrings:
390150:                 r1 = i.count(j)
390150:                 if j:
388620:                     r2, rem = divmod(n - len(i.replace(j, '')), len(j))
                       else:
 1530:                     r2, rem = len(i)+1, 0
390150:                 if rem or r1 != r2:
>>>>>>                     self.assertEqual(rem, 0, '%s != 0 for %s' % (rem, i))
>>>>>>                     self.assertEqual(r1, r2, '%s != %s for %s' % (r1, r2, i))
       
    1:     def test_find(self):
    5:         self.checkequal(0, 'abcdefghiabc', 'find', 'abc')
    5:         self.checkequal(9, 'abcdefghiabc', 'find', 'abc', 1)
    5:         self.checkequal(-1, 'abcdefghiabc', 'find', 'def', 4)
       
    5:         self.checkequal(0, 'abc', 'find', '', 0)
    5:         self.checkequal(3, 'abc', 'find', '', 3)
    5:         self.checkequal(-1, 'abc', 'find', '', 4)
       
               # to check the ability to pass None as defaults
    5:         self.checkequal( 2, 'rrarrrrrrrrra', 'find', 'a')
    5:         self.checkequal(12, 'rrarrrrrrrrra', 'find', 'a', 4)
    5:         self.checkequal(-1, 'rrarrrrrrrrra', 'find', 'a', 4, 6)
    5:         self.checkequal(12, 'rrarrrrrrrrra', 'find', 'a', 4, None)
    5:         self.checkequal( 2, 'rrarrrrrrrrra', 'find', 'a', None, 6)
       
    5:         self.checkraises(TypeError, 'hello', 'find')
    5:         self.checkraises(TypeError, 'hello', 'find', 42)
       
    5:         self.checkequal(0, '', 'find', '')
    5:         self.checkequal(-1, '', 'find', '', 1, 1)
    5:         self.checkequal(-1, '', 'find', '', sys.maxint, 0)
       
    5:         self.checkequal(-1, '', 'find', 'xx')
    5:         self.checkequal(-1, '', 'find', 'xx', 1, 1)
    5:         self.checkequal(-1, '', 'find', 'xx', sys.maxint, 0)
       
               # issue 7458
    5:         self.checkequal(-1, 'ab', 'find', 'xxx', sys.maxsize + 1, 0)
       
               # For a variety of combinations,
               #    verify that str.find() matches __contains__
               #    and that the found substring is really at that location
    5:         charset = ['', 'a', 'b', 'c']
    5:         digits = 5
    5:         base = len(charset)
    5:         teststrings = set()
 5125:         for i in xrange(base ** digits):
 5120:             entry = []
30720:             for j in xrange(digits):
25600:                 i, m = divmod(i, base)
25600:                 entry.append(charset[m])
 5120:             teststrings.add(''.join(entry))
    5:         teststrings = list(teststrings)
 1825:         for i in teststrings:
 1820:             i = self.fixtype(i)
664300:             for j in teststrings:
662480:                 loc = i.find(j)
662480:                 r1 = (loc != -1)
662480:                 r2 = j in i
662480:                 self.assertEqual(r1, r2)
662480:                 if loc != -1:
20375:                     self.assertEqual(i[loc:loc+len(j)], j)
       
    1:     def test_rfind(self):
    6:         self.checkequal(9,  'abcdefghiabc', 'rfind', 'abc')
    6:         self.checkequal(12, 'abcdefghiabc', 'rfind', '')
    6:         self.checkequal(0, 'abcdefghiabc', 'rfind', 'abcd')
    6:         self.checkequal(-1, 'abcdefghiabc', 'rfind', 'abcz')
       
    6:         self.checkequal(3, 'abc', 'rfind', '', 0)
    6:         self.checkequal(3, 'abc', 'rfind', '', 3)
    6:         self.checkequal(-1, 'abc', 'rfind', '', 4)
       
               # to check the ability to pass None as defaults
    6:         self.checkequal(12, 'rrarrrrrrrrra', 'rfind', 'a')
    6:         self.checkequal(12, 'rrarrrrrrrrra', 'rfind', 'a', 4)
    6:         self.checkequal(-1, 'rrarrrrrrrrra', 'rfind', 'a', 4, 6)
    6:         self.checkequal(12, 'rrarrrrrrrrra', 'rfind', 'a', 4, None)
    6:         self.checkequal( 2, 'rrarrrrrrrrra', 'rfind', 'a', None, 6)
       
    6:         self.checkraises(TypeError, 'hello', 'rfind')
    6:         self.checkraises(TypeError, 'hello', 'rfind', 42)
       
               # For a variety of combinations,
               #    verify that str.rfind() matches __contains__
               #    and that the found substring is really at that location
    6:         charset = ['', 'a', 'b', 'c']
    6:         digits = 5
    6:         base = len(charset)
    6:         teststrings = set()
 6150:         for i in xrange(base ** digits):
 6144:             entry = []
36864:             for j in xrange(digits):
30720:                 i, m = divmod(i, base)
30720:                 entry.append(charset[m])
 6144:             teststrings.add(''.join(entry))
    6:         teststrings = list(teststrings)
 2190:         for i in teststrings:
 2184:             i = self.fixtype(i)
797160:             for j in teststrings:
794976:                 loc = i.rfind(j)
794976:                 r1 = (loc != -1)
794976:                 r2 = j in i
794976:                 self.assertEqual(r1, r2)
794976:                 if loc != -1:
24450:                     self.assertEqual(i[loc:loc+len(j)], self.fixtype(j))
       
               # issue 7458
    6:         self.checkequal(-1, 'ab', 'rfind', 'xxx', sys.maxsize + 1, 0)
       
    1:     def test_index(self):
    6:         self.checkequal(0, 'abcdefghiabc', 'index', '')
    6:         self.checkequal(3, 'abcdefghiabc', 'index', 'def')
    6:         self.checkequal(0, 'abcdefghiabc', 'index', 'abc')
    6:         self.checkequal(9, 'abcdefghiabc', 'index', 'abc', 1)
       
    6:         self.checkraises(ValueError, 'abcdefghiabc', 'index', 'hib')
    6:         self.checkraises(ValueError, 'abcdefghiab', 'index', 'abc', 1)
    6:         self.checkraises(ValueError, 'abcdefghi', 'index', 'ghi', 8)
    6:         self.checkraises(ValueError, 'abcdefghi', 'index', 'ghi', -1)
       
               # to check the ability to pass None as defaults
    6:         self.checkequal( 2, 'rrarrrrrrrrra', 'index', 'a')
    6:         self.checkequal(12, 'rrarrrrrrrrra', 'index', 'a', 4)
    6:         self.checkraises(ValueError, 'rrarrrrrrrrra', 'index', 'a', 4, 6)
    6:         self.checkequal(12, 'rrarrrrrrrrra', 'index', 'a', 4, None)
    6:         self.checkequal( 2, 'rrarrrrrrrrra', 'index', 'a', None, 6)
       
    6:         self.checkraises(TypeError, 'hello', 'index')
    6:         self.checkraises(TypeError, 'hello', 'index', 42)
       
    1:     def test_rindex(self):
    6:         self.checkequal(12, 'abcdefghiabc', 'rindex', '')
    6:         self.checkequal(3,  'abcdefghiabc', 'rindex', 'def')
    6:         self.checkequal(9,  'abcdefghiabc', 'rindex', 'abc')
    6:         self.checkequal(0,  'abcdefghiabc', 'rindex', 'abc', 0, -1)
       
    6:         self.checkraises(ValueError, 'abcdefghiabc', 'rindex', 'hib')
    6:         self.checkraises(ValueError, 'defghiabc', 'rindex', 'def', 1)
    6:         self.checkraises(ValueError, 'defghiabc', 'rindex', 'abc', 0, -1)
    6:         self.checkraises(ValueError, 'abcdefghi', 'rindex', 'ghi', 0, 8)
    6:         self.checkraises(ValueError, 'abcdefghi', 'rindex', 'ghi', 0, -1)
       
               # to check the ability to pass None as defaults
    6:         self.checkequal(12, 'rrarrrrrrrrra', 'rindex', 'a')
    6:         self.checkequal(12, 'rrarrrrrrrrra', 'rindex', 'a', 4)
    6:         self.checkraises(ValueError, 'rrarrrrrrrrra', 'rindex', 'a', 4, 6)
    6:         self.checkequal(12, 'rrarrrrrrrrra', 'rindex', 'a', 4, None)
    6:         self.checkequal( 2, 'rrarrrrrrrrra', 'rindex', 'a', None, 6)
       
    6:         self.checkraises(TypeError, 'hello', 'rindex')
    6:         self.checkraises(TypeError, 'hello', 'rindex', 42)
       
    1:     def test_lower(self):
    4:         self.checkequal('hello', 'HeLLo', 'lower')
    4:         self.checkequal('hello', 'hello', 'lower')
    4:         self.checkraises(TypeError, 'hello', 'lower', 42)
       
    1:     def test_upper(self):
    4:         self.checkequal('HELLO', 'HeLLo', 'upper')
    4:         self.checkequal('HELLO', 'HELLO', 'upper')
    4:         self.checkraises(TypeError, 'hello', 'upper', 42)
       
    1:     def test_expandtabs(self):
    5:         self.checkequal('abc\rab      def\ng       hi', 'abc\rab\tdef\ng\thi', 'expandtabs')
    5:         self.checkequal('abc\rab      def\ng       hi', 'abc\rab\tdef\ng\thi', 'expandtabs', 8)
    5:         self.checkequal('abc\rab  def\ng   hi', 'abc\rab\tdef\ng\thi', 'expandtabs', 4)
    5:         self.checkequal('abc\r\nab  def\ng   hi', 'abc\r\nab\tdef\ng\thi', 'expandtabs', 4)
    5:         self.checkequal('abc\rab      def\ng       hi', 'abc\rab\tdef\ng\thi', 'expandtabs')
    5:         self.checkequal('abc\rab      def\ng       hi', 'abc\rab\tdef\ng\thi', 'expandtabs', 8)
    5:         self.checkequal('abc\r\nab\r\ndef\ng\r\nhi', 'abc\r\nab\r\ndef\ng\r\nhi', 'expandtabs', 4)
    5:         self.checkequal('  a\n b', ' \ta\n\tb', 'expandtabs', 1)
       
    5:         self.checkraises(TypeError, 'hello', 'expandtabs', 42, 42)
               # This test is only valid when sizeof(int) == sizeof(void*) == 4.
    5:         if sys.maxint < (1 << 32) and struct.calcsize('P') == 4:
>>>>>>             self.checkraises(OverflowError,
>>>>>>                              '\ta\n\tb', 'expandtabs', sys.maxint)
       
    1:     def test_split(self):
    6:         self.checkequal(['this', 'is', 'the', 'split', 'function'],
    6:             'this is the split function', 'split')
       
               # by whitespace
    6:         self.checkequal(['a', 'b', 'c', 'd'], 'a b c d ', 'split')
    6:         self.checkequal(['a', 'b c d'], 'a b c d', 'split', None, 1)
    6:         self.checkequal(['a', 'b', 'c d'], 'a b c d', 'split', None, 2)
    6:         self.checkequal(['a', 'b', 'c', 'd'], 'a b c d', 'split', None, 3)
    6:         self.checkequal(['a', 'b', 'c', 'd'], 'a b c d', 'split', None, 4)
    6:         self.checkequal(['a', 'b', 'c', 'd'], 'a b c d', 'split', None,
    6:                         sys.maxint-1)
    6:         self.checkequal(['a b c d'], 'a b c d', 'split', None, 0)
    6:         self.checkequal(['a b c d'], '  a b c d', 'split', None, 0)
    6:         self.checkequal(['a', 'b', 'c  d'], 'a  b  c  d', 'split', None, 2)
       
    6:         self.checkequal([], '         ', 'split')
    6:         self.checkequal(['a'], '  a    ', 'split')
    6:         self.checkequal(['a', 'b'], '  a    b   ', 'split')
    6:         self.checkequal(['a', 'b   '], '  a    b   ', 'split', None, 1)
    6:         self.checkequal(['a    b   c   '], '  a    b   c   ', 'split', None, 0)
    6:         self.checkequal(['a', 'b   c   '], '  a    b   c   ', 'split', None, 1)
    6:         self.checkequal(['a', 'b', 'c   '], '  a    b   c   ', 'split', None, 2)
    6:         self.checkequal(['a', 'b', 'c'], '  a    b   c   ', 'split', None, 3)
    6:         self.checkequal(['a', 'b'], '\n\ta \t\r b \v ', 'split')
    6:         aaa = ' a '*20
    6:         self.checkequal(['a']*20, aaa, 'split')
    6:         self.checkequal(['a'] + [aaa[4:]], aaa, 'split', None, 1)
    6:         self.checkequal(['a']*19 + ['a '], aaa, 'split', None, 19)
       
    6:         for b in ('arf\tbarf', 'arf\nbarf', 'arf\rbarf',
   36:                   'arf\fbarf', 'arf\vbarf'):
   30:             self.checkequal(['arf', 'barf'], b, 'split')
   30:             self.checkequal(['arf', 'barf'], b, 'split', None)
   30:             self.checkequal(['arf', 'barf'], b, 'split', None, 2)
       
               # by a char
    6:         self.checkequal(['a', 'b', 'c', 'd'], 'a|b|c|d', 'split', '|')
    6:         self.checkequal(['a|b|c|d'], 'a|b|c|d', 'split', '|', 0)
    6:         self.checkequal(['a', 'b|c|d'], 'a|b|c|d', 'split', '|', 1)
    6:         self.checkequal(['a', 'b', 'c|d'], 'a|b|c|d', 'split', '|', 2)
    6:         self.checkequal(['a', 'b', 'c', 'd'], 'a|b|c|d', 'split', '|', 3)
    6:         self.checkequal(['a', 'b', 'c', 'd'], 'a|b|c|d', 'split', '|', 4)
    6:         self.checkequal(['a', 'b', 'c', 'd'], 'a|b|c|d', 'split', '|',
    6:                         sys.maxint-2)
    6:         self.checkequal(['a|b|c|d'], 'a|b|c|d', 'split', '|', 0)
    6:         self.checkequal(['a', '', 'b||c||d'], 'a||b||c||d', 'split', '|', 2)
    6:         self.checkequal(['abcd'], 'abcd', 'split', '|')
    6:         self.checkequal([''], '', 'split', '|')
    6:         self.checkequal(['endcase ', ''], 'endcase |', 'split', '|')
    6:         self.checkequal(['', ' startcase'], '| startcase', 'split', '|')
    6:         self.checkequal(['', 'bothcase', ''], '|bothcase|', 'split', '|')
    6:         self.checkequal(['a', '', 'b\x00c\x00d'], 'a\x00\x00b\x00c\x00d', 'split', '\x00', 2)
       
    6:         self.checkequal(['a']*20, ('a|'*20)[:-1], 'split', '|')
    6:         self.checkequal(['a']*15 +['a|a|a|a|a'],
    6:                                    ('a|'*20)[:-1], 'split', '|', 15)
       
               # by string
    6:         self.checkequal(['a', 'b', 'c', 'd'], 'a//b//c//d', 'split', '//')
    6:         self.checkequal(['a', 'b//c//d'], 'a//b//c//d', 'split', '//', 1)
    6:         self.checkequal(['a', 'b', 'c//d'], 'a//b//c//d', 'split', '//', 2)
    6:         self.checkequal(['a', 'b', 'c', 'd'], 'a//b//c//d', 'split', '//', 3)
    6:         self.checkequal(['a', 'b', 'c', 'd'], 'a//b//c//d', 'split', '//', 4)
    6:         self.checkequal(['a', 'b', 'c', 'd'], 'a//b//c//d', 'split', '//',
    6:                         sys.maxint-10)
    6:         self.checkequal(['a//b//c//d'], 'a//b//c//d', 'split', '//', 0)
    6:         self.checkequal(['a', '', 'b////c////d'], 'a////b////c////d', 'split', '//', 2)
    6:         self.checkequal(['endcase ', ''], 'endcase test', 'split', 'test')
    6:         self.checkequal(['', ' begincase'], 'test begincase', 'split', 'test')
    6:         self.checkequal(['', ' bothcase ', ''], 'test bothcase test',
    6:                         'split', 'test')
    6:         self.checkequal(['a', 'bc'], 'abbbc', 'split', 'bb')
    6:         self.checkequal(['', ''], 'aaa', 'split', 'aaa')
    6:         self.checkequal(['aaa'], 'aaa', 'split', 'aaa', 0)
    6:         self.checkequal(['ab', 'ab'], 'abbaab', 'split', 'ba')
    6:         self.checkequal(['aaaa'], 'aaaa', 'split', 'aab')
    6:         self.checkequal([''], '', 'split', 'aaa')
    6:         self.checkequal(['aa'], 'aa', 'split', 'aaa')
    6:         self.checkequal(['A', 'bobb'], 'Abbobbbobb', 'split', 'bbobb')
    6:         self.checkequal(['A', 'B', ''], 'AbbobbBbbobb', 'split', 'bbobb')
       
    6:         self.checkequal(['a']*20, ('aBLAH'*20)[:-4], 'split', 'BLAH')
    6:         self.checkequal(['a']*20, ('aBLAH'*20)[:-4], 'split', 'BLAH', 19)
    6:         self.checkequal(['a']*18 + ['aBLAHa'], ('aBLAH'*20)[:-4],
    6:                         'split', 'BLAH', 18)
       
               # mixed use of str and unicode
    6:         if self.type2test is not bytearray:
    5:             result = [u'a', u'b', u'c d']
    5:             self.checkequal(result, 'a b c d', 'split', u' ', 2)
       
               # argument type
    6:         self.checkraises(TypeError, 'hello', 'split', 42, 42, 42)
       
               # null case
    6:         self.checkraises(ValueError, 'hello', 'split', '')
    6:         self.checkraises(ValueError, 'hello', 'split', '', 0)
       
    1:     def test_rsplit(self):
    6:         self.checkequal(['this', 'is', 'the', 'rsplit', 'function'],
    6:                          'this is the rsplit function', 'rsplit')
       
               # by whitespace
    6:         self.checkequal(['a', 'b', 'c', 'd'], 'a b c d ', 'rsplit')
    6:         self.checkequal(['a b c', 'd'], 'a b c d', 'rsplit', None, 1)
    6:         self.checkequal(['a b', 'c', 'd'], 'a b c d', 'rsplit', None, 2)
    6:         self.checkequal(['a', 'b', 'c', 'd'], 'a b c d', 'rsplit', None, 3)
    6:         self.checkequal(['a', 'b', 'c', 'd'], 'a b c d', 'rsplit', None, 4)
    6:         self.checkequal(['a', 'b', 'c', 'd'], 'a b c d', 'rsplit', None,
    6:                         sys.maxint-20)
    6:         self.checkequal(['a b c d'], 'a b c d', 'rsplit', None, 0)
    6:         self.checkequal(['a b c d'], 'a b c d  ', 'rsplit', None, 0)
    6:         self.checkequal(['a  b', 'c', 'd'], 'a  b  c  d', 'rsplit', None, 2)
       
    6:         self.checkequal([], '         ', 'rsplit')
    6:         self.checkequal(['a'], '  a    ', 'rsplit')
    6:         self.checkequal(['a', 'b'], '  a    b   ', 'rsplit')
    6:         self.checkequal(['  a', 'b'], '  a    b   ', 'rsplit', None, 1)
    6:         self.checkequal(['  a    b   c'], '  a    b   c   ', 'rsplit',
    6:                         None, 0)
    6:         self.checkequal(['  a    b','c'], '  a    b   c   ', 'rsplit',
    6:                         None, 1)
    6:         self.checkequal(['  a', 'b', 'c'], '  a    b   c   ', 'rsplit',
    6:                         None, 2)
    6:         self.checkequal(['a', 'b', 'c'], '  a    b   c   ', 'rsplit',
    6:                         None, 3)
    6:         self.checkequal(['a', 'b'], '\n\ta \t\r b \v ', 'rsplit', None, 88)
    6:         aaa = ' a '*20
    6:         self.checkequal(['a']*20, aaa, 'rsplit')
    6:         self.checkequal([aaa[:-4]] + ['a'], aaa, 'rsplit', None, 1)
    6:         self.checkequal([' a  a'] + ['a']*18, aaa, 'rsplit', None, 18)
       
    6:         for b in ('arf\tbarf', 'arf\nbarf', 'arf\rbarf',
   36:                   'arf\fbarf', 'arf\vbarf'):
   30:             self.checkequal(['arf', 'barf'], b, 'rsplit')
   30:             self.checkequal(['arf', 'barf'], b, 'rsplit', None)
   30:             self.checkequal(['arf', 'barf'], b, 'rsplit', None, 2)
       
               # by a char
    6:         self.checkequal(['a', 'b', 'c', 'd'], 'a|b|c|d', 'rsplit', '|')
    6:         self.checkequal(['a|b|c', 'd'], 'a|b|c|d', 'rsplit', '|', 1)
    6:         self.checkequal(['a|b', 'c', 'd'], 'a|b|c|d', 'rsplit', '|', 2)
    6:         self.checkequal(['a', 'b', 'c', 'd'], 'a|b|c|d', 'rsplit', '|', 3)
    6:         self.checkequal(['a', 'b', 'c', 'd'], 'a|b|c|d', 'rsplit', '|', 4)
    6:         self.checkequal(['a', 'b', 'c', 'd'], 'a|b|c|d', 'rsplit', '|',
    6:                         sys.maxint-100)
    6:         self.checkequal(['a|b|c|d'], 'a|b|c|d', 'rsplit', '|', 0)
    6:         self.checkequal(['a||b||c', '', 'd'], 'a||b||c||d', 'rsplit', '|', 2)
    6:         self.checkequal(['abcd'], 'abcd', 'rsplit', '|')
    6:         self.checkequal([''], '', 'rsplit', '|')
    6:         self.checkequal(['', ' begincase'], '| begincase', 'rsplit', '|')
    6:         self.checkequal(['endcase ', ''], 'endcase |', 'rsplit', '|')
    6:         self.checkequal(['', 'bothcase', ''], '|bothcase|', 'rsplit', '|')
       
    6:         self.checkequal(['a\x00\x00b', 'c', 'd'], 'a\x00\x00b\x00c\x00d', 'rsplit', '\x00', 2)
       
    6:         self.checkequal(['a']*20, ('a|'*20)[:-1], 'rsplit', '|')
    6:         self.checkequal(['a|a|a|a|a']+['a']*15,
    6:                         ('a|'*20)[:-1], 'rsplit', '|', 15)
       
               # by string
    6:         self.checkequal(['a', 'b', 'c', 'd'], 'a//b//c//d', 'rsplit', '//')
    6:         self.checkequal(['a//b//c', 'd'], 'a//b//c//d', 'rsplit', '//', 1)
    6:         self.checkequal(['a//b', 'c', 'd'], 'a//b//c//d', 'rsplit', '//', 2)
    6:         self.checkequal(['a', 'b', 'c', 'd'], 'a//b//c//d', 'rsplit', '//', 3)
    6:         self.checkequal(['a', 'b', 'c', 'd'], 'a//b//c//d', 'rsplit', '//', 4)
    6:         self.checkequal(['a', 'b', 'c', 'd'], 'a//b//c//d', 'rsplit', '//',
    6:                         sys.maxint-5)
    6:         self.checkequal(['a//b//c//d'], 'a//b//c//d', 'rsplit', '//', 0)
    6:         self.checkequal(['a////b////c', '', 'd'], 'a////b////c////d', 'rsplit', '//', 2)
    6:         self.checkequal(['', ' begincase'], 'test begincase', 'rsplit', 'test')
    6:         self.checkequal(['endcase ', ''], 'endcase test', 'rsplit', 'test')
    6:         self.checkequal(['', ' bothcase ', ''], 'test bothcase test',
    6:                         'rsplit', 'test')
    6:         self.checkequal(['ab', 'c'], 'abbbc', 'rsplit', 'bb')
    6:         self.checkequal(['', ''], 'aaa', 'rsplit', 'aaa')
    6:         self.checkequal(['aaa'], 'aaa', 'rsplit', 'aaa', 0)
    6:         self.checkequal(['ab', 'ab'], 'abbaab', 'rsplit', 'ba')
    6:         self.checkequal(['aaaa'], 'aaaa', 'rsplit', 'aab')
    6:         self.checkequal([''], '', 'rsplit', 'aaa')
    6:         self.checkequal(['aa'], 'aa', 'rsplit', 'aaa')
    6:         self.checkequal(['bbob', 'A'], 'bbobbbobbA', 'rsplit', 'bbobb')
    6:         self.checkequal(['', 'B', 'A'], 'bbobbBbbobbA', 'rsplit', 'bbobb')
       
    6:         self.checkequal(['a']*20, ('aBLAH'*20)[:-4], 'rsplit', 'BLAH')
    6:         self.checkequal(['a']*20, ('aBLAH'*20)[:-4], 'rsplit', 'BLAH', 19)
    6:         self.checkequal(['aBLAHa'] + ['a']*18, ('aBLAH'*20)[:-4],
    6:                         'rsplit', 'BLAH', 18)
       
               # mixed use of str and unicode
    6:         if self.type2test is not bytearray:
    5:             result = [u'a b', u'c', u'd']
    5:             self.checkequal(result, 'a b c d', 'rsplit', u' ', 2)
       
               # argument type
    6:         self.checkraises(TypeError, 'hello', 'rsplit', 42, 42, 42)
       
               # null case
    6:         self.checkraises(ValueError, 'hello', 'rsplit', '')
    6:         self.checkraises(ValueError, 'hello', 'rsplit', '', 0)
       
    1:     def test_strip_whitespace(self):
    6:         self.checkequal('hello', '   hello   ', 'strip')
    6:         self.checkequal('hello   ', '   hello   ', 'lstrip')
    6:         self.checkequal('   hello', '   hello   ', 'rstrip')
    6:         self.checkequal('hello', 'hello', 'strip')
       
    6:         b = ' \t\n\r\f\vabc \t\n\r\f\v'
    6:         self.checkequal('abc', b, 'strip')
    6:         self.checkequal('abc \t\n\r\f\v', b, 'lstrip')
    6:         self.checkequal(' \t\n\r\f\vabc', b, 'rstrip')
       
               # strip/lstrip/rstrip with None arg
    6:         self.checkequal('hello', '   hello   ', 'strip', None)
    6:         self.checkequal('hello   ', '   hello   ', 'lstrip', None)
    6:         self.checkequal('   hello', '   hello   ', 'rstrip', None)
    6:         self.checkequal('hello', 'hello', 'strip', None)
       
    1:     def test_strip(self):
               # strip/lstrip/rstrip with str arg
    6:         self.checkequal('hello', 'xyzzyhelloxyzzy', 'strip', 'xyz')
    6:         self.checkequal('helloxyzzy', 'xyzzyhelloxyzzy', 'lstrip', 'xyz')
    6:         self.checkequal('xyzzyhello', 'xyzzyhelloxyzzy', 'rstrip', 'xyz')
    6:         self.checkequal('hello', 'hello', 'strip', 'xyz')
    6:         self.checkequal('', 'mississippi', 'strip', 'mississippi')
       
               # only trims the start and end, does not strip internal characters
    6:         self.checkequal('mississipp', 'mississippi', 'strip', 'i')
       
               # strip/lstrip/rstrip with unicode arg
    6:         if self.type2test is not bytearray and test_support.have_unicode:
    5:             self.checkequal(unicode('hello', 'ascii'), 'xyzzyhelloxyzzy',
    5:                  'strip', unicode('xyz', 'ascii'))
    5:             self.checkequal(unicode('helloxyzzy', 'ascii'), 'xyzzyhelloxyzzy',
    5:                  'lstrip', unicode('xyz', 'ascii'))
    5:             self.checkequal(unicode('xyzzyhello', 'ascii'), 'xyzzyhelloxyzzy',
    5:                  'rstrip', unicode('xyz', 'ascii'))
                   # XXX
                   #self.checkequal(unicode('hello', 'ascii'), 'hello',
                   #     'strip', unicode('xyz', 'ascii'))
       
    6:         self.checkraises(TypeError, 'hello', 'strip', 42, 42)
    6:         self.checkraises(TypeError, 'hello', 'lstrip', 42, 42)
    6:         self.checkraises(TypeError, 'hello', 'rstrip', 42, 42)
       
    1:     def test_ljust(self):
    6:         self.checkequal('abc       ', 'abc', 'ljust', 10)
    6:         self.checkequal('abc   ', 'abc', 'ljust', 6)
    6:         self.checkequal('abc', 'abc', 'ljust', 3)
    6:         self.checkequal('abc', 'abc', 'ljust', 2)
    6:         if self.type2test is bytearray:
                   # Special case because bytearray argument is not accepted
    1:             self.assertEqual(b'abc*******', bytearray(b'abc').ljust(10, '*'))
               else:
    5:             self.checkequal('abc*******', 'abc', 'ljust', 10, '*')
    6:         self.checkraises(TypeError, 'abc', 'ljust')
       
    1:     def test_rjust(self):
    6:         self.checkequal('       abc', 'abc', 'rjust', 10)
    6:         self.checkequal('   abc', 'abc', 'rjust', 6)
    6:         self.checkequal('abc', 'abc', 'rjust', 3)
    6:         self.checkequal('abc', 'abc', 'rjust', 2)
    6:         if self.type2test is bytearray:
                   # Special case because bytearray argument is not accepted
    1:             self.assertEqual(b'*******abc', bytearray(b'abc').rjust(10, '*'))
               else:
    5:             self.checkequal('*******abc', 'abc', 'rjust', 10, '*')
    6:         self.checkraises(TypeError, 'abc', 'rjust')
       
    1:     def test_center(self):
    6:         self.checkequal('   abc    ', 'abc', 'center', 10)
    6:         self.checkequal(' abc  ', 'abc', 'center', 6)
    6:         self.checkequal('abc', 'abc', 'center', 3)
    6:         self.checkequal('abc', 'abc', 'center', 2)
    6:         if self.type2test is bytearray:
                   # Special case because bytearray argument is not accepted
    1:             result = bytearray(b'abc').center(10, '*')
    1:             self.assertEqual(b'***abc****', result)
               else:
    5:             self.checkequal('***abc****', 'abc', 'center', 10, '*')
    6:         self.checkraises(TypeError, 'abc', 'center')
       
    1:     def test_swapcase(self):
    5:         self.checkequal('hEllO CoMPuTErS', 'HeLLo cOmpUteRs', 'swapcase')
       
    5:         self.checkraises(TypeError, 'hello', 'swapcase', 42)
       
    1:     def test_replace(self):
    6:         EQ = self.checkequal
       
               # Operations on the empty string
    6:         EQ("", "", "replace", "", "")
    6:         EQ("A", "", "replace", "", "A")
    6:         EQ("", "", "replace", "A", "")
    6:         EQ("", "", "replace", "A", "A")
    6:         EQ("", "", "replace", "", "", 100)
    6:         EQ("", "", "replace", "", "", sys.maxint)
       
               # interleave (from=="", 'to' gets inserted everywhere)
    6:         EQ("A", "A", "replace", "", "")
    6:         EQ("*A*", "A", "replace", "", "*")
    6:         EQ("*1A*1", "A", "replace", "", "*1")
    6:         EQ("*-#A*-#", "A", "replace", "", "*-#")
    6:         EQ("*-A*-A*-", "AA", "replace", "", "*-")
    6:         EQ("*-A*-A*-", "AA", "replace", "", "*-", -1)
    6:         EQ("*-A*-A*-", "AA", "replace", "", "*-", sys.maxint)
    6:         EQ("*-A*-A*-", "AA", "replace", "", "*-", 4)
    6:         EQ("*-A*-A*-", "AA", "replace", "", "*-", 3)
    6:         EQ("*-A*-A", "AA", "replace", "", "*-", 2)
    6:         EQ("*-AA", "AA", "replace", "", "*-", 1)
    6:         EQ("AA", "AA", "replace", "", "*-", 0)
       
               # single character deletion (from=="A", to=="")
    6:         EQ("", "A", "replace", "A", "")
    6:         EQ("", "AAA", "replace", "A", "")
    6:         EQ("", "AAA", "replace", "A", "", -1)
    6:         EQ("", "AAA", "replace", "A", "", sys.maxint)
    6:         EQ("", "AAA", "replace", "A", "", 4)
    6:         EQ("", "AAA", "replace", "A", "", 3)
    6:         EQ("A", "AAA", "replace", "A", "", 2)
    6:         EQ("AA", "AAA", "replace", "A", "", 1)
    6:         EQ("AAA", "AAA", "replace", "A", "", 0)
    6:         EQ("", "AAAAAAAAAA", "replace", "A", "")
    6:         EQ("BCD", "ABACADA", "replace", "A", "")
    6:         EQ("BCD", "ABACADA", "replace", "A", "", -1)
    6:         EQ("BCD", "ABACADA", "replace", "A", "", sys.maxint)
    6:         EQ("BCD", "ABACADA", "replace", "A", "", 5)
    6:         EQ("BCD", "ABACADA", "replace", "A", "", 4)
    6:         EQ("BCDA", "ABACADA", "replace", "A", "", 3)
    6:         EQ("BCADA", "ABACADA", "replace", "A", "", 2)
    6:         EQ("BACADA", "ABACADA", "replace", "A", "", 1)
    6:         EQ("ABACADA", "ABACADA", "replace", "A", "", 0)
    6:         EQ("BCD", "ABCAD", "replace", "A", "")
    6:         EQ("BCD", "ABCADAA", "replace", "A", "")
    6:         EQ("BCD", "BCD", "replace", "A", "")
    6:         EQ("*************", "*************", "replace", "A", "")
    6:         EQ("^A^", "^"+"A"*1000+"^", "replace", "A", "", 999)
       
               # substring deletion (from=="the", to=="")
    6:         EQ("", "the", "replace", "the", "")
    6:         EQ("ater", "theater", "replace", "the", "")
    6:         EQ("", "thethe", "replace", "the", "")
    6:         EQ("", "thethethethe", "replace", "the", "")
    6:         EQ("aaaa", "theatheatheathea", "replace", "the", "")
    6:         EQ("that", "that", "replace", "the", "")
    6:         EQ("thaet", "thaet", "replace", "the", "")
    6:         EQ("here and re", "here and there", "replace", "the", "")
    6:         EQ("here and re and re", "here and there and there",
    6:            "replace", "the", "", sys.maxint)
    6:         EQ("here and re and re", "here and there and there",
    6:            "replace", "the", "", -1)
    6:         EQ("here and re and re", "here and there and there",
    6:            "replace", "the", "", 3)
    6:         EQ("here and re and re", "here and there and there",
    6:            "replace", "the", "", 2)
    6:         EQ("here and re and there", "here and there and there",
    6:            "replace", "the", "", 1)
    6:         EQ("here and there and there", "here and there and there",
    6:            "replace", "the", "", 0)
    6:         EQ("here and re and re", "here and there and there", "replace", "the", "")
       
    6:         EQ("abc", "abc", "replace", "the", "")
    6:         EQ("abcdefg", "abcdefg", "replace", "the", "")
       
               # substring deletion (from=="bob", to=="")
    6:         EQ("bob", "bbobob", "replace", "bob", "")
    6:         EQ("bobXbob", "bbobobXbbobob", "replace", "bob", "")
    6:         EQ("aaaaaaa", "aaaaaaabob", "replace", "bob", "")
    6:         EQ("aaaaaaa", "aaaaaaa", "replace", "bob", "")
       
               # single character replace in place (len(from)==len(to)==1)
    6:         EQ("Who goes there?", "Who goes there?", "replace", "o", "o")
    6:         EQ("WhO gOes there?", "Who goes there?", "replace", "o", "O")
    6:         EQ("WhO gOes there?", "Who goes there?", "replace", "o", "O", sys.maxint)
    6:         EQ("WhO gOes there?", "Who goes there?", "replace", "o", "O", -1)
    6:         EQ("WhO gOes there?", "Who goes there?", "replace", "o", "O", 3)
    6:         EQ("WhO gOes there?", "Who goes there?", "replace", "o", "O", 2)
    6:         EQ("WhO goes there?", "Who goes there?", "replace", "o", "O", 1)
    6:         EQ("Who goes there?", "Who goes there?", "replace", "o", "O", 0)
       
    6:         EQ("Who goes there?", "Who goes there?", "replace", "a", "q")
    6:         EQ("who goes there?", "Who goes there?", "replace", "W", "w")
    6:         EQ("wwho goes there?ww", "WWho goes there?WW", "replace", "W", "w")
    6:         EQ("Who goes there!", "Who goes there?", "replace", "?", "!")
    6:         EQ("Who goes there!!", "Who goes there??", "replace", "?", "!")
       
    6:         EQ("Who goes there?", "Who goes there?", "replace", ".", "!")
       
               # substring replace in place (len(from)==len(to) > 1)
    6:         EQ("Th** ** a t**sue", "This is a tissue", "replace", "is", "**")
    6:         EQ("Th** ** a t**sue", "This is a tissue", "replace", "is", "**", sys.maxint)
    6:         EQ("Th** ** a t**sue", "This is a tissue", "replace", "is", "**", -1)
    6:         EQ("Th** ** a t**sue", "This is a tissue", "replace", "is", "**", 4)
    6:         EQ("Th** ** a t**sue", "This is a tissue", "replace", "is", "**", 3)
    6:         EQ("Th** ** a tissue", "This is a tissue", "replace", "is", "**", 2)
    6:         EQ("Th** is a tissue", "This is a tissue", "replace", "is", "**", 1)
    6:         EQ("This is a tissue", "This is a tissue", "replace", "is", "**", 0)
    6:         EQ("cobob", "bobob", "replace", "bob", "cob")
    6:         EQ("cobobXcobocob", "bobobXbobobob", "replace", "bob", "cob")
    6:         EQ("bobob", "bobob", "replace", "bot", "bot")
       
               # replace single character (len(from)==1, len(to)>1)
    6:         EQ("ReyKKjaviKK", "Reykjavik", "replace", "k", "KK")
    6:         EQ("ReyKKjaviKK", "Reykjavik", "replace", "k", "KK", -1)
    6:         EQ("ReyKKjaviKK", "Reykjavik", "replace", "k", "KK", sys.maxint)
    6:         EQ("ReyKKjaviKK", "Reykjavik", "replace", "k", "KK", 2)
    6:         EQ("ReyKKjavik", "Reykjavik", "replace", "k", "KK", 1)
    6:         EQ("Reykjavik", "Reykjavik", "replace", "k", "KK", 0)
    6:         EQ("A----B----C----", "A.B.C.", "replace", ".", "----")
       
    6:         EQ("Reykjavik", "Reykjavik", "replace", "q", "KK")
       
               # replace substring (len(from)>1, len(to)!=len(from))
    6:         EQ("ham, ham, eggs and ham", "spam, spam, eggs and spam",
    6:            "replace", "spam", "ham")
    6:         EQ("ham, ham, eggs and ham", "spam, spam, eggs and spam",
    6:            "replace", "spam", "ham", sys.maxint)
    6:         EQ("ham, ham, eggs and ham", "spam, spam, eggs and spam",
    6:            "replace", "spam", "ham", -1)
    6:         EQ("ham, ham, eggs and ham", "spam, spam, eggs and spam",
    6:            "replace", "spam", "ham", 4)
    6:         EQ("ham, ham, eggs and ham", "spam, spam, eggs and spam",
    6:            "replace", "spam", "ham", 3)
    6:         EQ("ham, ham, eggs and spam", "spam, spam, eggs and spam",
    6:            "replace", "spam", "ham", 2)
    6:         EQ("ham, spam, eggs and spam", "spam, spam, eggs and spam",
    6:            "replace", "spam", "ham", 1)
    6:         EQ("spam, spam, eggs and spam", "spam, spam, eggs and spam",
    6:            "replace", "spam", "ham", 0)
       
    6:         EQ("bobob", "bobobob", "replace", "bobob", "bob")
    6:         EQ("bobobXbobob", "bobobobXbobobob", "replace", "bobob", "bob")
    6:         EQ("BOBOBOB", "BOBOBOB", "replace", "bob", "bobby")
       
    6:         with test_support.check_py3k_warnings():
    6:             ba = buffer('a')
    6:             bb = buffer('b')
    6:         EQ("bbc", "abc", "replace", ba, bb)
    6:         EQ("aac", "abc", "replace", bb, ba)
       
               #
    6:         self.checkequal('one@two!three!', 'one!two!three!', 'replace', '!', '@', 1)
    6:         self.checkequal('onetwothree', 'one!two!three!', 'replace', '!', '')
    6:         self.checkequal('one@two@three!', 'one!two!three!', 'replace', '!', '@', 2)
    6:         self.checkequal('one@two@three@', 'one!two!three!', 'replace', '!', '@', 3)
    6:         self.checkequal('one@two@three@', 'one!two!three!', 'replace', '!', '@', 4)
    6:         self.checkequal('one!two!three!', 'one!two!three!', 'replace', '!', '@', 0)
    6:         self.checkequal('one@two@three@', 'one!two!three!', 'replace', '!', '@')
    6:         self.checkequal('one!two!three!', 'one!two!three!', 'replace', 'x', '@')
    6:         self.checkequal('one!two!three!', 'one!two!three!', 'replace', 'x', '@', 2)
    6:         self.checkequal('-a-b-c-', 'abc', 'replace', '', '-')
    6:         self.checkequal('-a-b-c', 'abc', 'replace', '', '-', 3)
    6:         self.checkequal('abc', 'abc', 'replace', '', '-', 0)
    6:         self.checkequal('', '', 'replace', '', '')
    6:         self.checkequal('abc', 'abc', 'replace', 'ab', '--', 0)
    6:         self.checkequal('abc', 'abc', 'replace', 'xy', '--')
               # Next three for SF bug 422088: [OSF1 alpha] string.replace(); died with
               # MemoryError due to empty result (platform malloc issue when requesting
               # 0 bytes).
    6:         self.checkequal('', '123', 'replace', '123', '')
    6:         self.checkequal('', '123123', 'replace', '123', '')
    6:         self.checkequal('x', '123x123', 'replace', '123', '')
       
    6:         self.checkraises(TypeError, 'hello', 'replace')
    6:         self.checkraises(TypeError, 'hello', 'replace', 42)
    6:         self.checkraises(TypeError, 'hello', 'replace', 42, 'h')
    6:         self.checkraises(TypeError, 'hello', 'replace', 'h', 42)
       
    1:     @unittest.skipIf(sys.maxint > (1 << 32) or struct.calcsize('P') != 4,
    1:                      'only applies to 32-bit platforms')
           def test_replace_overflow(self):
               # Check for overflow checking on 32 bit machines
>>>>>>         A2_16 = "A" * (2**16)
>>>>>>         self.checkraises(OverflowError, A2_16, "replace", "", A2_16)
>>>>>>         self.checkraises(OverflowError, A2_16, "replace", "A", A2_16)
>>>>>>         self.checkraises(OverflowError, A2_16, "replace", "AA", A2_16+A2_16)
       
    1:     def test_zfill(self):
    6:         self.checkequal('123', '123', 'zfill', 2)
    6:         self.checkequal('123', '123', 'zfill', 3)
    6:         self.checkequal('0123', '123', 'zfill', 4)
    6:         self.checkequal('+123', '+123', 'zfill', 3)
    6:         self.checkequal('+123', '+123', 'zfill', 4)
    6:         self.checkequal('+0123', '+123', 'zfill', 5)
    6:         self.checkequal('-123', '-123', 'zfill', 3)
    6:         self.checkequal('-123', '-123', 'zfill', 4)
    6:         self.checkequal('-0123', '-123', 'zfill', 5)
    6:         self.checkequal('000', '', 'zfill', 3)
    6:         self.checkequal('34', '34', 'zfill', 1)
    6:         self.checkequal('0034', '34', 'zfill', 4)
       
    6:         self.checkraises(TypeError, '123', 'zfill')
       
       
    2: class NonStringModuleTest:
           # additional test cases for all string classes from bytearray to
           # UserString, but not valid for the "string" module
       
    1:     def test_islower(self):
    5:         self.checkequal(False, '', 'islower')
    5:         self.checkequal(True, 'a', 'islower')
    5:         self.checkequal(False, 'A', 'islower')
    5:         self.checkequal(False, '\n', 'islower')
    5:         self.checkequal(True, 'abc', 'islower')
    5:         self.checkequal(False, 'aBc', 'islower')
    5:         self.checkequal(True, 'abc\n', 'islower')
    5:         self.checkraises(TypeError, 'abc', 'islower', 42)
       
    1:     def test_isupper(self):
    5:         self.checkequal(False, '', 'isupper')
    5:         self.checkequal(False, 'a', 'isupper')
    5:         self.checkequal(True, 'A', 'isupper')
    5:         self.checkequal(False, '\n', 'isupper')
    5:         self.checkequal(True, 'ABC', 'isupper')
    5:         self.checkequal(False, 'AbC', 'isupper')
    5:         self.checkequal(True, 'ABC\n', 'isupper')
    5:         self.checkraises(TypeError, 'abc', 'isupper', 42)
       
    1:     def test_istitle(self):
    5:         self.checkequal(False, '', 'istitle')
    5:         self.checkequal(False, 'a', 'istitle')
    5:         self.checkequal(True, 'A', 'istitle')
    5:         self.checkequal(False, '\n', 'istitle')
    5:         self.checkequal(True, 'A Titlecased Line', 'istitle')
    5:         self.checkequal(True, 'A\nTitlecased Line', 'istitle')
    5:         self.checkequal(True, 'A Titlecased, Line', 'istitle')
    5:         self.checkequal(False, 'Not a capitalized String', 'istitle')
    5:         self.checkequal(False, 'Not\ta Titlecase String', 'istitle')
    5:         self.checkequal(False, 'Not--a Titlecase String', 'istitle')
    5:         self.checkequal(False, 'NOT', 'istitle')
    5:         self.checkraises(TypeError, 'abc', 'istitle', 42)
       
    1:     def test_isspace(self):
    5:         self.checkequal(False, '', 'isspace')
    5:         self.checkequal(False, 'a', 'isspace')
    5:         self.checkequal(True, ' ', 'isspace')
    5:         self.checkequal(True, '\t', 'isspace')
    5:         self.checkequal(True, '\r', 'isspace')
    5:         self.checkequal(True, '\n', 'isspace')
    5:         self.checkequal(True, ' \t\r\n', 'isspace')
    5:         self.checkequal(False, ' \t\r\na', 'isspace')
    5:         self.checkraises(TypeError, 'abc', 'isspace', 42)
       
    1:     def test_isalpha(self):
    5:         self.checkequal(False, '', 'isalpha')
    5:         self.checkequal(True, 'a', 'isalpha')
    5:         self.checkequal(True, 'A', 'isalpha')
    5:         self.checkequal(False, '\n', 'isalpha')
    5:         self.checkequal(True, 'abc', 'isalpha')
    5:         self.checkequal(False, 'aBc123', 'isalpha')
    5:         self.checkequal(False, 'abc\n', 'isalpha')
    5:         self.checkraises(TypeError, 'abc', 'isalpha', 42)
       
    1:     def test_isalnum(self):
    5:         self.checkequal(False, '', 'isalnum')
    5:         self.checkequal(True, 'a', 'isalnum')
    5:         self.checkequal(True, 'A', 'isalnum')
    5:         self.checkequal(False, '\n', 'isalnum')
    5:         self.checkequal(True, '123abc456', 'isalnum')
    5:         self.checkequal(True, 'a1b3c', 'isalnum')
    5:         self.checkequal(False, 'aBc000 ', 'isalnum')
    5:         self.checkequal(False, 'abc\n', 'isalnum')
    5:         self.checkraises(TypeError, 'abc', 'isalnum', 42)
       
    1:     def test_isdigit(self):
    5:         self.checkequal(False, '', 'isdigit')
    5:         self.checkequal(False, 'a', 'isdigit')
    5:         self.checkequal(True, '0', 'isdigit')
    5:         self.checkequal(True, '0123456789', 'isdigit')
    5:         self.checkequal(False, '0123456789a', 'isdigit')
       
    5:         self.checkraises(TypeError, 'abc', 'isdigit', 42)
       
    1:     def test_title(self):
    4:         self.checkequal(' Hello ', ' hello ', 'title')
    4:         self.checkequal('Hello ', 'hello ', 'title')
    4:         self.checkequal('Hello ', 'Hello ', 'title')
    4:         self.checkequal('Format This As Title String', "fOrMaT thIs aS titLe String", 'title')
    4:         self.checkequal('Format,This-As*Title;String', "fOrMaT,thIs-aS*titLe;String", 'title', )
    4:         self.checkequal('Getint', "getInt", 'title')
    4:         self.checkraises(TypeError, 'hello', 'title', 42)
       
    1:     def test_splitlines(self):
    5:         self.checkequal(['abc', 'def', '', 'ghi'], "abc\ndef\n\rghi", 'splitlines')
    5:         self.checkequal(['abc', 'def', '', 'ghi'], "abc\ndef\n\r\nghi", 'splitlines')
    5:         self.checkequal(['abc', 'def', 'ghi'], "abc\ndef\r\nghi", 'splitlines')
    5:         self.checkequal(['abc', 'def', 'ghi'], "abc\ndef\r\nghi\n", 'splitlines')
    5:         self.checkequal(['abc', 'def', 'ghi', ''], "abc\ndef\r\nghi\n\r", 'splitlines')
    5:         self.checkequal(['', 'abc', 'def', 'ghi', ''], "\nabc\ndef\r\nghi\n\r", 'splitlines')
    5:         self.checkequal(['\n', 'abc\n', 'def\r\n', 'ghi\n', '\r'], "\nabc\ndef\r\nghi\n\r", 'splitlines', 1)
       
    5:         self.checkraises(TypeError, 'abc', 'splitlines', 42, 42)
       
       
    2: class MixinStrUnicodeUserStringTest(NonStringModuleTest):
           # additional tests that only work for
           # stringlike objects, i.e. str, unicode, UserString
           # (but not the string module)
       
    1:     def test_startswith(self):
    4:         self.checkequal(True, 'hello', 'startswith', 'he')
    4:         self.checkequal(True, 'hello', 'startswith', 'hello')
    4:         self.checkequal(False, 'hello', 'startswith', 'hello world')
    4:         self.checkequal(True, 'hello', 'startswith', '')
    4:         self.checkequal(False, 'hello', 'startswith', 'ello')
    4:         self.checkequal(True, 'hello', 'startswith', 'ello', 1)
    4:         self.checkequal(True, 'hello', 'startswith', 'o', 4)
    4:         self.checkequal(False, 'hello', 'startswith', 'o', 5)
    4:         self.checkequal(True, 'hello', 'startswith', '', 5)
    4:         self.checkequal(False, 'hello', 'startswith', 'lo', 6)
    4:         self.checkequal(True, 'helloworld', 'startswith', 'lowo', 3)
    4:         self.checkequal(True, 'helloworld', 'startswith', 'lowo', 3, 7)
    4:         self.checkequal(False, 'helloworld', 'startswith', 'lowo', 3, 6)
       
               # test negative indices
    4:         self.checkequal(True, 'hello', 'startswith', 'he', 0, -1)
    4:         self.checkequal(True, 'hello', 'startswith', 'he', -53, -1)
    4:         self.checkequal(False, 'hello', 'startswith', 'hello', 0, -1)
    4:         self.checkequal(False, 'hello', 'startswith', 'hello world', -1, -10)
    4:         self.checkequal(False, 'hello', 'startswith', 'ello', -5)
    4:         self.checkequal(True, 'hello', 'startswith', 'ello', -4)
    4:         self.checkequal(False, 'hello', 'startswith', 'o', -2)
    4:         self.checkequal(True, 'hello', 'startswith', 'o', -1)
    4:         self.checkequal(True, 'hello', 'startswith', '', -3, -3)
    4:         self.checkequal(False, 'hello', 'startswith', 'lo', -9)
       
    4:         self.checkraises(TypeError, 'hello', 'startswith')
    4:         self.checkraises(TypeError, 'hello', 'startswith', 42)
       
               # test tuple arguments
    4:         self.checkequal(True, 'hello', 'startswith', ('he', 'ha'))
    4:         self.checkequal(False, 'hello', 'startswith', ('lo', 'llo'))
    4:         self.checkequal(True, 'hello', 'startswith', ('hellox', 'hello'))
    4:         self.checkequal(False, 'hello', 'startswith', ())
    4:         self.checkequal(True, 'helloworld', 'startswith', ('hellowo',
    4:                                                            'rld', 'lowo'), 3)
    4:         self.checkequal(False, 'helloworld', 'startswith', ('hellowo', 'ello',
    4:                                                             'rld'), 3)
    4:         self.checkequal(True, 'hello', 'startswith', ('lo', 'he'), 0, -1)
    4:         self.checkequal(False, 'hello', 'startswith', ('he', 'hel'), 0, 1)
    4:         self.checkequal(True, 'hello', 'startswith', ('he', 'hel'), 0, 2)
       
    4:         self.checkraises(TypeError, 'hello', 'startswith', (42,))
       
    1:     def test_endswith(self):
    4:         self.checkequal(True, 'hello', 'endswith', 'lo')
    4:         self.checkequal(False, 'hello', 'endswith', 'he')
    4:         self.checkequal(True, 'hello', 'endswith', '')
    4:         self.checkequal(False, 'hello', 'endswith', 'hello world')
    4:         self.checkequal(False, 'helloworld', 'endswith', 'worl')
    4:         self.checkequal(True, 'helloworld', 'endswith', 'worl', 3, 9)
    4:         self.checkequal(True, 'helloworld', 'endswith', 'world', 3, 12)
    4:         self.checkequal(True, 'helloworld', 'endswith', 'lowo', 1, 7)
    4:         self.checkequal(True, 'helloworld', 'endswith', 'lowo', 2, 7)
    4:         self.checkequal(True, 'helloworld', 'endswith', 'lowo', 3, 7)
    4:         self.checkequal(False, 'helloworld', 'endswith', 'lowo', 4, 7)
    4:         self.checkequal(False, 'helloworld', 'endswith', 'lowo', 3, 8)
    4:         self.checkequal(False, 'ab', 'endswith', 'ab', 0, 1)
    4:         self.checkequal(False, 'ab', 'endswith', 'ab', 0, 0)
       
               # test negative indices
    4:         self.checkequal(True, 'hello', 'endswith', 'lo', -2)
    4:         self.checkequal(False, 'hello', 'endswith', 'he', -2)
    4:         self.checkequal(True, 'hello', 'endswith', '', -3, -3)
    4:         self.checkequal(False, 'hello', 'endswith', 'hello world', -10, -2)
    4:         self.checkequal(False, 'helloworld', 'endswith', 'worl', -6)
    4:         self.checkequal(True, 'helloworld', 'endswith', 'worl', -5, -1)
    4:         self.checkequal(True, 'helloworld', 'endswith', 'worl', -5, 9)
    4:         self.checkequal(True, 'helloworld', 'endswith', 'world', -7, 12)
    4:         self.checkequal(True, 'helloworld', 'endswith', 'lowo', -99, -3)
    4:         self.checkequal(True, 'helloworld', 'endswith', 'lowo', -8, -3)
    4:         self.checkequal(True, 'helloworld', 'endswith', 'lowo', -7, -3)
    4:         self.checkequal(False, 'helloworld', 'endswith', 'lowo', 3, -4)
    4:         self.checkequal(False, 'helloworld', 'endswith', 'lowo', -8, -2)
       
    4:         self.checkraises(TypeError, 'hello', 'endswith')
    4:         self.checkraises(TypeError, 'hello', 'endswith', 42)
       
               # test tuple arguments
    4:         self.checkequal(False, 'hello', 'endswith', ('he', 'ha'))
    4:         self.checkequal(True, 'hello', 'endswith', ('lo', 'llo'))
    4:         self.checkequal(True, 'hello', 'endswith', ('hellox', 'hello'))
    4:         self.checkequal(False, 'hello', 'endswith', ())
    4:         self.checkequal(True, 'helloworld', 'endswith', ('hellowo',
    4:                                                            'rld', 'lowo'), 3)
    4:         self.checkequal(False, 'helloworld', 'endswith', ('hellowo', 'ello',
    4:                                                             'rld'), 3, -1)
    4:         self.checkequal(True, 'hello', 'endswith', ('hell', 'ell'), 0, -1)
    4:         self.checkequal(False, 'hello', 'endswith', ('he', 'hel'), 0, 1)
    4:         self.checkequal(True, 'hello', 'endswith', ('he', 'hell'), 0, 4)
       
    4:         self.checkraises(TypeError, 'hello', 'endswith', (42,))
       
    1:     def test___contains__(self):
    4:         self.checkequal(True, '', '__contains__', '')
    4:         self.checkequal(True, 'abc', '__contains__', '')
    4:         self.checkequal(False, 'abc', '__contains__', '\0')
    4:         self.checkequal(True, '\0abc', '__contains__', '\0')
    4:         self.checkequal(True, 'abc\0', '__contains__', '\0')
    4:         self.checkequal(True, '\0abc', '__contains__', 'a')
    4:         self.checkequal(True, 'asdf', '__contains__', 'asdf')
    4:         self.checkequal(False, 'asd', '__contains__', 'asdf')
    4:         self.checkequal(False, '', '__contains__', 'asdf')
       
    1:     def test_subscript(self):
    4:         self.checkequal(u'a', 'abc', '__getitem__', 0)
    4:         self.checkequal(u'c', 'abc', '__getitem__', -1)
    4:         self.checkequal(u'a', 'abc', '__getitem__', 0L)
    4:         self.checkequal(u'abc', 'abc', '__getitem__', slice(0, 3))
    4:         self.checkequal(u'abc', 'abc', '__getitem__', slice(0, 1000))
    4:         self.checkequal(u'a', 'abc', '__getitem__', slice(0, 1))
    4:         self.checkequal(u'', 'abc', '__getitem__', slice(0, 0))
       
    4:         self.checkraises(TypeError, 'abc', '__getitem__', 'def')
       
    1:     def test_slice(self):
    4:         self.checkequal('abc', 'abc', '__getslice__', 0, 1000)
    4:         self.checkequal('abc', 'abc', '__getslice__', 0, 3)
    4:         self.checkequal('ab', 'abc', '__getslice__', 0, 2)
    4:         self.checkequal('bc', 'abc', '__getslice__', 1, 3)
    4:         self.checkequal('b', 'abc', '__getslice__', 1, 2)
    4:         self.checkequal('', 'abc', '__getslice__', 2, 2)
    4:         self.checkequal('', 'abc', '__getslice__', 1000, 1000)
    4:         self.checkequal('', 'abc', '__getslice__', 2000, 1000)
    4:         self.checkequal('', 'abc', '__getslice__', 2, 1)
       
    4:         self.checkraises(TypeError, 'abc', '__getslice__', 'def')
       
    1:     def test_extended_getslice(self):
               # Test extended slicing by comparing with list slicing.
    4:         s = string.ascii_letters + string.digits
    4:         indices = (0, None, 1, 3, 41, -1, -2, -37)
   36:         for start in indices:
  288:             for stop in indices:
                       # Skip step 0 (invalid)
 2048:                 for step in indices[1:]:
 1792:                     L = list(s)[start:stop:step]
 1792:                     self.checkequal(u"".join(L), s, '__getitem__',
 1792:                                     slice(start, stop, step))
       
    1:     def test_mul(self):
    4:         self.checkequal('', 'abc', '__mul__', -1)
    4:         self.checkequal('', 'abc', '__mul__', 0)
    4:         self.checkequal('abc', 'abc', '__mul__', 1)
    4:         self.checkequal('abcabcabc', 'abc', '__mul__', 3)
    4:         self.checkraises(TypeError, 'abc', '__mul__')
    4:         self.checkraises(TypeError, 'abc', '__mul__', '')
               # XXX: on a 64-bit system, this doesn't raise an overflow error,
               # but either raises a MemoryError, or succeeds (if you have 54TiB)
               #self.checkraises(OverflowError, 10000*'abc', '__mul__', 2000000000)
       
    1:     def test_join(self):
               # join now works with any sequence type
               # moved here, because the argument order is
               # different in string.join (see the test in
               # test.test_string.StringTest.test_join)
    4:         self.checkequal('a b c d', ' ', 'join', ['a', 'b', 'c', 'd'])
    4:         self.checkequal('abcd', '', 'join', ('a', 'b', 'c', 'd'))
    4:         self.checkequal('bd', '', 'join', ('', 'b', '', 'd'))
    4:         self.checkequal('ac', '', 'join', ('a', '', 'c', ''))
    4:         self.checkequal('w x y z', ' ', 'join', Sequence())
    4:         self.checkequal('abc', 'a', 'join', ('abc',))
    4:         self.checkequal('z', 'a', 'join', UserList(['z']))
    4:         if test_support.have_unicode:
    4:             self.checkequal(unicode('a.b.c'), unicode('.'), 'join', ['a', 'b', 'c'])
    4:             self.checkequal(unicode('a.b.c'), '.', 'join', [unicode('a'), 'b', 'c'])
    4:             self.checkequal(unicode('a.b.c'), '.', 'join', ['a', unicode('b'), 'c'])
    4:             self.checkequal(unicode('a.b.c'), '.', 'join', ['a', 'b', unicode('c')])
    4:             self.checkraises(TypeError, '.', 'join', ['a', unicode('b'), 3])
   16:         for i in [5, 25, 125]:
   12:             self.checkequal(((('a' * i) + '-') * i)[:-1], '-', 'join',
   12:                  ['a' * i] * i)
   12:             self.checkequal(((('a' * i) + '-') * i)[:-1], '-', 'join',
   12:                  ('a' * i,) * i)
       
    4:         self.checkraises(TypeError, ' ', 'join', BadSeq1())
    4:         self.checkequal('a b c', ' ', 'join', BadSeq2())
       
    4:         self.checkraises(TypeError, ' ', 'join')
    4:         self.checkraises(TypeError, ' ', 'join', None)
    4:         self.checkraises(TypeError, ' ', 'join', 7)
    4:         self.checkraises(TypeError, ' ', 'join', Sequence([7, 'hello', 123L]))
    4:         try:
    4:             def f():
    4:                 yield 4 + ""
    4:             self.fixtype(' ').join(f())
    4:         except TypeError, e:
    4:             if '+' not in str(e):
>>>>>>                 self.fail('join() ate exception message')
               else:
>>>>>>             self.fail('exception not raised')
       
    1:     def test_formatting(self):
    4:         self.checkequal('+hello+', '+%s+', '__mod__', 'hello')
    4:         self.checkequal('+10+', '+%d+', '__mod__', 10)
    4:         self.checkequal('a', "%c", '__mod__', "a")
    4:         self.checkequal('a', "%c", '__mod__', "a")
    4:         self.checkequal('"', "%c", '__mod__', 34)
    4:         self.checkequal('$', "%c", '__mod__', 36)
    4:         self.checkequal('10', "%d", '__mod__', 10)
    4:         self.checkequal('\x7f', "%c", '__mod__', 0x7f)
       
   12:         for ordinal in (-100, 0x200000):
                   # unicode raises ValueError, str raises OverflowError
    8:             self.checkraises((ValueError, OverflowError), '%c', '__mod__', ordinal)
       
    4:         longvalue = sys.maxint + 10L
    4:         slongvalue = str(longvalue)
    4:         if slongvalue[-1] in ("L","l"): slongvalue = slongvalue[:-1]
    4:         self.checkequal(' 42', '%3ld', '__mod__', 42)
    4:         self.checkequal('42', '%d', '__mod__', 42L)
    4:         self.checkequal('42', '%d', '__mod__', 42.0)
    4:         self.checkequal(slongvalue, '%d', '__mod__', longvalue)
    4:         self.checkcall('%d', '__mod__', float(longvalue))
    4:         self.checkequal('0042.00', '%07.2f', '__mod__', 42)
    4:         self.checkequal('0042.00', '%07.2F', '__mod__', 42)
       
    4:         self.checkraises(TypeError, 'abc', '__mod__')
    4:         self.checkraises(TypeError, '%(foo)s', '__mod__', 42)
    4:         self.checkraises(TypeError, '%s%s', '__mod__', (42,))
    4:         self.checkraises(TypeError, '%c', '__mod__', (None,))
    4:         self.checkraises(ValueError, '%(foo', '__mod__', {})
    4:         self.checkraises(TypeError, '%(foo)s %(bar)s', '__mod__', ('foo', 42))
    4:         self.checkraises(TypeError, '%d', '__mod__', "42") # not numeric
    4:         self.checkraises(TypeError, '%d', '__mod__', (42+0j)) # no int/long conversion provided
       
               # argument names with properly nested brackets are supported
    4:         self.checkequal('bar', '%((foo))s', '__mod__', {'(foo)': 'bar'})
       
               # 100 is a magic number in PyUnicode_Format, this forces a resize
    4:         self.checkequal(103*'a'+'x', '%sx', '__mod__', 103*'a')
       
    4:         self.checkraises(TypeError, '%*s', '__mod__', ('foo', 'bar'))
    4:         self.checkraises(TypeError, '%10.*f', '__mod__', ('foo', 42.))
    4:         self.checkraises(ValueError, '%10', '__mod__', (42,))
       
    8:         class X(object): pass
    4:         self.checkraises(TypeError, 'abc', '__mod__', X())
    8:         class X(Exception):
    4:             def __getitem__(self, k):
    8:                 return k
    4:         self.checkequal('melon apple', '%(melon)s %(apple)s', '__mod__', X())
       
    1:     @test_support.cpython_only
           def test_formatting_c_limits(self):
    4:         from _testcapi import PY_SSIZE_T_MAX, INT_MAX, UINT_MAX
    4:         SIZE_MAX = (1 << (PY_SSIZE_T_MAX.bit_length() + 1)) - 1
    4:         width = int(PY_SSIZE_T_MAX + 1)
    4:         if width <= sys.maxint:
>>>>>>             self.checkraises(OverflowError, '%*s', '__mod__', (width, ''))
    4:         prec = int(INT_MAX + 1)
    4:         if prec <= sys.maxint:
    4:             self.checkraises(OverflowError, '%.*f', '__mod__', (prec, 1. / 7))
               # Issue 15989
    4:         width = int(SIZE_MAX + 1)
    4:         if width <= sys.maxint:
>>>>>>             self.checkraises(OverflowError, '%*s', '__mod__', (width, ''))
    4:         prec = int(UINT_MAX + 1)
    4:         if prec <= sys.maxint:
    4:             self.checkraises(OverflowError, '%.*f', '__mod__', (prec, 1. / 7))
       
    1:     def test_floatformatting(self):
               # float formatting
  404:         for prec in xrange(100):
  400:             format = '%%.%if' % prec
  400:             value = 0.01
24400:             for x in xrange(60):
24000:                 value = value * 3.14159265359 / 3.0 * 10.0
24000:                 self.checkcall(format, "__mod__", value)
       
    1:     def test_inplace_rewrites(self):
               # Check that strings don't copy and modify cached single-character strings
    4:         self.checkequal('a', 'A', 'lower')
    4:         self.checkequal(True, 'A', 'isupper')
    4:         self.checkequal('A', 'a', 'upper')
    4:         self.checkequal(True, 'a', 'islower')
       
    4:         self.checkequal('a', 'A', 'replace', 'A', 'a')
    4:         self.checkequal(True, 'A', 'isupper')
       
    4:         self.checkequal('A', 'a', 'capitalize')
    4:         self.checkequal(True, 'a', 'islower')
       
    4:         self.checkequal('A', 'a', 'swapcase')
    4:         self.checkequal(True, 'a', 'islower')
       
    4:         self.checkequal('A', 'a', 'title')
    4:         self.checkequal(True, 'a', 'islower')
       
    1:     def test_partition(self):
       
    4:         self.checkequal(('this is the par', 'ti', 'tion method'),
    4:             'this is the partition method', 'partition', 'ti')
       
               # from raymond's original specification
    4:         S = 'http://www.python.org'
    4:         self.checkequal(('http', '://', 'www.python.org'), S, 'partition', '://')
    4:         self.checkequal(('http://www.python.org', '', ''), S, 'partition', '?')
    4:         self.checkequal(('', 'http://', 'www.python.org'), S, 'partition', 'http://')
    4:         self.checkequal(('http://www.python.', 'org', ''), S, 'partition', 'org')
       
    4:         self.checkraises(ValueError, S, 'partition', '')
    4:         self.checkraises(TypeError, S, 'partition', None)
       
               # mixed use of str and unicode
    4:         self.assertEqual('a/b/c'.partition(u'/'), ('a', '/', 'b/c'))
       
    1:     def test_rpartition(self):
       
    4:         self.checkequal(('this is the rparti', 'ti', 'on method'),
    4:             'this is the rpartition method', 'rpartition', 'ti')
       
               # from raymond's original specification
    4:         S = 'http://www.python.org'
    4:         self.checkequal(('http', '://', 'www.python.org'), S, 'rpartition', '://')
    4:         self.checkequal(('', '', 'http://www.python.org'), S, 'rpartition', '?')
    4:         self.checkequal(('', 'http://', 'www.python.org'), S, 'rpartition', 'http://')
    4:         self.checkequal(('http://www.python.', 'org', ''), S, 'rpartition', 'org')
       
    4:         self.checkraises(ValueError, S, 'rpartition', '')
    4:         self.checkraises(TypeError, S, 'rpartition', None)
       
               # mixed use of str and unicode
    4:         self.assertEqual('a/b/c'.rpartition(u'/'), ('a/b', '/', 'c'))
       
    1:     def test_none_arguments(self):
               # issue 11828
    4:         s = 'hello'
    4:         self.checkequal(2, s, 'find', 'l', None)
    4:         self.checkequal(3, s, 'find', 'l', -2, None)
    4:         self.checkequal(2, s, 'find', 'l', None, -2)
    4:         self.checkequal(0, s, 'find', 'h', None, None)
       
    4:         self.checkequal(3, s, 'rfind', 'l', None)
    4:         self.checkequal(3, s, 'rfind', 'l', -2, None)
    4:         self.checkequal(2, s, 'rfind', 'l', None, -2)
    4:         self.checkequal(0, s, 'rfind', 'h', None, None)
       
    4:         self.checkequal(2, s, 'index', 'l', None)
    4:         self.checkequal(3, s, 'index', 'l', -2, None)
    4:         self.checkequal(2, s, 'index', 'l', None, -2)
    4:         self.checkequal(0, s, 'index', 'h', None, None)
       
    4:         self.checkequal(3, s, 'rindex', 'l', None)
    4:         self.checkequal(3, s, 'rindex', 'l', -2, None)
    4:         self.checkequal(2, s, 'rindex', 'l', None, -2)
    4:         self.checkequal(0, s, 'rindex', 'h', None, None)
       
    4:         self.checkequal(2, s, 'count', 'l', None)
    4:         self.checkequal(1, s, 'count', 'l', -2, None)
    4:         self.checkequal(1, s, 'count', 'l', None, -2)
    4:         self.checkequal(0, s, 'count', 'x', None, None)
       
    4:         self.checkequal(True, s, 'endswith', 'o', None)
    4:         self.checkequal(True, s, 'endswith', 'lo', -2, None)
    4:         self.checkequal(True, s, 'endswith', 'l', None, -2)
    4:         self.checkequal(False, s, 'endswith', 'x', None, None)
       
    4:         self.checkequal(True, s, 'startswith', 'h', None)
    4:         self.checkequal(True, s, 'startswith', 'l', -2, None)
    4:         self.checkequal(True, s, 'startswith', 'h', None, -2)
    4:         self.checkequal(False, s, 'startswith', 'x', None, None)
       
    1:     def test_find_etc_raise_correct_error_messages(self):
               # issue 11828
    4:         s = 'hello'
    4:         x = 'x'
    4:         self.assertRaisesRegexp(TypeError, r'\bfind\b', s.find,
    4:                                 x, None, None, None)
    4:         self.assertRaisesRegexp(TypeError, r'\brfind\b', s.rfind,
    4:                                 x, None, None, None)
    4:         self.assertRaisesRegexp(TypeError, r'\bindex\b', s.index,
    4:                                 x, None, None, None)
    4:         self.assertRaisesRegexp(TypeError, r'\brindex\b', s.rindex,
    4:                                 x, None, None, None)
    4:         self.assertRaisesRegexp(TypeError, r'^count\(', s.count,
    4:                                 x, None, None, None)
    4:         self.assertRaisesRegexp(TypeError, r'^startswith\(', s.startswith,
    4:                                 x, None, None, None)
    4:         self.assertRaisesRegexp(TypeError, r'^endswith\(', s.endswith,
    4:                                 x, None, None, None)
       
    2: class MixinStrStringUserStringTest:
           # Additional tests for 8bit strings, i.e. str, UserString and
           # the string module
       
    1:     def test_maketrans(self):
    3:         self.assertEqual(
    3:            ''.join(map(chr, xrange(256))).replace('abc', 'xyz'),
    3:            string.maketrans('abc', 'xyz')
               )
    3:         self.assertRaises(ValueError, string.maketrans, 'abc', 'xyzw')
       
    1:     def test_translate(self):
    3:         table = string.maketrans('abc', 'xyz')
    3:         self.checkequal('xyzxyz', 'xyzabcdef', 'translate', table, 'def')
       
    3:         table = string.maketrans('a', 'A')
    3:         self.checkequal('Abc', 'abc', 'translate', table)
    3:         self.checkequal('xyz', 'xyz', 'translate', table)
    3:         self.checkequal('yz', 'xyz', 'translate', table, 'x')
    3:         self.checkequal('yx', 'zyzzx', 'translate', None, 'z')
    3:         self.checkequal('zyzzx', 'zyzzx', 'translate', None, '')
    3:         self.checkequal('zyzzx', 'zyzzx', 'translate', None)
    3:         self.checkraises(ValueError, 'xyz', 'translate', 'too short', 'strip')
    3:         self.checkraises(ValueError, 'xyz', 'translate', 'too short')
       
       
    2: class MixinStrUserStringTest:
           # Additional tests that only work with
           # 8bit compatible object, i.e. str and UserString
       
    1:     @unittest.skipUnless(test_support.have_unicode, 'no unicode support')
           def test_encoding_decoding(self):
    3:         codecs = [('rot13', 'uryyb jbeyq'),
    3:                   ('base64', 'aGVsbG8gd29ybGQ=\n'),
    3:                   ('hex', '68656c6c6f20776f726c64'),
    3:                   ('uu', 'begin 666 <data>\n+:&5L;&\\@=V]R;&0 \n \nend\n')]
   15:         for encoding, data in codecs:
   12:             with test_support.check_py3k_warnings():
   12:                 self.checkequal(data, 'hello world', 'encode', encoding)
   12:             with test_support.check_py3k_warnings():
   12:                 self.checkequal('hello world', data, 'decode', encoding)
               # zlib is optional, so we make the test optional too...
    3:         try:
    3:             import zlib
>>>>>>         except ImportError:
>>>>>>             pass
               else:
    3:             data = 'x\x9c\xcbH\xcd\xc9\xc9W(\xcf/\xcaI\x01\x00\x1a\x0b\x04]'
    3:             with test_support.check_py3k_warnings():
    3:                 self.checkequal(data, 'hello world', 'encode', 'zlib')
    3:             with test_support.check_py3k_warnings():
    3:                 self.checkequal('hello world', data, 'decode', 'zlib')
       
    3:         self.checkraises(TypeError, 'xyz', 'decode', 42)
    3:         self.checkraises(TypeError, 'xyz', 'encode', 42)
       
       
    2: class MixinStrUnicodeTest:
           # Additional tests that only work with str and unicode.
       
    1:     def test_bug1001011(self):
               # Make sure join returns a NEW object for single item sequences
               # involving a subclass.
               # Make sure that it is of the appropriate type.
               # Check the optimisation still occurs for standard objects.
    2:         t = self.type2test
    4:         class subclass(t):
    2:             pass
    2:         s1 = subclass("abcd")
    2:         s2 = t().join([s1])
    2:         self.assertTrue(s1 is not s2)
    2:         self.assertTrue(type(s2) is t)
       
    2:         s1 = t("abcd")
    2:         s2 = t().join([s1])
    2:         self.assertTrue(s1 is s2)
       
               # Should also test mixed-type join.
    2:         if t is unicode:
    1:             s1 = subclass("abcd")
    1:             s2 = "".join([s1])
    1:             self.assertTrue(s1 is not s2)
    1:             self.assertTrue(type(s2) is t)
       
    1:             s1 = t("abcd")
    1:             s2 = "".join([s1])
    1:             self.assertTrue(s1 is s2)
       
    1:         elif t is str:
    1:             s1 = subclass("abcd")
    1:             s2 = u"".join([s1])
    1:             self.assertTrue(s1 is not s2)
    1:             self.assertTrue(type(s2) is unicode) # promotes!
       
    1:             s1 = t("abcd")
    1:             s2 = u"".join([s1])
    1:             self.assertTrue(s1 is not s2)
    1:             self.assertTrue(type(s2) is unicode) # promotes!
       
               else:
>>>>>>             self.fail("unexpected type for MixinStrUnicodeTest %r" % t)
