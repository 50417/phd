       """Test date/time type.
       
       See http://www.zope.org/Members/fdrake/DateTimeWiki/TestCases
    1: """
    1: from __future__ import division
    1: import sys
    1: import pickle
    1: import cPickle
    1: import unittest
       
    1: from test import test_support
       
    1: from datetime import MINYEAR, MAXYEAR
    1: from datetime import timedelta
    1: from datetime import tzinfo
    1: from datetime import time
    1: from datetime import date, datetime
       
    1: pickle_choices = [(pickler, unpickler, proto)
    3:                   for pickler in pickle, cPickle
    6:                   for unpickler in pickle, cPickle
   16:                   for proto in range(3)]
    1: assert len(pickle_choices) == 2*2*3
       
       # An arbitrary collection of objects of non-datetime types, for testing
       # mixed-type comparisons.
    1: OTHERSTUFF = (10, 10L, 34.5, "abc", {}, [], ())
       
       
       #############################################################################
       # module tests
       
    2: class TestModule(unittest.TestCase):
       
    1:     def test_constants(self):
    1:         import datetime
    1:         self.assertEqual(datetime.MINYEAR, 1)
    1:         self.assertEqual(datetime.MAXYEAR, 9999)
       
       #############################################################################
       # tzinfo tests
       
    2: class FixedOffset(tzinfo):
    1:     def __init__(self, offset, name, dstoffset=42):
  108:         if isinstance(offset, int):
   62:             offset = timedelta(minutes=offset)
  108:         if isinstance(dstoffset, int):
   69:             dstoffset = timedelta(minutes=dstoffset)
  108:         self.__offset = offset
  108:         self.__name = name
  108:         self.__dstoffset = dstoffset
    1:     def __repr__(self):
    7:         return self.__name.lower()
    1:     def utcoffset(self, dt):
  685:         return self.__offset
    1:     def tzname(self, dt):
   59:         return self.__name
    1:     def dst(self, dt):
  377:         return self.__dstoffset
       
    2: class PicklableFixedOffset(FixedOffset):
    1:     def __init__(self, offset=None, name=None, dstoffset=None):
   39:         FixedOffset.__init__(self, offset, name, dstoffset)
       
    2: class TestTZInfo(unittest.TestCase):
       
    1:     def test_non_abstractness(self):
               # In order to allow subclasses to get pickled, the C implementation
               # wasn't able to get away with having __init__ raise
               # NotImplementedError.
    1:         useless = tzinfo()
    1:         dt = datetime.max
    1:         self.assertRaises(NotImplementedError, useless.tzname, dt)
    1:         self.assertRaises(NotImplementedError, useless.utcoffset, dt)
    1:         self.assertRaises(NotImplementedError, useless.dst, dt)
       
    1:     def test_subclass_must_override(self):
    2:         class NotEnough(tzinfo):
    1:             def __init__(self, offset, name):
    1:                 self.__offset = offset
    1:                 self.__name = name
    1:         self.assertTrue(issubclass(NotEnough, tzinfo))
    1:         ne = NotEnough(3, "NotByALongShot")
    1:         self.assertIsInstance(ne, tzinfo)
       
    1:         dt = datetime.now()
    1:         self.assertRaises(NotImplementedError, ne.tzname, dt)
    1:         self.assertRaises(NotImplementedError, ne.utcoffset, dt)
    1:         self.assertRaises(NotImplementedError, ne.dst, dt)
       
    1:     def test_normal(self):
    1:         fo = FixedOffset(3, "Three")
    1:         self.assertIsInstance(fo, tzinfo)
    3:         for dt in datetime.now(), None:
    2:             self.assertEqual(fo.utcoffset(dt), timedelta(minutes=3))
    2:             self.assertEqual(fo.tzname(dt), "Three")
    2:             self.assertEqual(fo.dst(dt), timedelta(minutes=42))
       
    1:     def test_pickling_base(self):
               # There's no point to pickling tzinfo objects on their own (they
               # carry no data), but they need to be picklable anyway else
               # concrete subclasses can't be pickled.
    1:         orig = tzinfo.__new__(tzinfo)
    1:         self.assertIs(type(orig), tzinfo)
   13:         for pickler, unpickler, proto in pickle_choices:
   12:             green = pickler.dumps(orig, proto)
   12:             derived = unpickler.loads(green)
   12:             self.assertIs(type(derived), tzinfo)
       
    1:     def test_pickling_subclass(self):
               # Make sure we can pickle/unpickle an instance of a subclass.
    1:         offset = timedelta(minutes=-300)
    1:         orig = PicklableFixedOffset(offset, 'cookie')
    1:         self.assertIsInstance(orig, tzinfo)
    1:         self.assertTrue(type(orig) is PicklableFixedOffset)
    1:         self.assertEqual(orig.utcoffset(None), offset)
    1:         self.assertEqual(orig.tzname(None), 'cookie')
   13:         for pickler, unpickler, proto in pickle_choices:
   12:             green = pickler.dumps(orig, proto)
   12:             derived = unpickler.loads(green)
   12:             self.assertIsInstance(derived, tzinfo)
   12:             self.assertTrue(type(derived) is PicklableFixedOffset)
   12:             self.assertEqual(derived.utcoffset(None), offset)
   12:             self.assertEqual(derived.tzname(None), 'cookie')
       
       #############################################################################
       # Base class for testing a particular aspect of timedelta, time, date and
       # datetime comparisons.
       
    2: class HarmlessMixedComparison:
           # Test that __eq__ and __ne__ don't complain for mixed-type comparisons.
       
           # Subclasses must define 'theclass', and theclass(1, 1, 1) must be a
           # legit constructor.
       
    1:     def test_harmless_mixed_comparison(self):
    6:         me = self.theclass(1, 1, 1)
       
    6:         self.assertFalse(me == ())
    6:         self.assertTrue(me != ())
    6:         self.assertFalse(() == me)
    6:         self.assertTrue(() != me)
       
    6:         self.assertIn(me, [1, 20L, [], me])
    6:         self.assertIn([], [me, 1, 20L, []])
       
    1:     def test_harmful_mixed_comparison(self):
    6:         me = self.theclass(1, 1, 1)
       
   12:         self.assertRaises(TypeError, lambda: me < ())
   12:         self.assertRaises(TypeError, lambda: me <= ())
   12:         self.assertRaises(TypeError, lambda: me > ())
   12:         self.assertRaises(TypeError, lambda: me >= ())
       
   12:         self.assertRaises(TypeError, lambda: () < me)
   12:         self.assertRaises(TypeError, lambda: () <= me)
   12:         self.assertRaises(TypeError, lambda: () > me)
   12:         self.assertRaises(TypeError, lambda: () >= me)
       
    6:         self.assertRaises(TypeError, cmp, (), me)
    6:         self.assertRaises(TypeError, cmp, me, ())
       
       #############################################################################
       # timedelta tests
       
    2: class TestTimeDelta(HarmlessMixedComparison, unittest.TestCase):
       
    1:     theclass = timedelta
       
    1:     def test_constructor(self):
    1:         eq = self.assertEqual
    1:         td = timedelta
       
               # Check keyword args to constructor
    1:         eq(td(), td(weeks=0, days=0, hours=0, minutes=0, seconds=0,
    1:                     milliseconds=0, microseconds=0))
    1:         eq(td(1), td(days=1))
    1:         eq(td(0, 1), td(seconds=1))
    1:         eq(td(0, 0, 1), td(microseconds=1))
    1:         eq(td(weeks=1), td(days=7))
    1:         eq(td(days=1), td(hours=24))
    1:         eq(td(hours=1), td(minutes=60))
    1:         eq(td(minutes=1), td(seconds=60))
    1:         eq(td(seconds=1), td(milliseconds=1000))
    1:         eq(td(milliseconds=1), td(microseconds=1000))
       
               # Check float args to constructor
    1:         eq(td(weeks=1.0/7), td(days=1))
    1:         eq(td(days=1.0/24), td(hours=1))
    1:         eq(td(hours=1.0/60), td(minutes=1))
    1:         eq(td(minutes=1.0/60), td(seconds=1))
    1:         eq(td(seconds=0.001), td(milliseconds=1))
    1:         eq(td(milliseconds=0.001), td(microseconds=1))
       
    1:     def test_computations(self):
    1:         eq = self.assertEqual
    1:         td = timedelta
       
    1:         a = td(7) # One week
    1:         b = td(0, 60) # One minute
    1:         c = td(0, 0, 1000) # One millisecond
    1:         eq(a+b+c, td(7, 60, 1000))
    1:         eq(a-b, td(6, 24*3600 - 60))
    1:         eq(-a, td(-7))
    1:         eq(+a, td(7))
    1:         eq(-b, td(-1, 24*3600 - 60))
    1:         eq(-c, td(-1, 24*3600 - 1, 999000))
    1:         eq(abs(a), a)
    1:         eq(abs(-a), a)
    1:         eq(td(6, 24*3600), a)
    1:         eq(td(0, 0, 60*1000000), b)
    1:         eq(a*10, td(70))
    1:         eq(a*10, 10*a)
    1:         eq(a*10L, 10*a)
    1:         eq(b*10, td(0, 600))
    1:         eq(10*b, td(0, 600))
    1:         eq(b*10L, td(0, 600))
    1:         eq(c*10, td(0, 0, 10000))
    1:         eq(10*c, td(0, 0, 10000))
    1:         eq(c*10L, td(0, 0, 10000))
    1:         eq(a*-1, -a)
    1:         eq(b*-2, -b-b)
    1:         eq(c*-2, -c+-c)
    1:         eq(b*(60*24), (b*60)*24)
    1:         eq(b*(60*24), (60*b)*24)
    1:         eq(c*1000, td(0, 1))
    1:         eq(1000*c, td(0, 1))
    1:         eq(a//7, td(1))
    1:         eq(b//10, td(0, 6))
    1:         eq(c//1000, td(0, 0, 1))
    1:         eq(a//10, td(0, 7*24*360))
    1:         eq(a//3600000, td(0, 0, 7*24*1000))
       
               # Issue #11576
    1:         eq(td(999999999, 86399, 999999) - td(999999999, 86399, 999998),
    1:            td(0, 0, 1))
    1:         eq(td(999999999, 1, 1) - td(999999999, 1, 0),
    1:            td(0, 0, 1))
       
       
    1:     def test_disallowed_computations(self):
    1:         a = timedelta(42)
       
               # Add/sub ints, longs, floats should be illegal
    4:         for i in 1, 1L, 1.0:
    6:             self.assertRaises(TypeError, lambda: a+i)
    6:             self.assertRaises(TypeError, lambda: a-i)
    6:             self.assertRaises(TypeError, lambda: i+a)
    6:             self.assertRaises(TypeError, lambda: i-a)
       
               # Mul/div by float isn't supported.
    1:         x = 2.3
    2:         self.assertRaises(TypeError, lambda: a*x)
    2:         self.assertRaises(TypeError, lambda: x*a)
    2:         self.assertRaises(TypeError, lambda: a/x)
    2:         self.assertRaises(TypeError, lambda: x/a)
    2:         self.assertRaises(TypeError, lambda: a // x)
    2:         self.assertRaises(TypeError, lambda: x // a)
       
               # Division of int by timedelta doesn't make sense.
               # Division by zero doesn't make sense.
    3:         for zero in 0, 0L:
    4:             self.assertRaises(TypeError, lambda: zero // a)
    4:             self.assertRaises(ZeroDivisionError, lambda: a // zero)
       
    1:     def test_basic_attributes(self):
    1:         days, seconds, us = 1, 7, 31
    1:         td = timedelta(days, seconds, us)
    1:         self.assertEqual(td.days, days)
    1:         self.assertEqual(td.seconds, seconds)
    1:         self.assertEqual(td.microseconds, us)
       
    1:     def test_total_seconds(self):
    1:         td = timedelta(days=365)
    1:         self.assertEqual(td.total_seconds(), 31536000.0)
    6:         for total_seconds in [123456.789012, -123456.789012, 0.123456, 0, 1e6]:
    5:             td = timedelta(seconds=total_seconds)
    5:             self.assertEqual(td.total_seconds(), total_seconds)
               # Issue8644: Test that td.total_seconds() has the same
               # accuracy as td / timedelta(seconds=1).
    4:         for ms in [-1, -2, -123]:
    3:             td = timedelta(microseconds=ms)
    3:             self.assertEqual(td.total_seconds(),
    3:                              ((24*3600*td.days + td.seconds)*10**6
    3:                               + td.microseconds)/10**6)
       
    1:     def test_carries(self):
    1:         t1 = timedelta(days=100,
    1:                        weeks=-7,
    1:                        hours=-24*(100-49),
    1:                        minutes=-3,
    1:                        seconds=12,
    1:                        microseconds=(3*60 - 12) * 1e6 + 1)
    1:         t2 = timedelta(microseconds=1)
    1:         self.assertEqual(t1, t2)
       
    1:     def test_hash_equality(self):
    1:         t1 = timedelta(days=100,
    1:                        weeks=-7,
    1:                        hours=-24*(100-49),
    1:                        minutes=-3,
    1:                        seconds=12,
    1:                        microseconds=(3*60 - 12) * 1000000)
    1:         t2 = timedelta()
    1:         self.assertEqual(hash(t1), hash(t2))
       
    1:         t1 += timedelta(weeks=7)
    1:         t2 += timedelta(days=7*7)
    1:         self.assertEqual(t1, t2)
    1:         self.assertEqual(hash(t1), hash(t2))
       
    1:         d = {t1: 1}
    1:         d[t2] = 2
    1:         self.assertEqual(len(d), 1)
    1:         self.assertEqual(d[t1], 2)
       
    1:     def test_pickling(self):
    1:         args = 12, 34, 56
    1:         orig = timedelta(*args)
   13:         for pickler, unpickler, proto in pickle_choices:
   12:             green = pickler.dumps(orig, proto)
   12:             derived = unpickler.loads(green)
   12:             self.assertEqual(orig, derived)
       
    1:     def test_compare(self):
    1:         t1 = timedelta(2, 3, 4)
    1:         t2 = timedelta(2, 3, 4)
    1:         self.assertTrue(t1 == t2)
    1:         self.assertTrue(t1 <= t2)
    1:         self.assertTrue(t1 >= t2)
    1:         self.assertFalse(t1 != t2)
    1:         self.assertFalse(t1 < t2)
    1:         self.assertFalse(t1 > t2)
    1:         self.assertEqual(cmp(t1, t2), 0)
    1:         self.assertEqual(cmp(t2, t1), 0)
       
    4:         for args in (3, 3, 3), (2, 4, 4), (2, 3, 5):
    3:             t2 = timedelta(*args)   # this is larger than t1
    3:             self.assertTrue(t1 < t2)
    3:             self.assertTrue(t2 > t1)
    3:             self.assertTrue(t1 <= t2)
    3:             self.assertTrue(t2 >= t1)
    3:             self.assertTrue(t1 != t2)
    3:             self.assertTrue(t2 != t1)
    3:             self.assertFalse(t1 == t2)
    3:             self.assertFalse(t2 == t1)
    3:             self.assertFalse(t1 > t2)
    3:             self.assertFalse(t2 < t1)
    3:             self.assertFalse(t1 >= t2)
    3:             self.assertFalse(t2 <= t1)
    3:             self.assertEqual(cmp(t1, t2), -1)
    3:             self.assertEqual(cmp(t2, t1), 1)
       
    8:         for badarg in OTHERSTUFF:
    7:             self.assertEqual(t1 == badarg, False)
    7:             self.assertEqual(t1 != badarg, True)
    7:             self.assertEqual(badarg == t1, False)
    7:             self.assertEqual(badarg != t1, True)
       
   14:             self.assertRaises(TypeError, lambda: t1 <= badarg)
   14:             self.assertRaises(TypeError, lambda: t1 < badarg)
   14:             self.assertRaises(TypeError, lambda: t1 > badarg)
   14:             self.assertRaises(TypeError, lambda: t1 >= badarg)
   14:             self.assertRaises(TypeError, lambda: badarg <= t1)
   14:             self.assertRaises(TypeError, lambda: badarg < t1)
   14:             self.assertRaises(TypeError, lambda: badarg > t1)
   14:             self.assertRaises(TypeError, lambda: badarg >= t1)
       
    1:     def test_str(self):
    1:         td = timedelta
    1:         eq = self.assertEqual
       
    1:         eq(str(td(1)), "1 day, 0:00:00")
    1:         eq(str(td(-1)), "-1 day, 0:00:00")
    1:         eq(str(td(2)), "2 days, 0:00:00")
    1:         eq(str(td(-2)), "-2 days, 0:00:00")
       
    1:         eq(str(td(hours=12, minutes=58, seconds=59)), "12:58:59")
    1:         eq(str(td(hours=2, minutes=3, seconds=4)), "2:03:04")
    1:         eq(str(td(weeks=-30, hours=23, minutes=12, seconds=34)),
    1:            "-210 days, 23:12:34")
       
    1:         eq(str(td(milliseconds=1)), "0:00:00.001000")
    1:         eq(str(td(microseconds=3)), "0:00:00.000003")
       
    1:         eq(str(td(days=999999999, hours=23, minutes=59, seconds=59,
    1:                    microseconds=999999)),
    1:            "999999999 days, 23:59:59.999999")
       
    1:     def test_roundtrip(self):
    1:         for td in (timedelta(days=999999999, hours=23, minutes=59,
    1:                              seconds=59, microseconds=999999),
    1:                    timedelta(days=-999999999),
    4:                    timedelta(days=1, seconds=2, microseconds=3)):
       
                   # Verify td -> string -> td identity.
    3:             s = repr(td)
    3:             self.assertTrue(s.startswith('datetime.'))
    3:             s = s[9:]
    3:             td2 = eval(s)
    3:             self.assertEqual(td, td2)
       
                   # Verify identity via reconstructing from pieces.
    3:             td2 = timedelta(td.days, td.seconds, td.microseconds)
    3:             self.assertEqual(td, td2)
       
    1:     def test_resolution_info(self):
    1:         self.assertIsInstance(timedelta.min, timedelta)
    1:         self.assertIsInstance(timedelta.max, timedelta)
    1:         self.assertIsInstance(timedelta.resolution, timedelta)
    1:         self.assertTrue(timedelta.max > timedelta.min)
    1:         self.assertEqual(timedelta.min, timedelta(-999999999))
    1:         self.assertEqual(timedelta.max, timedelta(999999999, 24*3600-1, 1e6-1))
    1:         self.assertEqual(timedelta.resolution, timedelta(0, 0, 1))
       
    1:     def test_overflow(self):
    1:         tiny = timedelta.resolution
       
    1:         td = timedelta.min + tiny
    1:         td -= tiny  # no problem
    1:         self.assertRaises(OverflowError, td.__sub__, tiny)
    1:         self.assertRaises(OverflowError, td.__add__, -tiny)
       
    1:         td = timedelta.max - tiny
    1:         td += tiny  # no problem
    1:         self.assertRaises(OverflowError, td.__add__, tiny)
    1:         self.assertRaises(OverflowError, td.__sub__, -tiny)
       
    2:         self.assertRaises(OverflowError, lambda: -timedelta.max)
       
    1:     def test_microsecond_rounding(self):
    1:         td = timedelta
    1:         eq = self.assertEqual
       
               # Single-field rounding.
    1:         eq(td(milliseconds=0.4/1000), td(0))    # rounds to 0
    1:         eq(td(milliseconds=-0.4/1000), td(0))    # rounds to 0
    1:         eq(td(milliseconds=0.6/1000), td(microseconds=1))
    1:         eq(td(milliseconds=-0.6/1000), td(microseconds=-1))
       
               # Rounding due to contributions from more than one field.
    1:         us_per_hour = 3600e6
    1:         us_per_day = us_per_hour * 24
    1:         eq(td(days=.4/us_per_day), td(0))
    1:         eq(td(hours=.2/us_per_hour), td(0))
    1:         eq(td(days=.4/us_per_day, hours=.2/us_per_hour), td(microseconds=1))
       
    1:         eq(td(days=-.4/us_per_day), td(0))
    1:         eq(td(hours=-.2/us_per_hour), td(0))
    1:         eq(td(days=-.4/us_per_day, hours=-.2/us_per_hour), td(microseconds=-1))
       
    1:     def test_massive_normalization(self):
    1:         td = timedelta(microseconds=-1)
    1:         self.assertEqual((td.days, td.seconds, td.microseconds),
    1:                          (-1, 24*3600-1, 999999))
       
    1:     def test_bool(self):
    1:         self.assertTrue(timedelta(1))
    1:         self.assertTrue(timedelta(0, 1))
    1:         self.assertTrue(timedelta(0, 0, 1))
    1:         self.assertTrue(timedelta(microseconds=1))
    1:         self.assertFalse(timedelta(0))
       
    1:     def test_subclass_timedelta(self):
       
    2:         class T(timedelta):
    1:             @staticmethod
                   def from_td(td):
    1:                 return T(td.days, td.seconds, td.microseconds)
       
    1:             def as_hours(self):
                       sum = (self.days * 24 +
    3:                        self.seconds / 3600.0 +
    3:                        self.microseconds / 3600e6)
    3:                 return round(sum)
       
    1:         t1 = T(days=1)
    1:         self.assertIs(type(t1), T)
    1:         self.assertEqual(t1.as_hours(), 24)
       
    1:         t2 = T(days=-1, seconds=-3600)
    1:         self.assertIs(type(t2), T)
    1:         self.assertEqual(t2.as_hours(), -25)
       
    1:         t3 = t1 + t2
    1:         self.assertIs(type(t3), timedelta)
    1:         t4 = T.from_td(t3)
    1:         self.assertIs(type(t4), T)
    1:         self.assertEqual(t3.days, t4.days)
    1:         self.assertEqual(t3.seconds, t4.seconds)
    1:         self.assertEqual(t3.microseconds, t4.microseconds)
    1:         self.assertEqual(str(t3), str(t4))
    1:         self.assertEqual(t4.as_hours(), -1)
       
       #############################################################################
       # date tests
       
    2: class TestDateOnly(unittest.TestCase):
           # Tests here won't pass if also run on datetime objects, so don't
           # subclass this to test datetimes too.
       
    1:     def test_delta_non_days_ignored(self):
    1:         dt = date(2000, 1, 2)
    1:         delta = timedelta(days=1, hours=2, minutes=3, seconds=4,
    1:                           microseconds=5)
    1:         days = timedelta(delta.days)
    1:         self.assertEqual(days, timedelta(1))
       
    1:         dt2 = dt + delta
    1:         self.assertEqual(dt2, dt + days)
       
    1:         dt2 = delta + dt
    1:         self.assertEqual(dt2, dt + days)
       
    1:         dt2 = dt - delta
    1:         self.assertEqual(dt2, dt - days)
       
    1:         delta = -delta
    1:         days = timedelta(delta.days)
    1:         self.assertEqual(days, timedelta(-2))
       
    1:         dt2 = dt + delta
    1:         self.assertEqual(dt2, dt + days)
       
    1:         dt2 = delta + dt
    1:         self.assertEqual(dt2, dt + days)
       
    1:         dt2 = dt - delta
    1:         self.assertEqual(dt2, dt - days)
       
    2: class SubclassDate(date):
    1:     sub_var = 1
       
    2: class TestDate(HarmlessMixedComparison, unittest.TestCase):
           # Tests here should pass for both dates and datetimes, except for a
           # few tests that TestDateTime overrides.
       
    1:     theclass = date
       
    1:     def test_basic_attributes(self):
    1:         dt = self.theclass(2002, 3, 1)
    1:         self.assertEqual(dt.year, 2002)
    1:         self.assertEqual(dt.month, 3)
    1:         self.assertEqual(dt.day, 1)
       
    1:     def test_roundtrip(self):
    1:         for dt in (self.theclass(1, 2, 3),
    3:                    self.theclass.today()):
                   # Verify dt -> string -> date identity.
    2:             s = repr(dt)
    2:             self.assertTrue(s.startswith('datetime.'))
    2:             s = s[9:]
    2:             dt2 = eval(s)
    2:             self.assertEqual(dt, dt2)
       
                   # Verify identity via reconstructing from pieces.
    2:             dt2 = self.theclass(dt.year, dt.month, dt.day)
    2:             self.assertEqual(dt, dt2)
       
    1:     def test_ordinal_conversions(self):
               # Check some fixed values.
    3:         for y, m, d, n in [(1, 1, 1, 1),      # calendar origin
    3:                            (1, 12, 31, 365),
    3:                            (2, 1, 1, 366),
                                  # first example from "Calendrical Calculations"
   15:                            (1945, 11, 12, 710347)]:
   12:             d = self.theclass(y, m, d)
   12:             self.assertEqual(n, d.toordinal())
   12:             fromord = self.theclass.fromordinal(n)
   12:             self.assertEqual(d, fromord)
   12:             if hasattr(fromord, "hour"):
                   # if we're checking something fancier than a date, verify
                   # the extra fields have been zeroed out
    8:                 self.assertEqual(fromord.hour, 0)
    8:                 self.assertEqual(fromord.minute, 0)
    8:                 self.assertEqual(fromord.second, 0)
    8:                 self.assertEqual(fromord.microsecond, 0)
       
               # Check first and last days of year spottily across the whole
               # range of years supported.
 4290:         for year in xrange(MINYEAR, MAXYEAR+1, 7):
                   # Verify (year, 1, 1) -> ordinal -> y, m, d is identity.
 4287:             d = self.theclass(year, 1, 1)
 4287:             n = d.toordinal()
 4287:             d2 = self.theclass.fromordinal(n)
 4287:             self.assertEqual(d, d2)
                   # Verify that moving back a day gets to the end of year-1.
 4287:             if year > 1:
 4284:                 d = self.theclass.fromordinal(n-1)
 4284:                 d2 = self.theclass(year-1, 12, 31)
 4284:                 self.assertEqual(d, d2)
 4284:                 self.assertEqual(d2.toordinal(), n-1)
       
               # Test every day in a leap-year and a non-leap year.
    3:         dim = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    9:         for year, isleap in (2000, True), (2002, False):
    6:             n = self.theclass(year, 1, 1).toordinal()
   78:             for month, maxday in zip(range(1, 13), dim):
   72:                 if month == 2 and isleap:
    3:                     maxday += 1
 2265:                 for day in range(1, maxday+1):
 2193:                     d = self.theclass(year, month, day)
 2193:                     self.assertEqual(d.toordinal(), n)
 2193:                     self.assertEqual(d, self.theclass.fromordinal(n))
 2193:                     n += 1
       
    1:     def test_extreme_ordinals(self):
    3:         a = self.theclass.min
    3:         a = self.theclass(a.year, a.month, a.day)  # get rid of time parts
    3:         aord = a.toordinal()
    3:         b = a.fromordinal(aord)
    3:         self.assertEqual(a, b)
       
    6:         self.assertRaises(ValueError, lambda: a.fromordinal(aord - 1))
       
    3:         b = a + timedelta(days=1)
    3:         self.assertEqual(b.toordinal(), aord + 1)
    3:         self.assertEqual(b, self.theclass.fromordinal(aord + 1))
       
    3:         a = self.theclass.max
    3:         a = self.theclass(a.year, a.month, a.day)  # get rid of time parts
    3:         aord = a.toordinal()
    3:         b = a.fromordinal(aord)
    3:         self.assertEqual(a, b)
       
    6:         self.assertRaises(ValueError, lambda: a.fromordinal(aord + 1))
       
    3:         b = a - timedelta(days=1)
    3:         self.assertEqual(b.toordinal(), aord - 1)
    3:         self.assertEqual(b, self.theclass.fromordinal(aord - 1))
       
    1:     def test_bad_constructor_arguments(self):
               # bad years
    1:         self.theclass(MINYEAR, 1, 1)  # no exception
    1:         self.theclass(MAXYEAR, 1, 1)  # no exception
    1:         self.assertRaises(ValueError, self.theclass, MINYEAR-1, 1, 1)
    1:         self.assertRaises(ValueError, self.theclass, MAXYEAR+1, 1, 1)
               # bad months
    1:         self.theclass(2000, 1, 1)    # no exception
    1:         self.theclass(2000, 12, 1)   # no exception
    1:         self.assertRaises(ValueError, self.theclass, 2000, 0, 1)
    1:         self.assertRaises(ValueError, self.theclass, 2000, 13, 1)
               # bad days
    1:         self.theclass(2000, 2, 29)   # no exception
    1:         self.theclass(2004, 2, 29)   # no exception
    1:         self.theclass(2400, 2, 29)   # no exception
    1:         self.assertRaises(ValueError, self.theclass, 2000, 2, 30)
    1:         self.assertRaises(ValueError, self.theclass, 2001, 2, 29)
    1:         self.assertRaises(ValueError, self.theclass, 2100, 2, 29)
    1:         self.assertRaises(ValueError, self.theclass, 1900, 2, 29)
    1:         self.assertRaises(ValueError, self.theclass, 2000, 1, 0)
    1:         self.assertRaises(ValueError, self.theclass, 2000, 1, 32)
       
    1:     def test_hash_equality(self):
    1:         d = self.theclass(2000, 12, 31)
               # same thing
    1:         e = self.theclass(2000, 12, 31)
    1:         self.assertEqual(d, e)
    1:         self.assertEqual(hash(d), hash(e))
       
    1:         dic = {d: 1}
    1:         dic[e] = 2
    1:         self.assertEqual(len(dic), 1)
    1:         self.assertEqual(dic[d], 2)
    1:         self.assertEqual(dic[e], 2)
       
    1:         d = self.theclass(2001,  1,  1)
               # same thing
    1:         e = self.theclass(2001,  1,  1)
    1:         self.assertEqual(d, e)
    1:         self.assertEqual(hash(d), hash(e))
       
    1:         dic = {d: 1}
    1:         dic[e] = 2
    1:         self.assertEqual(len(dic), 1)
    1:         self.assertEqual(dic[d], 2)
    1:         self.assertEqual(dic[e], 2)
       
    1:     def test_computations(self):
    1:         a = self.theclass(2002, 1, 31)
    1:         b = self.theclass(1956, 1, 31)
       
    1:         diff = a-b
    1:         self.assertEqual(diff.days, 46*365 + len(range(1956, 2002, 4)))
    1:         self.assertEqual(diff.seconds, 0)
    1:         self.assertEqual(diff.microseconds, 0)
       
    1:         day = timedelta(1)
    1:         week = timedelta(7)
    1:         a = self.theclass(2002, 3, 2)
    1:         self.assertEqual(a + day, self.theclass(2002, 3, 3))
    1:         self.assertEqual(day + a, self.theclass(2002, 3, 3))
    1:         self.assertEqual(a - day, self.theclass(2002, 3, 1))
    1:         self.assertEqual(-day + a, self.theclass(2002, 3, 1))
    1:         self.assertEqual(a + week, self.theclass(2002, 3, 9))
    1:         self.assertEqual(a - week, self.theclass(2002, 2, 23))
    1:         self.assertEqual(a + 52*week, self.theclass(2003, 3, 1))
    1:         self.assertEqual(a - 52*week, self.theclass(2001, 3, 3))
    1:         self.assertEqual((a + week) - a, week)
    1:         self.assertEqual((a + day) - a, day)
    1:         self.assertEqual((a - week) - a, -week)
    1:         self.assertEqual((a - day) - a, -day)
    1:         self.assertEqual(a - (a + week), -week)
    1:         self.assertEqual(a - (a + day), -day)
    1:         self.assertEqual(a - (a - week), week)
    1:         self.assertEqual(a - (a - day), day)
       
               # Add/sub ints, longs, floats should be illegal
    4:         for i in 1, 1L, 1.0:
    6:             self.assertRaises(TypeError, lambda: a+i)
    6:             self.assertRaises(TypeError, lambda: a-i)
    6:             self.assertRaises(TypeError, lambda: i+a)
    6:             self.assertRaises(TypeError, lambda: i-a)
       
               # delta - date is senseless.
    2:         self.assertRaises(TypeError, lambda: day - a)
               # mixing date and (delta or date) via * or // is senseless
    2:         self.assertRaises(TypeError, lambda: day * a)
    2:         self.assertRaises(TypeError, lambda: a * day)
    2:         self.assertRaises(TypeError, lambda: day // a)
    2:         self.assertRaises(TypeError, lambda: a // day)
    2:         self.assertRaises(TypeError, lambda: a * a)
    2:         self.assertRaises(TypeError, lambda: a // a)
               # date + date is senseless
    2:         self.assertRaises(TypeError, lambda: a + a)
       
    1:     def test_overflow(self):
    3:         tiny = self.theclass.resolution
       
   12:         for delta in [tiny, timedelta(1), timedelta(2)]:
    9:             dt = self.theclass.min + delta
    9:             dt -= delta  # no problem
    9:             self.assertRaises(OverflowError, dt.__sub__, delta)
    9:             self.assertRaises(OverflowError, dt.__add__, -delta)
       
    9:             dt = self.theclass.max - delta
    9:             dt += delta  # no problem
    9:             self.assertRaises(OverflowError, dt.__add__, delta)
    9:             self.assertRaises(OverflowError, dt.__sub__, -delta)
       
    1:     def test_fromtimestamp(self):
    1:         import time
       
               # Try an arbitrary fixed value.
    1:         year, month, day = 1999, 9, 19
    1:         ts = time.mktime((year, month, day, 0, 0, 0, 0, 0, -1))
    1:         d = self.theclass.fromtimestamp(ts)
    1:         self.assertEqual(d.year, year)
    1:         self.assertEqual(d.month, month)
    1:         self.assertEqual(d.day, day)
       
    1:     def test_insane_fromtimestamp(self):
               # It's possible that some platform maps time_t to double,
               # and that this test will fail there.  This test should
               # exempt such platforms (provided they return reasonable
               # results!).
    3:         for insane in -1e200, 1e200:
    2:             self.assertRaises(ValueError, self.theclass.fromtimestamp,
    2:                               insane)
       
    1:     def test_today(self):
    3:         import time
       
               # We claim that today() is like fromtimestamp(time.time()), so
               # prove it.
    9:         for dummy in range(3):
    7:             today = self.theclass.today()
    7:             ts = time.time()
    7:             todayagain = self.theclass.fromtimestamp(ts)
    7:             if today == todayagain:
    1:                 break
                   # There are several legit reasons that could fail:
                   # 1. It recently became midnight, between the today() and the
                   #    time() calls.
                   # 2. The platform time() has such fine resolution that we'll
                   #    never get the same value twice.
                   # 3. The platform time() has poor resolution, and we just
                   #    happened to call today() right before a resolution quantum
                   #    boundary.
                   # 4. The system clock got fiddled between calls.
                   # In any case, wait a little while and try again.
    6:             time.sleep(0.1)
       
               # It worked or it didn't.  If it didn't, assume it's reason #2, and
               # let the test pass if they're within half a second of each other.
    3:         if today != todayagain:
    2:             self.assertAlmostEqual(todayagain, today,
    2:                                    delta=timedelta(seconds=0.5))
       
    1:     def test_weekday(self):
   24:         for i in range(7):
                   # March 4, 2002 is a Monday
   21:             self.assertEqual(self.theclass(2002, 3, 4+i).weekday(), i)
   21:             self.assertEqual(self.theclass(2002, 3, 4+i).isoweekday(), i+1)
                   # January 2, 1956 is a Monday
   21:             self.assertEqual(self.theclass(1956, 1, 2+i).weekday(), i)
   21:             self.assertEqual(self.theclass(1956, 1, 2+i).isoweekday(), i+1)
       
    1:     def test_isocalendar(self):
               # Check examples from
               # http://www.phys.uu.nl/~vgent/calendar/isocalendar.htm
   24:         for i in range(7):
   21:             d = self.theclass(2003, 12, 22+i)
   21:             self.assertEqual(d.isocalendar(), (2003, 52, i+1))
   21:             d = self.theclass(2003, 12, 29) + timedelta(i)
   21:             self.assertEqual(d.isocalendar(), (2004, 1, i+1))
   21:             d = self.theclass(2004, 1, 5+i)
   21:             self.assertEqual(d.isocalendar(), (2004, 2, i+1))
   21:             d = self.theclass(2009, 12, 21+i)
   21:             self.assertEqual(d.isocalendar(), (2009, 52, i+1))
   21:             d = self.theclass(2009, 12, 28) + timedelta(i)
   21:             self.assertEqual(d.isocalendar(), (2009, 53, i+1))
   21:             d = self.theclass(2010, 1, 4+i)
   21:             self.assertEqual(d.isocalendar(), (2010, 1, i+1))
       
    1:     def test_iso_long_years(self):
               # Calculate long ISO years and compare to table from
               # http://www.phys.uu.nl/~vgent/calendar/isocalendar.htm
               ISO_LONG_YEARS_TABLE = """
                     4   32   60   88
                     9   37   65   93
                    15   43   71   99
                    20   48   76
                    26   54   82
       
                   105  133  161  189
                   111  139  167  195
                   116  144  172
                   122  150  178
                   128  156  184
       
                   201  229  257  285
                   207  235  263  291
                   212  240  268  296
                   218  246  274
                   224  252  280
       
                   303  331  359  387
                   308  336  364  392
                   314  342  370  398
                   320  348  376
                   325  353  381
    3:         """
    3:         iso_long_years = map(int, ISO_LONG_YEARS_TABLE.split())
    3:         iso_long_years.sort()
    3:         L = []
 1203:         for i in range(400):
 1200:             d = self.theclass(2000+i, 12, 31)
 1200:             d1 = self.theclass(1600+i, 12, 31)
 1200:             self.assertEqual(d.isocalendar()[1:], d1.isocalendar()[1:])
 1200:             if d.isocalendar()[1] == 53:
  213:                 L.append(i)
    3:         self.assertEqual(L, iso_long_years)
       
    1:     def test_isoformat(self):
    1:         t = self.theclass(2, 3, 2)
    1:         self.assertEqual(t.isoformat(), "0002-03-02")
       
    1:     def test_ctime(self):
    3:         t = self.theclass(2002, 3, 2)
    3:         self.assertEqual(t.ctime(), "Sat Mar  2 00:00:00 2002")
       
    1:     def test_strftime(self):
    3:         t = self.theclass(2005, 3, 2)
    3:         self.assertEqual(t.strftime("m:%m d:%d y:%y"), "m:03 d:02 y:05")
    3:         self.assertEqual(t.strftime(""), "") # SF bug #761337
    3:         self.assertEqual(t.strftime('x'*1000), 'x'*1000) # SF bug #1556784
       
    3:         self.assertRaises(TypeError, t.strftime) # needs an arg
    3:         self.assertRaises(TypeError, t.strftime, "one", "two") # too many args
    3:         self.assertRaises(TypeError, t.strftime, 42) # arg wrong type
       
               # test that unicode input is allowed (issue 2782)
    3:         self.assertEqual(t.strftime(u"%m"), "03")
       
               # A naive object replaces %z and %Z w/ empty strings.
    3:         self.assertEqual(t.strftime("'%z' '%Z'"), "'' ''")
       
               #make sure that invalid format specifiers are handled correctly
               #self.assertRaises(ValueError, t.strftime, "%e")
               #self.assertRaises(ValueError, t.strftime, "%")
               #self.assertRaises(ValueError, t.strftime, "%#")
       
               #oh well, some systems just ignore those invalid ones.
               #at least, exercise them to make sure that no crashes
               #are generated
   12:         for f in ["%e", "%", "%#"]:
    9:             try:
    9:                 t.strftime(f)
    3:             except ValueError:
    3:                 pass
       
               #check that this standard extension works
    3:         t.strftime("%f")
       
       
    1:     def test_format(self):
    1:         dt = self.theclass(2007, 9, 10)
    1:         self.assertEqual(dt.__format__(''), str(dt))
       
               # check that a derived class's __str__() gets called
    2:         class A(self.theclass):
    1:             def __str__(self):
    1:                 return 'A'
    1:         a = A(2007, 9, 10)
    1:         self.assertEqual(a.__format__(''), 'A')
       
               # check that a derived class's strftime gets called
    2:         class B(self.theclass):
    1:             def strftime(self, format_spec):
    3:                 return 'B'
    1:         b = B(2007, 9, 10)
    1:         self.assertEqual(b.__format__(''), str(dt))
       
    1:         for fmt in ["m:%m d:%d y:%y",
    1:                     "m:%m d:%d y:%y H:%H M:%M S:%S",
    4:                     "%z %Z",
                           ]:
    3:             self.assertEqual(dt.__format__(fmt), dt.strftime(fmt))
    3:             self.assertEqual(a.__format__(fmt), dt.strftime(fmt))
    3:             self.assertEqual(b.__format__(fmt), 'B')
       
    1:     def test_resolution_info(self):
    3:         self.assertIsInstance(self.theclass.min, self.theclass)
    3:         self.assertIsInstance(self.theclass.max, self.theclass)
    3:         self.assertIsInstance(self.theclass.resolution, timedelta)
    3:         self.assertTrue(self.theclass.max > self.theclass.min)
       
    1:     def test_extreme_timedelta(self):
    3:         big = self.theclass.max - self.theclass.min
               # 3652058 days, 23 hours, 59 minutes, 59 seconds, 999999 microseconds
    3:         n = (big.days*24*3600 + big.seconds)*1000000 + big.microseconds
               # n == 315537897599999999 ~= 2**58.13
    3:         justasbig = timedelta(0, 0, n)
    3:         self.assertEqual(big, justasbig)
    3:         self.assertEqual(self.theclass.min + big, self.theclass.max)
    3:         self.assertEqual(self.theclass.max - big, self.theclass.min)
       
    1:     def test_timetuple(self):
   24:         for i in range(7):
                   # January 2, 1956 is a Monday (0)
   21:             d = self.theclass(1956, 1, 2+i)
   21:             t = d.timetuple()
   21:             self.assertEqual(t, (1956, 1, 2+i, 0, 0, 0, i, 2+i, -1))
                   # February 1, 1956 is a Wednesday (2)
   21:             d = self.theclass(1956, 2, 1+i)
   21:             t = d.timetuple()
   21:             self.assertEqual(t, (1956, 2, 1+i, 0, 0, 0, (2+i)%7, 32+i, -1))
                   # March 1, 1956 is a Thursday (3), and is the 31+29+1 = 61st day
                   # of the year.
   21:             d = self.theclass(1956, 3, 1+i)
   21:             t = d.timetuple()
   21:             self.assertEqual(t, (1956, 3, 1+i, 0, 0, 0, (3+i)%7, 61+i, -1))
   21:             self.assertEqual(t.tm_year, 1956)
   21:             self.assertEqual(t.tm_mon, 3)
   21:             self.assertEqual(t.tm_mday, 1+i)
   21:             self.assertEqual(t.tm_hour, 0)
   21:             self.assertEqual(t.tm_min, 0)
   21:             self.assertEqual(t.tm_sec, 0)
   21:             self.assertEqual(t.tm_wday, (3+i)%7)
   21:             self.assertEqual(t.tm_yday, 61+i)
   21:             self.assertEqual(t.tm_isdst, -1)
       
    1:     def test_pickling(self):
    1:         args = 6, 7, 23
    1:         orig = self.theclass(*args)
   13:         for pickler, unpickler, proto in pickle_choices:
   12:             green = pickler.dumps(orig, proto)
   12:             derived = unpickler.loads(green)
   12:             self.assertEqual(orig, derived)
       
    1:     def test_compare(self):
    3:         t1 = self.theclass(2, 3, 4)
    3:         t2 = self.theclass(2, 3, 4)
    3:         self.assertTrue(t1 == t2)
    3:         self.assertTrue(t1 <= t2)
    3:         self.assertTrue(t1 >= t2)
    3:         self.assertFalse(t1 != t2)
    3:         self.assertFalse(t1 < t2)
    3:         self.assertFalse(t1 > t2)
    3:         self.assertEqual(cmp(t1, t2), 0)
    3:         self.assertEqual(cmp(t2, t1), 0)
       
   12:         for args in (3, 3, 3), (2, 4, 4), (2, 3, 5):
    9:             t2 = self.theclass(*args)   # this is larger than t1
    9:             self.assertTrue(t1 < t2)
    9:             self.assertTrue(t2 > t1)
    9:             self.assertTrue(t1 <= t2)
    9:             self.assertTrue(t2 >= t1)
    9:             self.assertTrue(t1 != t2)
    9:             self.assertTrue(t2 != t1)
    9:             self.assertFalse(t1 == t2)
    9:             self.assertFalse(t2 == t1)
    9:             self.assertFalse(t1 > t2)
    9:             self.assertFalse(t2 < t1)
    9:             self.assertFalse(t1 >= t2)
    9:             self.assertFalse(t2 <= t1)
    9:             self.assertEqual(cmp(t1, t2), -1)
    9:             self.assertEqual(cmp(t2, t1), 1)
       
   24:         for badarg in OTHERSTUFF:
   21:             self.assertEqual(t1 == badarg, False)
   21:             self.assertEqual(t1 != badarg, True)
   21:             self.assertEqual(badarg == t1, False)
   21:             self.assertEqual(badarg != t1, True)
       
   42:             self.assertRaises(TypeError, lambda: t1 < badarg)
   42:             self.assertRaises(TypeError, lambda: t1 > badarg)
   42:             self.assertRaises(TypeError, lambda: t1 >= badarg)
   42:             self.assertRaises(TypeError, lambda: badarg <= t1)
   42:             self.assertRaises(TypeError, lambda: badarg < t1)
   42:             self.assertRaises(TypeError, lambda: badarg > t1)
   42:             self.assertRaises(TypeError, lambda: badarg >= t1)
       
    1:     def test_mixed_compare(self):
    2:         our = self.theclass(2000, 4, 5)
    2:         self.assertRaises(TypeError, cmp, our, 1)
    2:         self.assertRaises(TypeError, cmp, 1, our)
       
    4:         class AnotherDateTimeClass(object):
    2:             def __cmp__(self, other):
                       # Return "equal" so calling this can't be confused with
                       # compare-by-address (which never says "equal" for distinct
                       # objects).
    8:                 return 0
    2:             __hash__ = None # Silence Py3k warning
       
               # This still errors, because date and datetime comparison raise
               # TypeError instead of NotImplemented when they don't know what to
               # do, in order to stop comparison from falling back to the default
               # compare-by-address.
    2:         their = AnotherDateTimeClass()
    2:         self.assertRaises(TypeError, cmp, our, their)
               # Oops:  The next stab raises TypeError in the C implementation,
               # but not in the Python implementation of datetime.  The difference
               # is due to that the Python implementation defines __cmp__ but
               # the C implementation defines tp_richcompare.  This is more pain
               # to fix than it's worth, so commenting out the test.
               # self.assertEqual(cmp(their, our), 0)
       
               # But date and datetime comparison return NotImplemented instead if the
               # other object has a timetuple attr.  This gives the other object a
               # chance to do the comparison.
    4:         class Comparable(AnotherDateTimeClass):
    2:             def timetuple(self):
>>>>>>                 return ()
       
    2:         their = Comparable()
    2:         self.assertEqual(cmp(our, their), 0)
    2:         self.assertEqual(cmp(their, our), 0)
    2:         self.assertTrue(our == their)
    2:         self.assertTrue(their == our)
       
    1:     def test_bool(self):
               # All dates are considered true.
    3:         self.assertTrue(self.theclass.min)
    3:         self.assertTrue(self.theclass.max)
       
    1:     def test_strftime_out_of_range(self):
               # For nasty technical reasons, we can't handle years before 1900.
    3:         cls = self.theclass
    3:         self.assertEqual(cls(1900, 1, 1).strftime("%Y"), "1900")
   24:         for y in 1, 49, 51, 99, 100, 1000, 1899:
   21:             self.assertRaises(ValueError, cls(y, 1, 1).strftime, "%Y")
       
    1:     def test_replace(self):
    1:         cls = self.theclass
    1:         args = [1, 2, 3]
    1:         base = cls(*args)
    1:         self.assertEqual(base, base.replace())
       
    1:         i = 0
    1:         for name, newval in (("year", 2),
    1:                              ("month", 3),
    4:                              ("day", 4)):
    3:             newargs = args[:]
    3:             newargs[i] = newval
    3:             expected = cls(*newargs)
    3:             got = base.replace(**{name: newval})
    3:             self.assertEqual(expected, got)
    3:             i += 1
       
               # Out of bounds.
    1:         base = cls(2000, 2, 29)
    1:         self.assertRaises(ValueError, base.replace, year=2001)
       
    1:     def test_subclass_date(self):
       
    6:         class C(self.theclass):
    3:             theAnswer = 42
       
    3:             def __new__(cls, *args, **kws):
    3:                 temp = kws.copy()
    3:                 extra = temp.pop('extra')
    3:                 result = self.theclass.__new__(cls, *args, **temp)
    3:                 result.extra = extra
    3:                 return result
       
    3:             def newmeth(self, start):
    3:                 return start + self.year + self.month
       
    3:         args = 2003, 4, 14
       
    3:         dt1 = self.theclass(*args)
    3:         dt2 = C(*args, **{'extra': 7})
       
    3:         self.assertEqual(dt2.__class__, C)
    3:         self.assertEqual(dt2.theAnswer, 42)
    3:         self.assertEqual(dt2.extra, 7)
    3:         self.assertEqual(dt1.toordinal(), dt2.toordinal())
    3:         self.assertEqual(dt2.newmeth(-7), dt1.year + dt1.month - 7)
       
    1:     def test_pickling_subclass_date(self):
       
    3:         args = 6, 7, 23
    3:         orig = SubclassDate(*args)
   39:         for pickler, unpickler, proto in pickle_choices:
   36:             green = pickler.dumps(orig, proto)
   36:             derived = unpickler.loads(green)
   36:             self.assertEqual(orig, derived)
       
    1:     def test_backdoor_resistance(self):
               # For fast unpickling, the constructor accepts a pickle string.
               # This is a low-overhead backdoor.  A user can (by intent or
               # mistake) pass a string directly, which (if it's the right length)
               # will get treated like a pickle, and bypass the normal sanity
               # checks in the constructor.  This can create insane objects.
               # The constructor doesn't want to burn the time to validate all
               # fields, but does check the month field.  This stops, e.g.,
               # datetime.datetime('1995-03-25') from yielding an insane object.
    3:         base = '1995-03-25'
    3:         if not issubclass(self.theclass, datetime):
    1:             base = base[:4]
   15:         for month_byte in '9', chr(0), chr(13), '\xff':
   12:             self.assertRaises(TypeError, self.theclass,
   12:                                          base[:2] + month_byte + base[3:])
   39:         for ord_byte in range(1, 13):
                   # This shouldn't blow up because of the month byte alone.  If
                   # the implementation changes to do more-careful checking, it may
                   # blow up because other fields are insane.
   36:             self.theclass(base[:2] + chr(ord_byte) + base[3:])
       
       #############################################################################
       # datetime tests
       
    2: class SubclassDatetime(datetime):
    1:     sub_var = 1
       
    2: class TestDateTime(TestDate):
       
    1:     theclass = datetime
       
    1:     def test_basic_attributes(self):
    2:         dt = self.theclass(2002, 3, 1, 12, 0)
    2:         self.assertEqual(dt.year, 2002)
    2:         self.assertEqual(dt.month, 3)
    2:         self.assertEqual(dt.day, 1)
    2:         self.assertEqual(dt.hour, 12)
    2:         self.assertEqual(dt.minute, 0)
    2:         self.assertEqual(dt.second, 0)
    2:         self.assertEqual(dt.microsecond, 0)
       
    1:     def test_basic_attributes_nonzero(self):
               # Make sure all attributes are non-zero so bugs in
               # bit-shifting access show up.
    2:         dt = self.theclass(2002, 3, 1, 12, 59, 59, 8000)
    2:         self.assertEqual(dt.year, 2002)
    2:         self.assertEqual(dt.month, 3)
    2:         self.assertEqual(dt.day, 1)
    2:         self.assertEqual(dt.hour, 12)
    2:         self.assertEqual(dt.minute, 59)
    2:         self.assertEqual(dt.second, 59)
    2:         self.assertEqual(dt.microsecond, 8000)
       
    1:     def test_roundtrip(self):
    2:         for dt in (self.theclass(1, 2, 3, 4, 5, 6, 7),
    6:                    self.theclass.now()):
                   # Verify dt -> string -> datetime identity.
    4:             s = repr(dt)
    4:             self.assertTrue(s.startswith('datetime.'))
    4:             s = s[9:]
    4:             dt2 = eval(s)
    4:             self.assertEqual(dt, dt2)
       
                   # Verify identity via reconstructing from pieces.
    4:             dt2 = self.theclass(dt.year, dt.month, dt.day,
    4:                                 dt.hour, dt.minute, dt.second,
    4:                                 dt.microsecond)
    4:             self.assertEqual(dt, dt2)
       
    1:     def test_isoformat(self):
    2:         t = self.theclass(2, 3, 2, 4, 5, 1, 123)
    2:         self.assertEqual(t.isoformat(),    "0002-03-02T04:05:01.000123")
    2:         self.assertEqual(t.isoformat('T'), "0002-03-02T04:05:01.000123")
    2:         self.assertEqual(t.isoformat(' '), "0002-03-02 04:05:01.000123")
    2:         self.assertEqual(t.isoformat('\x00'), "0002-03-02\x0004:05:01.000123")
               # str is ISO format with the separator forced to a blank.
    2:         self.assertEqual(str(t), "0002-03-02 04:05:01.000123")
       
    2:         t = self.theclass(2, 3, 2)
    2:         self.assertEqual(t.isoformat(),    "0002-03-02T00:00:00")
    2:         self.assertEqual(t.isoformat('T'), "0002-03-02T00:00:00")
    2:         self.assertEqual(t.isoformat(' '), "0002-03-02 00:00:00")
               # str is ISO format with the separator forced to a blank.
    2:         self.assertEqual(str(t), "0002-03-02 00:00:00")
       
    1:     def test_format(self):
    2:         dt = self.theclass(2007, 9, 10, 4, 5, 1, 123)
    2:         self.assertEqual(dt.__format__(''), str(dt))
       
               # check that a derived class's __str__() gets called
    4:         class A(self.theclass):
    2:             def __str__(self):
    2:                 return 'A'
    2:         a = A(2007, 9, 10, 4, 5, 1, 123)
    2:         self.assertEqual(a.__format__(''), 'A')
       
               # check that a derived class's strftime gets called
    4:         class B(self.theclass):
    2:             def strftime(self, format_spec):
    6:                 return 'B'
    2:         b = B(2007, 9, 10, 4, 5, 1, 123)
    2:         self.assertEqual(b.__format__(''), str(dt))
       
    2:         for fmt in ["m:%m d:%d y:%y",
    2:                     "m:%m d:%d y:%y H:%H M:%M S:%S",
    8:                     "%z %Z",
                           ]:
    6:             self.assertEqual(dt.__format__(fmt), dt.strftime(fmt))
    6:             self.assertEqual(a.__format__(fmt), dt.strftime(fmt))
    6:             self.assertEqual(b.__format__(fmt), 'B')
       
    1:     def test_more_ctime(self):
               # Test fields that TestDate doesn't touch.
    2:         import time
       
    2:         t = self.theclass(2002, 3, 2, 18, 3, 5, 123)
    2:         self.assertEqual(t.ctime(), "Sat Mar  2 18:03:05 2002")
               # Oops!  The next line fails on Win2K under MSVC 6, so it's commented
               # out.  The difference is that t.ctime() produces " 2" for the day,
               # but platform ctime() produces "02" for the day.  According to
               # C99, t.ctime() is correct here.
               # self.assertEqual(t.ctime(), time.ctime(time.mktime(t.timetuple())))
       
               # So test a case where that difference doesn't matter.
    2:         t = self.theclass(2002, 3, 22, 18, 3, 5, 123)
    2:         self.assertEqual(t.ctime(), time.ctime(time.mktime(t.timetuple())))
       
    1:     def test_tz_independent_comparing(self):
    2:         dt1 = self.theclass(2002, 3, 1, 9, 0, 0)
    2:         dt2 = self.theclass(2002, 3, 1, 10, 0, 0)
    2:         dt3 = self.theclass(2002, 3, 1, 9, 0, 0)
    2:         self.assertEqual(dt1, dt3)
    2:         self.assertTrue(dt2 > dt3)
       
               # Make sure comparison doesn't forget microseconds, and isn't done
               # via comparing a float timestamp (an IEEE double doesn't have enough
               # precision to span microsecond resolution across years 1 thru 9999,
               # so comparing via timestamp necessarily calls some distinct values
               # equal).
    2:         dt1 = self.theclass(MAXYEAR, 12, 31, 23, 59, 59, 999998)
    2:         us = timedelta(microseconds=1)
    2:         dt2 = dt1 + us
    2:         self.assertEqual(dt2 - dt1, us)
    2:         self.assertTrue(dt1 < dt2)
       
    1:     def test_strftime_with_bad_tzname_replace(self):
               # verify ok if tzinfo.tzname().replace() returns a non-string
    4:         class MyTzInfo(FixedOffset):
    2:             def tzname(self, dt):
    4:                 class MyStr(str):
    2:                     def replace(self, *args):
    2:                         return None
    2:                 return MyStr('name')
    2:         t = self.theclass(2005, 3, 2, 0, 0, 0, 0, MyTzInfo(3, 'name'))
    2:         self.assertRaises(TypeError, t.strftime, '%Z')
       
    1:     def test_bad_constructor_arguments(self):
               # bad years
    2:         self.theclass(MINYEAR, 1, 1)  # no exception
    2:         self.theclass(MAXYEAR, 1, 1)  # no exception
    2:         self.assertRaises(ValueError, self.theclass, MINYEAR-1, 1, 1)
    2:         self.assertRaises(ValueError, self.theclass, MAXYEAR+1, 1, 1)
               # bad months
    2:         self.theclass(2000, 1, 1)    # no exception
    2:         self.theclass(2000, 12, 1)   # no exception
    2:         self.assertRaises(ValueError, self.theclass, 2000, 0, 1)
    2:         self.assertRaises(ValueError, self.theclass, 2000, 13, 1)
               # bad days
    2:         self.theclass(2000, 2, 29)   # no exception
    2:         self.theclass(2004, 2, 29)   # no exception
    2:         self.theclass(2400, 2, 29)   # no exception
    2:         self.assertRaises(ValueError, self.theclass, 2000, 2, 30)
    2:         self.assertRaises(ValueError, self.theclass, 2001, 2, 29)
    2:         self.assertRaises(ValueError, self.theclass, 2100, 2, 29)
    2:         self.assertRaises(ValueError, self.theclass, 1900, 2, 29)
    2:         self.assertRaises(ValueError, self.theclass, 2000, 1, 0)
    2:         self.assertRaises(ValueError, self.theclass, 2000, 1, 32)
               # bad hours
    2:         self.theclass(2000, 1, 31, 0)    # no exception
    2:         self.theclass(2000, 1, 31, 23)   # no exception
    2:         self.assertRaises(ValueError, self.theclass, 2000, 1, 31, -1)
    2:         self.assertRaises(ValueError, self.theclass, 2000, 1, 31, 24)
               # bad minutes
    2:         self.theclass(2000, 1, 31, 23, 0)    # no exception
    2:         self.theclass(2000, 1, 31, 23, 59)   # no exception
    2:         self.assertRaises(ValueError, self.theclass, 2000, 1, 31, 23, -1)
    2:         self.assertRaises(ValueError, self.theclass, 2000, 1, 31, 23, 60)
               # bad seconds
    2:         self.theclass(2000, 1, 31, 23, 59, 0)    # no exception
    2:         self.theclass(2000, 1, 31, 23, 59, 59)   # no exception
    2:         self.assertRaises(ValueError, self.theclass, 2000, 1, 31, 23, 59, -1)
    2:         self.assertRaises(ValueError, self.theclass, 2000, 1, 31, 23, 59, 60)
               # bad microseconds
    2:         self.theclass(2000, 1, 31, 23, 59, 59, 0)    # no exception
    2:         self.theclass(2000, 1, 31, 23, 59, 59, 999999)   # no exception
    2:         self.assertRaises(ValueError, self.theclass,
    2:                           2000, 1, 31, 23, 59, 59, -1)
    2:         self.assertRaises(ValueError, self.theclass,
    2:                           2000, 1, 31, 23, 59, 59,
    2:                           1000000)
       
    1:     def test_hash_equality(self):
    2:         d = self.theclass(2000, 12, 31, 23, 30, 17)
    2:         e = self.theclass(2000, 12, 31, 23, 30, 17)
    2:         self.assertEqual(d, e)
    2:         self.assertEqual(hash(d), hash(e))
       
    2:         dic = {d: 1}
    2:         dic[e] = 2
    2:         self.assertEqual(len(dic), 1)
    2:         self.assertEqual(dic[d], 2)
    2:         self.assertEqual(dic[e], 2)
       
    2:         d = self.theclass(2001,  1,  1,  0,  5, 17)
    2:         e = self.theclass(2001,  1,  1,  0,  5, 17)
    2:         self.assertEqual(d, e)
    2:         self.assertEqual(hash(d), hash(e))
       
    2:         dic = {d: 1}
    2:         dic[e] = 2
    2:         self.assertEqual(len(dic), 1)
    2:         self.assertEqual(dic[d], 2)
    2:         self.assertEqual(dic[e], 2)
       
    1:     def test_computations(self):
    2:         a = self.theclass(2002, 1, 31)
    2:         b = self.theclass(1956, 1, 31)
    2:         diff = a-b
    2:         self.assertEqual(diff.days, 46*365 + len(range(1956, 2002, 4)))
    2:         self.assertEqual(diff.seconds, 0)
    2:         self.assertEqual(diff.microseconds, 0)
    2:         a = self.theclass(2002, 3, 2, 17, 6)
    2:         millisec = timedelta(0, 0, 1000)
    2:         hour = timedelta(0, 3600)
    2:         day = timedelta(1)
    2:         week = timedelta(7)
    2:         self.assertEqual(a + hour, self.theclass(2002, 3, 2, 18, 6))
    2:         self.assertEqual(hour + a, self.theclass(2002, 3, 2, 18, 6))
    2:         self.assertEqual(a + 10*hour, self.theclass(2002, 3, 3, 3, 6))
    2:         self.assertEqual(a - hour, self.theclass(2002, 3, 2, 16, 6))
    2:         self.assertEqual(-hour + a, self.theclass(2002, 3, 2, 16, 6))
    2:         self.assertEqual(a - hour, a + -hour)
    2:         self.assertEqual(a - 20*hour, self.theclass(2002, 3, 1, 21, 6))
    2:         self.assertEqual(a + day, self.theclass(2002, 3, 3, 17, 6))
    2:         self.assertEqual(a - day, self.theclass(2002, 3, 1, 17, 6))
    2:         self.assertEqual(a + week, self.theclass(2002, 3, 9, 17, 6))
    2:         self.assertEqual(a - week, self.theclass(2002, 2, 23, 17, 6))
    2:         self.assertEqual(a + 52*week, self.theclass(2003, 3, 1, 17, 6))
    2:         self.assertEqual(a - 52*week, self.theclass(2001, 3, 3, 17, 6))
    2:         self.assertEqual((a + week) - a, week)
    2:         self.assertEqual((a + day) - a, day)
    2:         self.assertEqual((a + hour) - a, hour)
    2:         self.assertEqual((a + millisec) - a, millisec)
    2:         self.assertEqual((a - week) - a, -week)
    2:         self.assertEqual((a - day) - a, -day)
    2:         self.assertEqual((a - hour) - a, -hour)
    2:         self.assertEqual((a - millisec) - a, -millisec)
    2:         self.assertEqual(a - (a + week), -week)
    2:         self.assertEqual(a - (a + day), -day)
    2:         self.assertEqual(a - (a + hour), -hour)
    2:         self.assertEqual(a - (a + millisec), -millisec)
    2:         self.assertEqual(a - (a - week), week)
    2:         self.assertEqual(a - (a - day), day)
    2:         self.assertEqual(a - (a - hour), hour)
    2:         self.assertEqual(a - (a - millisec), millisec)
    2:         self.assertEqual(a + (week + day + hour + millisec),
    2:                          self.theclass(2002, 3, 10, 18, 6, 0, 1000))
    2:         self.assertEqual(a + (week + day + hour + millisec),
    2:                          (((a + week) + day) + hour) + millisec)
    2:         self.assertEqual(a - (week + day + hour + millisec),
    2:                          self.theclass(2002, 2, 22, 16, 5, 59, 999000))
    2:         self.assertEqual(a - (week + day + hour + millisec),
    2:                          (((a - week) - day) - hour) - millisec)
               # Add/sub ints, longs, floats should be illegal
    8:         for i in 1, 1L, 1.0:
   12:             self.assertRaises(TypeError, lambda: a+i)
   12:             self.assertRaises(TypeError, lambda: a-i)
   12:             self.assertRaises(TypeError, lambda: i+a)
   12:             self.assertRaises(TypeError, lambda: i-a)
       
               # delta - datetime is senseless.
    4:         self.assertRaises(TypeError, lambda: day - a)
               # mixing datetime and (delta or datetime) via * or // is senseless
    4:         self.assertRaises(TypeError, lambda: day * a)
    4:         self.assertRaises(TypeError, lambda: a * day)
    4:         self.assertRaises(TypeError, lambda: day // a)
    4:         self.assertRaises(TypeError, lambda: a // day)
    4:         self.assertRaises(TypeError, lambda: a * a)
    4:         self.assertRaises(TypeError, lambda: a // a)
               # datetime + datetime is senseless
    4:         self.assertRaises(TypeError, lambda: a + a)
       
    1:     def test_pickling(self):
    1:         args = 6, 7, 23, 20, 59, 1, 64**2
    1:         orig = self.theclass(*args)
   13:         for pickler, unpickler, proto in pickle_choices:
   12:             green = pickler.dumps(orig, proto)
   12:             derived = unpickler.loads(green)
   12:             self.assertEqual(orig, derived)
       
    1:     def test_more_pickling(self):
    2:         a = self.theclass(2003, 2, 7, 16, 48, 37, 444116)
    8:         for proto in range(pickle.HIGHEST_PROTOCOL + 1):
    6:             s = pickle.dumps(a, proto)
    6:             b = pickle.loads(s)
    6:             self.assertEqual(b.year, 2003)
    6:             self.assertEqual(b.month, 2)
    6:             self.assertEqual(b.day, 7)
       
    1:     def test_pickling_subclass_datetime(self):
    2:         args = 6, 7, 23, 20, 59, 1, 64**2
    2:         orig = SubclassDatetime(*args)
   26:         for pickler, unpickler, proto in pickle_choices:
   24:             green = pickler.dumps(orig, proto)
   24:             derived = unpickler.loads(green)
   24:             self.assertEqual(orig, derived)
       
    1:     def test_more_compare(self):
               # The test_compare() inherited from TestDate covers the error cases.
               # We just want to test lexicographic ordering on the members datetime
               # has that date lacks.
    2:         args = [2000, 11, 29, 20, 58, 16, 999998]
    2:         t1 = self.theclass(*args)
    2:         t2 = self.theclass(*args)
    2:         self.assertTrue(t1 == t2)
    2:         self.assertTrue(t1 <= t2)
    2:         self.assertTrue(t1 >= t2)
    2:         self.assertFalse(t1 != t2)
    2:         self.assertFalse(t1 < t2)
    2:         self.assertFalse(t1 > t2)
    2:         self.assertEqual(cmp(t1, t2), 0)
    2:         self.assertEqual(cmp(t2, t1), 0)
       
   16:         for i in range(len(args)):
   14:             newargs = args[:]
   14:             newargs[i] = args[i] + 1
   14:             t2 = self.theclass(*newargs)   # this is larger than t1
   14:             self.assertTrue(t1 < t2)
   14:             self.assertTrue(t2 > t1)
   14:             self.assertTrue(t1 <= t2)
   14:             self.assertTrue(t2 >= t1)
   14:             self.assertTrue(t1 != t2)
   14:             self.assertTrue(t2 != t1)
   14:             self.assertFalse(t1 == t2)
   14:             self.assertFalse(t2 == t1)
   14:             self.assertFalse(t1 > t2)
   14:             self.assertFalse(t2 < t1)
   14:             self.assertFalse(t1 >= t2)
   14:             self.assertFalse(t2 <= t1)
   14:             self.assertEqual(cmp(t1, t2), -1)
   14:             self.assertEqual(cmp(t2, t1), 1)
       
       
           # A helper for timestamp constructor tests.
    1:     def verify_field_equality(self, expected, got):
    4:         self.assertEqual(expected.tm_year, got.year)
    4:         self.assertEqual(expected.tm_mon, got.month)
    4:         self.assertEqual(expected.tm_mday, got.day)
    4:         self.assertEqual(expected.tm_hour, got.hour)
    4:         self.assertEqual(expected.tm_min, got.minute)
    4:         self.assertEqual(expected.tm_sec, got.second)
       
    1:     def test_fromtimestamp(self):
    2:         import time
       
    2:         ts = time.time()
    2:         expected = time.localtime(ts)
    2:         got = self.theclass.fromtimestamp(ts)
    2:         self.verify_field_equality(expected, got)
       
    1:     def test_utcfromtimestamp(self):
    2:         import time
       
    2:         ts = time.time()
    2:         expected = time.gmtime(ts)
    2:         got = self.theclass.utcfromtimestamp(ts)
    2:         self.verify_field_equality(expected, got)
       
    1:     def test_microsecond_rounding(self):
               # Test whether fromtimestamp "rounds up" floats that are less
               # than one microsecond smaller than an integer.
    2:         self.assertEqual(self.theclass.fromtimestamp(0.9999999),
    2:                          self.theclass.fromtimestamp(1))
       
    1:     def test_insane_fromtimestamp(self):
               # It's possible that some platform maps time_t to double,
               # and that this test will fail there.  This test should
               # exempt such platforms (provided they return reasonable
               # results!).
    6:         for insane in -1e200, 1e200:
    4:             self.assertRaises(ValueError, self.theclass.fromtimestamp,
    4:                               insane)
       
    1:     def test_insane_utcfromtimestamp(self):
               # It's possible that some platform maps time_t to double,
               # and that this test will fail there.  This test should
               # exempt such platforms (provided they return reasonable
               # results!).
    6:         for insane in -1e200, 1e200:
    4:             self.assertRaises(ValueError, self.theclass.utcfromtimestamp,
    4:                               insane)
    1:     @unittest.skipIf(sys.platform == "win32", "Windows doesn't accept negative timestamps")
           def test_negative_float_fromtimestamp(self):
               # The result is tz-dependent; at least test that this doesn't
               # fail (like it did before bug 1646728 was fixed).
    2:         self.theclass.fromtimestamp(-1.05)
       
    1:     @unittest.skipIf(sys.platform == "win32", "Windows doesn't accept negative timestamps")
           def test_negative_float_utcfromtimestamp(self):
    2:         d = self.theclass.utcfromtimestamp(-1.05)
    2:         self.assertEqual(d, self.theclass(1969, 12, 31, 23, 59, 58, 950000))
       
    1:     def test_utcnow(self):
    2:         import time
       
               # Call it a success if utcnow() and utcfromtimestamp() are within
               # a second of each other.
    2:         tolerance = timedelta(seconds=1)
    2:         for dummy in range(3):
    2:             from_now = self.theclass.utcnow()
    2:             from_timestamp = self.theclass.utcfromtimestamp(time.time())
    2:             if abs(from_timestamp - from_now) <= tolerance:
    2:                 break
                   # Else try again a few times.
    2:         self.assertLessEqual(abs(from_timestamp - from_now), tolerance)
       
    1:     def test_strptime(self):
    2:         import _strptime
       
    2:         string = '2004-12-01 13:02:47.197'
    2:         format = '%Y-%m-%d %H:%M:%S.%f'
    2:         result, frac = _strptime._strptime(string, format)
    2:         expected = self.theclass(*(result[0:6]+(frac,)))
    2:         got = self.theclass.strptime(string, format)
    2:         self.assertEqual(expected, got)
       
    1:     def test_more_timetuple(self):
               # This tests fields beyond those tested by the TestDate.test_timetuple.
    2:         t = self.theclass(2004, 12, 31, 6, 22, 33)
    2:         self.assertEqual(t.timetuple(), (2004, 12, 31, 6, 22, 33, 4, 366, -1))
    2:         self.assertEqual(t.timetuple(),
    2:                          (t.year, t.month, t.day,
    2:                           t.hour, t.minute, t.second,
    2:                           t.weekday(),
    2:                           t.toordinal() - date(t.year, 1, 1).toordinal() + 1,
    2:                           -1))
    2:         tt = t.timetuple()
    2:         self.assertEqual(tt.tm_year, t.year)
    2:         self.assertEqual(tt.tm_mon, t.month)
    2:         self.assertEqual(tt.tm_mday, t.day)
    2:         self.assertEqual(tt.tm_hour, t.hour)
    2:         self.assertEqual(tt.tm_min, t.minute)
    2:         self.assertEqual(tt.tm_sec, t.second)
    2:         self.assertEqual(tt.tm_wday, t.weekday())
    2:         self.assertEqual(tt.tm_yday, t.toordinal() -
    2:                                      date(t.year, 1, 1).toordinal() + 1)
    2:         self.assertEqual(tt.tm_isdst, -1)
       
    1:     def test_more_strftime(self):
               # This tests fields beyond those tested by the TestDate.test_strftime.
    2:         t = self.theclass(2004, 12, 31, 6, 22, 33, 47)
    2:         self.assertEqual(t.strftime("%m %d %y %f %S %M %H %j"),
    2:                                     "12 31 04 000047 33 22 06 366")
       
    1:     def test_extract(self):
    1:         dt = self.theclass(2002, 3, 4, 18, 45, 3, 1234)
    1:         self.assertEqual(dt.date(), date(2002, 3, 4))
    1:         self.assertEqual(dt.time(), time(18, 45, 3, 1234))
       
    1:     def test_combine(self):
    1:         d = date(2002, 3, 4)
    1:         t = time(18, 45, 3, 1234)
    1:         expected = self.theclass(2002, 3, 4, 18, 45, 3, 1234)
    1:         combine = self.theclass.combine
    1:         dt = combine(d, t)
    1:         self.assertEqual(dt, expected)
       
    1:         dt = combine(time=t, date=d)
    1:         self.assertEqual(dt, expected)
       
    1:         self.assertEqual(d, dt.date())
    1:         self.assertEqual(t, dt.time())
    1:         self.assertEqual(dt, combine(dt.date(), dt.time()))
       
    1:         self.assertRaises(TypeError, combine) # need an arg
    1:         self.assertRaises(TypeError, combine, d) # need two args
    1:         self.assertRaises(TypeError, combine, t, d) # args reversed
    1:         self.assertRaises(TypeError, combine, d, t, 1) # too many args
    1:         self.assertRaises(TypeError, combine, "date", "time") # wrong types
       
    1:     def test_replace(self):
    1:         cls = self.theclass
    1:         args = [1, 2, 3, 4, 5, 6, 7]
    1:         base = cls(*args)
    1:         self.assertEqual(base, base.replace())
       
    1:         i = 0
    1:         for name, newval in (("year", 2),
    1:                              ("month", 3),
    1:                              ("day", 4),
    1:                              ("hour", 5),
    1:                              ("minute", 6),
    1:                              ("second", 7),
    8:                              ("microsecond", 8)):
    7:             newargs = args[:]
    7:             newargs[i] = newval
    7:             expected = cls(*newargs)
    7:             got = base.replace(**{name: newval})
    7:             self.assertEqual(expected, got)
    7:             i += 1
       
               # Out of bounds.
    1:         base = cls(2000, 2, 29)
    1:         self.assertRaises(ValueError, base.replace, year=2001)
       
    1:     def test_astimezone(self):
               # Pretty boring!  The TZ test is more interesting here.  astimezone()
               # simply can't be applied to a naive object.
    2:         dt = self.theclass.now()
    2:         f = FixedOffset(44, "")
    2:         self.assertRaises(TypeError, dt.astimezone) # not enough args
    2:         self.assertRaises(TypeError, dt.astimezone, f, f) # too many args
    2:         self.assertRaises(TypeError, dt.astimezone, dt) # arg wrong type
    2:         self.assertRaises(ValueError, dt.astimezone, f) # naive
    2:         self.assertRaises(ValueError, dt.astimezone, tz=f)  # naive
       
    4:         class Bogus(tzinfo):
    2:             def utcoffset(self, dt): return None
    2:             def dst(self, dt): return timedelta(0)
    2:         bog = Bogus()
    2:         self.assertRaises(ValueError, dt.astimezone, bog)   # naive
       
    4:         class AlsoBogus(tzinfo):
    2:             def utcoffset(self, dt): return timedelta(0)
    2:             def dst(self, dt): return None
    2:         alsobog = AlsoBogus()
    2:         self.assertRaises(ValueError, dt.astimezone, alsobog) # also naive
       
    1:     def test_subclass_datetime(self):
       
    4:         class C(self.theclass):
    2:             theAnswer = 42
       
    2:             def __new__(cls, *args, **kws):
    2:                 temp = kws.copy()
    2:                 extra = temp.pop('extra')
    2:                 result = self.theclass.__new__(cls, *args, **temp)
    2:                 result.extra = extra
    2:                 return result
       
    2:             def newmeth(self, start):
    2:                 return start + self.year + self.month + self.second
       
    2:         args = 2003, 4, 14, 12, 13, 41
       
    2:         dt1 = self.theclass(*args)
    2:         dt2 = C(*args, **{'extra': 7})
       
    2:         self.assertEqual(dt2.__class__, C)
    2:         self.assertEqual(dt2.theAnswer, 42)
    2:         self.assertEqual(dt2.extra, 7)
    2:         self.assertEqual(dt1.toordinal(), dt2.toordinal())
    2:         self.assertEqual(dt2.newmeth(-7), dt1.year + dt1.month +
    2:                                           dt1.second - 7)
       
    2: class SubclassTime(time):
    1:     sub_var = 1
       
    2: class TestTime(HarmlessMixedComparison, unittest.TestCase):
       
    1:     theclass = time
       
    1:     def test_basic_attributes(self):
    2:         t = self.theclass(12, 0)
    2:         self.assertEqual(t.hour, 12)
    2:         self.assertEqual(t.minute, 0)
    2:         self.assertEqual(t.second, 0)
    2:         self.assertEqual(t.microsecond, 0)
       
    1:     def test_basic_attributes_nonzero(self):
               # Make sure all attributes are non-zero so bugs in
               # bit-shifting access show up.
    2:         t = self.theclass(12, 59, 59, 8000)
    2:         self.assertEqual(t.hour, 12)
    2:         self.assertEqual(t.minute, 59)
    2:         self.assertEqual(t.second, 59)
    2:         self.assertEqual(t.microsecond, 8000)
       
    1:     def test_roundtrip(self):
    2:         t = self.theclass(1, 2, 3, 4)
       
               # Verify t -> string -> time identity.
    2:         s = repr(t)
    2:         self.assertTrue(s.startswith('datetime.'))
    2:         s = s[9:]
    2:         t2 = eval(s)
    2:         self.assertEqual(t, t2)
       
               # Verify identity via reconstructing from pieces.
    2:         t2 = self.theclass(t.hour, t.minute, t.second,
    2:                            t.microsecond)
    2:         self.assertEqual(t, t2)
       
    1:     def test_comparing(self):
    2:         args = [1, 2, 3, 4]
    2:         t1 = self.theclass(*args)
    2:         t2 = self.theclass(*args)
    2:         self.assertTrue(t1 == t2)
    2:         self.assertTrue(t1 <= t2)
    2:         self.assertTrue(t1 >= t2)
    2:         self.assertFalse(t1 != t2)
    2:         self.assertFalse(t1 < t2)
    2:         self.assertFalse(t1 > t2)
    2:         self.assertEqual(cmp(t1, t2), 0)
    2:         self.assertEqual(cmp(t2, t1), 0)
       
   10:         for i in range(len(args)):
    8:             newargs = args[:]
    8:             newargs[i] = args[i] + 1
    8:             t2 = self.theclass(*newargs)   # this is larger than t1
    8:             self.assertTrue(t1 < t2)
    8:             self.assertTrue(t2 > t1)
    8:             self.assertTrue(t1 <= t2)
    8:             self.assertTrue(t2 >= t1)
    8:             self.assertTrue(t1 != t2)
    8:             self.assertTrue(t2 != t1)
    8:             self.assertFalse(t1 == t2)
    8:             self.assertFalse(t2 == t1)
    8:             self.assertFalse(t1 > t2)
    8:             self.assertFalse(t2 < t1)
    8:             self.assertFalse(t1 >= t2)
    8:             self.assertFalse(t2 <= t1)
    8:             self.assertEqual(cmp(t1, t2), -1)
    8:             self.assertEqual(cmp(t2, t1), 1)
       
   16:         for badarg in OTHERSTUFF:
   14:             self.assertEqual(t1 == badarg, False)
   14:             self.assertEqual(t1 != badarg, True)
   14:             self.assertEqual(badarg == t1, False)
   14:             self.assertEqual(badarg != t1, True)
       
   28:             self.assertRaises(TypeError, lambda: t1 <= badarg)
   28:             self.assertRaises(TypeError, lambda: t1 < badarg)
   28:             self.assertRaises(TypeError, lambda: t1 > badarg)
   28:             self.assertRaises(TypeError, lambda: t1 >= badarg)
   28:             self.assertRaises(TypeError, lambda: badarg <= t1)
   28:             self.assertRaises(TypeError, lambda: badarg < t1)
   28:             self.assertRaises(TypeError, lambda: badarg > t1)
   28:             self.assertRaises(TypeError, lambda: badarg >= t1)
       
    1:     def test_bad_constructor_arguments(self):
               # bad hours
    2:         self.theclass(0, 0)    # no exception
    2:         self.theclass(23, 0)   # no exception
    2:         self.assertRaises(ValueError, self.theclass, -1, 0)
    2:         self.assertRaises(ValueError, self.theclass, 24, 0)
               # bad minutes
    2:         self.theclass(23, 0)    # no exception
    2:         self.theclass(23, 59)   # no exception
    2:         self.assertRaises(ValueError, self.theclass, 23, -1)
    2:         self.assertRaises(ValueError, self.theclass, 23, 60)
               # bad seconds
    2:         self.theclass(23, 59, 0)    # no exception
    2:         self.theclass(23, 59, 59)   # no exception
    2:         self.assertRaises(ValueError, self.theclass, 23, 59, -1)
    2:         self.assertRaises(ValueError, self.theclass, 23, 59, 60)
               # bad microseconds
    2:         self.theclass(23, 59, 59, 0)        # no exception
    2:         self.theclass(23, 59, 59, 999999)   # no exception
    2:         self.assertRaises(ValueError, self.theclass, 23, 59, 59, -1)
    2:         self.assertRaises(ValueError, self.theclass, 23, 59, 59, 1000000)
       
    1:     def test_hash_equality(self):
    2:         d = self.theclass(23, 30, 17)
    2:         e = self.theclass(23, 30, 17)
    2:         self.assertEqual(d, e)
    2:         self.assertEqual(hash(d), hash(e))
       
    2:         dic = {d: 1}
    2:         dic[e] = 2
    2:         self.assertEqual(len(dic), 1)
    2:         self.assertEqual(dic[d], 2)
    2:         self.assertEqual(dic[e], 2)
       
    2:         d = self.theclass(0,  5, 17)
    2:         e = self.theclass(0,  5, 17)
    2:         self.assertEqual(d, e)
    2:         self.assertEqual(hash(d), hash(e))
       
    2:         dic = {d: 1}
    2:         dic[e] = 2
    2:         self.assertEqual(len(dic), 1)
    2:         self.assertEqual(dic[d], 2)
    2:         self.assertEqual(dic[e], 2)
       
    1:     def test_isoformat(self):
    2:         t = self.theclass(4, 5, 1, 123)
    2:         self.assertEqual(t.isoformat(), "04:05:01.000123")
    2:         self.assertEqual(t.isoformat(), str(t))
       
    2:         t = self.theclass()
    2:         self.assertEqual(t.isoformat(), "00:00:00")
    2:         self.assertEqual(t.isoformat(), str(t))
       
    2:         t = self.theclass(microsecond=1)
    2:         self.assertEqual(t.isoformat(), "00:00:00.000001")
    2:         self.assertEqual(t.isoformat(), str(t))
       
    2:         t = self.theclass(microsecond=10)
    2:         self.assertEqual(t.isoformat(), "00:00:00.000010")
    2:         self.assertEqual(t.isoformat(), str(t))
       
    2:         t = self.theclass(microsecond=100)
    2:         self.assertEqual(t.isoformat(), "00:00:00.000100")
    2:         self.assertEqual(t.isoformat(), str(t))
       
    2:         t = self.theclass(microsecond=1000)
    2:         self.assertEqual(t.isoformat(), "00:00:00.001000")
    2:         self.assertEqual(t.isoformat(), str(t))
       
    2:         t = self.theclass(microsecond=10000)
    2:         self.assertEqual(t.isoformat(), "00:00:00.010000")
    2:         self.assertEqual(t.isoformat(), str(t))
       
    2:         t = self.theclass(microsecond=100000)
    2:         self.assertEqual(t.isoformat(), "00:00:00.100000")
    2:         self.assertEqual(t.isoformat(), str(t))
       
    1:     def test_1653736(self):
               # verify it doesn't accept extra keyword arguments
    2:         t = self.theclass(second=1)
    2:         self.assertRaises(TypeError, t.isoformat, foo=3)
       
    1:     def test_strftime(self):
    2:         t = self.theclass(1, 2, 3, 4)
    2:         self.assertEqual(t.strftime('%H %M %S %f'), "01 02 03 000004")
               # A naive object replaces %z and %Z with empty strings.
    2:         self.assertEqual(t.strftime("'%z' '%Z'"), "'' ''")
       
    1:     def test_format(self):
    2:         t = self.theclass(1, 2, 3, 4)
    2:         self.assertEqual(t.__format__(''), str(t))
       
               # check that a derived class's __str__() gets called
    4:         class A(self.theclass):
    2:             def __str__(self):
    2:                 return 'A'
    2:         a = A(1, 2, 3, 4)
    2:         self.assertEqual(a.__format__(''), 'A')
       
               # check that a derived class's strftime gets called
    4:         class B(self.theclass):
    2:             def strftime(self, format_spec):
    2:                 return 'B'
    2:         b = B(1, 2, 3, 4)
    2:         self.assertEqual(b.__format__(''), str(t))
       
    4:         for fmt in ['%H %M %S',
                           ]:
    2:             self.assertEqual(t.__format__(fmt), t.strftime(fmt))
    2:             self.assertEqual(a.__format__(fmt), t.strftime(fmt))
    2:             self.assertEqual(b.__format__(fmt), 'B')
       
    1:     def test_str(self):
    2:         self.assertEqual(str(self.theclass(1, 2, 3, 4)), "01:02:03.000004")
    2:         self.assertEqual(str(self.theclass(10, 2, 3, 4000)), "10:02:03.004000")
    2:         self.assertEqual(str(self.theclass(0, 2, 3, 400000)), "00:02:03.400000")
    2:         self.assertEqual(str(self.theclass(12, 2, 3, 0)), "12:02:03")
    2:         self.assertEqual(str(self.theclass(23, 15, 0, 0)), "23:15:00")
       
    1:     def test_repr(self):
    2:         name = 'datetime.' + self.theclass.__name__
    2:         self.assertEqual(repr(self.theclass(1, 2, 3, 4)),
    2:                          "%s(1, 2, 3, 4)" % name)
    2:         self.assertEqual(repr(self.theclass(10, 2, 3, 4000)),
    2:                          "%s(10, 2, 3, 4000)" % name)
    2:         self.assertEqual(repr(self.theclass(0, 2, 3, 400000)),
    2:                          "%s(0, 2, 3, 400000)" % name)
    2:         self.assertEqual(repr(self.theclass(12, 2, 3, 0)),
    2:                          "%s(12, 2, 3)" % name)
    2:         self.assertEqual(repr(self.theclass(23, 15, 0, 0)),
    2:                          "%s(23, 15)" % name)
       
    1:     def test_resolution_info(self):
    2:         self.assertIsInstance(self.theclass.min, self.theclass)
    2:         self.assertIsInstance(self.theclass.max, self.theclass)
    2:         self.assertIsInstance(self.theclass.resolution, timedelta)
    2:         self.assertTrue(self.theclass.max > self.theclass.min)
       
    1:     def test_pickling(self):
    1:         args = 20, 59, 16, 64**2
    1:         orig = self.theclass(*args)
   13:         for pickler, unpickler, proto in pickle_choices:
   12:             green = pickler.dumps(orig, proto)
   12:             derived = unpickler.loads(green)
   12:             self.assertEqual(orig, derived)
       
    1:     def test_pickling_subclass_time(self):
    2:         args = 20, 59, 16, 64**2
    2:         orig = SubclassTime(*args)
   26:         for pickler, unpickler, proto in pickle_choices:
   24:             green = pickler.dumps(orig, proto)
   24:             derived = unpickler.loads(green)
   24:             self.assertEqual(orig, derived)
       
    1:     def test_bool(self):
    2:         cls = self.theclass
    2:         self.assertTrue(cls(1))
    2:         self.assertTrue(cls(0, 1))
    2:         self.assertTrue(cls(0, 0, 1))
    2:         self.assertTrue(cls(0, 0, 0, 1))
    2:         self.assertFalse(cls(0))
    2:         self.assertFalse(cls())
       
    1:     def test_replace(self):
    1:         cls = self.theclass
    1:         args = [1, 2, 3, 4]
    1:         base = cls(*args)
    1:         self.assertEqual(base, base.replace())
       
    1:         i = 0
    1:         for name, newval in (("hour", 5),
    1:                              ("minute", 6),
    1:                              ("second", 7),
    5:                              ("microsecond", 8)):
    4:             newargs = args[:]
    4:             newargs[i] = newval
    4:             expected = cls(*newargs)
    4:             got = base.replace(**{name: newval})
    4:             self.assertEqual(expected, got)
    4:             i += 1
       
               # Out of bounds.
    1:         base = cls(1)
    1:         self.assertRaises(ValueError, base.replace, hour=24)
    1:         self.assertRaises(ValueError, base.replace, minute=-1)
    1:         self.assertRaises(ValueError, base.replace, second=100)
    1:         self.assertRaises(ValueError, base.replace, microsecond=1000000)
       
    1:     def test_subclass_time(self):
       
    4:         class C(self.theclass):
    2:             theAnswer = 42
       
    2:             def __new__(cls, *args, **kws):
    2:                 temp = kws.copy()
    2:                 extra = temp.pop('extra')
    2:                 result = self.theclass.__new__(cls, *args, **temp)
    2:                 result.extra = extra
    2:                 return result
       
    2:             def newmeth(self, start):
    2:                 return start + self.hour + self.second
       
    2:         args = 4, 5, 6
       
    2:         dt1 = self.theclass(*args)
    2:         dt2 = C(*args, **{'extra': 7})
       
    2:         self.assertEqual(dt2.__class__, C)
    2:         self.assertEqual(dt2.theAnswer, 42)
    2:         self.assertEqual(dt2.extra, 7)
    2:         self.assertEqual(dt1.isoformat(), dt2.isoformat())
    2:         self.assertEqual(dt2.newmeth(-7), dt1.hour + dt1.second - 7)
       
    1:     def test_backdoor_resistance(self):
               # see TestDate.test_backdoor_resistance().
    2:         base = '2:59.0'
   10:         for hour_byte in ' ', '9', chr(24), '\xff':
    8:             self.assertRaises(TypeError, self.theclass,
    8:                                          hour_byte + base[1:])
       
       # A mixin for classes with a tzinfo= argument.  Subclasses must define
       # theclass as a class attribute, and theclass(1, 1, 1, tzinfo=whatever)
       # must be legit (which is true for time and datetime).
    2: class TZInfoBase:
       
    1:     def test_argument_passing(self):
    2:         cls = self.theclass
               # A datetime passes itself on, a time passes None.
    4:         class introspective(tzinfo):
    4:             def tzname(self, dt):    return dt and "real" or "none"
    2:             def utcoffset(self, dt):
    4:                 return timedelta(minutes = dt and 42 or -42)
    2:             dst = utcoffset
       
    2:         obj = cls(1, 2, 3, tzinfo=introspective())
       
    2:         expected = cls is time and "none" or "real"
    2:         self.assertEqual(obj.tzname(), expected)
       
    2:         expected = timedelta(minutes=(cls is time and -42 or 42))
    2:         self.assertEqual(obj.utcoffset(), expected)
    2:         self.assertEqual(obj.dst(), expected)
       
    1:     def test_bad_tzinfo_classes(self):
    2:         cls = self.theclass
    2:         self.assertRaises(TypeError, cls, 1, 1, 1, tzinfo=12)
       
    4:         class NiceTry(object):
    2:             def __init__(self): pass
    2:             def utcoffset(self, dt): pass
    2:         self.assertRaises(TypeError, cls, 1, 1, 1, tzinfo=NiceTry)
       
    4:         class BetterTry(tzinfo):
    4:             def __init__(self): pass
    2:             def utcoffset(self, dt): pass
    2:         b = BetterTry()
    2:         t = cls(1, 1, 1, tzinfo=b)
    2:         self.assertIs(t.tzinfo, b)
       
    1:     def test_utc_offset_out_of_bounds(self):
    4:         class Edgy(tzinfo):
    2:             def __init__(self, offset):
    8:                 self.offset = timedelta(minutes=offset)
    2:             def utcoffset(self, dt):
    8:                 return self.offset
       
    2:         cls = self.theclass
    2:         for offset, legit in ((-1440, False),
    2:                               (-1439, True),
    2:                               (1439, True),
   10:                               (1440, False)):
    8:             if cls is time:
    4:                 t = cls(1, 2, 3, tzinfo=Edgy(offset))
    4:             elif cls is datetime:
    4:                 t = cls(6, 6, 6, 1, 2, 3, tzinfo=Edgy(offset))
                   else:
>>>>>>                 assert 0, "impossible"
    8:             if legit:
    4:                 aofs = abs(offset)
    4:                 h, m = divmod(aofs, 60)
    4:                 tag = "%c%02d:%02d" % (offset < 0 and '-' or '+', h, m)
    4:                 if isinstance(t, datetime):
    2:                     t = t.timetz()
    4:                 self.assertEqual(str(t), "01:02:03" + tag)
                   else:
    4:                 self.assertRaises(ValueError, str, t)
       
    1:     def test_tzinfo_classes(self):
    2:         cls = self.theclass
    4:         class C1(tzinfo):
    4:             def utcoffset(self, dt): return None
    4:             def dst(self, dt): return None
    4:             def tzname(self, dt): return None
    2:         for t in (cls(1, 1, 1),
    2:                   cls(1, 1, 1, tzinfo=None),
    8:                   cls(1, 1, 1, tzinfo=C1())):
    6:             self.assertIsNone(t.utcoffset())
    6:             self.assertIsNone(t.dst())
    6:             self.assertIsNone(t.tzname())
       
    4:         class C3(tzinfo):
    4:             def utcoffset(self, dt): return timedelta(minutes=-1439)
    4:             def dst(self, dt): return timedelta(minutes=1439)
    4:             def tzname(self, dt): return "aname"
    2:         t = cls(1, 1, 1, tzinfo=C3())
    2:         self.assertEqual(t.utcoffset(), timedelta(minutes=-1439))
    2:         self.assertEqual(t.dst(), timedelta(minutes=1439))
    2:         self.assertEqual(t.tzname(), "aname")
       
               # Wrong types.
    4:         class C4(tzinfo):
    4:             def utcoffset(self, dt): return "aname"
    4:             def dst(self, dt): return 7
    4:             def tzname(self, dt): return 0
    2:         t = cls(1, 1, 1, tzinfo=C4())
    2:         self.assertRaises(TypeError, t.utcoffset)
    2:         self.assertRaises(TypeError, t.dst)
    2:         self.assertRaises(TypeError, t.tzname)
       
               # Offset out of range.
    4:         class C6(tzinfo):
    4:             def utcoffset(self, dt): return timedelta(hours=-24)
    4:             def dst(self, dt): return timedelta(hours=24)
    2:         t = cls(1, 1, 1, tzinfo=C6())
    2:         self.assertRaises(ValueError, t.utcoffset)
    2:         self.assertRaises(ValueError, t.dst)
       
               # Not a whole number of minutes.
    4:         class C7(tzinfo):
    4:             def utcoffset(self, dt): return timedelta(seconds=61)
    4:             def dst(self, dt): return timedelta(microseconds=-81)
    2:         t = cls(1, 1, 1, tzinfo=C7())
    2:         self.assertRaises(ValueError, t.utcoffset)
    2:         self.assertRaises(ValueError, t.dst)
       
    1:     def test_aware_compare(self):
    2:         cls = self.theclass
       
               # Ensure that utcoffset() gets ignored if the comparands have
               # the same tzinfo member.
    4:         class OperandDependentOffset(tzinfo):
    2:             def utcoffset(self, t):
   48:                 if t.minute < 10:
                           # d0 and d1 equal after adjustment
   28:                     return timedelta(minutes=t.minute)
                       else:
                           # d2 off in the weeds
   20:                     return timedelta(minutes=59)
       
    2:         base = cls(8, 9, 10, tzinfo=OperandDependentOffset())
    2:         d0 = base.replace(minute=3)
    2:         d1 = base.replace(minute=9)
    2:         d2 = base.replace(minute=11)
    8:         for x in d0, d1, d2:
   24:             for y in d0, d1, d2:
   18:                 got = cmp(x, y)
   18:                 expected = cmp(x.minute, y.minute)
   18:                 self.assertEqual(got, expected)
       
               # However, if they're different members, uctoffset is not ignored.
               # Note that a time can't actually have an operand-depedent offset,
               # though (and time.utcoffset() passes None to tzinfo.utcoffset()),
               # so skip this test for time.
    2:         if cls is not time:
    1:             d0 = base.replace(minute=3, tzinfo=OperandDependentOffset())
    1:             d1 = base.replace(minute=9, tzinfo=OperandDependentOffset())
    1:             d2 = base.replace(minute=11, tzinfo=OperandDependentOffset())
    4:             for x in d0, d1, d2:
   12:                 for y in d0, d1, d2:
    9:                     got = cmp(x, y)
    9:                     if (x is d0 or x is d1) and (y is d0 or y is d1):
    4:                         expected = 0
    5:                     elif x is y is d2:
    1:                         expected = 0
    4:                     elif x is d2:
    2:                         expected = -1
                           else:
    2:                         assert y is d2
    2:                         expected = 1
    9:                     self.assertEqual(got, expected)
       
       
       # Testing time objects with a non-None tzinfo.
    2: class TestTimeTZ(TestTime, TZInfoBase, unittest.TestCase):
    1:     theclass = time
       
    1:     def test_empty(self):
    1:         t = self.theclass()
    1:         self.assertEqual(t.hour, 0)
    1:         self.assertEqual(t.minute, 0)
    1:         self.assertEqual(t.second, 0)
    1:         self.assertEqual(t.microsecond, 0)
    1:         self.assertIsNone(t.tzinfo)
       
    1:     def test_zones(self):
    1:         est = FixedOffset(-300, "EST", 1)
    1:         utc = FixedOffset(0, "UTC", -2)
    1:         met = FixedOffset(60, "MET", 3)
    1:         t1 = time( 7, 47, tzinfo=est)
    1:         t2 = time(12, 47, tzinfo=utc)
    1:         t3 = time(13, 47, tzinfo=met)
    1:         t4 = time(microsecond=40)
    1:         t5 = time(microsecond=40, tzinfo=utc)
       
    1:         self.assertEqual(t1.tzinfo, est)
    1:         self.assertEqual(t2.tzinfo, utc)
    1:         self.assertEqual(t3.tzinfo, met)
    1:         self.assertIsNone(t4.tzinfo)
    1:         self.assertEqual(t5.tzinfo, utc)
       
    1:         self.assertEqual(t1.utcoffset(), timedelta(minutes=-300))
    1:         self.assertEqual(t2.utcoffset(), timedelta(minutes=0))
    1:         self.assertEqual(t3.utcoffset(), timedelta(minutes=60))
    1:         self.assertIsNone(t4.utcoffset())
    1:         self.assertRaises(TypeError, t1.utcoffset, "no args")
       
    1:         self.assertEqual(t1.tzname(), "EST")
    1:         self.assertEqual(t2.tzname(), "UTC")
    1:         self.assertEqual(t3.tzname(), "MET")
    1:         self.assertIsNone(t4.tzname())
    1:         self.assertRaises(TypeError, t1.tzname, "no args")
       
    1:         self.assertEqual(t1.dst(), timedelta(minutes=1))
    1:         self.assertEqual(t2.dst(), timedelta(minutes=-2))
    1:         self.assertEqual(t3.dst(), timedelta(minutes=3))
    1:         self.assertIsNone(t4.dst())
    1:         self.assertRaises(TypeError, t1.dst, "no args")
       
    1:         self.assertEqual(hash(t1), hash(t2))
    1:         self.assertEqual(hash(t1), hash(t3))
    1:         self.assertEqual(hash(t2), hash(t3))
       
    1:         self.assertEqual(t1, t2)
    1:         self.assertEqual(t1, t3)
    1:         self.assertEqual(t2, t3)
    2:         self.assertRaises(TypeError, lambda: t4 == t5) # mixed tz-aware & naive
    2:         self.assertRaises(TypeError, lambda: t4 < t5) # mixed tz-aware & naive
    2:         self.assertRaises(TypeError, lambda: t5 < t4) # mixed tz-aware & naive
       
    1:         self.assertEqual(str(t1), "07:47:00-05:00")
    1:         self.assertEqual(str(t2), "12:47:00+00:00")
    1:         self.assertEqual(str(t3), "13:47:00+01:00")
    1:         self.assertEqual(str(t4), "00:00:00.000040")
    1:         self.assertEqual(str(t5), "00:00:00.000040+00:00")
       
    1:         self.assertEqual(t1.isoformat(), "07:47:00-05:00")
    1:         self.assertEqual(t2.isoformat(), "12:47:00+00:00")
    1:         self.assertEqual(t3.isoformat(), "13:47:00+01:00")
    1:         self.assertEqual(t4.isoformat(), "00:00:00.000040")
    1:         self.assertEqual(t5.isoformat(), "00:00:00.000040+00:00")
       
    1:         d = 'datetime.time'
    1:         self.assertEqual(repr(t1), d + "(7, 47, tzinfo=est)")
    1:         self.assertEqual(repr(t2), d + "(12, 47, tzinfo=utc)")
    1:         self.assertEqual(repr(t3), d + "(13, 47, tzinfo=met)")
    1:         self.assertEqual(repr(t4), d + "(0, 0, 0, 40)")
    1:         self.assertEqual(repr(t5), d + "(0, 0, 0, 40, tzinfo=utc)")
       
    1:         self.assertEqual(t1.strftime("%H:%M:%S %%Z=%Z %%z=%z"),
    1:                                      "07:47:00 %Z=EST %z=-0500")
    1:         self.assertEqual(t2.strftime("%H:%M:%S %Z %z"), "12:47:00 UTC +0000")
    1:         self.assertEqual(t3.strftime("%H:%M:%S %Z %z"), "13:47:00 MET +0100")
       
    1:         yuck = FixedOffset(-1439, "%z %Z %%z%%Z")
    1:         t1 = time(23, 59, tzinfo=yuck)
    1:         self.assertEqual(t1.strftime("%H:%M %%Z='%Z' %%z='%z'"),
    1:                                      "23:59 %Z='%z %Z %%z%%Z' %z='-2359'")
       
               # Check that an invalid tzname result raises an exception.
    2:         class Badtzname(tzinfo):
    2:             def tzname(self, dt): return 42
    1:         t = time(2, 3, 4, tzinfo=Badtzname())
    1:         self.assertEqual(t.strftime("%H:%M:%S"), "02:03:04")
    1:         self.assertRaises(TypeError, t.strftime, "%Z")
       
    1:     def test_hash_edge_cases(self):
               # Offsets that overflow a basic time.
    1:         t1 = self.theclass(0, 1, 2, 3, tzinfo=FixedOffset(1439, ""))
    1:         t2 = self.theclass(0, 0, 2, 3, tzinfo=FixedOffset(1438, ""))
    1:         self.assertEqual(hash(t1), hash(t2))
       
    1:         t1 = self.theclass(23, 58, 6, 100, tzinfo=FixedOffset(-1000, ""))
    1:         t2 = self.theclass(23, 48, 6, 100, tzinfo=FixedOffset(-1010, ""))
    1:         self.assertEqual(hash(t1), hash(t2))
       
    1:     def test_pickling(self):
               # Try one without a tzinfo.
    1:         args = 20, 59, 16, 64**2
    1:         orig = self.theclass(*args)
   13:         for pickler, unpickler, proto in pickle_choices:
   12:             green = pickler.dumps(orig, proto)
   12:             derived = unpickler.loads(green)
   12:             self.assertEqual(orig, derived)
       
               # Try one with a tzinfo.
    1:         tinfo = PicklableFixedOffset(-300, 'cookie')
    1:         orig = self.theclass(5, 6, 7, tzinfo=tinfo)
   13:         for pickler, unpickler, proto in pickle_choices:
   12:             green = pickler.dumps(orig, proto)
   12:             derived = unpickler.loads(green)
   12:             self.assertEqual(orig, derived)
   12:             self.assertIsInstance(derived.tzinfo, PicklableFixedOffset)
   12:             self.assertEqual(derived.utcoffset(), timedelta(minutes=-300))
   12:             self.assertEqual(derived.tzname(), 'cookie')
       
    1:     def test_more_bool(self):
               # Test cases with non-None tzinfo.
    1:         cls = self.theclass
       
    1:         t = cls(0, tzinfo=FixedOffset(-300, ""))
    1:         self.assertTrue(t)
       
    1:         t = cls(5, tzinfo=FixedOffset(-300, ""))
    1:         self.assertTrue(t)
       
    1:         t = cls(5, tzinfo=FixedOffset(300, ""))
    1:         self.assertFalse(t)
       
    1:         t = cls(23, 59, tzinfo=FixedOffset(23*60 + 59, ""))
    1:         self.assertFalse(t)
       
               # Mostly ensuring this doesn't overflow internally.
    1:         t = cls(0, tzinfo=FixedOffset(23*60 + 59, ""))
    1:         self.assertTrue(t)
       
               # But this should yield a value error -- the utcoffset is bogus.
    1:         t = cls(0, tzinfo=FixedOffset(24*60, ""))
    2:         self.assertRaises(ValueError, lambda: bool(t))
       
               # Likewise.
    1:         t = cls(0, tzinfo=FixedOffset(-24*60, ""))
    2:         self.assertRaises(ValueError, lambda: bool(t))
       
    1:     def test_replace(self):
    1:         cls = self.theclass
    1:         z100 = FixedOffset(100, "+100")
    1:         zm200 = FixedOffset(timedelta(minutes=-200), "-200")
    1:         args = [1, 2, 3, 4, z100]
    1:         base = cls(*args)
    1:         self.assertEqual(base, base.replace())
       
    1:         i = 0
    1:         for name, newval in (("hour", 5),
    1:                              ("minute", 6),
    1:                              ("second", 7),
    1:                              ("microsecond", 8),
    6:                              ("tzinfo", zm200)):
    5:             newargs = args[:]
    5:             newargs[i] = newval
    5:             expected = cls(*newargs)
    5:             got = base.replace(**{name: newval})
    5:             self.assertEqual(expected, got)
    5:             i += 1
       
               # Ensure we can get rid of a tzinfo.
    1:         self.assertEqual(base.tzname(), "+100")
    1:         base2 = base.replace(tzinfo=None)
    1:         self.assertIsNone(base2.tzinfo)
    1:         self.assertIsNone(base2.tzname())
       
               # Ensure we can add one.
    1:         base3 = base2.replace(tzinfo=z100)
    1:         self.assertEqual(base, base3)
    1:         self.assertIs(base.tzinfo, base3.tzinfo)
       
               # Out of bounds.
    1:         base = cls(1)
    1:         self.assertRaises(ValueError, base.replace, hour=24)
    1:         self.assertRaises(ValueError, base.replace, minute=-1)
    1:         self.assertRaises(ValueError, base.replace, second=100)
    1:         self.assertRaises(ValueError, base.replace, microsecond=1000000)
       
    1:     def test_mixed_compare(self):
    1:         t1 = time(1, 2, 3)
    1:         t2 = time(1, 2, 3)
    1:         self.assertEqual(t1, t2)
    1:         t2 = t2.replace(tzinfo=None)
    1:         self.assertEqual(t1, t2)
    1:         t2 = t2.replace(tzinfo=FixedOffset(None, ""))
    1:         self.assertEqual(t1, t2)
    1:         t2 = t2.replace(tzinfo=FixedOffset(0, ""))
    2:         self.assertRaises(TypeError, lambda: t1 == t2)
       
               # In time w/ identical tzinfo objects, utcoffset is ignored.
    2:         class Varies(tzinfo):
    1:             def __init__(self):
    2:                 self.offset = timedelta(minutes=22)
    1:             def utcoffset(self, t):
    4:                 self.offset += timedelta(minutes=1)
    4:                 return self.offset
       
    1:         v = Varies()
    1:         t1 = t2.replace(tzinfo=v)
    1:         t2 = t2.replace(tzinfo=v)
    1:         self.assertEqual(t1.utcoffset(), timedelta(minutes=23))
    1:         self.assertEqual(t2.utcoffset(), timedelta(minutes=24))
    1:         self.assertEqual(t1, t2)
       
               # But if they're not identical, it isn't ignored.
    1:         t2 = t2.replace(tzinfo=Varies())
    1:         self.assertTrue(t1 < t2)  # t1's offset counter still going up
       
    1:     def test_subclass_timetz(self):
       
    2:         class C(self.theclass):
    1:             theAnswer = 42
       
    1:             def __new__(cls, *args, **kws):
    1:                 temp = kws.copy()
    1:                 extra = temp.pop('extra')
    1:                 result = self.theclass.__new__(cls, *args, **temp)
    1:                 result.extra = extra
    1:                 return result
       
    1:             def newmeth(self, start):
    1:                 return start + self.hour + self.second
       
    1:         args = 4, 5, 6, 500, FixedOffset(-300, "EST", 1)
       
    1:         dt1 = self.theclass(*args)
    1:         dt2 = C(*args, **{'extra': 7})
       
    1:         self.assertEqual(dt2.__class__, C)
    1:         self.assertEqual(dt2.theAnswer, 42)
    1:         self.assertEqual(dt2.extra, 7)
    1:         self.assertEqual(dt1.utcoffset(), dt2.utcoffset())
    1:         self.assertEqual(dt2.newmeth(-7), dt1.hour + dt1.second - 7)
       
       
       # Testing datetime objects with a non-None tzinfo.
       
    2: class TestDateTimeTZ(TestDateTime, TZInfoBase, unittest.TestCase):
    1:     theclass = datetime
       
    1:     def test_trivial(self):
    1:         dt = self.theclass(1, 2, 3, 4, 5, 6, 7)
    1:         self.assertEqual(dt.year, 1)
    1:         self.assertEqual(dt.month, 2)
    1:         self.assertEqual(dt.day, 3)
    1:         self.assertEqual(dt.hour, 4)
    1:         self.assertEqual(dt.minute, 5)
    1:         self.assertEqual(dt.second, 6)
    1:         self.assertEqual(dt.microsecond, 7)
    1:         self.assertEqual(dt.tzinfo, None)
       
    1:     def test_even_more_compare(self):
               # The test_compare() and test_more_compare() inherited from TestDate
               # and TestDateTime covered non-tzinfo cases.
       
               # Smallest possible after UTC adjustment.
    1:         t1 = self.theclass(1, 1, 1, tzinfo=FixedOffset(1439, ""))
               # Largest possible after UTC adjustment.
    1:         t2 = self.theclass(MAXYEAR, 12, 31, 23, 59, 59, 999999,
    1:                            tzinfo=FixedOffset(-1439, ""))
       
               # Make sure those compare correctly, and w/o overflow.
    1:         self.assertTrue(t1 < t2)
    1:         self.assertTrue(t1 != t2)
    1:         self.assertTrue(t2 > t1)
       
    1:         self.assertTrue(t1 == t1)
    1:         self.assertTrue(t2 == t2)
       
               # Equal afer adjustment.
    1:         t1 = self.theclass(1, 12, 31, 23, 59, tzinfo=FixedOffset(1, ""))
    1:         t2 = self.theclass(2, 1, 1, 3, 13, tzinfo=FixedOffset(3*60+13+2, ""))
    1:         self.assertEqual(t1, t2)
       
               # Change t1 not to subtract a minute, and t1 should be larger.
    1:         t1 = self.theclass(1, 12, 31, 23, 59, tzinfo=FixedOffset(0, ""))
    1:         self.assertTrue(t1 > t2)
       
               # Change t1 to subtract 2 minutes, and t1 should be smaller.
    1:         t1 = self.theclass(1, 12, 31, 23, 59, tzinfo=FixedOffset(2, ""))
    1:         self.assertTrue(t1 < t2)
       
               # Back to the original t1, but make seconds resolve it.
    1:         t1 = self.theclass(1, 12, 31, 23, 59, tzinfo=FixedOffset(1, ""),
    1:                            second=1)
    1:         self.assertTrue(t1 > t2)
       
               # Likewise, but make microseconds resolve it.
    1:         t1 = self.theclass(1, 12, 31, 23, 59, tzinfo=FixedOffset(1, ""),
    1:                            microsecond=1)
    1:         self.assertTrue(t1 > t2)
       
               # Make t2 naive and it should fail.
    1:         t2 = self.theclass.min
    2:         self.assertRaises(TypeError, lambda: t1 == t2)
    1:         self.assertEqual(t2, t2)
       
               # It's also naive if it has tzinfo but tzinfo.utcoffset() is None.
    2:         class Naive(tzinfo):
    3:             def utcoffset(self, dt): return None
    1:         t2 = self.theclass(5, 6, 7, tzinfo=Naive())
    2:         self.assertRaises(TypeError, lambda: t1 == t2)
    1:         self.assertEqual(t2, t2)
       
               # OTOH, it's OK to compare two of these mixing the two ways of being
               # naive.
    1:         t1 = self.theclass(5, 6, 7)
    1:         self.assertEqual(t1, t2)
       
               # Try a bogus uctoffset.
    2:         class Bogus(tzinfo):
    1:             def utcoffset(self, dt):
    1:                 return timedelta(minutes=1440) # out of bounds
    1:         t1 = self.theclass(2, 2, 2, tzinfo=Bogus())
    1:         t2 = self.theclass(2, 2, 2, tzinfo=FixedOffset(0, ""))
    2:         self.assertRaises(ValueError, lambda: t1 == t2)
       
    1:     def test_pickling(self):
               # Try one without a tzinfo.
    1:         args = 6, 7, 23, 20, 59, 1, 64**2
    1:         orig = self.theclass(*args)
   13:         for pickler, unpickler, proto in pickle_choices:
   12:             green = pickler.dumps(orig, proto)
   12:             derived = unpickler.loads(green)
   12:             self.assertEqual(orig, derived)
       
               # Try one with a tzinfo.
    1:         tinfo = PicklableFixedOffset(-300, 'cookie')
    1:         orig = self.theclass(*args, **{'tzinfo': tinfo})
    1:         derived = self.theclass(1, 1, 1, tzinfo=FixedOffset(0, "", 0))
   13:         for pickler, unpickler, proto in pickle_choices:
   12:             green = pickler.dumps(orig, proto)
   12:             derived = unpickler.loads(green)
   12:             self.assertEqual(orig, derived)
   12:             self.assertIsInstance(derived.tzinfo, PicklableFixedOffset)
   12:             self.assertEqual(derived.utcoffset(), timedelta(minutes=-300))
   12:             self.assertEqual(derived.tzname(), 'cookie')
       
    1:     def test_extreme_hashes(self):
               # If an attempt is made to hash these via subtracting the offset
               # then hashing a datetime object, OverflowError results.  The
               # Python implementation used to blow up here.
    1:         t = self.theclass(1, 1, 1, tzinfo=FixedOffset(1439, ""))
    1:         hash(t)
    1:         t = self.theclass(MAXYEAR, 12, 31, 23, 59, 59, 999999,
    1:                           tzinfo=FixedOffset(-1439, ""))
    1:         hash(t)
       
               # OTOH, an OOB offset should blow up.
    1:         t = self.theclass(5, 5, 5, tzinfo=FixedOffset(-1440, ""))
    1:         self.assertRaises(ValueError, hash, t)
       
    1:     def test_zones(self):
    1:         est = FixedOffset(-300, "EST")
    1:         utc = FixedOffset(0, "UTC")
    1:         met = FixedOffset(60, "MET")
    1:         t1 = datetime(2002, 3, 19,  7, 47, tzinfo=est)
    1:         t2 = datetime(2002, 3, 19, 12, 47, tzinfo=utc)
    1:         t3 = datetime(2002, 3, 19, 13, 47, tzinfo=met)
    1:         self.assertEqual(t1.tzinfo, est)
    1:         self.assertEqual(t2.tzinfo, utc)
    1:         self.assertEqual(t3.tzinfo, met)
    1:         self.assertEqual(t1.utcoffset(), timedelta(minutes=-300))
    1:         self.assertEqual(t2.utcoffset(), timedelta(minutes=0))
    1:         self.assertEqual(t3.utcoffset(), timedelta(minutes=60))
    1:         self.assertEqual(t1.tzname(), "EST")
    1:         self.assertEqual(t2.tzname(), "UTC")
    1:         self.assertEqual(t3.tzname(), "MET")
    1:         self.assertEqual(hash(t1), hash(t2))
    1:         self.assertEqual(hash(t1), hash(t3))
    1:         self.assertEqual(hash(t2), hash(t3))
    1:         self.assertEqual(t1, t2)
    1:         self.assertEqual(t1, t3)
    1:         self.assertEqual(t2, t3)
    1:         self.assertEqual(str(t1), "2002-03-19 07:47:00-05:00")
    1:         self.assertEqual(str(t2), "2002-03-19 12:47:00+00:00")
    1:         self.assertEqual(str(t3), "2002-03-19 13:47:00+01:00")
    1:         d = 'datetime.datetime(2002, 3, 19, '
    1:         self.assertEqual(repr(t1), d + "7, 47, tzinfo=est)")
    1:         self.assertEqual(repr(t2), d + "12, 47, tzinfo=utc)")
    1:         self.assertEqual(repr(t3), d + "13, 47, tzinfo=met)")
       
    1:     def test_combine(self):
    1:         met = FixedOffset(60, "MET")
    1:         d = date(2002, 3, 4)
    1:         tz = time(18, 45, 3, 1234, tzinfo=met)
    1:         dt = datetime.combine(d, tz)
    1:         self.assertEqual(dt, datetime(2002, 3, 4, 18, 45, 3, 1234,
    1:                                         tzinfo=met))
       
    1:     def test_extract(self):
    1:         met = FixedOffset(60, "MET")
    1:         dt = self.theclass(2002, 3, 4, 18, 45, 3, 1234, tzinfo=met)
    1:         self.assertEqual(dt.date(), date(2002, 3, 4))
    1:         self.assertEqual(dt.time(), time(18, 45, 3, 1234))
    1:         self.assertEqual(dt.timetz(), time(18, 45, 3, 1234, tzinfo=met))
       
    1:     def test_tz_aware_arithmetic(self):
    1:         import random
       
    1:         now = self.theclass.now()
    1:         tz55 = FixedOffset(-330, "west 5:30")
    1:         timeaware = now.time().replace(tzinfo=tz55)
    1:         nowaware = self.theclass.combine(now.date(), timeaware)
    1:         self.assertIs(nowaware.tzinfo, tz55)
    1:         self.assertEqual(nowaware.timetz(), timeaware)
       
               # Can't mix aware and non-aware.
    2:         self.assertRaises(TypeError, lambda: now - nowaware)
    2:         self.assertRaises(TypeError, lambda: nowaware - now)
       
               # And adding datetime's doesn't make sense, aware or not.
    2:         self.assertRaises(TypeError, lambda: now + nowaware)
    2:         self.assertRaises(TypeError, lambda: nowaware + now)
    2:         self.assertRaises(TypeError, lambda: nowaware + nowaware)
       
               # Subtracting should yield 0.
    1:         self.assertEqual(now - now, timedelta(0))
    1:         self.assertEqual(nowaware - nowaware, timedelta(0))
       
               # Adding a delta should preserve tzinfo.
    1:         delta = timedelta(weeks=1, minutes=12, microseconds=5678)
    1:         nowawareplus = nowaware + delta
    1:         self.assertIs(nowaware.tzinfo, tz55)
    1:         nowawareplus2 = delta + nowaware
    1:         self.assertIs(nowawareplus2.tzinfo, tz55)
    1:         self.assertEqual(nowawareplus, nowawareplus2)
       
               # that - delta should be what we started with, and that - what we
               # started with should be delta.
    1:         diff = nowawareplus - delta
    1:         self.assertIs(diff.tzinfo, tz55)
    1:         self.assertEqual(nowaware, diff)
    2:         self.assertRaises(TypeError, lambda: delta - nowawareplus)
    1:         self.assertEqual(nowawareplus - nowaware, delta)
       
               # Make up a random timezone.
    1:         tzr = FixedOffset(random.randrange(-1439, 1440), "randomtimezone")
               # Attach it to nowawareplus.
    1:         nowawareplus = nowawareplus.replace(tzinfo=tzr)
    1:         self.assertIs(nowawareplus.tzinfo, tzr)
               # Make sure the difference takes the timezone adjustments into account.
    1:         got = nowaware - nowawareplus
               # Expected:  (nowaware base - nowaware offset) -
               #            (nowawareplus base - nowawareplus offset) =
               #            (nowaware base - nowawareplus base) +
               #            (nowawareplus offset - nowaware offset) =
               #            -delta + nowawareplus offset - nowaware offset
    1:         expected = nowawareplus.utcoffset() - nowaware.utcoffset() - delta
    1:         self.assertEqual(got, expected)
       
               # Try max possible difference.
    1:         min = self.theclass(1, 1, 1, tzinfo=FixedOffset(1439, "min"))
    1:         max = self.theclass(MAXYEAR, 12, 31, 23, 59, 59, 999999,
    1:                             tzinfo=FixedOffset(-1439, "max"))
    1:         maxdiff = max - min
    1:         self.assertEqual(maxdiff, self.theclass.max - self.theclass.min +
    1:                                   timedelta(minutes=2*1439))
       
    1:     def test_tzinfo_now(self):
    1:         meth = self.theclass.now
               # Ensure it doesn't require tzinfo (i.e., that this doesn't blow up).
    1:         base = meth()
               # Try with and without naming the keyword.
    1:         off42 = FixedOffset(42, "42")
    1:         another = meth(off42)
    1:         again = meth(tz=off42)
    1:         self.assertIs(another.tzinfo, again.tzinfo)
    1:         self.assertEqual(another.utcoffset(), timedelta(minutes=42))
               # Bad argument with and w/o naming the keyword.
    1:         self.assertRaises(TypeError, meth, 16)
    1:         self.assertRaises(TypeError, meth, tzinfo=16)
               # Bad keyword name.
    1:         self.assertRaises(TypeError, meth, tinfo=off42)
               # Too many args.
    1:         self.assertRaises(TypeError, meth, off42, off42)
       
               # We don't know which time zone we're in, and don't have a tzinfo
               # class to represent it, so seeing whether a tz argument actually
               # does a conversion is tricky.
    1:         weirdtz = FixedOffset(timedelta(hours=15, minutes=58), "weirdtz", 0)
    1:         utc = FixedOffset(0, "utc", 0)
    1:         for dummy in range(3):
    1:             now = datetime.now(weirdtz)
    1:             self.assertIs(now.tzinfo, weirdtz)
    1:             utcnow = datetime.utcnow().replace(tzinfo=utc)
    1:             now2 = utcnow.astimezone(weirdtz)
    1:             if abs(now - now2) < timedelta(seconds=30):
    1:                 break
                   # Else the code is broken, or more than 30 seconds passed between
                   # calls; assuming the latter, just try again.
               else:
                   # Three strikes and we're out.
>>>>>>             self.fail("utcnow(), now(tz), or astimezone() may be broken")
       
    1:     def test_tzinfo_fromtimestamp(self):
    1:         import time
    1:         meth = self.theclass.fromtimestamp
    1:         ts = time.time()
               # Ensure it doesn't require tzinfo (i.e., that this doesn't blow up).
    1:         base = meth(ts)
               # Try with and without naming the keyword.
    1:         off42 = FixedOffset(42, "42")
    1:         another = meth(ts, off42)
    1:         again = meth(ts, tz=off42)
    1:         self.assertIs(another.tzinfo, again.tzinfo)
    1:         self.assertEqual(another.utcoffset(), timedelta(minutes=42))
               # Bad argument with and w/o naming the keyword.
    1:         self.assertRaises(TypeError, meth, ts, 16)
    1:         self.assertRaises(TypeError, meth, ts, tzinfo=16)
               # Bad keyword name.
    1:         self.assertRaises(TypeError, meth, ts, tinfo=off42)
               # Too many args.
    1:         self.assertRaises(TypeError, meth, ts, off42, off42)
               # Too few args.
    1:         self.assertRaises(TypeError, meth)
       
               # Try to make sure tz= actually does some conversion.
    1:         timestamp = 1000000000
    1:         utcdatetime = datetime.utcfromtimestamp(timestamp)
               # In POSIX (epoch 1970), that's 2001-09-09 01:46:40 UTC, give or take.
               # But on some flavor of Mac, it's nowhere near that.  So we can't have
               # any idea here what time that actually is, we can only test that
               # relative changes match.
    1:         utcoffset = timedelta(hours=-15, minutes=39) # arbitrary, but not zero
    1:         tz = FixedOffset(utcoffset, "tz", 0)
    1:         expected = utcdatetime + utcoffset
    1:         got = datetime.fromtimestamp(timestamp, tz)
    1:         self.assertEqual(expected, got.replace(tzinfo=None))
       
    1:     def test_tzinfo_utcnow(self):
    1:         meth = self.theclass.utcnow
               # Ensure it doesn't require tzinfo (i.e., that this doesn't blow up).
    1:         base = meth()
               # Try with and without naming the keyword; for whatever reason,
               # utcnow() doesn't accept a tzinfo argument.
    1:         off42 = FixedOffset(42, "42")
    1:         self.assertRaises(TypeError, meth, off42)
    1:         self.assertRaises(TypeError, meth, tzinfo=off42)
       
    1:     def test_tzinfo_utcfromtimestamp(self):
    1:         import time
    1:         meth = self.theclass.utcfromtimestamp
    1:         ts = time.time()
               # Ensure it doesn't require tzinfo (i.e., that this doesn't blow up).
    1:         base = meth(ts)
               # Try with and without naming the keyword; for whatever reason,
               # utcfromtimestamp() doesn't accept a tzinfo argument.
    1:         off42 = FixedOffset(42, "42")
    1:         self.assertRaises(TypeError, meth, ts, off42)
    1:         self.assertRaises(TypeError, meth, ts, tzinfo=off42)
       
    1:     def test_tzinfo_timetuple(self):
               # TestDateTime tested most of this.  datetime adds a twist to the
               # DST flag.
    2:         class DST(tzinfo):
    1:             def __init__(self, dstvalue):
    9:                 if isinstance(dstvalue, int):
    7:                     dstvalue = timedelta(minutes=dstvalue)
    9:                 self.dstvalue = dstvalue
    1:             def dst(self, dt):
    9:                 return self.dstvalue
       
    1:         cls = self.theclass
    5:         for dstvalue, flag in (-33, 1), (33, 1), (0, 0), (None, -1):
    4:             d = cls(1, 1, 1, 10, 20, 30, 40, tzinfo=DST(dstvalue))
    4:             t = d.timetuple()
    4:             self.assertEqual(1, t.tm_year)
    4:             self.assertEqual(1, t.tm_mon)
    4:             self.assertEqual(1, t.tm_mday)
    4:             self.assertEqual(10, t.tm_hour)
    4:             self.assertEqual(20, t.tm_min)
    4:             self.assertEqual(30, t.tm_sec)
    4:             self.assertEqual(0, t.tm_wday)
    4:             self.assertEqual(1, t.tm_yday)
    4:             self.assertEqual(flag, t.tm_isdst)
       
               # dst() returns wrong type.
    1:         self.assertRaises(TypeError, cls(1, 1, 1, tzinfo=DST("x")).timetuple)
       
               # dst() at the edge.
    1:         self.assertEqual(cls(1,1,1, tzinfo=DST(1439)).timetuple().tm_isdst, 1)
    1:         self.assertEqual(cls(1,1,1, tzinfo=DST(-1439)).timetuple().tm_isdst, 1)
       
               # dst() out of range.
    1:         self.assertRaises(ValueError, cls(1,1,1, tzinfo=DST(1440)).timetuple)
    1:         self.assertRaises(ValueError, cls(1,1,1, tzinfo=DST(-1440)).timetuple)
       
    1:     def test_utctimetuple(self):
    2:         class DST(tzinfo):
    1:             def __init__(self, dstvalue):
    7:                 if isinstance(dstvalue, int):
    4:                     dstvalue = timedelta(minutes=dstvalue)
    7:                 self.dstvalue = dstvalue
    1:             def dst(self, dt):
>>>>>>                 return self.dstvalue
       
    1:         cls = self.theclass
               # This can't work:  DST didn't implement utcoffset.
    1:         self.assertRaises(NotImplementedError,
    1:                           cls(1, 1, 1, tzinfo=DST(0)).utcoffset)
       
    2:         class UOFS(DST):
    1:             def __init__(self, uofs, dofs=None):
    6:                 DST.__init__(self, dofs)
    6:                 self.uofs = timedelta(minutes=uofs)
    1:             def utcoffset(self, dt):
    6:                 return self.uofs
       
               # Ensure tm_isdst is 0 regardless of what dst() says:  DST is never
               # in effect for a UTC time.
    5:         for dstvalue in -33, 33, 0, None:
    4:             d = cls(1, 2, 3, 10, 20, 30, 40, tzinfo=UOFS(-53, dstvalue))
    4:             t = d.utctimetuple()
    4:             self.assertEqual(d.year, t.tm_year)
    4:             self.assertEqual(d.month, t.tm_mon)
    4:             self.assertEqual(d.day, t.tm_mday)
    4:             self.assertEqual(11, t.tm_hour) # 20mm + 53mm = 1hn + 13mm
    4:             self.assertEqual(13, t.tm_min)
    4:             self.assertEqual(d.second, t.tm_sec)
    4:             self.assertEqual(d.weekday(), t.tm_wday)
    4:             self.assertEqual(d.toordinal() - date(1, 1, 1).toordinal() + 1,
    4:                              t.tm_yday)
    4:             self.assertEqual(0, t.tm_isdst)
       
               # At the edges, UTC adjustment can normalize into years out-of-range
               # for a datetime object.  Ensure that a correct timetuple is
               # created anyway.
    1:         tiny = cls(MINYEAR, 1, 1, 0, 0, 37, tzinfo=UOFS(1439))
               # That goes back 1 minute less than a full day.
    1:         t = tiny.utctimetuple()
    1:         self.assertEqual(t.tm_year, MINYEAR-1)
    1:         self.assertEqual(t.tm_mon, 12)
    1:         self.assertEqual(t.tm_mday, 31)
    1:         self.assertEqual(t.tm_hour, 0)
    1:         self.assertEqual(t.tm_min, 1)
    1:         self.assertEqual(t.tm_sec, 37)
    1:         self.assertEqual(t.tm_yday, 366)    # "year 0" is a leap year
    1:         self.assertEqual(t.tm_isdst, 0)
       
    1:         huge = cls(MAXYEAR, 12, 31, 23, 59, 37, 999999, tzinfo=UOFS(-1439))
               # That goes forward 1 minute less than a full day.
    1:         t = huge.utctimetuple()
    1:         self.assertEqual(t.tm_year, MAXYEAR+1)
    1:         self.assertEqual(t.tm_mon, 1)
    1:         self.assertEqual(t.tm_mday, 1)
    1:         self.assertEqual(t.tm_hour, 23)
    1:         self.assertEqual(t.tm_min, 58)
    1:         self.assertEqual(t.tm_sec, 37)
    1:         self.assertEqual(t.tm_yday, 1)
    1:         self.assertEqual(t.tm_isdst, 0)
       
    1:     def test_tzinfo_isoformat(self):
    1:         zero = FixedOffset(0, "+00:00")
    1:         plus = FixedOffset(220, "+03:40")
    1:         minus = FixedOffset(-231, "-03:51")
    1:         unknown = FixedOffset(None, "")
       
    1:         cls = self.theclass
    1:         datestr = '0001-02-03'
    6:         for ofs in None, zero, plus, minus, unknown:
   15:             for us in 0, 987001:
   10:                 d = cls(1, 2, 3, 4, 5, 59, us, tzinfo=ofs)
   10:                 timestr = '04:05:59' + (us and '.987001' or '')
   10:                 ofsstr = ofs is not None and d.tzname() or ''
   10:                 tailstr = timestr + ofsstr
   10:                 iso = d.isoformat()
   10:                 self.assertEqual(iso, datestr + 'T' + tailstr)
   10:                 self.assertEqual(iso, d.isoformat('T'))
   10:                 self.assertEqual(d.isoformat('k'), datestr + 'k' + tailstr)
   10:                 self.assertEqual(str(d), datestr + ' ' + tailstr)
       
    1:     def test_replace(self):
    1:         cls = self.theclass
    1:         z100 = FixedOffset(100, "+100")
    1:         zm200 = FixedOffset(timedelta(minutes=-200), "-200")
    1:         args = [1, 2, 3, 4, 5, 6, 7, z100]
    1:         base = cls(*args)
    1:         self.assertEqual(base, base.replace())
       
    1:         i = 0
    1:         for name, newval in (("year", 2),
    1:                              ("month", 3),
    1:                              ("day", 4),
    1:                              ("hour", 5),
    1:                              ("minute", 6),
    1:                              ("second", 7),
    1:                              ("microsecond", 8),
    9:                              ("tzinfo", zm200)):
    8:             newargs = args[:]
    8:             newargs[i] = newval
    8:             expected = cls(*newargs)
    8:             got = base.replace(**{name: newval})
    8:             self.assertEqual(expected, got)
    8:             i += 1
       
               # Ensure we can get rid of a tzinfo.
    1:         self.assertEqual(base.tzname(), "+100")
    1:         base2 = base.replace(tzinfo=None)
    1:         self.assertIsNone(base2.tzinfo)
    1:         self.assertIsNone(base2.tzname())
       
               # Ensure we can add one.
    1:         base3 = base2.replace(tzinfo=z100)
    1:         self.assertEqual(base, base3)
    1:         self.assertIs(base.tzinfo, base3.tzinfo)
       
               # Out of bounds.
    1:         base = cls(2000, 2, 29)
    1:         self.assertRaises(ValueError, base.replace, year=2001)
       
    1:     def test_more_astimezone(self):
               # The inherited test_astimezone covered some trivial and error cases.
    1:         fnone = FixedOffset(None, "None")
    1:         f44m = FixedOffset(44, "44")
    1:         fm5h = FixedOffset(-timedelta(hours=5), "m300")
       
    1:         dt = self.theclass.now(tz=f44m)
    1:         self.assertIs(dt.tzinfo, f44m)
               # Replacing with degenerate tzinfo raises an exception.
    1:         self.assertRaises(ValueError, dt.astimezone, fnone)
               # Ditto with None tz.
    1:         self.assertRaises(TypeError, dt.astimezone, None)
               # Replacing with same tzinfo makes no change.
    1:         x = dt.astimezone(dt.tzinfo)
    1:         self.assertIs(x.tzinfo, f44m)
    1:         self.assertEqual(x.date(), dt.date())
    1:         self.assertEqual(x.time(), dt.time())
       
               # Replacing with different tzinfo does adjust.
    1:         got = dt.astimezone(fm5h)
    1:         self.assertIs(got.tzinfo, fm5h)
    1:         self.assertEqual(got.utcoffset(), timedelta(hours=-5))
    1:         expected = dt - dt.utcoffset()  # in effect, convert to UTC
    1:         expected += fm5h.utcoffset(dt)  # and from there to local time
    1:         expected = expected.replace(tzinfo=fm5h) # and attach new tzinfo
    1:         self.assertEqual(got.date(), expected.date())
    1:         self.assertEqual(got.time(), expected.time())
    1:         self.assertEqual(got.timetz(), expected.timetz())
    1:         self.assertIs(got.tzinfo, expected.tzinfo)
    1:         self.assertEqual(got, expected)
       
    1:     def test_aware_subtract(self):
    1:         cls = self.theclass
       
               # Ensure that utcoffset() is ignored when the operands have the
               # same tzinfo member.
    2:         class OperandDependentOffset(tzinfo):
    1:             def utcoffset(self, t):
   12:                 if t.minute < 10:
                           # d0 and d1 equal after adjustment
    8:                     return timedelta(minutes=t.minute)
                       else:
                           # d2 off in the weeds
    4:                     return timedelta(minutes=59)
       
    1:         base = cls(8, 9, 10, 11, 12, 13, 14, tzinfo=OperandDependentOffset())
    1:         d0 = base.replace(minute=3)
    1:         d1 = base.replace(minute=9)
    1:         d2 = base.replace(minute=11)
    4:         for x in d0, d1, d2:
   12:             for y in d0, d1, d2:
    9:                 got = x - y
    9:                 expected = timedelta(minutes=x.minute - y.minute)
    9:                 self.assertEqual(got, expected)
       
               # OTOH, if the tzinfo members are distinct, utcoffsets aren't
               # ignored.
    1:         base = cls(8, 9, 10, 11, 12, 13, 14)
    1:         d0 = base.replace(minute=3, tzinfo=OperandDependentOffset())
    1:         d1 = base.replace(minute=9, tzinfo=OperandDependentOffset())
    1:         d2 = base.replace(minute=11, tzinfo=OperandDependentOffset())
    4:         for x in d0, d1, d2:
   12:             for y in d0, d1, d2:
    9:                 got = x - y
    9:                 if (x is d0 or x is d1) and (y is d0 or y is d1):
    4:                     expected = timedelta(0)
    5:                 elif x is y is d2:
    1:                     expected = timedelta(0)
    4:                 elif x is d2:
    2:                     expected = timedelta(minutes=(11-59)-0)
                       else:
    2:                     assert y is d2
    2:                     expected = timedelta(minutes=0-(11-59))
    9:                 self.assertEqual(got, expected)
       
    1:     def test_mixed_compare(self):
    1:         t1 = datetime(1, 2, 3, 4, 5, 6, 7)
    1:         t2 = datetime(1, 2, 3, 4, 5, 6, 7)
    1:         self.assertEqual(t1, t2)
    1:         t2 = t2.replace(tzinfo=None)
    1:         self.assertEqual(t1, t2)
    1:         t2 = t2.replace(tzinfo=FixedOffset(None, ""))
    1:         self.assertEqual(t1, t2)
    1:         t2 = t2.replace(tzinfo=FixedOffset(0, ""))
    2:         self.assertRaises(TypeError, lambda: t1 == t2)
       
               # In datetime w/ identical tzinfo objects, utcoffset is ignored.
    2:         class Varies(tzinfo):
    1:             def __init__(self):
    2:                 self.offset = timedelta(minutes=22)
    1:             def utcoffset(self, t):
    6:                 self.offset += timedelta(minutes=1)
    6:                 return self.offset
       
    1:         v = Varies()
    1:         t1 = t2.replace(tzinfo=v)
    1:         t2 = t2.replace(tzinfo=v)
    1:         self.assertEqual(t1.utcoffset(), timedelta(minutes=23))
    1:         self.assertEqual(t2.utcoffset(), timedelta(minutes=24))
    1:         self.assertEqual(t1, t2)
       
               # But if they're not identical, it isn't ignored.
    1:         t2 = t2.replace(tzinfo=Varies())
    1:         self.assertTrue(t1 < t2)  # t1's offset counter still going up
       
    1:     def test_subclass_datetimetz(self):
       
    2:         class C(self.theclass):
    1:             theAnswer = 42
       
    1:             def __new__(cls, *args, **kws):
    1:                 temp = kws.copy()
    1:                 extra = temp.pop('extra')
    1:                 result = self.theclass.__new__(cls, *args, **temp)
    1:                 result.extra = extra
    1:                 return result
       
    1:             def newmeth(self, start):
    1:                 return start + self.hour + self.year
       
    1:         args = 2002, 12, 31, 4, 5, 6, 500, FixedOffset(-300, "EST", 1)
       
    1:         dt1 = self.theclass(*args)
    1:         dt2 = C(*args, **{'extra': 7})
       
    1:         self.assertEqual(dt2.__class__, C)
    1:         self.assertEqual(dt2.theAnswer, 42)
    1:         self.assertEqual(dt2.extra, 7)
    1:         self.assertEqual(dt1.utcoffset(), dt2.utcoffset())
    1:         self.assertEqual(dt2.newmeth(-7), dt1.hour + dt1.year - 7)
       
       # Pain to set up DST-aware tzinfo classes.
       
    1: def first_sunday_on_or_after(dt):
 3798:     days_to_go = 6 - dt.weekday()
 3798:     if days_to_go:
 3795:         dt += timedelta(days_to_go)
 3798:     return dt
       
    1: ZERO = timedelta(0)
    1: HOUR = timedelta(hours=1)
    1: DAY = timedelta(days=1)
       # In the US, DST starts at 2am (standard time) on the first Sunday in April.
    1: DSTSTART = datetime(1, 4, 1, 2)
       # and ends at 2am (DST time; 1am standard time) on the last Sunday of Oct,
       # which is the first Sunday on or after Oct 25.  Because we view 1:MM as
       # being standard time on that day, there is no spelling in local time of
       # the last hour of DST (that's 1:MM DST, but 1:MM is taken as standard time).
    1: DSTEND = datetime(1, 10, 25, 1)
       
    2: class USTimeZone(tzinfo):
       
    1:     def __init__(self, hours, reprname, stdname, dstname):
    5:         self.stdoffset = timedelta(hours=hours)
    5:         self.reprname = reprname
    5:         self.stdname = stdname
    5:         self.dstname = dstname
       
    1:     def __repr__(self):
>>>>>>         return self.reprname
       
    1:     def tzname(self, dt):
>>>>>>         if self.dst(dt):
>>>>>>             return self.dstname
               else:
>>>>>>             return self.stdname
       
    1:     def utcoffset(self, dt):
  803:         return self.stdoffset + self.dst(dt)
       
    1:     def dst(self, dt):
 1903:         if dt is None or dt.tzinfo is None:
                   # An exception instead may be sensible here, in one or more of
                   # the cases.
    4:             return ZERO
 1899:         assert dt.tzinfo is self
       
               # Find first Sunday in April.
 1899:         start = first_sunday_on_or_after(DSTSTART.replace(year=dt.year))
 1899:         assert start.weekday() == 6 and start.month == 4 and start.day <= 7
       
               # Find last Sunday in October.
 1899:         end = first_sunday_on_or_after(DSTEND.replace(year=dt.year))
 1899:         assert end.weekday() == 6 and end.month == 10 and end.day >= 25
       
               # Can't compare naive to aware objects, so strip the timezone from
               # dt first.
 1899:         if start <= dt.replace(tzinfo=None) < end:
  942:             return HOUR
               else:
  957:             return ZERO
       
    1: Eastern  = USTimeZone(-5, "Eastern",  "EST", "EDT")
    1: Central  = USTimeZone(-6, "Central",  "CST", "CDT")
    1: Mountain = USTimeZone(-7, "Mountain", "MST", "MDT")
    1: Pacific  = USTimeZone(-8, "Pacific",  "PST", "PDT")
    1: utc_real = FixedOffset(0, "UTC", 0)
       # For better test coverage, we want another flavor of UTC that's west of
       # the Eastern and Pacific timezones.
    1: utc_fake = FixedOffset(-12*60, "UTCfake", 0)
       
    2: class TestTimezoneConversions(unittest.TestCase):
           # The DST switch times for 2002, in std time.
    1:     dston = datetime(2002, 4, 7, 2)
    1:     dstoff = datetime(2002, 10, 27, 1)
       
    1:     theclass = datetime
       
           # Check a time that's inside DST.
    1:     def checkinside(self, dt, tz, utc, dston, dstoff):
   90:         self.assertEqual(dt.dst(), HOUR)
       
               # Conversion to our own timezone is always an identity.
   90:         self.assertEqual(dt.astimezone(tz), dt)
       
   90:         asutc = dt.astimezone(utc)
   90:         there_and_back = asutc.astimezone(tz)
       
               # Conversion to UTC and back isn't always an identity here,
               # because there are redundant spellings (in local time) of
               # UTC time when DST begins:  the clock jumps from 1:59:59
               # to 3:00:00, and a local time of 2:MM:SS doesn't really
               # make sense then.  The classes above treat 2:MM:SS as
               # daylight time then (it's "after 2am"), really an alias
               # for 1:MM:SS standard time.  The latter form is what
               # conversion back from UTC produces.
   90:         if dt.date() == dston.date() and dt.hour == 2:
                   # We're in the redundant hour, and coming back from
                   # UTC gives the 1:MM:SS standard-time spelling.
   42:             self.assertEqual(there_and_back + HOUR, dt)
                   # Although during was considered to be in daylight
                   # time, there_and_back is not.
   42:             self.assertEqual(there_and_back.dst(), ZERO)
                   # They're the same times in UTC.
   42:             self.assertEqual(there_and_back.astimezone(utc),
   42:                              dt.astimezone(utc))
               else:
                   # We're not in the redundant hour.
   48:             self.assertEqual(dt, there_and_back)
       
               # Because we have a redundant spelling when DST begins, there is
               # (unfortunately) an hour when DST ends that can't be spelled at all in
               # local time.  When DST ends, the clock jumps from 1:59 back to 1:00
               # again.  The hour 1:MM DST has no spelling then:  1:MM is taken to be
               # standard time.  1:MM DST == 0:MM EST, but 0:MM is taken to be
               # daylight time.  The hour 1:MM daylight == 0:MM standard can't be
               # expressed in local time.  Nevertheless, we want conversion back
               # from UTC to mimic the local clock's "repeat an hour" behavior.
   90:         nexthour_utc = asutc + HOUR
   90:         nexthour_tz = nexthour_utc.astimezone(tz)
   90:         if dt.date() == dstoff.date() and dt.hour == 0:
                   # We're in the hour before the last DST hour.  The last DST hour
                   # is ineffable.  We want the conversion back to repeat 1:MM.
   18:             self.assertEqual(nexthour_tz, dt.replace(hour=1))
   18:             nexthour_utc += HOUR
   18:             nexthour_tz = nexthour_utc.astimezone(tz)
   18:             self.assertEqual(nexthour_tz, dt.replace(hour=1))
               else:
   72:             self.assertEqual(nexthour_tz - dt, HOUR)
       
           # Check a time that's outside DST.
    1:     def checkoutside(self, dt, tz, utc):
   90:         self.assertEqual(dt.dst(), ZERO)
       
               # Conversion to our own timezone is always an identity.
   90:         self.assertEqual(dt.astimezone(tz), dt)
       
               # Converting to UTC and back is an identity too.
   90:         asutc = dt.astimezone(utc)
   90:         there_and_back = asutc.astimezone(tz)
   90:         self.assertEqual(dt, there_and_back)
       
    1:     def convert_between_tz_and_utc(self, tz, utc):
    6:         dston = self.dston.replace(tzinfo=tz)
               # Because 1:MM on the day DST ends is taken as being standard time,
               # there is no spelling in tz for the last hour of daylight time.
               # For purposes of the test, the last hour of DST is 0:MM, which is
               # taken as being daylight time (and 1:MM is taken as being standard
               # time).
    6:         dstoff = self.dstoff.replace(tzinfo=tz)
    6:         for delta in (timedelta(weeks=13),
    6:                       DAY,
    6:                       HOUR,
    6:                       timedelta(minutes=1),
   36:                       timedelta(microseconds=1)):
       
   30:             self.checkinside(dston, tz, utc, dston, dstoff)
   90:             for during in dston + delta, dstoff - delta:
   60:                 self.checkinside(during, tz, utc, dston, dstoff)
       
   30:             self.checkoutside(dstoff, tz, utc)
   90:             for outside in dston - delta, dstoff + delta:
   60:                 self.checkoutside(outside, tz, utc)
       
    1:     def test_easy(self):
               # Despite the name of this test, the endcases are excruciating.
    1:         self.convert_between_tz_and_utc(Eastern, utc_real)
    1:         self.convert_between_tz_and_utc(Pacific, utc_real)
    1:         self.convert_between_tz_and_utc(Eastern, utc_fake)
    1:         self.convert_between_tz_and_utc(Pacific, utc_fake)
               # The next is really dancing near the edge.  It works because
               # Pacific and Eastern are far enough apart that their "problem
               # hours" don't overlap.
    1:         self.convert_between_tz_and_utc(Eastern, Pacific)
    1:         self.convert_between_tz_and_utc(Pacific, Eastern)
               # OTOH, these fail!  Don't enable them.  The difficulty is that
               # the edge case tests assume that every hour is representable in
               # the "utc" class.  This is always true for a fixed-offset tzinfo
               # class (lke utc_real and utc_fake), but not for Eastern or Central.
               # For these adjacent DST-aware time zones, the range of time offsets
               # tested ends up creating hours in the one that aren't representable
               # in the other.  For the same reason, we would see failures in the
               # Eastern vs Pacific tests too if we added 3*HOUR to the list of
               # offset deltas in convert_between_tz_and_utc().
               #
               # self.convert_between_tz_and_utc(Eastern, Central)  # can't work
               # self.convert_between_tz_and_utc(Central, Eastern)  # can't work
       
    1:     def test_tricky(self):
               # 22:00 on day before daylight starts.
    1:         fourback = self.dston - timedelta(hours=4)
    1:         ninewest = FixedOffset(-9*60, "-0900", 0)
    1:         fourback = fourback.replace(tzinfo=ninewest)
               # 22:00-0900 is 7:00 UTC == 2:00 EST == 3:00 DST.  Since it's "after
               # 2", we should get the 3 spelling.
               # If we plug 22:00 the day before into Eastern, it "looks like std
               # time", so its offset is returned as -5, and -5 - -9 = 4.  Adding 4
               # to 22:00 lands on 2:00, which makes no sense in local time (the
               # local clock jumps from 1 to 3).  The point here is to make sure we
               # get the 3 spelling.
    1:         expected = self.dston.replace(hour=3)
    1:         got = fourback.astimezone(Eastern).replace(tzinfo=None)
    1:         self.assertEqual(expected, got)
       
               # Similar, but map to 6:00 UTC == 1:00 EST == 2:00 DST.  In that
               # case we want the 1:00 spelling.
    1:         sixutc = self.dston.replace(hour=6, tzinfo=utc_real)
               # Now 6:00 "looks like daylight", so the offset wrt Eastern is -4,
               # and adding -4-0 == -4 gives the 2:00 spelling.  We want the 1:00 EST
               # spelling.
    1:         expected = self.dston.replace(hour=1)
    1:         got = sixutc.astimezone(Eastern).replace(tzinfo=None)
    1:         self.assertEqual(expected, got)
       
               # Now on the day DST ends, we want "repeat an hour" behavior.
               #  UTC  4:MM  5:MM  6:MM  7:MM  checking these
               #  EST 23:MM  0:MM  1:MM  2:MM
               #  EDT  0:MM  1:MM  2:MM  3:MM
               # wall  0:MM  1:MM  1:MM  2:MM  against these
    3:         for utc in utc_real, utc_fake:
    6:             for tz in Eastern, Pacific:
    4:                 first_std_hour = self.dstoff - timedelta(hours=2) # 23:MM
                       # Convert that to UTC.
    4:                 first_std_hour -= tz.utcoffset(None)
                       # Adjust for possibly fake UTC.
    4:                 asutc = first_std_hour + utc.utcoffset(None)
                       # First UTC hour to convert; this is 4:00 when utc=utc_real &
                       # tz=Eastern.
    4:                 asutcbase = asutc.replace(tzinfo=utc)
   20:                 for tzhour in (0, 1, 1, 2):
   16:                     expectedbase = self.dstoff.replace(hour=tzhour)
   64:                     for minute in 0, 30, 59:
   48:                         expected = expectedbase.replace(minute=minute)
   48:                         asutc = asutcbase.replace(minute=minute)
   48:                         astz = asutc.astimezone(tz)
   48:                         self.assertEqual(astz.replace(tzinfo=None), expected)
   16:                     asutcbase += HOUR
       
       
    1:     def test_bogus_dst(self):
    2:         class ok(tzinfo):
    3:             def utcoffset(self, dt): return HOUR
    3:             def dst(self, dt): return HOUR
       
    1:         now = self.theclass.now().replace(tzinfo=utc_real)
               # Doesn't blow up.
    1:         now.astimezone(ok())
       
               # Does blow up.
    2:         class notok(ok):
    2:             def dst(self, dt): return None
    1:         self.assertRaises(ValueError, now.astimezone, notok())
       
    1:     def test_fromutc(self):
    1:         self.assertRaises(TypeError, Eastern.fromutc)   # not enough args
    1:         now = datetime.utcnow().replace(tzinfo=utc_real)
    1:         self.assertRaises(ValueError, Eastern.fromutc, now) # wrong tzinfo
    1:         now = now.replace(tzinfo=Eastern)   # insert correct tzinfo
    1:         enow = Eastern.fromutc(now)         # doesn't blow up
    1:         self.assertEqual(enow.tzinfo, Eastern) # has right tzinfo member
    1:         self.assertRaises(TypeError, Eastern.fromutc, now, now) # too many args
    1:         self.assertRaises(TypeError, Eastern.fromutc, date.today()) # wrong type
       
               # Always converts UTC to standard time.
    2:         class FauxUSTimeZone(USTimeZone):
    1:             def fromutc(self, dt):
   24:                 return dt + self.stdoffset
    1:         FEastern  = FauxUSTimeZone(-5, "FEastern",  "FEST", "FEDT")
       
               #  UTC  4:MM  5:MM  6:MM  7:MM  8:MM  9:MM
               #  EST 23:MM  0:MM  1:MM  2:MM  3:MM  4:MM
               #  EDT  0:MM  1:MM  2:MM  3:MM  4:MM  5:MM
       
               # Check around DST start.
    1:         start = self.dston.replace(hour=4, tzinfo=Eastern)
    1:         fstart = start.replace(tzinfo=FEastern)
    7:         for wall in 23, 0, 1, 3, 4, 5:
    6:             expected = start.replace(hour=wall)
    6:             if wall == 23:
    1:                 expected -= timedelta(days=1)
    6:             got = Eastern.fromutc(start)
    6:             self.assertEqual(expected, got)
       
    6:             expected = fstart + FEastern.stdoffset
    6:             got = FEastern.fromutc(fstart)
    6:             self.assertEqual(expected, got)
       
                   # Ensure astimezone() calls fromutc() too.
    6:             got = fstart.replace(tzinfo=utc_real).astimezone(FEastern)
    6:             self.assertEqual(expected, got)
       
    6:             start += HOUR
    6:             fstart += HOUR
       
               # Check around DST end.
    1:         start = self.dstoff.replace(hour=4, tzinfo=Eastern)
    1:         fstart = start.replace(tzinfo=FEastern)
    7:         for wall in 0, 1, 1, 2, 3, 4:
    6:             expected = start.replace(hour=wall)
    6:             got = Eastern.fromutc(start)
    6:             self.assertEqual(expected, got)
       
    6:             expected = fstart + FEastern.stdoffset
    6:             got = FEastern.fromutc(fstart)
    6:             self.assertEqual(expected, got)
       
                   # Ensure astimezone() calls fromutc() too.
    6:             got = fstart.replace(tzinfo=utc_real).astimezone(FEastern)
    6:             self.assertEqual(expected, got)
       
    6:             start += HOUR
    6:             fstart += HOUR
       
       
       #############################################################################
       # oddballs
       
    2: class Oddballs(unittest.TestCase):
       
    1:     def test_bug_1028306(self):
               # Trying to compare a date to a datetime should act like a mixed-
               # type comparison, despite that datetime is a subclass of date.
    1:         as_date = date.today()
    1:         as_datetime = datetime.combine(as_date, time())
    1:         self.assertTrue(as_date != as_datetime)
    1:         self.assertTrue(as_datetime != as_date)
    1:         self.assertFalse(as_date == as_datetime)
    1:         self.assertFalse(as_datetime == as_date)
    2:         self.assertRaises(TypeError, lambda: as_date < as_datetime)
    2:         self.assertRaises(TypeError, lambda: as_datetime < as_date)
    2:         self.assertRaises(TypeError, lambda: as_date <= as_datetime)
    2:         self.assertRaises(TypeError, lambda: as_datetime <= as_date)
    2:         self.assertRaises(TypeError, lambda: as_date > as_datetime)
    2:         self.assertRaises(TypeError, lambda: as_datetime > as_date)
    2:         self.assertRaises(TypeError, lambda: as_date >= as_datetime)
    2:         self.assertRaises(TypeError, lambda: as_datetime >= as_date)
       
               # Nevertheless, comparison should work with the base-class (date)
               # projection if use of a date method is forced.
    1:         self.assertTrue(as_date.__eq__(as_datetime))
    1:         different_day = (as_date.day + 1) % 20 + 1
    1:         self.assertFalse(as_date.__eq__(as_datetime.replace(day=different_day)))
       
               # And date should compare with other subclasses of date.  If a
               # subclass wants to stop this, it's up to the subclass to do so.
    1:         date_sc = SubclassDate(as_date.year, as_date.month, as_date.day)
    1:         self.assertEqual(as_date, date_sc)
    1:         self.assertEqual(date_sc, as_date)
       
               # Ditto for datetimes.
    1:         datetime_sc = SubclassDatetime(as_datetime.year, as_datetime.month,
    1:                                        as_date.day, 0, 0, 0)
    1:         self.assertEqual(as_datetime, datetime_sc)
    1:         self.assertEqual(datetime_sc, as_datetime)
       
    1: def test_main():
    1:     test_support.run_unittest(__name__)
       
    1: if __name__ == "__main__":
>>>>>>     test_main()
