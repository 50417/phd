       # Copyright 2004-2005 Elemental Security, Inc. All Rights Reserved.
       # Licensed to PSF under a Contributor Agreement.
       
       """Parser engine for the grammar tables generated by pgen.
       
       The grammar table must be loaded first.
       
       See Parser/parser.c in the Python distribution for additional info on
       how this parsing engine works.
       
    1: """
       
       # Local imports
    1: from . import token
       
    2: class ParseError(Exception):
    1:     """Exception to signal the parser is stuck."""
       
    1:     def __init__(self, msg, type, value, context):
    8:         Exception.__init__(self, "%s: type=%r, value=%r, context=%r" %
    8:                            (msg, type, value, context))
    8:         self.msg = msg
    8:         self.type = type
    8:         self.value = value
    8:         self.context = context
       
    2: class Parser(object):
           """Parser engine.
       
           The proper usage sequence is:
       
           p = Parser(grammar, [converter])  # create instance
           p.setup([start])                  # prepare for parsing
           <for each input token>:
               if p.addtoken(...):           # parse a token; may raise ParseError
                   break
           root = p.rootnode                 # root of abstract syntax tree
       
           A Parser instance may be reused by calling setup() repeatedly.
       
           A Parser instance contains state pertaining to the current token
           sequence, and should not be used concurrently by different threads
           to parse separate token sequences.
       
           See driver.py for how to get input tokens by tokenizing a file or
           string.
       
           Parsing is complete when addtoken() returns True; the root of the
           abstract syntax tree can then be retrieved from the rootnode
           instance variable.  When a syntax error occurs, addtoken() raises
           the ParseError exception.  There is no error recovery; the parser
           cannot be used after a syntax error was reported (but it can be
           reinitialized by calling setup()).
       
    1:     """
       
    1:     def __init__(self, grammar, convert=None):
               """Constructor.
       
               The grammar argument is a grammar.Grammar instance; see the
               grammar module for more information.
       
               The parser is not ready yet for parsing; you must call the
               setup() method to get it started.
       
               The optional convert argument is a function mapping concrete
               syntax tree nodes to abstract syntax tree nodes.  If not
               given, no conversion is done and the syntax tree produced is
               the concrete syntax tree.  If given, it must be a function of
               two arguments, the first being the grammar (a grammar.Grammar
               instance), and the second being the concrete syntax tree node
               to be converted.  The syntax tree is converted from the bottom
               up.
       
               A concrete syntax tree node is a (type, value, context, nodes)
               tuple, where type is the node type (a token or symbol number),
               value is None for symbols and a string for tokens, context is
               None or an opaque value used for error reporting (typically a
               (lineno, offset) pair), and nodes is a list of children for
               symbols, and None for tokens.
       
               An abstract syntax tree node may be anything; this is entirely
               up to the converter function.
       
               """
 3272:         self.grammar = grammar
 3272:         self.convert = convert or (lambda grammar, node: node)
       
    1:     def setup(self, start=None):
               """Prepare for parsing.
       
               This *must* be called before starting to parse.
       
               The optional argument is an alternative start symbol; it
               defaults to the grammar's start symbol.
       
               You can use a Parser instance to parse any number of programs;
               each time you call setup() the parser is reset to an initial
               state determined by the (implicit or explicit) start symbol.
       
               """
 3272:         if start is None:
 3272:             start = self.grammar.start
               # Each stack entry is a tuple: (dfa, state, node).
               # A node is a tuple: (type, value, context, children),
               # where children is a list of nodes or None, and context may be None.
 3272:         newnode = (start, None, None, [])
 3272:         stackentry = (self.grammar.dfas[start], 0, newnode)
 3272:         self.stack = [stackentry]
 3272:         self.rootnode = None
 3272:         self.used_names = set() # Aliased to self.rootnode.used_names in pop()
       
    1:     def addtoken(self, type, value, context):
               """Add a token; return True iff this is the end of the program."""
               # Map from token to label
226836:         ilabel = self.classify(type, value, context)
               # Loop until the token is shifted; may raise exceptions
1597448:         while True:
1597448:             dfa, state, node = self.stack[-1]
1597448:             states, first = dfa
1597448:             arcs = states[state]
                   # Look for a state with this label
3814204:             for i, newstate in arcs:
3177411:                 t, v = self.grammar.labels[i]
3177411:                 if ilabel == i:
                           # Look it up in the list of labels
226828:                     assert t < 256
                           # Shift a token; we're done with it
226828:                     self.shift(type, value, newstate, context)
                           # Pop while we are in an accept-only state
226828:                     state = newstate
323846:                     while states[state] == [(0, state)]:
100282:                         self.pop()
100282:                         if not self.stack:
                                   # Done parsing!
 3264:                             return True
97018:                         dfa, state, node = self.stack[-1]
97018:                         states, first = dfa
                           # Done with this token
223564:                     return False
2950583:                 elif t >= 256:
                           # See if it's a symbol and if we're in its first set
1072910:                     itsdfa = self.grammar.dfas[t]
1072910:                     itsstates, itsfirst = itsdfa
1072910:                     if ilabel in itsfirst:
                               # Push a symbol
733827:                         self.push(t, self.grammar.dfas[t], newstate, context)
733827:                         break # To continue the outer while loop
                   else:
636793:                 if (0, state) in arcs:
                           # An accepting state, pop it and try something else
636785:                     self.pop()
636785:                     if not self.stack:
                               # Done parsing, but another token is input
>>>>>>                         raise ParseError("too much input",
>>>>>>                                          type, value, context)
                       else:
                           # No success finding a transition
    8:                     raise ParseError("bad input", type, value, context)
       
    1:     def classify(self, type, value, context):
               """Turn a token into a label.  (Internal)"""
226836:         if type == token.NAME:
                   # Keep a listing of all used names
72533:             self.used_names.add(value)
                   # Check for reserved words
72533:             ilabel = self.grammar.keywords.get(value)
72533:             if ilabel is not None:
11252:                 return ilabel
215584:         ilabel = self.grammar.tokens.get(type)
215584:         if ilabel is None:
>>>>>>             raise ParseError("bad token", type, value, context)
215584:         return ilabel
       
    1:     def shift(self, type, value, newstate, context):
               """Shift a token.  (Internal)"""
226828:         dfa, state, node = self.stack[-1]
226828:         newnode = (type, value, context, None)
226828:         newnode = self.convert(self.grammar, newnode)
226828:         if newnode is not None:
226828:             node[-1].append(newnode)
226828:         self.stack[-1] = (dfa, newstate, node)
       
    1:     def push(self, type, newdfa, newstate, context):
               """Push a nonterminal.  (Internal)"""
733827:         dfa, state, node = self.stack[-1]
733827:         newnode = (type, None, context, [])
733827:         self.stack[-1] = (dfa, newstate, node)
733827:         self.stack.append((newdfa, 0, newnode))
       
    1:     def pop(self):
               """Pop a nonterminal.  (Internal)"""
737067:         popdfa, popstate, popnode = self.stack.pop()
737067:         newnode = self.convert(self.grammar, popnode)
737067:         if newnode is not None:
737067:             if self.stack:
733803:                 dfa, state, node = self.stack[-1]
733803:                 node[-1].append(newnode)
                   else:
 3264:                 self.rootnode = newnode
 3264:                 self.rootnode.used_names = self.used_names
