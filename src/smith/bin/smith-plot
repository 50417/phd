#!/usr/bin/env python3
#
# Plot labelled training data and unlabelled performance
#
from argparse import ArgumentParser

import matplotlib.cm as cm
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import re
import seaborn as sns
import sklearn
import sys

from math import sqrt,ceil
from functools import partial
from random import seed,random

import labm8
from labm8 import fmt
from labm8 import fs
from labm8 import viz

import smith
from smith import cgo13

# Seaborn configuration:
sns.set(style="ticks", color_codes=True)

def rand_jitter(arr, factor=0.01):
    stdev = factor* (max(arr) - min(arr))
    return arr + np.random.randn(len(arr)) * stdev


def scatter_with_jitter(plt, x, y, **kwargs):
    jitter_opts = kwargs.get("jitter_opts", {})
    if "jitter_opts" in kwargs: kwargs.pop("jitter_opts")

    return plt.scatter(rand_jitter(x, **jitter_opts),
                       rand_jitter(y, **jitter_opts), **kwargs)


def plot_eigenvectors(data):
    if len(set(data["Group"])) > 1:
        s = pd.concat([data["E1"], data["E2"], data["E3"], data["E4"],
                       data["Group"]], axis=1,
                      keys=["E1", "E2", "E3", "E4", "Group"])
        g = sns.pairplot(s, hue="Group")
    else:
        s = pd.concat([data["E1"], data["E2"], data["E3"], data["E4"]], axis=1,
                      keys=["E1", "E2", "E3", "E4"])
        sns.pairplot(s)


def plot_features(data):
    if len(set(data["Group"])) > 1:
        s = pd.concat([
            data["F1_norm"], data["F2_norm"], data["F3_norm"], data["F4_norm"],
            data["Group"]], axis=1, keys=["F1", "F2", "F3", "F4", "Group"])
        sns.pairplot(s, hue="Group")
    else:
        s = pd.concat([
            data["F1_norm"], data["F2_norm"], data["F3_norm"], data["F4_norm"]],
                      axis=1, keys=["F1", "F2", "F3", "F4"])
        sns.pairplot(s)


def plot_runtimes(data):
    # TODO:
    pass


def main():
    parser = ArgumentParser()
    parser.add_argument('type', help='{features,eigens}')
    parser.add_argument('input', help='path to input training data CSV')
    parser.add_argument("-g", "--group", action="store", default="none",
                        help='group results by {none,class,suite,prog}')
    parser.add_argument("--filter", action="store", default="none",
                        help="filter data by {none,suite}")
    parser.add_argument("-t", "--title", action="store", default=None,
                        help="Set plot title")
    parser.add_argument("-o", "--output", action="store", default=None,
                        help="Save plot to location")
    args = parser.parse_args()

    data = cgo13.LabelledData.from_csv(smith.assert_exists(args.input),
                                       group_by=args.group,
                                       filter_by=args.filter)

    target = args.type
    if args.type == "features":
        plot_features(data)
    elif args.type == "eigens":
        plot_eigenvectors(data)
    elif args.type == "runtimes":
        plot_runtimes(data)
    elif args.type == "xval":
        results = cgo13.classification(data, group_by=args.group)
        groups = sorted(set(data["Group"]))

        def shortlabels(groups):
            return [re.sub("-.+$", "", x) for x in groups]

        sns.heatmap(results, annot=True, fmt=".2f", linewidths=.5,
                    xticklabels=shortlabels(groups),
                    yticklabels=shortlabels(groups))
    else:
        print("fatal: Unknown plot type '{}'".format(args.type))
        sys.exit(1)

    if args.title:
        plt.subplots_adjust(top=0.95)
        plt.gcf().suptitle(args.title)

    viz.finalise(args.output, tight=False)


if __name__ == '__main__':
    main()
