#!/usr/bin/env python3
#
# Plot labelled training data and unlabelled performance
#
from argparse import ArgumentParser

import matplotlib.cm as cm
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import re
import seaborn as sns
import sklearn
import sys

from math import sqrt,ceil
from functools import partial
from random import seed,random

import labm8
from labm8 import fmt
from labm8 import fs
from labm8 import viz

import smith
from smith import cgo13

# Seaborn configuration:
sns.set(style="ticks", color_codes=True)

def rand_jitter(arr, factor=0.01):
    stdev = factor* (max(arr) - min(arr))
    return arr + np.random.randn(len(arr)) * stdev


def scatter_with_jitter(plt, x, y, **kwargs):
    jitter_opts = kwargs.get("jitter_opts", {})
    if "jitter_opts" in kwargs: kwargs.pop("jitter_opts")

    return plt.scatter(rand_jitter(x, **jitter_opts),
                       rand_jitter(y, **jitter_opts), **kwargs)


def plot_eigenvectors(data, args):
    if len(set(data["Group"])) > 1:
        s = pd.concat([data["E1"], data["E2"], data["E3"], data["E4"],
                       data["Group"]], axis=1,
                      keys=["E1", "E2", "E3", "E4", "Group"])
        g = sns.pairplot(s, hue="Group")
    else:
        s = pd.concat([data["E1"], data["E2"], data["E3"], data["E4"]], axis=1,
                      keys=["E1", "E2", "E3", "E4"])
        sns.pairplot(s)


def plot_norm_features(data, args):
    if len(set(data["Group"])) > 1:
        s = pd.concat([
            data["F1_norm"], data["F2_norm"], data["F3_norm"], data["F4_norm"],
            data["Group"]], axis=1, keys=[
                "F1 (norm)", "F2 (norm)", "F3 (norm)", "F4 (norm)", "Group"])
        sns.pairplot(s, hue="Group")
    else:
        s = pd.concat([
            data["F1_norm"], data["F2_norm"], data["F3_norm"], data["F4_norm"]],
                      axis=1, keys=[
                          "F1 (norm)", "F2 (norm)", "F3 (norm)", "F4 (norm)"])
        sns.pairplot(s)


def plot_features(data, args):
    if len(set(data["Group"])) > 1:
        s = pd.concat([
            data["F1:transfer/(comp+mem)"], data["F2:coalesced/mem"],
            data["F3:(localmem/mem)*avgws"], data["F4:comp/mem"],
            data["Group"]], axis=1, keys=["F1", "F2", "F3", "F4", "Group"])
        sns.pairplot(s, hue="Group")
    else:
        s = pd.concat([
            data["F1:transfer/(comp+mem)"], data["F2:coalesced/mem"],
            data["F3:(localmem/mem)*avgws"], data["F4:comp/mem"]],
                      axis=1, keys=["F1", "F2", "F3", "F4"])
        sns.pairplot(s)


def plot_runtimes(data, args):
    x = data["runtime"][data["runtime"] < 1]
    sns.distplot(x, kde=False)


def plot_noise(data, args):
    targets = [data] + [cgo13.UnLabelledData.from_csv(x) for x in args.other]

    cp = sns.color_palette()
    for d,c in zip(targets, cp):
        x = d["runtime"]
        y = d["ci"]
        plt.scatter(x, y, color=c)
    plt.xlim(0,)
    plt.ylim(0,)


def plot_xval(data, args):
    results = cgo13.classification(data, group_by=args.group)
    groups = sorted(set(data["Group"]))

    def shortlabels(groups):
        return [re.sub("-.+$", "", x) for x in groups]

    sns.heatmap(results, annot=True, fmt=".2f", linewidths=.5,
                xticklabels=shortlabels(groups),
                yticklabels=shortlabels(groups))


def plot_neighbours(data, args):
    other = cgo13.LabelledData.from_csv(args.other[0]) if args.other else data

    if "use_eigens" in args and args.use_eigens:
        results = cgo13.nearest_neighbours(data, other,
                                           distance=cgo13.eigens_distance)
    else:
        results = cgo13.nearest_neighbours(data, other)

    results = list(results)
    xlim = (min([r[0] for r in results]), max([r[0] for r in results]))

    nbins= 15

    x = [r[0] for r in results if r[2]]
    plt.subplot(2, 1, 1)
    ax = sns.distplot(x, kde=False)
    sns.plt.xlim(xlim)
    if "log" in args and args.log:
        ax.set_yscale("log", nonposy='clip')


    x = [r[0] for r in results if not r[2]]
    plt.subplot(2, 1, 2)
    ax = sns.distplot(x, kde=False, color="r")
    sns.plt.xlim(xlim)
    if "log" in args and args.log:
        ax.set_yscale("log", nonposy='clip')


def plot_eigen_neighbours(data, args):
    args.use_eigens = True
    return plot_neighbours(data, args)


def main():
    types = {
        "eigen-neighbours": plot_eigen_neighbours,
        "eigens": plot_eigenvectors,
        "en": plot_eigen_neighbours,
        "features": plot_features,
        "normfeats": plot_norm_features,
        "featnorms": plot_norm_features,
        "normfeatures": plot_norm_features,
        "neighbours": plot_neighbours,
        "ci": plot_noise,
        "nn": plot_neighbours,
        "run": plot_runtimes,
        "runtime": plot_runtimes,
        "runtimes": plot_runtimes,
        "xval": plot_xval,
    }

    parser = ArgumentParser()
    parser.add_argument('type', help=('Possible values: {{{}}}'
                                      .format(",".join(sorted(types.keys())))))
    parser.add_argument('input', help='path to input training data CSV')
    parser.add_argument("-g", "--group", action="store", default="none",
                        help='group results by {none,class,suite,prog}')
    parser.add_argument("--filter", action="store", default="none",
                        help="filter data by {none,suite}")
    parser.add_argument("-t", "--title", action="store", default=None,
                        help="Set plot title")
    parser.add_argument("-o", "--output", action="store", default=None,
                        help="Save plot to location")
    parser.add_argument("-u", "--unlabelled", action="store_true",
                        help="If true, data is unlabelled")
    parser.add_argument("-O", "--other", nargs="+", action="store",
                        default=[],
                        help="Alternative dataset (used for some modes)")
    args = parser.parse_args()

    plot = types.get(args.type, None)
    if plot is None:
        print("fatal: Unknown plot type '{}'. Possible values: {{{}}}"
              .format(args.type, ",".join(sorted(types.keys()))))
        sys.exit(1)

    if args.unlabelled:
        data = cgo13.UnLabelledData.from_csv(smith.assert_exists(args.input))
    else:
        data = cgo13.LabelledData.from_csv(smith.assert_exists(args.input),
                                           group_by=args.group,
                                           filter_by=args.filter)

    plot(data, args)

    if args.title:
        plt.subplots_adjust(top=0.95)
        plt.gcf().suptitle(args.title)

    viz.finalise(args.output, tight=False)


if __name__ == '__main__':
    main()
