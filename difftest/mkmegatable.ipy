#!/usr/bin/env ipython

from collections import namedtuple, OrderedDict
from labm8 import fs
import os
import pandas as pd
import sqlalchemy as sql
import subprocess
import sys

import db
from db import *
%run util.py


hostname = "cc1"
db.init(hostname)

session = db.make_session()

null_columns = " & ".join(["-"] * 6)


TIME_LIMIT = 24 * 2600


def get_outcome_columns(tables: Tableset, testbed: Testbed, no_opt: bool):
    """
    Return results for the specified time limit.

    Arguments:
        results_table: SQLAlchemy table for results.
        programs_table: SQLAlchemy table for programs.
        params_table: SQLAlchemy table for params.
        reduction_table: SQLAlchemy table for reduction results. If
            provided, reductions will be added to the runtime of "w" classified
            results, where possible.
        testbed (db.Testbed): Testbed instance to return results for.
        no_opt (bool): Testbed optimizations off?
    """
    counts = {"pass": 0, "bf": 0, "bc": 0, "bto": 0, "c": 0, "to": 0}

    q = results_in_timelimit(session, tables, testbed.id, no_opt, TIME_LIMIT,
                             tables.results.outcome)

    try:
        for outcome, in q:
            counts[outcome] = counts.get(outcome, 0) + 1
    except InsufficientDataError as e:
        print(e, file=sys.stderr)
        counts['total'] = '*'

    # sum up all results
    total = counts.pop("total", "")
    counts['total'] = str(sum(counts.values())) + total

    print('\r\033[1K ', device_str(testbed.device), no_opt, counts, end="")
    return f"{counts['bf']} & {counts['bc']} & {counts['bto']} & {counts['c']} & {counts['to']} & {counts['pass']} & {counts['total']}"


def get_classification_columns(tables: Tableset, testbed: Testbed, no_opt: bool):
    """
    Return results for the specified time limit.

    Arguments:
        results_table: SQLAlchemy table for results.
        programs_table: SQLAlchemy table for programs.
        params_table: SQLAlchemy table for params.
        reduction_table: SQLAlchemy table for reduction results. If
            provided, reductions will be added to the runtime of "w" classified
            results, where possible.
        testbed (db.Testbed): Testbed instance to return results for.
        no_opt (bool): Testbed optimizations off?
    """
    counts = {"w": 0, "bf": 0, "c": 0, "to": 0, "pass": 0, "fail": 0}

    q = results_in_timelimit(session, tables, testbed.id, no_opt, TIME_LIMIT,
                             tables.results.classification, tables.programs.src)

    try:
        for classification, src in q:
            # TODO: Merge this into classification logic
            if classification == "w" and "float" in src:
                continue
            counts[classification] = counts.get(classification, 0) + 1
    except InsufficientDataError as e:
        print(e, file=sys.stderr)
        counts['total'] = '*'

    suffix = counts.pop("total", "")
    total = sum(counts.values())

    # don't count "pass"es
    num_passes = counts.pop("pass")
    total_anomalous = sum(counts.values())

    counts['total'] = "{:.1f}\\%".format((total_anomalous / max(total, 1)) * 100) + suffix

    print('\r\033[1K ', device_str(testbed.device), no_opt, counts, end="")
    return f"{counts['w']} & {counts['bf']} & {counts['c']} & {counts['to']} & {counts['total']}"


def get_row(config_id, testbed_id, get_columns):
    """ get mega-table row """
    testbed = session.query(Testbed).filter(Testbed.id == testbed_id).first()
    platform_name = platform_str(testbed.platform)
    device_name = device_str(testbed.device)
    driver_name = driver_str(testbed.driver)

    clsmith_columns = get_columns(CLSMITH_TABLES, testbed, True)
    clgen_columns = get_columns(CLGEN_TABLES, testbed, True)

    clsmith_withopt_columns = get_columns(CLSMITH_TABLES, testbed, False)
    clgen_withopt_columns = get_columns(CLGEN_TABLES, testbed, False)

    return f"""\
\\multirow{{ 2}}{{*}}{{{config_id}}} & \
\\multirow{{ 2}}{{*}}{{{device_name}}} & \
$-$ & {clsmith_columns}       & {clgen_columns} \\\\
& & \
$+$ & {clsmith_withopt_columns} & {clgen_withopt_columns} \\\\"""


def mkmegatable(get_columns, header):
    """ construct a megatable with with requested columns """
    rows = "\n\\hline\n".join(get_row(*x, get_columns) for x in CONFIGURATIONS)
    return f"""\
  {header}
  {rows}
  \\bottomrule
\\end{{tabular}}
"""

def get_outcomes_table():
    return mkmegatable(get_outcome_columns, f"""\\begin{{tabular}}{{lll | rrrrrrr | rrrrrrr }}
  \\toprule
  & & & \\multicolumn{{7}}{{c|}}{{\\textbf{{CLSmith}}}} & \\multicolumn{{7}}{{c}}{{\\textbf{{CLgen}}}} \\\\
  \\textbf{{\\#.}} & \\textbf{{Device}} & $\\pm$ &
  \\textbf{{bf}} & \\textbf{{bc}} & \\textbf{{bto}} & \\textbf{{c}} & \\textbf{{to}} & \\cmark & \\textbf{{total}} &
  \\textbf{{bf}} & \\textbf{{bc}} & \\textbf{{bto}} & \\textbf{{c}} & \\textbf{{to}} & \\cmark & \\textbf{{total}} \\\\
  \\midrule""")

def get_classifications_table():
    return mkmegatable(get_classification_columns, f"""\\begin{{tabular}}{{lll | rrrrr | rrrrr }}
  \\toprule
  & & & \\multicolumn{{5}}{{c|}}{{\\textbf{{CLSmith}}}} & \\multicolumn{{5}}{{c}}{{\\textbf{{CLgen}}}} \\\\
  \\textbf{{\\#.}} & \\textbf{{Device}} & $\\pm$ &
  \\textbf{{w}} & \\textbf{{bf}} & \\textbf{{c}} & \\textbf{{to}} & \\textbf{{\\% of total}} &
  \\textbf{{w}} & \\textbf{{bf}} & \\textbf{{c}} & \\textbf{{to}} & \\textbf{{\\% of total}} \\\\
  \\midrule""")


if __name__ == "__main__":
    # push LaTex to Overleaf
    !cd ~/docs/paper-project_b/ && git pull --rebase

    print("Generating outcomes table ...")
    with open(os.path.expanduser("~/docs/paper-project_b/build/tab/outcomes.tex"), "w") as outfile:
        print(get_outcomes_table(), file=outfile)

    print("\nGenerating classifications table ...")
    with open(os.path.expanduser("~/docs/paper-project_b/build/tab/megatable.tex"), "w") as outfile:
        print(get_classifications_table(), file=outfile)

    !cd ~/docs/paper-project_b/build && git add . && git commit -m "auto: build/tab: Megatables" && git push
