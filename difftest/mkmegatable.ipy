#!/usr/bin/env ipython

from collections import OrderedDict
from labm8 import fs
import os
import pandas as pd
import sqlalchemy as sql
import subprocess
import sys

import db
from db import *
%run util.py


hostname = "cc1"
db.init(hostname)

session = db.make_session()

null_columns = " & ".join(["-"] * 6)

# Measured average CLgen sample time
clgen_generation_time = .9


TIME_LIMIT = 24 * 2600


def get_outcome_columns(results_table, programs_table, params_table,
                        reductions_table, testbed: Testbed, no_opt: bool):
    """
    Return results for the specified time limit.

    Arguments:
        results_table: SQLAlchemy table for results.
        programs_table: SQLAlchemy table for programs.
        params_table: SQLAlchemy table for params.
        reduction_table: SQLAlchemy table for reduction results. If
            provided, reductions will be added to the runtime of "w" classified
            results, where possible.
        testbed (db.Testbed): Testbed instance to return results for.
        no_opt (bool): Testbed optimizations off?
    """
    # query to return all results in-order
    param_ids = session.query(params_table.id).filter(params_table.optimizations == no_opt)
    q = session.query(results_table).filter(
        results_table.testbed_id == testbed.id,
        results_table.params_id.in_(param_ids)).order_by(results_table.date)

    # Otherwise, simulate results for a fixed period of time
    t = 0  # elapsed time
    counts = {"pass": 0, "bf": 0, "bc": 0, "bto": 0, "c": 0, "to": 0}

    # times
    generation_time = sql.sql.func.ifnull(programs_table.runtime, clgen_generation_time)
    runtime = results_table.runtime
    reduction_time = sql.sql.func.ifnull(reductions_table.runtime, 0)
    total_time = generation_time + runtime + reduction_time

    q = session.query(
            results_table.outcome,
            total_time)\
        .outerjoin(programs_table)\
        .outerjoin(reductions_table)\
        .filter(results_table.testbed_id == testbed.id,
                results_table.params_id.in_(param_ids),
                results_table.outcome != None)\
        .order_by(results_table.date)

    # accumulate results within the time limit
    for outcome, total_time in q:
        if t + total_time > TIME_LIMIT:
            break
        t += total_time
        counts[outcome] = counts.get(outcome, 0) + 1
    else:
        # We ran out of results before we hit the time limit.
        # asterisk denotes insufficient results
        counts['total'] = '*'
        total_hours = t / 3600
        devname = device_str(testbed.device)
        print(f"insufficient {results_table.__tablename__} for {devname} {no_opt} ({total_hours:.1f} hs)", file=sys.stderr)

    # sum up all results
    total = counts.pop("total", "")
    counts['total'] = str(sum(counts.values())) + total

    return f"{counts['bf']} & {counts['bc']} & {counts['bto']} & {counts['c']} & {counts['to']} & {counts['pass']} & {counts['total']}"


def get_classification_columns(results_table, programs_table, params_table,
                               reductions_table, testbed: Testbed, no_opt: bool):
    """
    Return results for the specified time limit.

    Arguments:
        results_table: SQLAlchemy table for results.
        programs_table: SQLAlchemy table for programs.
        params_table: SQLAlchemy table for params.
        reduction_table: SQLAlchemy table for reduction results. If
            provided, reductions will be added to the runtime of "w" classified
            results, where possible.
        testbed (db.Testbed): Testbed instance to return results for.
        no_opt (bool): Testbed optimizations off?
    """
    # query to return all results in-order
    param_ids = session.query(params_table.id).filter(params_table.optimizations == no_opt)
    q = session.query(results_table).filter(
        results_table.testbed_id == testbed.id,
        results_table.params_id.in_(param_ids)).order_by(results_table.date)

    # Otherwise, simulate results for a fixed period of time
    t = 0  # elapsed time
    counts = {"w": 0, "bf": 0, "c": 0, "to": 0, "pass": 0, "fail": 0}

    # times
    generation_time = sql.sql.func.ifnull(programs_table.runtime, clgen_generation_time)
    runtime = results_table.runtime
    reduction_time = sql.sql.func.ifnull(reductions_table.runtime, 0)
    total_time = generation_time + runtime + reduction_time

    q = session.query(
            results_table.classification,
            #generation_time, runtime, reduction_time,
            total_time)\
        .outerjoin(programs_table)\
        .outerjoin(reductions_table)\
        .filter(results_table.testbed_id == testbed.id,
                results_table.params_id.in_(param_ids),
                results_table.classification != None)\
        .order_by(results_table.date)

    # accumulate results within the time limit
    for classification, total_time in q:
        # classification, generation_time, runtime, reduction_time, total_time = row
        if t + total_time > TIME_LIMIT:
            break
        t += total_time
        counts[classification] = counts.get(classification, 0) + 1
    else:
        # We ran out of results before we hit the time limit.
        # asterisk denotes insufficient results
        counts['total'] = ' *'
        total_hours = t / 3600
        devname = device_str(testbed.device)
        print(f"insufficient {results_table.__tablename__} for {devname} {no_opt} ({total_hours:.1f} hs)", file=sys.stderr)

    suffix = counts.pop("total", "")
    total = sum(counts.values())

    # don't count "pass"es
    num_passes = counts.pop("pass")
    total_anomalous = sum(counts.values())

    counts['total'] = "{:.1f}\\%".format((total_anomalous / max(total, 1)) * 100) + suffix

    return f"{counts['w']} & {counts['bf']} & {counts['c']} & {counts['to']} & {counts['total']}"


def get_row(config_id, testbed_id, get_columns):
    """ get mega-table row """
    testbed = session.query(Testbed).filter(Testbed.id == testbed_id).first()
    platform_name = platform_str(testbed.platform)
    device_name = device_str(testbed.device)
    driver_name = driver_str(testbed.driver)

    noopt = True
    clsmith_columns = get_columns(
        CLSmithResult, CLSmithProgram, cl_launcherParams, CLSmithReduction, testbed, noopt)
    clgen_columns = get_columns(
        CLgenResult, CLgenProgram, cldriveParams, CLgenReduction, testbed, noopt)

    withopt = False
    clsmith_withopt_columns = get_columns(
        CLSmithResult, CLSmithProgram, cl_launcherParams, CLSmithReduction, testbed, withopt)
    clgen_withopt_columns = get_columns(
        CLgenResult, CLgenProgram, cldriveParams, CLgenReduction, testbed, withopt)

    return f"""\
\\multirow{{ 2}}{{*}}{{{config_id}}} & \
\\multirow{{ 2}}{{*}}{{{device_name}}} & \
$-$ & {clsmith_columns}       & {clgen_columns} \\\\
& & \
$+$ & {clsmith_withopt_columns} & {clgen_withopt_columns} \\\\"""


def mkmegatable(get_columns, header):
    """ construct a megatable with with requested columns """
    rows = "\n\\hline\n".join(get_row(*x, get_columns) for x in CONFIGURATIONS)
    return f"""\
  {header}
  {rows}
  \\bottomrule
\\end{{tabular}}
"""

outcomes_table = mkmegatable(get_outcome_columns, f"""\\begin{{tabular}}{{lll | rrrrrrr | rrrrrrr }}
  \\toprule
  & & & \\multicolumn{{7}}{{c|}}{{\\textbf{{CLSmith}}}} & \\multicolumn{{7}}{{c}}{{\\textbf{{CLgen}}}} \\\\
  \\textbf{{\\#.}} & \\textbf{{Device}} & $\\pm$ &
  \\textbf{{bf}} & \\textbf{{bc}} & \\textbf{{bto}} & \\textbf{{c}} & \\textbf{{to}} & \\cmark & \\textbf{{total}} &
  \\textbf{{bf}} & \\textbf{{bc}} & \\textbf{{bto}} & \\textbf{{c}} & \\textbf{{to}} & \\cmark & \\textbf{{total}} \\\\
  \\midrule""")

classifications_table = mkmegatable(get_classification_columns, f"""\\begin{{tabular}}{{lll | rrrrr | rrrrr }}
  \\toprule
  & & & \\multicolumn{{5}}{{c|}}{{\\textbf{{CLSmith}}}} & \\multicolumn{{5}}{{c}}{{\\textbf{{CLgen}}}} \\\\
  \\textbf{{\\#.}} & \\textbf{{Device}} & $\\pm$ &
  \\textbf{{w}} & \\textbf{{bf}} & \\textbf{{c}} & \\textbf{{to}} & \\textbf{{total}} &
  \\textbf{{w}} & \\textbf{{bf}} & \\textbf{{c}} & \\textbf{{to}} & \\textbf{{total}} \\\\
  \\midrule""")

# push LaTex to Overleaf
!cd ~/docs/paper-project_b/ && git pull --rebase

with open(os.path.expanduser("~/docs/paper-project_b/build/tab/outcomes.tex"), "w") as outfile:
    print(outcomes_table, file=outfile)

with open(os.path.expanduser("~/docs/paper-project_b/build/tab/megatable.tex"), "w") as outfile:
    print(classifications_table, file=outfile)

!cd ~/docs/paper-project_b/build && git add . && git commit -m "auto: build/tab: Megatables" && git push
