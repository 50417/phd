#!/usr/bin/env ipython

from collections import namedtuple, OrderedDict
from labm8 import fs
import os
import pandas as pd
import sqlalchemy as sql
import subprocess
import sys

import db
from db import *
%run util.py


hostname = "cc1"
db.init(hostname)

session = db.make_session()

null_columns = " & ".join(["-"] * 6)


TIME_LIMIT = 48 * 3600


def get_outcome_columns(tables: Tableset, testbed: Testbed, no_opt: bool):
    """
    Return results for the specified time limit.

    Arguments:
        results_table: SQLAlchemy table for results.
        programs_table: SQLAlchemy table for programs.
        params_table: SQLAlchemy table for params.
        reduction_table: SQLAlchemy table for reduction results. If
            provided, reductions will be added to the runtime of "w" classified
            results, where possible.
        testbed (db.Testbed): Testbed instance to return results for.
        no_opt (bool): Testbed optimizations off?
    """
    optimizations = not no_opt
    param_ids = [x[0] for x in
        session.query(tables.params.id)\
            .filter(tables.params.optimizations == optimizations)]

    counts = dict((OUTCOMES[outcome], count) for outcome, count in
        session.query(tables.results.outcome, sql.sql.func.count(tables.results.outcome))\
                .join(tables.meta)\
                .join(tables.testcases)\
                .filter(tables.results.testbed_id == testbed.id,
                        tables.testcases.params_id.in_(param_ids),
                        tables.meta.cumtime < TIME_LIMIT)\
                .group_by(tables.results.outcome))

    counts['total'] = sum(counts.values())

    print(' ', device_str(testbed.device), tables.name, no_opt, counts)
    return " & ".join(str(counts.get(x, 0)) for x in ["bf", "bc", "bto", "c", "to", "pass", "total"])


def get_classification_columns(tables: Tableset, testbed: Testbed, no_opt: bool):
    """
    Return results for the specified time limit.

    Arguments:
        results_table: SQLAlchemy table for results.
        programs_table: SQLAlchemy table for programs.
        params_table: SQLAlchemy table for params.
        reduction_table: SQLAlchemy table for reduction results. If
            provided, reductions will be added to the runtime of "w" classified
            results, where possible.
        testbed (db.Testbed): Testbed instance to return results for.
        no_opt (bool): Testbed optimizations off?
    """
    optimizations = not no_opt
    param_ids = [x[0] for x in
        session.query(tables.params.id)\
            .filter(tables.params.optimizations == optimizations)]

    counts = dict((CLASSIFICATIONS[classification], count) for classification, count in
        session.query(tables.classifications.classification, sql.sql.func.count(tables.classifications.classification))\
                .join(tables.results)\
                .join(tables.meta)\
                .join(tables.testcases)\
                .filter(tables.results.testbed_id == testbed.id,
                        tables.testcases.params_id.in_(param_ids),
                        tables.meta.cumtime < TIME_LIMIT)\
                .group_by(tables.classifications.classification))

    counts['total'] = sum(counts.values())

    print(' ', device_str(testbed.device), tables.name, no_opt, counts)
    return " & ".join(str(counts.get(x, 0)) for x in ["w", "bf", "c", "to", "total"])


def get_row(config_id, testbed_id, get_columns):
    """ get mega-table row """
    testbed = session.query(Testbed).filter(Testbed.id == testbed_id).first()
    platform_name = platform_str(testbed.platform)
    device_name = device_str(testbed.device)
    driver_name = driver_str(testbed.driver)

    clsmith_columns = get_columns(CLSMITH_TABLES, testbed, True)
    clgen_columns = get_columns(CLGEN_TABLES, testbed, True)

    clsmith_withopt_columns = get_columns(CLSMITH_TABLES, testbed, False)
    clgen_withopt_columns = get_columns(CLGEN_TABLES, testbed, False)

    return f"""\
\\multirow{{ 2}}{{*}}{{{config_id}}} & \
\\multirow{{ 2}}{{*}}{{{device_name}}} & \
$-$ & {clsmith_columns}       & {clgen_columns} \\\\
& & \
$+$ & {clsmith_withopt_columns} & {clgen_withopt_columns} \\\\"""


def mkmegatable(get_columns, header):
    """ construct a megatable with with requested columns """
    rows = "\n\\hline\n".join(get_row(*x, get_columns) for x in CONFIGURATIONS)
    return f"""\
  {header}
  {rows}
  \\bottomrule
\\end{{tabular}}
"""

def get_outcomes_table():
    return mkmegatable(get_outcome_columns, f"""\\begin{{tabular}}{{lll | rrrrrrr | rrrrrrr }}
  \\toprule
  & & & \\multicolumn{{7}}{{c|}}{{\\textbf{{CLSmith}}}} & \\multicolumn{{7}}{{c}}{{\\textbf{{CLgen}}}} \\\\
  \\textbf{{\\#.}} & \\textbf{{Device}} & $\\pm$ &
  \\textbf{{bf}} & \\textbf{{bc}} & \\textbf{{bto}} & \\textbf{{c}} & \\textbf{{to}} & \\cmark & \\textbf{{total}} &
  \\textbf{{bf}} & \\textbf{{bc}} & \\textbf{{bto}} & \\textbf{{c}} & \\textbf{{to}} & \\cmark & \\textbf{{total}} \\\\
  \\midrule""")

def get_classifications_table():
    return mkmegatable(get_classification_columns, f"""\\begin{{tabular}}{{lll | rrrrr | rrrrr }}
  \\toprule
  & & & \\multicolumn{{5}}{{c|}}{{\\textbf{{CLSmith}}}} & \\multicolumn{{5}}{{c}}{{\\textbf{{CLgen}}}} \\\\
  \\textbf{{\\#.}} & \\textbf{{Device}} & $\\pm$ &
  \\textbf{{ao}} & \\textbf{{abf}} & \\textbf{{ac}} & \\textbf{{ato}} & \\textbf{{total}} &
  \\textbf{{ao}} & \\textbf{{abf}} & \\textbf{{ac}} & \\textbf{{ato}} & \\textbf{{total}} \\\\
  \\midrule""")


if __name__ == "__main__":
    # push LaTex to Overleaf
    !cd ~/docs/paper-project_b/ && git pull --rebase

    print("Generating outcomes table ...")
    with open(os.path.expanduser("~/docs/paper-project_b/build/tab/outcomes.tex"), "w") as outfile:
        print(get_outcomes_table(), file=outfile)

    print("\nGenerating classifications table ...")
    with open(os.path.expanduser("~/docs/paper-project_b/build/tab/megatable.tex"), "w") as outfile:
        print(get_classifications_table(), file=outfile)

    !cd ~/docs/paper-project_b/build && git add . && git commit -m "auto: build/tab: Megatables" && git push
