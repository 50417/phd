\section{Motivation}\label{sec:methodology}

\newsavebox{\IntelSizetIntReduced}
\begin{lrbox}{\IntelSizetIntReduced}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__global double* a) {
      int b = get_global_id(0);
      if (b < -1) {
        a[b] = 1;
      }
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\OclgrindRaceSwitch}
\begin{lrbox}{\OclgrindRaceSwitch}
  \hspace{1.5em}
  \begin{lstlisting}
  __kernel void A(__global int* a, __global int* b) {
    switch (get_global_id(0)) {
      case 0:
        a[get_global_id(0)] = b[get_global_id(0) + 13];
        break;
      case 2:
        a[get_global_id(0)] = b[get_global_id(0) + 11];
        break;
      case 6:
        a[get_global_id(0)] = b[get_global_id(0) + 128];
    }
    barrier(2);
  }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\AlmostEverythingCrash}
\begin{lrbox}{\AlmostEverythingCrash}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A() {
      __builtin_astype(d, uint4);
    }
  \end{lstlisting}
\end{lrbox}

\begin{figure}
  \centering %
  \subfloat[This widely used pattern of integer comparison to thread ID is miscompiled on two compilers when optimizations are enabled and the integer literal is negative, causing the \texttt{if} statement to be executed (hand-reduced version of Figure~\ref{lst:intel-size_t-int}).]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelSizetIntReduced}}}%
    \label{lst:intel-size_t-int-reduced}
  }\\%
  \subfloat[A race condition in \texttt{switch} statement evaluation causes Oclgrind to sporadically crash when executed with a global size $> 1$, irrespective of optimization level.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\OclgrindRaceSwitch}}}%
    \label{lst:oclgrind-race-switch}
  }\\%
  \subfloat[Of the 10 compilers we tested, 6 crash with segfault when compiling this malformed kernel.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\AlmostEverythingCrash}}}%
    \label{lst:almost-everything-crash}
  }\\%
  \caption{Motivating bugs exposed using our approach.}%
  \label{lst:motivation}%
\end{figure}


We motivate the case for compiler fuzzing through deep learning using three example of bugs found using DeepSmith which cannot be generated using existing techniques.

An error in the optimizer of two of the compilers we tested
% Configs.\ $4+$, $6+$
causes the \texttt{if} statement of Figure~\ref{lst:intel-size_t-int-reduced} to be executed when the kernel is compiled with optimizations enabled.
% cd ~/data/kernels/github-pp
% ls | xargs egrep -l 'int [A-Z]+ = get_global_id\(' -- | wc -l
% >> 2144
% ls | wc -l
% >> 4655
This is troubling --- 46\% of kernels on GitHub use this ($tid \rightarrow$ int, \texttt{if}) pattern to guard against invalid memory accesses.


\cc{TODO} Figure~\ref{lst:oclgrind-race-switch}. CLSmith does not support conditional control flow based on thread ID.

\cc{TODO} Figure~\ref{lst:almost-everything-crash}. The behavior of compilers under invalid inputs is --- to the best of our knowledge --- a much lesser explored topic. While it is hard to quantify what constitutes a ``plausible'' error in code, we believe that our approach contributes a significant improvement for generating human-like code over current random-enumeration approaches. \cc{Maybe work on fuzzing JITs?}
