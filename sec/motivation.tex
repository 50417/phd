\section{Motivation}

\newsavebox{\IntelSizetIntReduced}
\begin{lrbox}{\IntelSizetIntReduced}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__global double* a) {
      int b = get_global_id(0);
      if (b < -1)
        a[b] = 1;
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\OclgrindRaceSwitch}
\begin{lrbox}{\OclgrindRaceSwitch}
  \hspace{1.5em}
  \begin{lstlisting}
  __kernel void A(__global int* a, __global int* b) {
    switch (get_global_id(0)) {
      case 0:
        a[get_global_id(0)] = b[get_global_id(0) + 13];
        break;
      case 2:
        a[get_global_id(0)] = b[get_global_id(0) + 11];
        break;
      case 6:
        a[get_global_id(0)] = b[get_global_id(0) + 128];
    }
    barrier(2);
  }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\AlmostEverythingCrash}
\begin{lrbox}{\AlmostEverythingCrash}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A() {
      __builtin_astype(d, uint4);
    }
  \end{lstlisting}
\end{lrbox}

\begin{figure}
  \centering %
  \subfloat[This widely used pattern of integer comparison to thread ID is miscompiled on two compilers when optimizations are enabled, causing the \texttt{if} statement to be executed (hand-reduced version of Figure~\ref{lst:intel-size_t-int}).]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelSizetIntReduced}}}%
    \label{lst:intel-size_t-int-reduced}
  }\\%
  \subfloat[A race condition in \texttt{switch} statement evaluation causes this program to sporadically crash when executed with one compiler and global size $> 1$, irrespective of optimization level.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\OclgrindRaceSwitch}}}%
    \label{lst:oclgrind-race-switch}
  }\\%
  \subfloat[Of the 10 compilers we tested, 6 crash with segfault when compiling this malformed kernel. CLSmith does not generate erroneous code such as this.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\AlmostEverythingCrash}}}%
    \label{lst:almost-everything-crash}
  }\\%
  \caption{Motivating bugs exposed using our approach.}%
  \label{lst:motivation}%
\end{figure}


We motivate the case for compiler fuzzing through deep learning using three example of bugs found using DeepSmith which cannot be generated using existing techniques.

An error in the optimizer of two of the compilers we tested
% Configs.\ $4+$, $6+$
causes the \texttt{if} statement of Figure~\ref{lst:intel-size_t-int-reduced} to be executed when the kernel is compiled with optimizations enabled.
% cd ~/data/kernels/github-pp
% ls | xargs egrep -l 'int [A-Z]+ = get_global_id\(' -- | wc -l
% >> 2144
% ls | wc -l
% >> 4655
This is troubling --- 46\% of kernels on GitHub use this ($tid \rightarrow$ int, \texttt{if}) pattern to guard against invalid memory accesses.


\cc{TODO} Figure~\ref{lst:oclgrind-race-switch}.
\cc{TODO} Figure~\ref{lst:almost-everything-crash}.
