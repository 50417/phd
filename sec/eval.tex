\section{Evaluation}

This section reports on the results of extensive DeepSmith testing of the 10 OpenCL testbeds from Table~\ref{tab:platforms} over four months. We found bugs in all the compilers we tested --- every compiler crashed, and every compiler generated programs which crash or silently compute the wrong result. To date, we have submitted XX bug reports to compiler vendors. % We divide our discussion by class of bug: first, defects which manifest at compile-time, then runtime defects.
Unless stated otherwise, all code listings are presented verbatim as generated by DeepSmith.


\subsection{Compile-time Defects}

We found numerous cases where kernels trigger a crash in the compiler (and as a result, the host process), or the compiler to loop indefinitely. In the majority of cases, we found compiler crashes to be insensitive to OpenCL optimization setting. Figure~\cc{TODO shows an example of one which is not\ldots}

We found the most compiler crash bugs in compiler frontends. Because DeepSmith generates syntactically incorrect code, some test cases do not make it past the lexer, parser, and typechecker. This biases DeepSmith towards discovering bugs in compiler front-ends.

%%%%%%%%%% INVALID SYNTAX
\newsavebox{\OclgrindSemaAssertion}
\begin{lrbox}{\OclgrindSemaAssertion}
  \hspace{1.5em}
  \begin{lstlisting}
    kernel void A(global unsigned char* a, global unsigned char* b) {
      unsigned long c = get_global_id(0);
      d[0] = (mad24(f, (int)(a[0], b[get_global_id(0)])) % (d * (d + 3)) + (c / 2))] * a[c + 1];
    }
  \end{lstlisting}
\end{lrbox}
% This has been forwarded to the LLVM folks https://bugs.llvm.org/show_bug.cgi?id=33897
% __kernel void A(__global float* b) {
%	(float4)(b);
% }

\begin{figure}
  \centering %
  \subfloat[Testbeds $10\pm$ compiler assertion during semantic analysis.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\OclgrindSemaAssertion}}}%
    \label{lst:oclgrind-sema-assertion}
  }\\%
  \caption{Syntactically incorrect codes which crash compilers.}
  \label{lst:bad-syntax}
\end{figure}
%%%%%%%%%% INVALID SYNTAX


\paragraph{Syntax errors} Figure~\ref{lst:oclgrind-sema-assertion}.

110 distinct test cases which crash testbed $9\pm$ during compilation, all silently. 

%%%%%%%%%% TYPE ERRORS
\newsavebox{\NvidiaRecursionSegfault}
\begin{lrbox}{\NvidiaRecursionSegfault}
  \hspace{1.5em}
  \begin{lstlisting}
    kernel void A(float4 a, global float4* b, global float4* c, unsigned int d, global double* e, global int2* f, global int4* g, constant int* h, constant int* i) {
      A(a, b, c, d, d, e, f, g, h);
    }
  \end{lstlisting}
\end{lrbox}
% HAND REDUCED: kernel void A(constant int2* a, global int* b) { A(b, a); }

\newsavebox{\BeignetScalarizeInsert}
\begin{lrbox}{\BeignetScalarizeInsert}
  \hspace{1.5em}
  \begin{lstlisting}
    kernel void A(global float4* a) {
      a[get_local_id(0) / 8][get_local_id(0)] = get_local_id(0);
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\OclgrindUncorrectedTypos}
\begin{lrbox}{\OclgrindUncorrectedTypos}
  \hspace{1.5em}
  \begin{lstlisting}
    kernel void A(global float* a, global float* b) {
      a[0] = max(a[c], b[2]);
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\BeignetPtrIntSpin}
\begin{lrbox}{\BeignetPtrIntSpin}
  \hspace{1.5em}
  \begin{lstlisting}
    kernel void A(global int* a) {
      int b = get_global_id(0);
      a[b] = (6 * 32) + 4 * (32 / 32) + a;
    }
  \end{lstlisting}
\end{lrbox}

\begin{figure}
  \centering
  \subfloat[Testbeds $1\pm$, $2\pm$ segementation fault.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\NvidiaRecursionSegfault}}}%
    \label{lst:nvidia-recursion-segfault}
  }\\%
  \subfloat[Testbeds $3\pm$ assertion \emph{scalarizeInsert} during code generation.]{%
      \noindent\mbox{\parbox{\columnwidth}{\usebox{\BeignetScalarizeInsert}}}%
      \label{lst:oclgrind-uncorrected-typos}
    }\\%
  \subfloat[Testbeds $10\pm$ assertion \emph{Uncorrected typos!} during semantic analysis.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\OclgrindUncorrectedTypos}}}%
    \label{lst:oclgrind-uncorrected-typos}
  }\\%
  \subfloat[Invalid pointer to integer conversion spins Testbeds $3\pm$ at 100\% CPU usage and consuming more memory, until the entire system memory is used and the process crashes.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\BeignetPtrIntSpin}}}%
    \label{lst:oclgrind-uncorrected-typos}
  }\\%
  \caption{Kernels with type errors which crash compilers.}
  \label{}
\end{figure}
%%%%%%%%%% TYPE ERRORS



% \texttt{kernel void A(global float* a) { (float4)(a); }}

\newsavebox{\NvidiaCompileSegfault}
\begin{lrbox}{\NvidiaCompileSegfault}
  \hspace{1.5em}
  \begin{lstlisting}
    kernel void A(global float* a, local float* b, local float* c, int d, int e) {
      int f, g;
      int h = get_local_id(0);
      int i = get_local_id(1);
      int j = get_global_id(0);
      global char* k = c + f * g + f;
      if (f + 1 < h)
        b[f * d + g * h + g] = g * f;
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\XeonPhiSegfault}
\begin{lrbox}{\XeonPhiSegfault}
  \hspace{1.5em}
  \begin{lstlisting}
    kernel void A(void) {
      global int* a;
      unsigned int* b;
      b = a[0];
      a[0] = b;
      a[0] = b;
      barrier(1);
      if (get_global_id(0) == 0) {
        *a = 0;
      }
      a[get_local_id(0)] = 0;
    }
  \end{lstlisting}
\end{lrbox}


%%%%%%%%%% VECTORIZER
\newsavebox{\IntelVectorizerSegfault}
\begin{lrbox}{\IntelVectorizerSegfault}
  \hspace{1.5em}
  \begin{lstlisting}
    kernel void A() {
      while (true) {
        barrier(1);
      }
    }
  \end{lstlisting}
\end{lrbox}

\begin{figure}
  \centering
  \subfloat[Testbeds $5\pm$ crash during vectorizer pass.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelVectorizerSegfault}}}%
    \label{lst:intel-vectorizer-segfault}
  }\\%
  \caption{Example kernels which crash vectorizers.}%
  \label{lst:vectorizer-crashes}%
\end{figure}
%%%%%%%%%% VECTORIZER

\newsavebox{\IntelGtDoubleAssertion}
\begin{lrbox}{\IntelGtDoubleAssertion}
  \hspace{1.5em}
  \begin{lstlisting}
    kernel void A(read_only image2d_t a, global double2* b) {
      b[0] = get_global_id(0);
    }
  \end{lstlisting}
\end{lrbox}

\begin{figure}
  \centering %
  \subfloat[Testbeds $3\pm$ assertion \emph{sel.hasDoubleType()} during code generation.]{%
      \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelGtDoubleAssertion}}}%
      \label{lst:intel-gt2-double-assertion}
    }\\%
  \subfloat[Testbeds $1\pm$ segementation fault.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\NvidiaCompileSegfault}}}%
    \label{lst:nvidia-compile-segfault}
  }\\%
  \subfloat[Testbeds $7\pm$ segementation fault.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\XeonPhiSegfault}}}%
    \label{lst:xeon-phi-segfault}
  }\\%
  \caption{Example kernels which crash compilers.}%
  \label{lst:compiler-crashes}%
\end{figure}

\paragraph{Undeclared variables} Figure~\ref{lst:oclgrind-uncorrected-typos}

\paragraph{Type errors} Figure~\ref{lst:oclgrind-sema-assertion} raises an assertion in the compiler frontend during semantic analysis of the AST for testbeds $10\pm$. Though the code \emph{plausibly} looks correct, it is ill-formed as the identifiers \texttt{d} and \texttt{f} are undefined; all other testbeds raise a build failure. Such test cases (in which the code \emph{looks} right, but contains errors) are extremely unlikely through random token enumeration, and impossible through grammar-based tools.

Figure~\ref{lst:nvidia-recursion-segfault} induces an error in handling of global to constant address qualifiers.

\paragraph{Unreachable code} To date we have identified 207 distinct cases where unreachable code is executed. \cc{How many *distinct* traces?}

\paragraph{Vectorizer Crashes} Figure~\ref{lst:intel-vectorizer-segfault} segfaults during vectorization. \cc{How many? Is there a pattern?}

\paragraph{Code generation} Figures~\ref{lst:intel-llvm-assertion} and~\ref{lst:intel-scalartype-assertion} cause failures in the LLVM code generator backend.


\paragraph{Compiler Hangs} Testbeds $1+$ and $2+$ hang on large loop bounds \cc{how large does the loop bound have to be?}. Testbeds $3\pm$ hang while assigning a value from a pointer address. All Intel compilers (testbeds $4+$, $5+$, $6+$, $7+$) hang during optimization of non-terminating while loops.

\newsavebox{\IntelPtrCompilerHang}
\begin{lrbox}{\IntelPtrCompilerHang}
  \hspace{1.5em}
  \begin{lstlisting}
    kernel void A(global ulong* a) {
      a[get_global_id(0)] = (ulong)(a + 1);
    }
  \end{lstlisting}
\end{lrbox}
% Another 3± hang:
% __kernel void A(__global const char* a, __global char* b, __global char* c) {
%   int d = get_global_id(0);
%   c[d] = get_global_id(0) + c;
% }

% Another 3± hang:
% __kernel void A(global int* a) {
%   local int b[4][3][4][5];
%   b[1][2][3][3] = b[3];
% }

\newsavebox{\IntelOptCompilerHang}
\begin{lrbox}{\IntelOptCompilerHang}
  \hspace{1.5em}
  % CLgenProgram.id = 6992
  \begin{lstlisting}
    kernel void A(global float* a, global float* b, global float* c) {
      int d, e, f;
      d = get_local_id(0);
      float g = 0.0;
      for (int g = 0; g < 100000; g++) {
        barrier(1);
      }
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\XeonPhiSpin}
\begin{lrbox}{\XeonPhiSpin}
  \hspace{1.5em}
  \begin{lstlisting}
    kernel void A(global unsigned char* a, unsigned b) {
      a[get_global_id(0)] %= 42;
      barrier(1);
    }
  \end{lstlisting}
\end{lrbox}
% LLVM ERROR: LLVM2PIL: Cannot yet select: 0x7f72a45a7ed0: i8,i8 = umul_lohi 0x7f72a45a87d0, 0x7f72a45a88d0 [ORD=16] [ID=22]
% 0x7f72a45a87d0: i8 = srl 0x7f72a45a7dd0, 0x7f72a42fff90 [ORD=16] [ID=21]
% 0x7f72a45a7dd0: i8,ch = load 0x7f72a41d9438, 0x7f72a4300790, 0x7f72a4300590<LD1[%scevgep2]> [ORD=15] [ID=20]
% 0x7f72a4300790: i64 = add 0x7f72a45a83d0, 0x7f72a45a80d0 [ORD=14] [ID=17]
% 0x7f72a45a83d0: i64,ch = CopyFromReg 0x7f72a41d9438, 0x7f72a45a86d0 [ORD=14] [ID=13]
% 0x7f72a45a86d0: i64 = Register %vreg1 [ID=1]
% 0x7f72a45a80d0: i64,ch = CopyFromReg 0x7f72a41d9438, 0x7f72a45a81d0 [ORD=14] [ID=14]
% 0x7f72a45a81d0: i64 = Register %vreg2 [ID=2]
% 0x7f72a4300590: i64 = undef [ID=3]
% 0x7f72a42fff90: i8 = Constant<1> [ID=9]
% 0x7f72a45a88d0: i8 = Constant<49> [ID=10]

\newsavebox{\IntelOptLoopHang}
\begin{lrbox}{\IntelOptLoopHang}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(long a, long b) {
      while (a > 273444) { }
    }
  \end{lstlisting}
\end{lrbox}
% Another example:
% __kernel void A(__global int* a) {
%   int b = get_global_id(0);
%   while (b < 512) { }
% }


\begin{figure}
  \centering %
  \subfloat[Implicit pointer to integer conversion hangs Testbeds $3\pm$. All other Testbeds compile in < 1s.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelPtrCompilerHang}}}%
    \label{lst:gt2-compiler-hang}
  }\\%
  \subfloat[Testbed $1+$ hangs during optimization of kernels with large loop bounds. Testbeds $1-$, $2\pm$ compile in under 1 second.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelOptCompilerHang}}}%
    \label{lst:intel-opt-compiler-hang}
  }\\%
  \subfloat[Testbeds $7\pm$ stuck in infinite loop during code generation, consuming 100\% CPU usage.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\XeonPhiSpin}}}%
    \label{lst:xeon-phi-spin}
  }\\%
  \subfloat[Testbeds $4+$, $5+$, $6+$, $7+$ hang during optimization \cc{why?}.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelOptLoopHang}}}%
    \label{lst:intel-inf-loop}
  }\\%
  \caption{Example kernels which hang compilers.}%
  \label{lst:compiler-hangs}%
\end{figure}


\subsection{Runtime Defects}


\newsavebox{\IntelSizetIntUnreduced}
\begin{lrbox}{\IntelSizetIntUnreduced}
  \hspace{1.5em}
  \begin{lstlisting}
    kernel void A(global double* a, global double* b, global double* c, int d, int e) {
      double f;
      int g = get_global_id(0);
      if (g < e - d - 1) {
        c[g] = (((e) / d) % 5) % (e + d);
      }
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\PoclUndefinedSymbols}
\begin{lrbox}{\PoclUndefinedSymbols}
  \hspace{1.5em}
  \begin{lstlisting}
    kernel void A(local int* a) {
      for (int b = 0; b < 100; b++) {
        B(a);
      }
    }
  \end{lstlisting}
\end{lrbox}


\newsavebox{\BeignetCastError}
\begin{lrbox}{\BeignetCastError}
  \hspace{1.5em}
  \begin{lstlisting}
    kernel void A(global float* a, global float* b, global float* c, const int d) {
      int e = get_global_id(0);
      if (e < d) {
        c[e] = a[e] + b[e];
      }
      b[e] = (char)(c[e] + d);
    }
  \end{lstlisting}
\end{lrbox}



\begin{figure}
  \centering %
  \subfloat[Testbeds $4+$, $6+$ incorrectly execute \texttt{if} branch.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelSizetIntUnreduced}}}%
    \label{lst:intel-size_t-int-unreduced}
  }\\%
  \subfloat[Compilation should fail due to call to undefined function \texttt{B()}; Testbeds $6\pm$ silently succeed then crash upon kernel execution.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\PoclUndefinedSymbols}}}%
    \label{lst:pocl-undefined-symbols}
  }\\%
  \subfloat[Testbeds $3\pm$ incorrect cast yields \texttt{b[e] = 127}, not \texttt{b[e] = 0}.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\BeignetCastError}}}%
    \label{lst:beignet-cast-error}
  }\\%
  \caption{Example kernels which are miscompiled.}%
  \label{lst:wrong-code}%
\end{figure}


\paragraph{Thread-dependent flow control} An error in the optimizer of Testbeds $4+$, $6+$ causes the \texttt{if} statement of Figure~\ref{lst:intel-size_t-int-unreduced} to be executed.
% cd ~/data/kernels/github-pp
% ls | xargs egrep -l 'int [A-Z]+ = get_global_id\(' -- | wc -l
% >> 2144
% ls | wc -l
% >> 4655

\paragraph{Silently succeeding} Figure~\ref{lst:pocl-undefined-symbols} exposes a bug in in which a kernel containing an undefined symbol will successfully compile without warning, then crash the program when attempting to run the kernel. Such a test case is trivial to generate, yet could not be synthesized by CSmith.

\paragraph{Type conversion} Figure~\ref{lst:beignet-cast-error}. The code performs int and float addition, casting the result to a char, then storing in float. Changing any one of those 


\subsection{Gray Areas and False Positives}

Some compilers are more permissive than others - some compilers will reject kernels with out-of-range literals \emph{integer literal is too large}.

None of the three statements in Figure~\ref{lst:xeon-phi-invalid-write} are executed by testbeds~$7\pm$, all other configurations return the final value. In testbeds $1\pm$ (but not $2\pm$), out-of-bounds memory reads and writes can be used to overflow into neighboring kernel arguments. In both cases, oclgrind can automatically catch the inalid accesses to prevent false-positives, but perhaps should results may be interesting for testing robustness / security. E.g.~\cite{Holler2012}.

The hardest false-positive to prevent was division by zero and related mathematical functions which require non-zero values. In all cases we discovered these can be prevented by simply changing the input values and checking to see if the output remains anomalous.

\newsavebox{\XeonPhiInvalidWrite}
\begin{lrbox}{\XeonPhiInvalidWrite}
  \hspace{1.5em}
  \begin{lstlisting}
    kernel void A(global int* a) {
      a[0] = 1;
      a[-1] = 2;
      a[0] = 3;
    }
  \end{lstlisting}
\end{lrbox}

\begin{figure}
  \centering %
  \subfloat[The invalid write in line 3 does not affect execution of lines 2 and 4 for all testbeds except $7\pm$. On Testbeds $7\pm$, lines 2 and 4 execute when the invalid write has an index < $44032$, and not  when index $\ge 44032$.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\XeonPhiInvalidWrite}}}%
    \label{lst:xeon-phi-invalid-write}
  }\\%
  \caption{Example kernels which mis-match.}%
  \label{lst:gray-areas}%
\end{figure}


\newsavebox{\UninitRead}
\begin{lrbox}{\UninitRead}
  \hspace{1.5em}
  \begin{lstlisting}
      __kernel void A(__global int* a, __global int* b) {
        int c[16];
        int d = get_global_id(0);
        a[d] = b[d] + c[d];
      }
  \end{lstlisting}
\end{lrbox}

%\begin{figure}
%  \centering %
%  \subfloat[Read of uninitialized automatic variable \texttt{c}.]{%
%    \noindent\mbox{\parbox{\columnwidth}{\usebox{\UninitRead}}}%
%    \label{lst:uninit-read}
%  }\\%
%  \caption{False positives.}%
%  \label{lst:uninit-read}%
%\end{figure}


\subsection{Clang progression over time}\label{sec:clangs}

TODO: Using the clang frontend, compile 75,000 DeepSmith kernels. Figure~\ref{fig:clangs}.

\begin{figure}
  \centering %
  \includegraphics[width=.95\columnwidth]{build/img/clang-crashes}%
  \caption{%
    Clang frontend errors of LLVM releases.% 2 years of development has lead to a tenfold decrease in crash rate.
  }%
  \label{fig:clangs} %
\end{figure}

TODO: Report the 5 distinct crashes in LLVM trunk.


\subsection{Comparison to State-of-the-art}\label{sec:vs_clsmith}

In this section we compare DeepSmith to CLSmith~\cite{Lidbury2015a}, the state-of-the-art in OpenCL compiler testing.

\paragraph{Experimental Setup}

We ran each program generator using its default configuration for 48 hours on each of the 10 testbeds of Table~\ref{tab:platforms}. We ran the tests twice, first with optimizations disabled ($-$), then with optimizations enabled ($+$). Total runtime for a test case consists of the generation time, and the time to execute the test case. For DeepSmith, the time to generate test-harness is included.


\subsection{Results Overview}

\begin{table*}
  \scriptsize %
  \centering %
  \input{build/tab/outcomes}
  \caption{%
    Results from 48 hours of testing using CLSmith and DeepSmith. Testbed \#. as per Table~\ref{tab:platforms}. $\pm$ denotes optimizations off ($-$) vs on ($+$). The remaining columns denote build failure (\textbf{bf}), build crash (\textbf{bc}), build timeout (\textbf{bto}), runtime crash (\textbf{c}), timeout (\textbf{to}), and passed (\textbf{\cmark}) outcomes for CLSmith and DeepSmith, respectively.%
  }
  \label{tab:outcomes}
\end{table*}

Table~\ref{tab:outcomes} shows the outcomes of 48 hours of consecutive testing for each of the platforms from Table~\ref{tab:platforms}.

An average of XX CLSmith and XX DeepSmith test cases were evaluated on each device, with an average time per test case of XX and XX respectively. The XX-fold increase in testing throughput achieved by DeepSmith is a result of XXX. Figure~\ref{fig:runtimes} shows the times taken to generate and execute test cases. DeepSmith generation time is proportional to program length, benchmarked at an average 465 chars / second. For Clsmith, generation time depends on the number of rejections which are required before production of statically verified code is correct \cc{ldots}.

Optimization level generally does not affect testing throughput significantly, with the exception of testbed $7+$, in which the slow compilation of kernels containing structs greatly reduces the number of test cases evaluated. This is a result of CLSmith's heavy reliance on structs, and is a known issue --- in XX the authors omnit testing on this testbed for this reason. ``Compilation for the Xeon Phi co-processor is prohibitively slow when relatively large structs are used with op- timizations enabled.''

83.8\% of CLSmith test cases produce a majority \textbf{\cmark} outcome. Proportionally, DeepSmith test cases are less likely to produce a majority pass at 47.9\% of the total. Neither CLSmith or DeepTune guarantee program termination, although DeepSmith programs more likely to terminate --- XX\% majority-\textbf{to} vs XX\% for CLSmith.


\paragraph{Comparison of Results}

CLSmith crashed 8 of the 20 compilers, DeepSmith crashed all of them. See Section X for examples of bugs found from build crashes.

For all except testbed $3\pm$, DeepSmith exposes more compiler crashes than CLSmith. On average, DeepSmith hangs the compiler more frequently. \cc{\ldots}

The integrated GPU Conifgs.\ we tested ($3\pm$) frequently failed to compile CLSmith kernels, resulting in over 10,000 compiler crashes \textbf{bc} or timeouts \textbf{bc}.
% 10,318
% SELECT stderr,COUNT(*) FROM CLSmithResults LEFT JOIN CLSmithMetas ON CLSmithResults.id=CLSmithMetas.id WHERE testbed_id=13 AND CLSmithResults.outcome='bc' AND cumtime < 48 * 3600 GROUP BY CLSmithResults.stderr;
Of the build crashes, 68\% failed silently, and the remainder were caused by the same pointer assignment assertion for which DeepSmith generated a 4 line test case in Figure~\ref{lst:intel-llvm-assertion}. \cc{We also generated silent build crashes, but with an average line count of XX, versus CLSmith's line count of XX.}

% 622 total bc
Testbeds $4$, $5$, $6$, and $7$ have a number CLSmith bc outcomes when optimizations are enabled. Of the non-silent crashes, the cause is the OpenCL vectorizer pass, same as Figure~\ref{lst:intel-vectorizer-segfault}.

\cc{Testbeds $4$, $6$ are the same driver on different hardware, and exhibit similar behavior}


\begin{figure}
	\centering %
	\includegraphics[width=\columnwidth]{build/img/kernel-sizes}%
	\caption{%
		Kernel line counts, grouped by outcome. DeepSmith test cases are on average two orders of magnitude smaller than CLSmith.%
	}%
	\label{fig:kernel-sizes} %
\end{figure}

\paragraph{Test Case Size}
%SELECT MIN(linecount) as minlen,
%->    AVG(linecount) as meanlen,
%->        MAX(linecount) as maxlen
%-> FROM CLSmithResults results
%-> LEFT JOIN CLSmithMetas meta ON results.id = meta.id
%-> LEFT JOIN CLSmithTestCases testcases ON results.testcase_id = testcases.id
%-> LEFT JOIN CLSmithPrograms programs ON testcases.program_id = programs.id
%-> WHERE cumtime < 48 * 3600;
%+--------+-----------+--------+
%| minlen | meanlen   | maxlen |
%+--------+-----------+--------+
%|     56 | 1186.8496 |  11222 |
%+--------+-----------+--------+
The average CLSmith program is 1189 lines long (excluding headers). CLSmith kernels are unreadable, requiring automatic or manual test case reduction.
%SELECT MIN(linecount) as minlen,
%->    AVG(linecount) as meanlen,
%->        MAX(linecount) as maxlen
%-> FROM CLgenResults results
%-> LEFT JOIN CLgenMetas meta ON results.id = meta.id
%-> LEFT JOIN CLgenTestCases testcases ON results.testcase_id = testcases.id
%-> LEFT JOIN CLgenPrograms programs ON testcases.program_id = programs.id
%-> WHERE cumtime < 48 * 3600;
%+--------+---------+--------+
%| minlen | meanlen | maxlen |
%+--------+---------+--------+
%|      1 | 20.3163 |    636 |
%+--------+---------+--------+
Average CLgen kernel is 20 lines long.
% SELECT SUM(linecount)
% FROM CLSmithResults results
% INNER JOIN CLSmithMetas meta ON results.id = meta.id
% INNER JOIN CLSmithTestCases testcases ON results.testcase_id = testcases.id
% INNER JOIN CLSmithPrograms programs on testcases.program_id = programs.id
% WHERE cumtime < 48 * 3600;
Over the course of testing, a combined $3.39 \times 10^8$ of CLSmith code was evaluated, compared to $3.76 \times 10^6$ lines of DeepSmith code.


\paragraph{Differential Tests}

Table~\ref{tab:classifications} shows the results of applying voting heuristics to the results of Table~\ref{tab:outcomes}.

\begin{figure}
	\centering %
	\includegraphics[width=\columnwidth]{build/img/runtimes}%
	\caption{%
		Runtimes, excluding timeouts. On average, DeepSmith test cases are evaluated $XX\times$ faster than CLSmith ($2.45\times$, $4.46\times$, and $66.54\times$ for generation, execution and reduction, respectively).%
%    Total speedup is 3.03x
%    CLgen generation is 2.45x faster than CLSmith
%    CLgen execution is 4.46x faster than CLSmith
%    CLgen reduction is 66.54x faster than CLSmith
	}%
	\label{fig:runtimes} %
\end{figure}


\begin{table*}
	\scriptsize %
	\centering %
	\input{build/tab/megatable}
	\caption{Using voting heuristics to expose anomalous results from 48 hours of testing using CLSmith and DeepSmith. Columns denote anomalous-output (ao), anomalous build failure (\textbf{abf}), anomalous runtime crash (\textbf{ac}), and anomalous timeout (\textbf{ato}) classifications for CLSmith and DeepSmith, respectively. \cc{TODO: Add a distinct crashes column?}}
	\label{tab:classifications}
\end{table*}

The 2357 \textbf{abf} results for CLSmith on Testbeds $4\pm$ and $6\pm$ are all a result of compilers rejecting empty declarations, (e.g. \texttt{int;}) which CLSmith occasionally emits. This is a known CLSmith issue which will likely be addressed.
% https://github.com/ChrisLidbury/CLSmith/issues/7
Similarly, Intel Testbeds 4--7 (but not 3) reject DeepSmith kernels which omit a type specified (e.g. \texttt{\_\_global* a}), whereas all other Testbeds (including 3) emit and warning and default to \texttt{int} type.

% Anomalous build failures
Testbeds $1\pm$, $2\pm$ reject kernels which \texttt{size\_t} parameters.


\paragraph{Test case Reduction} We used a modified version of C-Reduce which supports OpenCL~\cite{Pflanzer2016} to perform automatic test case, using the default settings. The available implementation supports reduction only of anomalous-output test cases, though this could be extended to support other outcomes (we did not do this). Test case reduction is a time-consuming process, even with the parallelized implementation. Figure~\ref{fig:kernel-sizes} shows the runtimes of reductions, and Figure~\cc{TODO} shows the test case sizes before and after reduction. For CLSmith-generated kernels, test case reduction is necessary to expose the problematic code from within the hundreds of lines of generated program. DeepSmith kernels are on average an order of magnitude smaller. We found that reduction \ldots

% Average GitHub charchounts: 1451
% Average GitHub linecounts: 53

\newsavebox{\IntelPtrAssertion}
\begin{lrbox}{\IntelPtrAssertion}
  \hspace{1.5em}
  \begin{lstlisting}
    kernel void A(global int* a, global int* b) {
      int c = (int)get_global_id(0);
      a[c] += b;
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\IntelScalarAssertion}
\begin{lrbox}{\IntelScalarAssertion}
  \hspace{1.5em}
  \begin{lstlisting}
    kernel void A(global float* a, global float* b, global float* c, local float* d, unsigned int e, unsigned int f) {
      for (unsigned int g = get_local_id(0) + get_local_size(0); g < get_local_size(0); g += get_local_size(0)) {
        a[2 * get_local_id(0) + 1] = get_local_id(0);
      }
    }
  \end{lstlisting}
\end{lrbox}

\begin{figure}
  \centering %
  \subfloat[Testbeds $3\pm$ assertion during code generation for pointer assignment.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelPtrAssertion}}}%
    \label{lst:intel-ptr-assertion}
  }\\%
  \subfloat[Testbeds $3\pm$ assertion in scalar type code generation.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelScalarAssertion}}}%
    \label{lst:intel-scalar-assertion}
  }\\%
  \caption{Kernels which trigger compiler assertions which both CLSmith and DeepSmith exposed.}%
  \label{lst:clsmith-compiler-assertions}%
\end{figure}

In 48 hours of testing, DeepSmith triggered 9 distinct compiler assertions, CLSmith 2. Both of the assertions triggered by CLSmith were also triggered by CLgen.
% Test case sizes:
%
% SELECT assertion, AVG(linecount)
% FROM CLSmithResults results
% LEFT JOIN CLSmithTestCases testcases ON results.testcase_id = testcases.id
% LEFT JOIN CLSmithPrograms programs ON testcases.program_id = programs.id
% INNER JOIN CLSmithAssertions assertions ON results.stderr_id = assertions.id
% GROUP BY assertion;
%
% CLSmith:
% 'ASSERTION FAILED: (isa<AllocaInst>(ptr) || ptrCandidate.empty()) && \"storing/loading pointers only support private array\"', '1410.8486'
% 'ASSERTION FAILED: iter != pointerOrigMap.end()', '889.0990'
%
% CLgen:
% ASSERTION FAILED: (isa<AllocaInst>(ptr) || ptrCandidate.empty()) && "storing/loading pointers only support private array"	12.5382
% ASSERTION FAILED: 0	86.3295
% ASSERTION FAILED: isScalarType(type)	5.0000
% ASSERTION FAILED: iter != pointerOrigMap.end()	9.5455
% ASSERTION FAILED: Missing parameters for sync instruction	10.0000
% ASSERTION FAILED: Not implemented	7.1579
% ASSERTION FAILED: Not supported	4.7857
% ASSERTION FAILED: sel.hasDoubleType()	4.6364
% ASSERTION FAILED: srcType != ir::TYPE_U64	3.0000
The CLSmith kernels which triggered the two assertions were on average 1411 and 889 lines respectively (excluding headers). The same assertions were triggered with DeepSmith kernels of average 13 lines and 10 lines, respectively. \cc{TODO: listings}
%
% SELECT num, src, assertion
%FROM CLgenResults results
%LEFT JOIN CLgenTestCases testcases ON results.testcase_id = testcases.id
%LEFT JOIN CLgenPrograms programs ON testcases.program_id = programs.id
%LEFT JOIN Configurations ON results.testbed_id = Configurations.id
%INNER JOIN CLgenAssertions assertions ON results.stderr_id = assertions.id
%WHERE assertion = 'ASSERTION FAILED: srcType != ir::TYPE_U64';
We were able to trigger the assertion \emph{srcType != ir::TYPE\_U64} in Testbeds $3\pm$ with only a 3 line test case.
%
DeepSmith also triggered \emph{unreachable!} compiler errors in 180 distinct test cases, CLSmith triggered 0.

\cc{What is the bug rate per line of code?}


\paragraph{Bug Diversity}

Hard to quantify, but our results suggest the value of our syntactic approach.

% How many GitHub kernels contain 'struct's?
% $ ls | xargs grep -l struct -- | wc -l
% 331
CLSmith is biased towards identifying struct miscompilations, though only 7.1\% of OpenCL kernels on GitHub use them.

Our approach is biased towards identifying bugs in compiler front-ends, since not all generated programms are well formed/well typed. Results suggest we cover more areas of the compiler, E.g. compiler crashes, compiler timeouts, etc.

Oclgrind was resilient to CLSmith testing, yet we managed to trip it up during compilation, and discovered the switch race condition.

Overall, CLSmith is better at finding miscompilations. We believe our approach to be complimentary.

%\begin{figure}
%	\centering %
%	\includegraphics[width=\columnwidth]{build/img/total-tests}%
%	\caption{%
%		Test cases. \cc{TODO: Replot with the fastest and slowest device for each}%
%	}%
%	\label{fig:total-tests} %
%\end{figure}
