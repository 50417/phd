\section{Bugs Discovered in OpenCL Compilers}

This section reports on the results of extensive testing of OpenCL compilers using DeepSmith over the past several months. We found bugs in all the compilers we tested --- every compiler crashed, and every compiler silently generated wrong code. To date, we have submitted XX bug reports to compiler vendors. We divide our discussion by class of bug: first compiler and runtime crashes, then wrong-code bugs.

\subsection{Compiler Crashes}

We found numerous cases where kernels trigger a crash in the compiler (and as a result, the host process). Segmentation faults during compilation were a common source of crash.

In the majority of cases, we found compiler crashes to be insensitive to OpenCL optimization setting.


\paragraph{Front-end} We found the compiler crash bugs in compiler frontends. Because of the large volume of ill-formed test cases, our approach is biased towards discovering bugs in the early stages of compilation: lexing and parsing.

Figure~\ref{lst:oclgrind-sema-assertion} raises an assertion in the compiler frontend during semantic analysis of the AST for configurations $10\pm$. Though the code \emph{plausibly} looks correct, it is ill-formed as the identifiers \texttt{d} and \texttt{f} are undefined; all other configurations raise a build failure. Such test cases (in which the code \emph{looks} right, but contains errors) are extremely unlikely through random string testing, and impossible through grammar-based tools.

Parsers were a common source of errors. To date we have identified over 60 cases where unreachable code is executed due to parse error handling. We also found that relatively large code samples, containing many errors crashed multiple compiles \cc{that shared clang frontend?}.

\paragraph{Middle-end} Figure~\ref{lst:intel-vectorizer-segfault} segfaults during vectorization.

\paragraph{Back-end} Figures~\ref{lst:intel-llvm-assertion} and~\ref{lst:intel-scalartype-assertion} cause failures in the LLVM code generator backend.

Occasionally, the cause of the crash is unclear, as in Figures~\ref{lst:nvidia-recursion-segfault} and~\ref{lst:nvidia-compile-segfault} which segfault the compiler without warning. We found the two commercial vendors NVIDIA and Intel were the most likely to fail silently. When a commerical compiler crahses without an error message, we can only report and move on.

A bug in \texttt{clang::sema} has been forwarded to the LLVM folks.

This kernel Figure~\ref{lst:crash-almost-everything} crashes all Intel compilers except, interestingly, the Intel i5-570.

\input{lst/compiler-crash-bugs}

\subsection{Runtime Crashes}

Figure~\ref{lst:pocl-undefined-symbols} exposes a bug in in which a kernel containing an undefined symbol will successfully compile without warning, then crash the program when attempting to run the kernel. Such a test case is trivial to generate, yet could not be synthesized by CSmith.

Figure~\ref{lst:oclgrind-llvm-densemap-assertion} exposed a race condition in switch statement handling. After reporting to developers, this been fixed.
% https://github.com/jrprice/Oclgrind/commit/23eeaa602d63b7cbec286864c4180252dcde861e

\input{lst/runtime-crash-bugs}

\subsection{Wrong-code Bugs}

\input{lst/wrong-code-bugs}