\section{Bugs Discovered in OpenCL Compilers}

This section reports on the results of extensive DeepSmith testing of the 10 OpenCL testbeds from Table~\ref{tab:platforms} over four months. We found bugs in all the compilers we tested --- every compiler crashed, and every compiler generated programs which crash or silently compute the wrong result. To date, we have submitted XX bug reports to compiler vendors. We divide our discussion by class of bug: first, defects which manifest at compile-time, then runtime defects. Unless stated otherwise, all code samples are presented verbatim as generated by DeepSmith.


\subsection{Compile-time Defects}

We found numerous cases where kernels trigger a crash in the compiler (and as a result, the host process). Segmentation faults during compilation were a common source of crash. In the majority of cases, we found compiler crashes to be insensitive to OpenCL optimization setting. Figure~\cc{TODO shows an example of one which is not\ldots}

%%%%%%%%%% INVALID SYNTAX
\newsavebox{\OclgrindSemaAssertion}
\begin{lrbox}{\OclgrindSemaAssertion}
  \hspace{1.5em}
  \begin{lstlisting}
    kernel void A(global unsigned char* a, global unsigned char* b) {
      unsigned long c = get_global_id(0);
      d[0] = (mad24(f, (int)(a[0], b[get_global_id(0)])) % (d * (d + 3)) + (c / 2))] * a[c + 1];
    }
  \end{lstlisting}
\end{lrbox}
% This has been forwarded to the LLVM folks https://bugs.llvm.org/show_bug.cgi?id=33897
% __kernel void A(__global float* b) {
%	(float4)(b);
% }

\begin{figure}
  \centering %
  \subfloat[Testbeds $10\pm$ compiler assertion during semantic analysis.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\OclgrindSemaAssertion}}}%
    \label{lst:oclgrind-sema-assertion}
  }\\%
  \caption{Syntactically incorrect codes which crash compilers.}
  \label{lst:bad-syntax}
\end{figure}
%%%%%%%%%% INVALID SYNTAX


%%%%%%%%%% TYPE ERRORS
\newsavebox{\NvidiaRecursionSegfault}
\begin{lrbox}{\NvidiaRecursionSegfault}
  \hspace{1.5em}
  \begin{lstlisting}
    kernel void A(float4 a, global float4* b, global float4* c, unsigned int d, global double* e, global int2* f, global int4* g, constant int* h, constant int* i) {
      A(a, b, c, d, d, e, f, g, h);
    }
  \end{lstlisting}
\end{lrbox}
% HAND REDUCED: kernel void A(constant int2* a, global int* b) { A(b, a); }

\newsavebox{\OclgrindUncorrectedTypos}
\begin{lrbox}{\OclgrindUncorrectedTypos}
  \hspace{1.5em}
  \begin{lstlisting}
    kernel void A(global float* a, global float* b) {
      a[0] = max(a[c], b[2]);
    }
  \end{lstlisting}
\end{lrbox}

\begin{figure}
  \centering
  \subfloat[Testbeds $1\pm$, $2\pm$ segementation fault.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\NvidiaRecursionSegfault}}}%
    \label{lst:nvidia-recursion-segfault}
  }\\%
  \subfloat[Testbeds $10\pm$ assertion \emph{Uncorrected typos!} during semantic analysis.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\OclgrindUncorrectedTypos}}}%
    \label{lst:oclgrind-uncorrected-typos}
  }\\%
  \caption{Kernels with type errors which crash compilers.}
  \label{}
\end{figure}
%%%%%%%%%% TYPE ERRORS

\texttt{kernel void A(global float* a) { (float4)(a); }}

\newsavebox{\NvidiaCompileSegfault}
\begin{lrbox}{\NvidiaCompileSegfault}
  \hspace{1.5em}
  \begin{lstlisting}
    kernel void A(global float* a, local float* b, local float* c, int d, int e) {
      int f, g;
      int h = get_local_id(0);
      int i = get_local_id(1);
      int j = get_global_id(0);
      global char* k = c + f * g + f;
      if (f + 1 < h)
        b[f * d + g * h + g] = g * f;
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\XeonPhiSegfault}
\begin{lrbox}{\XeonPhiSegfault}
  \hspace{1.5em}
  \begin{lstlisting}
    kernel void A(void) {
      global int* a;
      unsigned int* b;
      b = a[0];
      a[0] = b;
      a[0] = b;
      barrier(1);
      if (get_global_id(0) == 0) {
        *a = 0;
      }
      a[get_local_id(0)] = 0;
    }
  \end{lstlisting}
\end{lrbox}


%%%%%%%%%% VECTORIZER
\newsavebox{\IntelVectorizerSegfault}
\begin{lrbox}{\IntelVectorizerSegfault}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A() {
      while (true) {
        barrier(1);
      }
    }
  \end{lstlisting}
\end{lrbox}

\begin{figure}
  \centering
  \subfloat[Testbeds $5\pm$ crash during vectorizer pass.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelVectorizerSegfault}}}%
    \label{lst:intel-vectorizer-segfault}
  }\\%
  \caption{Example kernels which crash vectorizers.}%
  \label{lst:vectorizer-crashes}%
\end{figure}
%%%%%%%%%% VECTORIZER

\newsavebox{\IntelGtDoubleAssertion}
\begin{lrbox}{\IntelGtDoubleAssertion}
  \hspace{1.5em}
  \begin{lstlisting}
    kernel void A(read_only image2d_t a, global double2* b) {
      b[0] = get_global_id(0);
    }
  \end{lstlisting}
\end{lrbox}

\begin{figure}
  \centering %
  \subfloat[Testbeds $3\pm$ assertion \emph{sel.hasDoubleType()} during code generation.]{%
      \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelGtDoubleAssertion}}}%
      \label{lst:intel-gt2-double-assertion}
    }\\%
  \subfloat[Testbeds $1\pm$ segementation fault.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\NvidiaCompileSegfault}}}%
    \label{lst:nvidia-compile-segfault}
  }\\%
  \subfloat[Testbeds $7\pm$ segementation fault.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\XeonPhiSegfault}}}%
    \label{lst:xeon-phi-segfault}
  }\\%
  \caption{Example kernels which crash compilers.}%
  \label{lst:compiler-crashes}%
\end{figure}

\paragraph{Front-end} We found the most compiler crash bugs in compiler frontends. Because DeepSmith generates syntactically incorrect code, some test-cases do not make it past the lexer, parser, and typechecker. This biases DeepSmith towards discovering bugs in compiler front-ends.

Figure~\ref{lst:oclgrind-sema-assertion} raises an assertion in the compiler frontend during semantic analysis of the AST for testbeds $10\pm$. Though the code \emph{plausibly} looks correct, it is ill-formed as the identifiers \texttt{d} and \texttt{f} are undefined; all other configurations raise a build failure. Such test-cases (in which the code \emph{looks} right, but contains errors) are extremely unlikely through random token enumeration, and impossible through grammar-based tools.

\cc{Anomalous build failures:} Some compilers are more permissive than others - \emph{integer literal is too large}

\paragraph{Unreachable code} To date we have identified 207 distinct cases where unreachable code is executed during parsing. \cc{How many *distinct* traces?}

\paragraph{Vectorizer Crashes} Figure~\ref{lst:intel-vectorizer-segfault} segfaults during vectorization. \cc{How many? Is there a pattern?}

\paragraph{Code generation} Figures~\ref{lst:intel-llvm-assertion} and~\ref{lst:intel-scalartype-assertion} cause failures in the LLVM code generator backend.

Occasionally, the cause of the crash is unclear, as in Figures~\ref{lst:nvidia-recursion-segfault} and~\ref{lst:nvidia-compile-segfault} which segfault the compiler without warning. We found the two commercial vendors NVIDIA and Intel were the most likely to fail silently. When a commerical compiler crashes without an error message, we can only report and move on.


\paragraph{Compiler Hangs}
Testbeds $1+$ and $2+$ hang on large loop bounds. Testbeds $3\pm$ hang while assigning a value from a pointer address. Testbeds $4+$, $5+$, $6+$, $7+$ hang on non-terminating while loops.

\newsavebox{\IntelPtrCompilerHang}
\begin{lrbox}{\IntelPtrCompilerHang}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__global ulong* a) {
      a[get_global_id(0)] = (ulong)(a + 1);
    }
  \end{lstlisting}
\end{lrbox}
% Another 3± hang:
% __kernel void A(__global const char* a, __global char* b, __global char* c) {
%   int d = get_global_id(0);
%   c[d] = get_global_id(0) + c;
% }

% Another 3± hang:
% __kernel void A(global int* a) {
%   local int b[4][3][4][5];
%   b[1][2][3][3] = b[3];
% }

\newsavebox{\IntelOptCompilerHang}
\begin{lrbox}{\IntelOptCompilerHang}
  \hspace{1.5em}
  % CLgenProgram.id = 6992
  \begin{lstlisting}
    __kernel void A(__global float* a, __global float* b, __global float* c) {
      int d, e, f;
      d = get_local_id(0);
      float g = 0.0;
      for (int g = 0; g < 100000; g++) {
        barrier(1);
      }
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\XeonPhiSpin}
\begin{lrbox}{\XeonPhiSpin}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__global unsigned char* a, unsigned b) {
      a[get_global_id(0)] %= 42;
      barrier(1);
    }
  \end{lstlisting}
\end{lrbox}
% LLVM ERROR: LLVM2PIL: Cannot yet select: 0x7f72a45a7ed0: i8,i8 = umul_lohi 0x7f72a45a87d0, 0x7f72a45a88d0 [ORD=16] [ID=22]
% 0x7f72a45a87d0: i8 = srl 0x7f72a45a7dd0, 0x7f72a42fff90 [ORD=16] [ID=21]
% 0x7f72a45a7dd0: i8,ch = load 0x7f72a41d9438, 0x7f72a4300790, 0x7f72a4300590<LD1[%scevgep2]> [ORD=15] [ID=20]
% 0x7f72a4300790: i64 = add 0x7f72a45a83d0, 0x7f72a45a80d0 [ORD=14] [ID=17]
% 0x7f72a45a83d0: i64,ch = CopyFromReg 0x7f72a41d9438, 0x7f72a45a86d0 [ORD=14] [ID=13]
% 0x7f72a45a86d0: i64 = Register %vreg1 [ID=1]
% 0x7f72a45a80d0: i64,ch = CopyFromReg 0x7f72a41d9438, 0x7f72a45a81d0 [ORD=14] [ID=14]
% 0x7f72a45a81d0: i64 = Register %vreg2 [ID=2]
% 0x7f72a4300590: i64 = undef [ID=3]
% 0x7f72a42fff90: i8 = Constant<1> [ID=9]
% 0x7f72a45a88d0: i8 = Constant<49> [ID=10]

\newsavebox{\IntelOptLoopHang}
\begin{lrbox}{\IntelOptLoopHang}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(long a, long b) {
      while (a > 273444) { }
    }
  \end{lstlisting}
\end{lrbox}
% Another example:
% __kernel void A(__global int* a) {
%   int b = get_global_id(0);
%   while (b < 512) { }
% }


\begin{figure}
  \centering %
  \subfloat[Implicit pointer to integer conversion hangs Testbeds $3\pm$. All other Testbeds compile in < 1s.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelPtrCompilerHang}}}%
    \label{lst:gt2-compiler-hang}
  }\\%
  \subfloat[Testbed $1+$ hangs during optimization of kernels with large loop bounds. Testbeds $1-$, $2\pm$ compile in under 1 second.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelOptCompilerHang}}}%
    \label{lst:intel-opt-compiler-hang}
  }\\%
  \subfloat[Testbeds $7\pm$ stuck in infinite loop during code generation, consuming 100\% CPU usage.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\XeonPhiSpin}}}%
    \label{lst:xeon-phi-spin}
  }\\%
  \subfloat[Testbeds $4+$, $5+$, $6+$, $7+$ hang during optimization \cc{why?}.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelOptLoopHang}}}%
    \label{lst:intel-inf-loop}
  }\\%
  \caption{Example kernels which hang compilers.}%
  \label{lst:compiler-hangs}%
\end{figure}


\subsection{Runtime Defects}


\newsavebox{\IntelSizetIntUnreduced}
\begin{lrbox}{\IntelSizetIntUnreduced}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__global double* a, __global double* b, __global double* c, int d, int e) {
      double f;
      int g = get_global_id(0);
      if (g < e - d - 1) {
        c[g] = (((e) / d) % 5) % (e + d);
      }
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\PoclUndefinedSymbols}
\begin{lrbox}{\PoclUndefinedSymbols}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__local int* a) {
      for (int b = 0; b < 100; b++) {
        B(a);
      }
    }
  \end{lstlisting}
\end{lrbox}


\begin{figure}
  \centering %
  \subfloat[Testbeds $4+$, $6+$ incorrectly execute \texttt{if} branch.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelSizetIntUnreduced}}}%
    \label{lst:intel-size_t-int-unreduced}
  }\\%
  \subfloat[Compilation should fail due to call to undefined function \texttt{B()}; Testbeds $6\pm$ silently succeed then crash upon kernel execution.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\PoclUndefinedSymbols}}}%
    \label{lst:pocl-undefined-symbols}
  }\\%
  \caption{Example kernels which are miscompiled.}%
  \label{lst:wrong-code}%
\end{figure}


An error in the optimizer of Testbeds $4+$, $6+$ causes the \texttt{if} statement of Figure~\ref{lst:intel-size_t-int-unreduced} to be executed.
% cd ~/data/kernels/github-pp
% ls | xargs egrep -l 'int [A-Z]+ = get_global_id\(' -- | wc -l
% >> 2144
% ls | wc -l
% >> 4655

Figure~\ref{lst:pocl-undefined-symbols} exposes a bug in in which a kernel containing an undefined symbol will successfully compile without warning, then crash the program when attempting to run the kernel. Such a test-case is trivial to generate, yet could not be synthesized by CSmith.


\subsubsection{Gray Areas}

Figure~\ref{lst:xeon-phi-invalid-write}.

In Testbeds $1\pm$, out-of-bounds memory reads and writes can be used to overflow into neighboring kernel arguments (\cc{Probably not interesting}).

Out-of-bounds accesses to buffer arguments in testbeds $1\pm$, $2\pm$ bleed into the next buffer.


\newsavebox{\XeonPhiInvalidWrite}
\begin{lrbox}{\XeonPhiInvalidWrite}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__global int* a) {
      a[0] = 1;
      a[-1] = 2;
      a[0] = 3;
    }
  \end{lstlisting}
\end{lrbox}

\begin{figure}
  \centering %
  \subfloat[The invalid write in line 3 does not affect execution of lines 2 and 4 for all configurations except $7\pm$. On Testbeds $7\pm$, lines 2 and 4 execute when the invalid write has an index < $44032$, but not if the index $\ge 44032$.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\XeonPhiInvalidWrite}}}%
    \label{lst:xeon-phi-invalid-write}
  }\\%
  \caption{Example kernels which mis-match.}%
  \label{lst:gray-areas}%
\end{figure}


\newsavebox{\UninitRead}
\begin{lrbox}{\UninitRead}
  \hspace{1.5em}
  \begin{lstlisting}
      __kernel void A(__global int* a, __global int* b) {
        int c[16];
        int d = get_global_id(0);
        a[d] = b[d] + c[d];
      }
  \end{lstlisting}
\end{lrbox}

%\begin{figure}
%  \centering %
%  \subfloat[Read of uninitialized automatic variable \texttt{c}.]{%
%    \noindent\mbox{\parbox{\columnwidth}{\usebox{\UninitRead}}}%
%    \label{lst:uninit-read}
%  }\\%
%  \caption{False positives.}%
%  \label{lst:uninit-read}%
%\end{figure}
