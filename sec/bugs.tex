\section{Bugs Discovered in OpenCL Compilers}

This section reports on the results of extensive testing of OpenCL compilers using DeepSmith over the past several months. We found bugs in all the compilers we tested --- every compiler crashed, and every compiler silently generated wrong code. To date, we have submitted XX bug reports to compiler vendors. We divide our discussion by class of bug: first compiler and runtime crashes, then wrong-code bugs.

\subsection{Compiler Crashes}

\newsavebox{\IntelVectorizerSegfault}
\begin{lrbox}{\IntelVectorizerSegfault}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A() {
      while (true) {
        barrier(1);
      }
    }
  \end{lstlisting}
\end{lrbox}


\newsavebox{\OclgrindSemaAssertion}
\begin{lrbox}{\OclgrindSemaAssertion}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__global unsigned char* a, __global unsigned char* b) {
      unsigned long c = get_global_id(0);
      d[0] = (mad24(f, (int)(a[0], b[get_global_id(0)])) % (d * (d + 3)) + (c / 2))] * a[c + 1];
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\NvidiaCompileSegfault}
\begin{lrbox}{\NvidiaCompileSegfault}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__global float* a, __local float* b, __local float* c, int d, int e) {
      int f, g;
      int h = get_local_id(0);
      int i = get_local_id(1);
      int j = get_global_id(0);
      __global char* k = c + f * g + f;
      if (f + 1 < h)
        b[f * d + g * h + g] = g * f;
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\NvidiaRecursionSegfault}
\begin{lrbox}{\NvidiaRecursionSegfault}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(float4 a, __global float4* b, __global float4* c, unsigned int d, __global double* e, __global int2* f, __global int4* g, __constant int* h, __constant int* i) {
      A(a, b, c, d, d, e, f, g, h);
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\XeonPhiSegfault}
\begin{lrbox}{\XeonPhiSegfault}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(void) {
      __global int* a;
      unsigned int* b;
      b = a[0];
      a[0] = b;
      a[0] = b;
      barrier(1);
      if (get_global_id(0) == 0) {
        *a = 0;
      }
      a[get_local_id(0)] = 0;
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\IntelPtrAssertion}
\begin{lrbox}{\IntelPtrAssertion}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__global int* a, __global int* b) {
      int c = (int)get_global_id(0);
      a[c] += b;
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\IntelScalarAssertion}
\begin{lrbox}{\IntelScalarAssertion}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__global float* a, __global float* b, __global float* c, __local float* d, unsigned int e, unsigned int f) {
      for (unsigned int g = get_local_id(0) + get_local_size(0); g < get_local_size(0); g += get_local_size(0)) {
        a[2 * get_local_id(0) + 1] = get_local_id(0);
      }
    }
  \end{lstlisting}
\end{lrbox}

\begin{figure}
  \centering %
  \subfloat[Configs.\ $5\pm$ crash during vectorizer pass.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelVectorizerSegfault}}}%
    \label{lst:intel-vectorizer-segfault}
  }\\%
  \subfloat[Configs.\ $10\pm$ compiler assertion during semantic analysis.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\OclgrindSemaAssertion}}}%
    \label{lst:oclgrind-sema-assertion}
  }\\%
  \subfloat[Configs.\ $1\pm$ segementation fault.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\NvidiaCompileSegfault}}}%
    \label{lst:nvidia-compile-segfault}
  }\\%
  \subfloat[Configs.\ $1\pm$, $2\pm$ segementation fault.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\NvidiaRecursionSegfault}}}%
    \label{lst:nvidia-recursion-segfault}
  }\\%
  \subfloat[Configs.\ $7\pm$ segementation fault.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\XeonPhiSegfault}}}%
    \label{lst:xeon-phi-segfault}
  }\\%
  \subfloat[Configs.\ $3\pm$ assertion during code generation for pointer assignment.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelPtrAssertion}}}%
    \label{lst:intel-ptr-assertion}
  }\\%
  \subfloat[Configs.\ $3\pm$ assertion in scalar type code generation.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelScalarAssertion}}}%
    \label{lst:intel-scalar-assertion}
  }\\%
  \caption{Example kernels which crash compilers.}%
  \label{lst:compiler-crashes}%
\end{figure}


We found numerous cases where kernels trigger a crash in the compiler (and as a result, the host process). Segmentation faults during compilation were a common source of crash.

In the majority of cases, we found compiler crashes to be insensitive to OpenCL optimization setting.


\paragraph{Front-end} We found the compiler crash bugs in compiler frontends. Because of the large volume of ill-formed test-cases, our approach is biased towards discovering bugs in the early stages of compilation: lexing and parsing.

Figure~\ref{lst:oclgrind-sema-assertion} raises an assertion in the compiler frontend during semantic analysis of the AST for configurations $10\pm$. Though the code \emph{plausibly} looks correct, it is ill-formed as the identifiers \texttt{d} and \texttt{f} are undefined; all other configurations raise a build failure. Such test-cases (in which the code \emph{looks} right, but contains errors) are extremely unlikely through random string testing, and impossible through grammar-based tools.

Parsers were a common source of errors. To date we have identified over 60 cases where unreachable code is executed due to parse error handling. We also found that relatively large code samples, containing many errors crashed multiple compiles \cc{that shared clang frontend?}.

\paragraph{Middle-end} Figure~\ref{lst:intel-vectorizer-segfault} segfaults during vectorization.

\paragraph{Back-end} Figures~\ref{lst:intel-llvm-assertion} and~\ref{lst:intel-scalartype-assertion} cause failures in the LLVM code generator backend.

Occasionally, the cause of the crash is unclear, as in Figures~\ref{lst:nvidia-recursion-segfault} and~\ref{lst:nvidia-compile-segfault} which segfault the compiler without warning. We found the two commercial vendors NVIDIA and Intel were the most likely to fail silently. When a commerical compiler crashes without an error message, we can only report and move on.

A bug in \texttt{clang::sema} has been forwarded to the LLVM folks.

% TODO: LLVM bug https://bugs.llvm.org/show_bug.cgi?id=33897
% __kernel void A(__global float* b) {
%	(float4)(b);
% }

\subsection{Compiler Hangs}

\newsavebox{\IntelPtrCompilerHang}
\begin{lrbox}{\IntelPtrCompilerHang}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__global int* a) {
      int b = get_global_id(0);
      a[b] = (6 * 32) + 4 * (32 / 32) + a;
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\IntelOptCompilerHang}
\begin{lrbox}{\IntelOptCompilerHang}
  \hspace{1.5em}
  % CLgenProgram.id = 6992
  \begin{lstlisting}
    __kernel void A(__global float* a, __global float* b, __global float* c) {
      int d, e, f;
      d = get_local_id(0);
      float g = 0.0;
      for (int g = 0; g < 100000; g++) {
        barrier(1);
      }
    }
  \end{lstlisting}
\end{lrbox}

\begin{figure}
  \centering %
  \subfloat[Configs.\ $3\pm$ hangs (all other configurations compile in < 1s).]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelPtrCompilerHang}}}%
    \label{lst:gt2-compiler-hang}
  }\\%
  \subfloat[Config.\ $1+$ hangs during compilation, as optimization time grows with the size of loop bounds. Configs.\ $1-$, $2\pm$ compile in under 1 second.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelOptCompilerHang}}}%
    \label{lst:intel-opt-compiler-hang}
  }\\%
  \caption{Example kernels which hang compilers.}%
  \label{lst:compiler-hangs}%
\end{figure}

Configs.\ $1+$ and $2+$ hang on large loop bounds. Configs.\ $3\pm$ hang while assigning a value from a pointer address. Configs.\ $4+$, $5+$, $6+$, $7+$ hang on non-terminating while loops.

\begin{figure}
\begin{lstlisting}
__kernel void A(__global const char* a, __global char* b, __global char* c) {
	int d = get_global_id(0);
	c[d] = get_global_id(0) + c;
}
\end{lstlisting}
\begin{lstlisting}
__kernel void A(__global ulong* a) {
  a[get_global_id(0)] = (ulong)(a + 1);
}
\end{lstlisting}
\caption{The implicit conversion of pointers to integers in these two kernel causes Configs.\ $3\pm$ to spin in a loop, consuming 100\% CPU and increasing memory until system memory exhausted and the compiler crashes.}
\end{figure}

\begin{figure}
\begin{lstlisting}
__kernel void entry(__global unsigned char* a, unsigned b) {
  a[get_global_id(0)] %= 42;
  barrier(1);
}
\end{lstlisting}
\caption{Configs.\ $7\pm$ spin consuming 100\% CPU usage during code generation.}
%LLVM ERROR: LLVM2PIL: Cannot yet select: 0x7f72a45a7ed0: i8,i8 = umul_lohi 0x7f72a45a87d0, 0x7f72a45a88d0 [ORD=16] [ID=22]
%0x7f72a45a87d0: i8 = srl 0x7f72a45a7dd0, 0x7f72a42fff90 [ORD=16] [ID=21]
%0x7f72a45a7dd0: i8,ch = load 0x7f72a41d9438, 0x7f72a4300790, 0x7f72a4300590<LD1[%scevgep2]> [ORD=15] [ID=20]
%0x7f72a4300790: i64 = add 0x7f72a45a83d0, 0x7f72a45a80d0 [ORD=14] [ID=17]
%0x7f72a45a83d0: i64,ch = CopyFromReg 0x7f72a41d9438, 0x7f72a45a86d0 [ORD=14] [ID=13]
%0x7f72a45a86d0: i64 = Register %vreg1 [ID=1]
%0x7f72a45a80d0: i64,ch = CopyFromReg 0x7f72a41d9438, 0x7f72a45a81d0 [ORD=14] [ID=14]
%0x7f72a45a81d0: i64 = Register %vreg2 [ID=2]
%0x7f72a4300590: i64 = undef [ID=3]
%0x7f72a42fff90: i8 = Constant<1> [ID=9]
%0x7f72a45a88d0: i8 = Constant<49> [ID=10]
\end{figure}

% TODO: Another 3Â± hang
%__kernel void A(global int* a) {
%  local int b[4][3][4][5];
%
%  b[1][2][3][3] = b[3];
%}

\begin{figure}
\begin{lstlisting}
__kernel void A(long a, long b) {
  while (a > 273444) { }
}

__kernel void A(__global int* a) {
  int b = get_global_id(0);
  while (b < 512) { }
}
\end{lstlisting}
\caption{Configs.\ $4+$, $5+$, $6+$, $7+$ hang.}
\end{figure}

\subsection{Runtime Crashes}

Figure~\ref{lst:pocl-undefined-symbols} exposes a bug in in which a kernel containing an undefined symbol will successfully compile without warning, then crash the program when attempting to run the kernel. Such a test-case is trivial to generate, yet could not be synthesized by CSmith.

Figure~\ref{lst:oclgrind-llvm-densemap-assertion} exposed a race condition in switch statement handling. After reporting to developers, this been fixed.
% https://github.com/jrprice/Oclgrind/commit/23eeaa602d63b7cbec286864c4180252dcde861e

\input{lst/runtime-crash-bugs}

\subsection{Wrong-code Bugs}

An error in the optimizer of Configs.\ $4+$, $6+$ causes the \texttt{if} statement of Figure~\ref{lst:compiler-crashes} to be executed.
% cd ~/data/kernels/github-pp
% ls | xargs egrep -l 'int [A-Z]+ = get_global_id\(' -- | wc -l
% >> 2144
% ls | wc -l
% >> 4655
This is troubling --- 46\% of kernels on GitHub use this \texttt{if} construct to guard against invalid memory accesses. Figure~\ref{lst:compiler-crashes} shows a hand-reduced minimal test-case.

\input{lst/wrong-code-bugs}


\begin{figure}
\begin{lstlisting}
__kernel void A(__global int* a) {
  a[-1] = 2;
  a[0] = 1;
}
\end{lstlisting}
\caption{Read of uninitialized automatic variable \texttt{c}.}
\label{lst:uninit-read}
\end{figure}


\subsection{False Positives}

\begin{figure}
\begin{lstlisting}
__kernel void A(__global int* a, __global int* b) {
  int c[16];
  int d = get_global_id(0);
  a[d] = b[d] + c[d];
}
\end{lstlisting}
\caption{Read of uninitialized automatic variable \texttt{c}.}
\label{lst:uninit-read}
\end{figure}
