\section{Bugs Discovered in OpenCL Compilers}

This section reports on the results of extensive testing of OpenCL compilers using DeepSmith over the past several months. We found bugs in all the compilers we tested --- every compiler crashed, and every compiler silently generated wrong code. To date, we have submitted XX bug reports to compiler vendors. We divide our discussion by class of bug: first compiler and runtime crashes, then wrong-code bugs.


\subsection{Experimental Setup}

Tables~\ref{tab:platforms}.

\subsection{Compiler Crashes}

\newsavebox{\IntelVectorizerSegfault}
\begin{lrbox}{\IntelVectorizerSegfault}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A() {
      while (true) {
        barrier(1);
      }
    }
  \end{lstlisting}
\end{lrbox}


\newsavebox{\OclgrindSemaAssertion}
\begin{lrbox}{\OclgrindSemaAssertion}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__global unsigned char* a, __global unsigned char* b) {
      unsigned long c = get_global_id(0);
      d[0] = (mad24(f, (int)(a[0], b[get_global_id(0)])) % (d * (d + 3)) + (c / 2))] * a[c + 1];
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\NvidiaCompileSegfault}
\begin{lrbox}{\NvidiaCompileSegfault}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__global float* a, __local float* b, __local float* c, int d, int e) {
      int f, g;
      int h = get_local_id(0);
      int i = get_local_id(1);
      int j = get_global_id(0);
      __global char* k = c + f * g + f;
      if (f + 1 < h)
        b[f * d + g * h + g] = g * f;
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\NvidiaRecursionSegfault}
\begin{lrbox}{\NvidiaRecursionSegfault}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(float4 a, __global float4* b, __global float4* c, unsigned int d, __global double* e, __global int2* f, __global int4* g, __constant int* h, __constant int* i) {
      A(a, b, c, d, d, e, f, g, h);
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\XeonPhiSegfault}
\begin{lrbox}{\XeonPhiSegfault}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(void) {
      __global int* a;
      unsigned int* b;
      b = a[0];
      a[0] = b;
      a[0] = b;
      barrier(1);
      if (get_global_id(0) == 0) {
        *a = 0;
      }
      a[get_local_id(0)] = 0;
    }
  \end{lstlisting}
\end{lrbox}

\begin{figure}
  \centering %
  \subfloat[Configs.\ $5\pm$ crash during vectorizer pass.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelVectorizerSegfault}}}%
    \label{lst:intel-vectorizer-segfault}
  }\\%
  \subfloat[Configs.\ $10\pm$ compiler assertion during semantic analysis.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\OclgrindSemaAssertion}}}%
    \label{lst:oclgrind-sema-assertion}
  }\\%
  \subfloat[Configs.\ $1\pm$ segementation fault.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\NvidiaCompileSegfault}}}%
    \label{lst:nvidia-compile-segfault}
  }\\%
  \subfloat[Configs.\ $1\pm$, $2\pm$ segementation fault.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\NvidiaRecursionSegfault}}}%
    \label{lst:nvidia-recursion-segfault}
  }\\%
  \subfloat[Configs.\ $7\pm$ segementation fault.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\XeonPhiSegfault}}}%
    \label{lst:xeon-phi-segfault}
  }\\%
  \caption{Example kernels which crash compilers.}%
  \label{lst:compiler-crashes}%
\end{figure}


We found numerous cases where kernels trigger a crash in the compiler (and as a result, the host process). Segmentation faults during compilation were a common source of crash.

In the majority of cases, we found compiler crashes to be insensitive to OpenCL optimization setting.

\paragraph{Front-end} We found the most compiler crash bugs in compiler frontends. Because there is no guarantee that DeepSmith programs well-formed, our approach is biased towards discovering bugs in the early stages of compilation: lexing and parsing.

Figure~\ref{lst:oclgrind-sema-assertion} raises an assertion in the compiler frontend during semantic analysis of the AST for configurations $10\pm$. Though the code \emph{plausibly} looks correct, it is ill-formed as the identifiers \texttt{d} and \texttt{f} are undefined; all other configurations raise a build failure. Such test-cases (in which the code \emph{looks} right, but contains errors) are extremely unlikely through random token enumeration, and impossible through grammar-based tools.

Parsers were a common source of errors. To date we have identified 207 distinct cases where unreachable code is executed during parsing.

\paragraph{Middle-end} Figure~\ref{lst:intel-vectorizer-segfault} segfaults during vectorization.

\paragraph{Back-end} Figures~\ref{lst:intel-llvm-assertion} and~\ref{lst:intel-scalartype-assertion} cause failures in the LLVM code generator backend.

Occasionally, the cause of the crash is unclear, as in Figures~\ref{lst:nvidia-recursion-segfault} and~\ref{lst:nvidia-compile-segfault} which segfault the compiler without warning. We found the two commercial vendors NVIDIA and Intel were the most likely to fail silently. When a commerical compiler crashes without an error message, we can only report and move on.

A bug in \texttt{clang::sema} has been forwarded to the LLVM folks.

% TODO: LLVM bug https://bugs.llvm.org/show_bug.cgi?id=33897
% __kernel void A(__global float* b) {
%	(float4)(b);
% }


\subsection{Compiler Hangs}

\newsavebox{\IntelPtrCompilerHang}
\begin{lrbox}{\IntelPtrCompilerHang}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__global ulong* a) {
      a[get_global_id(0)] = (ulong)(a + 1);
    }
  \end{lstlisting}
\end{lrbox}
% Another 3± hang:
% __kernel void A(__global const char* a, __global char* b, __global char* c) {
%   int d = get_global_id(0);
%   c[d] = get_global_id(0) + c;
% }

% Another 3± hang:
% __kernel void A(global int* a) {
%   local int b[4][3][4][5];
%   b[1][2][3][3] = b[3];
% }

\newsavebox{\IntelOptCompilerHang}
\begin{lrbox}{\IntelOptCompilerHang}
  \hspace{1.5em}
  % CLgenProgram.id = 6992
  \begin{lstlisting}
    __kernel void A(__global float* a, __global float* b, __global float* c) {
      int d, e, f;
      d = get_local_id(0);
      float g = 0.0;
      for (int g = 0; g < 100000; g++) {
        barrier(1);
      }
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\XeonPhiSpin}
\begin{lrbox}{\XeonPhiSpin}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__global unsigned char* a, unsigned b) {
      a[get_global_id(0)] %= 42;
      barrier(1);
    }
  \end{lstlisting}
\end{lrbox}
% LLVM ERROR: LLVM2PIL: Cannot yet select: 0x7f72a45a7ed0: i8,i8 = umul_lohi 0x7f72a45a87d0, 0x7f72a45a88d0 [ORD=16] [ID=22]
% 0x7f72a45a87d0: i8 = srl 0x7f72a45a7dd0, 0x7f72a42fff90 [ORD=16] [ID=21]
% 0x7f72a45a7dd0: i8,ch = load 0x7f72a41d9438, 0x7f72a4300790, 0x7f72a4300590<LD1[%scevgep2]> [ORD=15] [ID=20]
% 0x7f72a4300790: i64 = add 0x7f72a45a83d0, 0x7f72a45a80d0 [ORD=14] [ID=17]
% 0x7f72a45a83d0: i64,ch = CopyFromReg 0x7f72a41d9438, 0x7f72a45a86d0 [ORD=14] [ID=13]
% 0x7f72a45a86d0: i64 = Register %vreg1 [ID=1]
% 0x7f72a45a80d0: i64,ch = CopyFromReg 0x7f72a41d9438, 0x7f72a45a81d0 [ORD=14] [ID=14]
% 0x7f72a45a81d0: i64 = Register %vreg2 [ID=2]
% 0x7f72a4300590: i64 = undef [ID=3]
% 0x7f72a42fff90: i8 = Constant<1> [ID=9]
% 0x7f72a45a88d0: i8 = Constant<49> [ID=10]

\newsavebox{\IntelOptLoopHang}
\begin{lrbox}{\IntelOptLoopHang}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(long a, long b) {
      while (a > 273444) { }
    }
  \end{lstlisting}
\end{lrbox}
% Another example:
% __kernel void A(__global int* a) {
%   int b = get_global_id(0);
%   while (b < 512) { }
% }


\begin{figure}
  \centering %
  \subfloat[Implicit pointer to integer conversion hangs Configs.\ $3\pm$. All other Configs.\ compile in < 1s.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelPtrCompilerHang}}}%
    \label{lst:gt2-compiler-hang}
  }\\%
  \subfloat[Config.\ $1+$ hangs during optimization of programs with large loop bounds. Configs.\ $1-$, $2\pm$ compile in under 1 second.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelOptCompilerHang}}}%
    \label{lst:intel-opt-compiler-hang}
  }\\%
  \subfloat[Configs.\ $7\pm$ stuck in infinite loop during code generation, consuming 100\% CPU usage.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\XeonPhiSpin}}}%
    \label{lst:xeon-phi-spin}
  }\\%
  \subfloat[Configs.\ $4+$, $5+$, $6+$, $7+$ hang during optimization \cc{why?}.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelOptLoopHang}}}%
    \label{lst:intel-inf-loop}
  }\\%
  \caption{Example kernels which hang compilers.}%
  \label{lst:compiler-hangs}%
\end{figure}

Configs.\ $1+$ and $2+$ hang on large loop bounds. Configs.\ $3\pm$ hang while assigning a value from a pointer address. Configs.\ $4+$, $5+$, $6+$, $7+$ hang on non-terminating while loops.


\subsection{Anomalous Outputs}

\newsavebox{\IntelSizetInt}
\begin{lrbox}{\IntelSizetInt}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__global double* a, __global double* b, __global double* c, int d, int e) {
      double f;
      int g = get_global_id(0);
      if (g < e - d - 1) {
        c[g] = (((e) / d) % 5) % (e + d);
      }
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\PoclUndefinedSymbols}
\begin{lrbox}{\PoclUndefinedSymbols}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__local int* a) {
      for (int b = 0; b < 100; b++) {
        B(a);
      }
    }
  \end{lstlisting}
\end{lrbox}


\begin{figure}
  \centering %
  \subfloat[Configs.\ $4+$, $6+$ incorrectly execute \texttt{if} branch.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelSizetInt}}}%
    \label{lst:intel-size_t-int}
  }\\%
  \subfloat[Compilation should fail due to call to undefined function \texttt{B()}; Configs.\ $6\pm$ silently succeed then crash upon kernel execution.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\PoclUndefinedSymbols}}}%
    \label{lst:pocl-undefined-symbols}
  }\\%
  \caption{Example kernels which are miscompiled.}%
  \label{lst:wrong-code}%
\end{figure}


An error in the optimizer of Configs.\ $4+$, $6+$ causes the \texttt{if} statement of Figure~\ref{lst:compiler-crashes} to be executed.
% cd ~/data/kernels/github-pp
% ls | xargs egrep -l 'int [A-Z]+ = get_global_id\(' -- | wc -l
% >> 2144
% ls | wc -l
% >> 4655
This is troubling --- 46\% of kernels on GitHub use this \texttt{if} construct to guard against invalid memory accesses. Figure~\ref{lst:compiler-crashes} shows a hand-reduced minimal test-case.

Figure~\ref{lst:pocl-undefined-symbols} exposes a bug in in which a kernel containing an undefined symbol will successfully compile without warning, then crash the program when attempting to run the kernel. Such a test-case is trivial to generate, yet could not be synthesized by CSmith.


\subsection{Gray Areas}

Figure~\ref{lst:xeon-phi-invalid-write}.

In Configs.\ $1\pm$, an out-of-bounds reads and writes from one buffer argument will bleed into the next buffer.

some compilers are more permissive than others - \emph{integer literal is too large}


\newsavebox{\XeonPhiInvalidWrite}
\begin{lrbox}{\XeonPhiInvalidWrite}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__global int* a) {
      a[0] = 1;
      a[-1] = 2;
      a[0] = 3;
    }
  \end{lstlisting}
\end{lrbox}

\begin{figure}
  \centering %
  \subfloat[The invalid write in line 3 does not affect execution of lines 2 and 4 for all configurations except $7\pm$. On configs.\ $7\pm$, lines 2 and 4 execute when the invalid write has an index < $44032$, but not if the index $\ge 44032$.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\XeonPhiInvalidWrite}}}%
    \label{lst:xeon-phi-invalid-write}
  }\\%
  \caption{Example kernels which mis-match.}%
  \label{lst:gray-areas}%
\end{figure}


\newsavebox{\UninitRead}
\begin{lrbox}{\UninitRead}
  \hspace{1.5em}
  \begin{lstlisting}
      __kernel void A(__global int* a, __global int* b) {
        int c[16];
        int d = get_global_id(0);
        a[d] = b[d] + c[d];
      }
  \end{lstlisting}
\end{lrbox}

\begin{figure}
  \centering %
  \subfloat[Read of uninitialized automatic variable \texttt{c}.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\UninitRead}}}%
    \label{lst:uninit-read}
  }\\%
  \caption{False positives.}%
  \label{lst:uninit-read}%
\end{figure}
