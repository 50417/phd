\section{Bugs Discovered in OpenCL Compilers}

This section reports on the results of extensive testing of OpenCL compilers using CLgen. We found bugs in all the compilers we tested --- every compiler crashed, and every compiler silently generated wrong code. To date, we have submitted XX bug reports to compiler vendors. We divide our discussion by class of bug: first compiler and runtime crashes, then wrong-code bugs.

\subsection{Compiler Crashes}

We found numerous cases where a kernel triggers a crash in the compiler (and as a result, the host process). Segmentation faults during compilation were a common source of crash. Occasionally, the cause of the crash is unclear, such as in Figures~\ref{lst:nvidia-recursion-segfault} and~\ref{lst:nvidia-compile-segfault} which segfault the compiler without warning. We found the two commercial vendors NVIDIA and Intel were the most likely to fail silently.

In the majority of cases, we found compiler crashes to be insensitive to OpenCL optimization setting.

Our testing revealed bugs in relatively benign and stable parts of mature compilers, such as Figure~\ref{lst:oclgrind-llvm-densemap-assertion}, which exposes a bug in LLVM's hash map implementation.

\paragraph{Front-end} We found the most bugs in compiler frontends. Because of the large volume of ill-formed test cases, our approach is biased towards discovering bugs in the early stages of compilation: lexing and parsing.

Figure~\ref{lst:oclgrind-sema-assertion} raises an assertion in the compiler frontend during semantic analysis of the AST for configurations $10\pm$. Though the code \emph{plausibly} looks correct, it is ill-formed as the identifiers \texttt{d} and \texttt{f} are undefined; all other configurations raise a build failure. Such test cases (in which the code \emph{looks} right, but contains errors) are extremely unlikely through random string testing, and impossible through grammar-based tools.

Parsers were a common source of errors. To date we have identified over 60 cases where unreachable code is executed due to parse error handling. 

\paragraph{Middle-end} Figure~\ref{lst:intel-vectorizer-segfault} segfaults during the vectorizer pass.

\paragraph{Back-end} Figures~\ref{lst:intel-llvm-assertion} and~\ref{lst:intel-scalartype-assertion} cause failures in the LLVM code generator backend.

\input{lst/compiler-crash-bugs}

\subsection{Runtime Crashes}

Figure~\ref{lst:pocl-undefined-symbols} exposes a bug in in which a kernel containing an undefined symbol will successfully compile without warning, then crash the program when attempting to run the kernel. Such a test case is trivial to generate, yet could not be synthesized by CSmith.

\input{lst/runtime-crash-bugs}

\subsection{Wrong-code Bugs}

\input{lst/wrong-code-bugs}