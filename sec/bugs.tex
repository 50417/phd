\section{Bugs Discovered in OpenCL Compilers}

This section reports on the results of extensive testing of OpenCL compilers using DeepSmith over the past several months. We found bugs in all the compilers we tested --- every compiler crashed, and every compiler silently generated wrong code. To date, we have submitted XX bug reports to compiler vendors. We divide our discussion by class of bug: first compiler and runtime crashes, then wrong-code bugs.

\subsection{Compiler Crashes}

\newsavebox{\IntelVectorizerSegfault}
\begin{lrbox}{\IntelVectorizerSegfault}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A() {
      while (true) {
        barrier(1);
      }
    }
  \end{lstlisting}
\end{lrbox}


\newsavebox{\OclgrindSemaAssertion}
\begin{lrbox}{\OclgrindSemaAssertion}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__global unsigned char* a, __global unsigned char* b) {
      unsigned long c = get_global_id(0);
      d[0] = (mad24(f, (int)(a[0], b[get_global_id(0)])) % (d * (d + 3)) + (c / 2))] * a[c + 1];
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\NvidiaCompileSegfault}
\begin{lrbox}{\NvidiaCompileSegfault}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__global float* a, __local float* b, __local float* c, int d, int e) {
      int f, g;
      int h = get_local_id(0);
      int i = get_local_id(1);
      int j = get_global_id(0);
      __global char* k = c + f * g + f;
      if (f + 1 < h)
        b[f * d + g * h + g] = g * f;
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\NvidiaRecursionSegfault}
\begin{lrbox}{\NvidiaRecursionSegfault}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(float4 a, __global float4* b, __global float4* c, unsigned int d, __global double* e, __global int2* f, __global int4* g, __constant int* h, __constant int* i) {
      A(a, b, c, d, d, e, f, g, h);
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\XeonPhiSegfault}
\begin{lrbox}{\XeonPhiSegfault}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(void) {
      __global int* a;
      unsigned int* b;
      b = a[0];
      a[0] = b;
      a[0] = b;
      barrier(1);
      if (get_global_id(0) == 0) {
        *a = 0;
      }
      a[get_local_id(0)] = 0;
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\IntelPtrAssertion}
\begin{lrbox}{\IntelPtrAssertion}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__global int* a, __global int* b) {
      int c = (int)get_global_id(0);
      a[c] += b;
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\IntelScalarAssertion}
\begin{lrbox}{\IntelScalarAssertion}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__global float* a, __global float* b, __global float* c, __local float* d, unsigned int e, unsigned int f) {
      for (unsigned int g = get_local_id(0) + get_local_size(0); g < get_local_size(0); g += get_local_size(0)) {
        a[2 * get_local_id(0) + 1] = get_local_id(0);
      }
    }
  \end{lstlisting}
\end{lrbox}

\begin{figure}
  \centering %
  \subfloat[Configs.\ $5\pm$ crash during vectorizer pass.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelVectorizerSegfault}}}%
    \label{lst:intel-vectorizer-segfault}
  }\\%
  \subfloat[Configs.\ $10\pm$ compiler assertion during semantic analysis.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\OclgrindSemaAssertion}}}%
    \label{lst:oclgrind-sema-assertion}
  }\\%
  \subfloat[Configs.\ $1\pm$ segementation fault.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\NvidiaCompileSegfault}}}%
    \label{lst:nvidia-compile-segfault}
  }\\%
  \subfloat[Configs.\ $1\pm$, $2\pm$ segementation fault.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\NvidiaRecursionSegfault}}}%
    \label{lst:nvidia-recursion-segfault}
  }\\%
  \subfloat[Configs.\ $7\pm$ segementation fault.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\XeonPhiSegfault}}}%
    \label{lst:xeon-phi-segfault}
  }\\%
  \subfloat[Configs.\ $3\pm$ assertion during code generation for pointer assignment.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelPtrAssertion}}}%
    \label{lst:intel-ptr-assertion}
  }\\%
  \subfloat[Configs.\ $3\pm$ assertion in scalar type code generation.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelScalarAssertion}}}%
    \label{lst:intel-scalar-assertion}
  }\\%
  \caption{Example kernels which crash compilers.}%
  \label{lst:compiler-crashes}%
\end{figure}


We found numerous cases where kernels trigger a crash in the compiler (and as a result, the host process). Segmentation faults during compilation were a common source of crash.

In the majority of cases, we found compiler crashes to be insensitive to OpenCL optimization setting.


\paragraph{Front-end} We found the compiler crash bugs in compiler frontends. Because of the large volume of ill-formed test-cases, our approach is biased towards discovering bugs in the early stages of compilation: lexing and parsing.

Figure~\ref{lst:oclgrind-sema-assertion} raises an assertion in the compiler frontend during semantic analysis of the AST for configurations $10\pm$. Though the code \emph{plausibly} looks correct, it is ill-formed as the identifiers \texttt{d} and \texttt{f} are undefined; all other configurations raise a build failure. Such test-cases (in which the code \emph{looks} right, but contains errors) are extremely unlikely through random string testing, and impossible through grammar-based tools.

Parsers were a common source of errors. To date we have identified over 60 cases where unreachable code is executed due to parse error handling. We also found that relatively large code samples, containing many errors crashed multiple compiles \cc{that shared clang frontend?}.

\paragraph{Middle-end} Figure~\ref{lst:intel-vectorizer-segfault} segfaults during vectorization.

\paragraph{Back-end} Figures~\ref{lst:intel-llvm-assertion} and~\ref{lst:intel-scalartype-assertion} cause failures in the LLVM code generator backend.

Occasionally, the cause of the crash is unclear, as in Figures~\ref{lst:nvidia-recursion-segfault} and~\ref{lst:nvidia-compile-segfault} which segfault the compiler without warning. We found the two commercial vendors NVIDIA and Intel were the most likely to fail silently. When a commerical compiler crashes without an error message, we can only report and move on.

A bug in \texttt{clang::sema} has been forwarded to the LLVM folks.

% TODO: LLVM bug https://bugs.llvm.org/show_bug.cgi?id=33897
% __kernel void A(__global float* b) {
%	(float4)(b);
% }


\subsection{Compiler Hangs}

\newsavebox{\IntelPtrCompilerHang}
\begin{lrbox}{\IntelPtrCompilerHang}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__global ulong* a) {
      a[get_global_id(0)] = (ulong)(a + 1);
    }
  \end{lstlisting}
\end{lrbox}
% Another 3± hang:
% __kernel void A(__global const char* a, __global char* b, __global char* c) {
%   int d = get_global_id(0);
%   c[d] = get_global_id(0) + c;
% }

% Another 3± hang:
% __kernel void A(global int* a) {
%   local int b[4][3][4][5];
%   b[1][2][3][3] = b[3];
% }

\newsavebox{\IntelOptCompilerHang}
\begin{lrbox}{\IntelOptCompilerHang}
  \hspace{1.5em}
  % CLgenProgram.id = 6992
  \begin{lstlisting}
    __kernel void A(__global float* a, __global float* b, __global float* c) {
      int d, e, f;
      d = get_local_id(0);
      float g = 0.0;
      for (int g = 0; g < 100000; g++) {
        barrier(1);
      }
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\XeonPhiSpin}
\begin{lrbox}{\XeonPhiSpin}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__global unsigned char* a, unsigned b) {
      a[get_global_id(0)] %= 42;
      barrier(1);
    }
  \end{lstlisting}
\end{lrbox}
% LLVM ERROR: LLVM2PIL: Cannot yet select: 0x7f72a45a7ed0: i8,i8 = umul_lohi 0x7f72a45a87d0, 0x7f72a45a88d0 [ORD=16] [ID=22]
% 0x7f72a45a87d0: i8 = srl 0x7f72a45a7dd0, 0x7f72a42fff90 [ORD=16] [ID=21]
% 0x7f72a45a7dd0: i8,ch = load 0x7f72a41d9438, 0x7f72a4300790, 0x7f72a4300590<LD1[%scevgep2]> [ORD=15] [ID=20]
% 0x7f72a4300790: i64 = add 0x7f72a45a83d0, 0x7f72a45a80d0 [ORD=14] [ID=17]
% 0x7f72a45a83d0: i64,ch = CopyFromReg 0x7f72a41d9438, 0x7f72a45a86d0 [ORD=14] [ID=13]
% 0x7f72a45a86d0: i64 = Register %vreg1 [ID=1]
% 0x7f72a45a80d0: i64,ch = CopyFromReg 0x7f72a41d9438, 0x7f72a45a81d0 [ORD=14] [ID=14]
% 0x7f72a45a81d0: i64 = Register %vreg2 [ID=2]
% 0x7f72a4300590: i64 = undef [ID=3]
% 0x7f72a42fff90: i8 = Constant<1> [ID=9]
% 0x7f72a45a88d0: i8 = Constant<49> [ID=10]

\newsavebox{\IntelOptLoopHang}
\begin{lrbox}{\IntelOptLoopHang}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(long a, long b) {
      while (a > 273444) { }
    }
  \end{lstlisting}
\end{lrbox}
% Another example:
% __kernel void A(__global int* a) {
%   int b = get_global_id(0);
%   while (b < 512) { }
% }


\begin{figure}
  \centering %
  \subfloat[Implicit pointer to integer conversion hangs Configs.\ $3\pm$. All other Configs.\ compile in < 1s.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelPtrCompilerHang}}}%
    \label{lst:gt2-compiler-hang}
  }\\%
  \subfloat[Config.\ $1+$ hangs during optimization of programs with large loop bounds. Configs.\ $1-$, $2\pm$ compile in under 1 second.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelOptCompilerHang}}}%
    \label{lst:intel-opt-compiler-hang}
  }\\%
  \subfloat[Configs.\ $7\pm$ spin consuming 100\% CPU usage during code generation.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\XeonPhiSpin}}}%
    \label{lst:xeon-phi-spin}
  }\\%
  \subfloat[Configs.\ $4+$, $5+$, $6+$, $7+$ hang.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelOptLoopHang}}}%
    \label{lst:xeon-phi-spin}
  }\\%
  \caption{Example kernels which hang compilers.}%
  \label{lst:compiler-hangs}%
\end{figure}

Configs.\ $1+$ and $2+$ hang on large loop bounds. Configs.\ $3\pm$ hang while assigning a value from a pointer address. Configs.\ $4+$, $5+$, $6+$, $7+$ hang on non-terminating while loops.


\subsection{Runtime Crashes}

\newsavebox{\PoclUndefinedSymbols}
\begin{lrbox}{\PoclUndefinedSymbols}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__local int* a) {
      for (int b = 0; b < 100; b++) {
        B(a);
      }
    }
  \end{lstlisting}
\end{lrbox}

\begin{figure}
  \centering %
  \subfloat[Compilation should fail; config $6\pm$ succeeds then crashes program.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\PoclUndefinedSymbols}}}%
    \label{lst:pocl-undefined-symbols}
  }\\%
  \caption{Example kernels which crash at runtime.}%
  \label{lst:compiler-hangs}%
\end{figure}

Figure~\ref{lst:pocl-undefined-symbols} exposes a bug in in which a kernel containing an undefined symbol will successfully compile without warning, then crash the program when attempting to run the kernel. Such a test-case is trivial to generate, yet could not be synthesized by CSmith.

Figure~\ref{lst:oclgrind-llvm-densemap-assertion} exposed a race condition in switch statement handling. After reporting to developers, this been fixed.
% https://github.com/jrprice/Oclgrind/commit/23eeaa602d63b7cbec286864c4180252dcde861e


\subsection{Wrong-code Bugs}

\newsavebox{\IntelSizetInt}
\begin{lrbox}{\IntelSizetInt}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__global double* a, __global double* b, __global double* c, int d, int e) {
      double f;
      int g = get_global_id(0);
      if (g < e - d - 1) {
        c[g] = (((e) / d) % 5) % (e + d);
      }
    }
  \end{lstlisting}
\end{lrbox}

\newsavebox{\XeonPhiInvalidWrite}
\begin{lrbox}{\XeonPhiInvalidWrite}
  \hspace{1.5em}
  \begin{lstlisting}
    __kernel void A(__global int* a) {
      a[0] = 1;
      a[-1] = 2;
      a[0] = 3;
    }
  \end{lstlisting}
\end{lrbox}

\begin{figure}
  \centering %
  \subfloat[Configs.\ $4+$, $6+$ incorrectly execute \texttt{if} branch.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\IntelSizetInt}}}%
    \label{lst:intel-size_t-int}
  }\\%
  \subfloat[Invalid write \texttt{a[-1]} prevents \texttt{a[0]} writes in Configs.\ $7\pm$.]{%
    \noindent\mbox{\parbox{\columnwidth}{\usebox{\XeonPhiInvalidWrite}}}%
    \label{lst:xeon-phi-invalid-write}
  }\\%
  \caption{Example kernels for which compilers emit wrong-code.}%
  \label{lst:wrong-code}%
\end{figure}


An error in the optimizer of Configs.\ $4+$, $6+$ causes the \texttt{if} statement of Figure~\ref{lst:compiler-crashes} to be executed.
% cd ~/data/kernels/github-pp
% ls | xargs egrep -l 'int [A-Z]+ = get_global_id\(' -- | wc -l
% >> 2144
% ls | wc -l
% >> 4655
This is troubling --- 46\% of kernels on GitHub use this \texttt{if} construct to guard against invalid memory accesses. Figure~\ref{lst:compiler-crashes} shows a hand-reduced minimal test-case.


\subsection{False Positives}

\begin{figure}
\begin{lstlisting}
__kernel void A(__global int* a, __global int* b) {
  int c[16];
  int d = get_global_id(0);
  a[d] = b[d] + c[d];
}
\end{lstlisting}
\caption{Read of uninitialized automatic variable \texttt{c}.}
\label{lst:uninit-read}
\end{figure}
