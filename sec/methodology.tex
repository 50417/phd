\section{Testing Methodologies}\label{sec:methodology}

Test cases must be executed, resulting in one-of-six possible outcomes. Then voting across outcomes from different compilers is used to expose anomalous outcomes.


\subsection{Test Case Execution}

\begin{figure}
  \centering %
  \includegraphics[width=.62\columnwidth]{img/test_process}%
  \caption{%
    Test case execution, and possible outcomes. Each test case produces one of 6 possible outcomes: \{bf,bc,bto,c,to,\cmark\}.%
  }%
\label{fig:test-process} %
\end{figure}


Figure~\ref{fig:test-process} shows the methodology for determining the outcomes of a single test case.

In prior work we required that synthesized programs be well formed and compute \emph{useful work}. For the purpose of testing compilers, we discarded these requirements. Instead, we demand that the behavior of test cases is \emph{portable} and \emph{reproducible}. In some respects this simplifies the execution process. The possible outcomes for a test case are a build failure (\textbf{bf}), build crash (\textbf{bc}), runtime crash (\textbf{c}), or pass (\textbf{\cmark}). A \textbf{bf} occurs when compilation of a kernel fails, usually accompanied by an error message. A \textbf{bc} outcome occurs when the compiler crashes. In~\cite{Lidbury2015a}, the authors do not distinguish between compiler crashes and build failures. A \textbf{c} outcome occurs when the program crashes during execution. The \textbf{bto} and \textbf{to} outcomes occur when the program compilation or execution time out, respectively. As in previous work, we do not guarantee that generated programs time out, finding that XX\% of programs do not.

There are six possible outcomes of a test case execution:
%
\begin{enumerate}
	\item \textbf{bf} \emph{Build failure} Online compilation of OpenCL program fails, whereas the majority of configurations produce a binary.
	\item \textbf{bc} \emph{Build crash} Compilation of program fails due to compiler crahs.
	\item \textbf{bto} \emph{Build timeout} Online compilation of OpenCL exceeds a timeout of 60 seconds.
	\item \textbf{c} \emph{Runtime crash} One or more OpenCL API calls return an error status during the program execution, or the program crashes.
	\item \textbf{to} \emph{Runtime timeout} Program execution exceeds the timeout of 60 second.
	\item \textbf{\cmark} \emph{Completion} The program terminates gracefully and produces an output.
\end{enumerate}


\subsection{Voting Heuristics for Differential Testing}

Voting is used to expose anomalous outcomes from configurations. In prior work, voting has been used to determine wrong-code bugs. In~\cite{Lidbury2015a}, a configuration is determined to have produced a wrong code result for a kernel if there is a majority of at least 3 among the non-\{\textbf{bf},\textbf{c},\textbf{to}\} results for the kernel, and the configuration yields a non-\{\textbf{bf},\textbf{c},\textbf{to}\} result that disagrees with the majority. We extend this approach to describe not only anomalous code bugs, but also anomalous build failures, crashes, and timeouts.

A majority exists if there at least 6 configurations produce non-bc results with the same outcome, and of these $n$ non-bc configurations, at least $\ceil{n/2}$ configurations have the same outcome. Majority outcome $\mu$. For \cmark outcomes, the output of the program is used.

Only 2.3\% of CLSmith programs with anomalous outputs are insensitive to optimization level.

%
\begin{enumerate}
	\item \textbf{w} \emph{Wrong code} Program terminates gracefully, but computes a result which differs from the majority output. For a DeepSmith result to be classified with \emph{wrong-code}, we require first that the program passes verification using GPUVerify~\cite{Betts2012}, and that a reference run with Oclgrind~\cite{Price2015} produces no warnings. \cc{Vote on compiler warnings, and optimization sensitivity. This means we way miss bugs which optimization level insensitive, though our experiences testing with CLSmith revelead only discovered 2 such cases}.
	\item \textbf{bf} \emph{Build failure} Online compilation of OpenCL program fails, whereas the majority of configurations produce a binary. \cc{TODO: voting to exclude programs which rely on OpenCL 2.0 / compiler specific features}
	\item \textbf{c} \emph{Runtime crash} One or more OpenCL API calls return an error status during the program execution, or the program crashes.
	\item \textbf{to} \emph{Runtime timeout} Program execution exceeds the timeout of 60 second, whereas the majority of configurations produce an output.
\end{enumerate}


\paragraph{Floating points} The OpenCL 1.2 specification permits acceptable error bounds (ULP) for floating point operations and builtin functions. Some operations like addition, subtraction, and multiplication are precise; divide permits a small error, and builtins vary widely. Thus two implementation may give different answers that both fit within the allowed ranges (and because errors propagate through operations it's hard to even describe the ULP on the final output). \texttt{half\_} functions permit large error bounds. \texttt{native\_} functions have ``implementation defined'' error bounds. TODO: Denormal numbers may optionally be pushed to zero.

\cc{If we difftest across floats:}
CSmith, and by extension, CLSmith, do not support floating point operations. In our observations with testing using CLSmith (described in Section~\ref{sec:vs_clsmith}), we observed that in cases of wrong-code bugs, the computed values are usually entirely incorrect, not only marginally different. We hypothesized that by allowing relaxed comparisons between floating point values, we could still differential test. We permit a margin of deviation for floating point comparisons. This means that if a compiler were to emit wrong code which changes the computed value only subtly, we may miss it; though we have no reason to suggest that such a case is any more likely than a wrong code bug leading the compiler to produce exactly the same output, which neither we or any prior work have noted.

\cc{If we ignore floats:}
Given that not all vendors provide bounds for floating point imprecision, we excluded kernels containing floating points from the wrong-code check. Given knowledge about hardware imprecision, it would be possible to compute threshold for floating point difftests.
% Section 7.4 of OpenCL 1.2 spec.