#!/usr/bin/env python2.7
#
# Copyright 2016, 2017, 2018 Chris Cummins <chrisc.101@gmail.com>.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
from __future__ import print_function

import logging
import os
import socket
import sys

from argparse import ArgumentParser
from collections import deque
from time import time

import dotfiles
from util import *
from dotfiles import *


class SchedulingError(Exception): pass


def schedule_task(task_name, schedule, all_tasks, depth=1):
    """ recursively schedule a task and its dependencies """
    # Sanity check for scheduling errors:
    if depth > 1000:
        raise SchedulingError("failed to resolve schedule for task '" +
                              task_name + "' after 1000 tries")
        sys.exit(1)

    # Instantiate the task class:
    if not hasattr(dotfiles, task_name):
        raise SchedulingError("task '" + task_name + "' not found!")

    # If the task is not runnable, schedule nothing.
    task_class = getattr(dotfiles, task_name)
    if not is_runnable_task(task_class):
        return True

    task = task_class()

    # Build a list of dependencies:
    deps = get_task_deps(task)

    # Check that all dependencies have already been scheduled:
    for dep_name in deps:
        if dep_name == task_name:
            raise SchedulingError("task '" + task_name + "' depends on itself")

        if dep_name not in schedule:
            # If any of the dependencies are not runnable, schedule nothing.
            if schedule_task(dep_name, schedule, all_tasks, depth + 1):
                return True

    # Schedule the task if necessary:
    if task_name not in schedule:
        schedule.append(task_name)


def get_tasks_to_run(*task_names):
    """ generate the list of task names to run """
    # Remove duplicate task names:
    task_names = set(task_names)

    # Build a list of available task names:
    all_tasks = set([type(x[1]()).__name__ for x in inspect.getmembers(sys.modules[__name__], is_runnable_task)])

    # Determine the tasks which need scheduling:
    to_schedule = task_names if len(task_names) else list(all_tasks)

    # Build the schedule:
    to_schedule = deque(sorted(to_schedule))
    schedule = []
    try:
        while len(to_schedule):
            task = to_schedule.popleft()
            schedule_task(task, schedule, all_tasks)
    except SchedulingError as e:
        print("fatal:", e, file=sys.stderr)
        sys.exit(1)

    return deque(schedule)


def main(*args):
    """ main dotfiles method """

    # Parse arguments
    parser = ArgumentParser()
    parser.add_argument('tasks', metavar='<task>', nargs='*',
                        help="the name of tasks to run (default: all)")
    type_group = parser.add_mutually_exclusive_group()
    type_group.add_argument('-d', '--describe', action="store_true")
    type_group.add_argument('-u', '--upgrade', action='store_true')
    type_group.add_argument('-r', '--remove', action='store_true')
    verbosity_group = parser.add_mutually_exclusive_group()
    verbosity_group.add_argument('-v', '--verbose', action='store_true')
    verbosity_group.add_argument('-D', '--debug', action='store_true')
    args = parser.parse_args(args)

    # Configure logger
    if args.debug:
        loglevel = logging.DEBUG
    elif args.verbose:
        loglevel = logging.INFO
    else:
        loglevel = logging.WARNING
    logging.basicConfig(level=loglevel, format="%(message)s")

    # Get the list of tasks to run
    logging.debug("creating tasks list ...")
    queue = get_tasks_to_run(*args.tasks)
    done = set()
    ntasks = len(queue)

    # --describe flag prints a description of the work to be done:
    if args.describe:
        print("There are " + Colors.BOLD + str(ntasks) + Colors.END +
              " tasks to run on " + PLATFORM + ":")
        for i, task_name in enumerate(queue):
            task = getattr(dotfiles, task_name)()
            description = (task.__doc__ or "").strip()
            print("  [{:2d}/{:2d}]".format(i + 1, ntasks) + Colors.BOLD,
                  str(task), Colors.END + "... " + description)
            # build a list of generated files
            genfiles = getattr(task, "__genfiles__", [])
            genfiles += getattr(task, "__" + PLATFORM + "_genfiles__", [])
            for file in sorted(set(genfiles)):
                logging.info("    " + os.path.abspath(os.path.expanduser(file)))

        return 0

    if args.upgrade:
        task_type = "upgrade"
    elif args.remove:
        task_type = "uninstall"
    else:
        task_type = "install"

    # Run the tasks
    print("Running " + Colors.BOLD + str(ntasks) + " " + task_type +
          Colors.END + " tasks on", PLATFORM + ":")
    errored = False
    try:
        for i, task_name in enumerate(queue):
            task = getattr(dotfiles, task_name)()

            # Resolve and run install() method:
            print("[{:2d}/{:2d}]".format(i + 1, ntasks) + Colors.BOLD,
                  str(task), Colors.END + "...")
            if logging.getLogger().level <= logging.INFO:
                print()
            sys.stdout.flush()
            start_time = time()
            get_task_method(task, task_type)()
            done.add(task)
            # build a list of generated files:
            genfiles = getattr(task, "__genfiles__", [])
            genfiles += getattr(task, "__" + PLATFORM + "_genfiles__", [])

            if task_type == "install":
                for file in set(genfiles):
                    file = os.path.abspath(os.path.expanduser(file))
                    if not (os.path.exists(file) or
                            shell_ok("sudo test -f '{file}'".format(**vars())) or
                            shell_ok("sudo test -d '{file}'".format(**vars()))):
                        raise InvalidTaskError('genfile "{file}" not created'.format(**vars()))
            runtime = time() - start_time

            # print("{:.3f}s".format(runtime))
            sys.stdout.flush()
    except KeyboardInterrupt:
        print("\ninterrupt")
        errored = True
    except Exception as e:
        print(Colors.BOLD + Colors.RED + type(e).__name__)
        print(e, Colors.END)
        errored = True
        if logging.getLogger().level <= logging.DEBUG:
            raise
    finally:
        # Task teardowm
        logging.debug("")
        for task in done:
            logging.debug("  " + Colors.BOLD + type(task).__name__ + " teardown" + Colors.END)
            get_task_method(task, "teardown")()

            # build a list of temporary files
            tmpfiles = getattr(task, "__tmpfiles__", [])
            tmpfiles += getattr(task, "__" + PLATFORM + "_tmpfiles__", [])

            # remove any temporary files
            for file in tmpfiles:
                file = os.path.abspath(os.path.expanduser(file))
                if os.path.exists(file):
                    logging.debug("rm {file}".format(**vars()))
                    os.remove(file)

    return 1 if errored else 0


if __name__ == "__main__":
    sys.exit(main(*sys.argv[1:]))
