// -*-c++-*-
//
#ifndef USTL_TYPE_TRAITS_H
#define USTL_TYPE_TRAITS_H

namespace ustl {

////////////////////
// Helper Classes //
////////////////////

//
// struct integral_constant<T, v>:
//
// wraps a static constant of specified type. It is the base class for
// the C++ type traits.
//
template<typename T, T v>
struct integral_constant {
  static constexpr T value = v;
  using value_type = T;
  using type = integral_constant;
  constexpr operator value_type() const noexcept { return value; }
  constexpr value_type operator()() const noexcept { return value; }
};

using true_type = std::integral_constant<bool, true>;
using false_type = std::integral_constant<bool, false>;


/////////////////////////////
// Primary type categories //
/////////////////////////////

//
// struct is_void<T>:
//
// Checks whether T is a void type. Provides the member constant value
// that is equal to true, if T is the type void, const void, volatile
// void, or const volatile void. Otherwise, value is equal to false.
//
template<typename T> struct is_void : false_type {};
template<> struct is_void<void> : true_type {};
template<> struct is_void<const void> : true_type {};
template<> struct is_void<volatile void> : true_type {};
template<> struct is_void<const volatile void> : true_type {};

//
// struct is_integral<T>:
//
// Checks whether T is an integral type. Provides the member constant
// value which is equal to true, if T is the type bool, char,
// char16_t, char32_t, wchar_t, short, int, long, long long, or any
// implementation-defined extended integer types, including any
// signed, unsigned, and cv-qualified variants. Otherwise, value is
// equal to false.
//
template<typename T> struct is_integral : false_type {};

// Specialisations for integral types:
#define cv_is_integral(x) \
    template<> struct is_integral<x> : true_type {}; \
    template<> struct is_integral<const x> : true_type {}; \
    template<> struct is_integral<volatile x> : true_type {}; \
    template<> struct is_integral<const volatile x> : true_type {};

#define cvu_is_integral(x) \
    cv_is_integral(x); \
    cv_is_integral(unsigned x);

cv_is_integral(bool);
cv_is_integral(char16_t);
cv_is_integral(char32_t);
cv_is_integral(wchar_t);
cvu_is_integral(short);  // NOLINT(runtime/int)
cvu_is_integral(int);
cvu_is_integral(long);  // NOLINT(runtime/int)
cvu_is_integral(long long);  // NOLINT(runtime/int)

#undef cv_is_integral
#undef cvu_is_integral

// Helper variable template:
template<typename T>
constexpr bool is_integral_v = is_integral<T>::value;


///////////////////////////////
// Composite type categories //
///////////////////////////////


/////////////////////
// Type properties //
/////////////////////


//////////////////////////
// Supported operations //
//////////////////////////


//////////////////////
// Property queries //
//////////////////////


////////////////////////
// Type relationships //
////////////////////////

//
// If T and U name the same type with the same const-volatile
// qualifications, provides the member constant value equal to
// true. Otherwise value is false.
//
template<typename T, typename U>
struct is_same : false_type {};

template<typename T>
struct is_same<T, T> : true_type {};

// Helper variable template:
template<typename T, typename U>
constexpr bool is_same_v = is_same<T, U>::value;


/////////////////////////////////
// Const-volatility specifiers //
/////////////////////////////////


//
// struct remove_const<T>:
//
// Removes the topmost const.
//
template<typename T>
struct remove_const {
  using type = T;
};

// specialisation for const type:
template<typename T>
struct remove_const<const T> {
  using type = T;
};


//
// struct remove_volatile<T>:
//
// Removes the topmost volatile.
//
template<typename T>
struct remove_volatile {
  using type = T;
};

// specialisation for volatile type:
template<typename T>
struct remove_volatile<volatile T> {
  using type = T;
};


//
// struct remove_cv<T>:
//
// Removes the topmost const, the topmost volatile, or both, if
// present.
//
template<typename T>
struct remove_cv {
  using type =
      typename remove_volatile<typename std::remove_const<T>::type>::type;
};


////////////////
// References //
////////////////


//////////////
// Pointers //
//////////////


////////////////////
// Sign modifiers //
////////////////////


////////////
// Arrays //
////////////

//
// remove_extent:
//

//
// remove_all_extents
//


///////////////////////////////////
// Miscellaneous transformations //
///////////////////////////////////


//
// struct enable_if<B, T>:
//
// If B is true, std::enable_if has a public member typedef type,
// equal to T; otherwise, there is no member typedef.
//
// This metafunction is a convenient way to leverage SFINAE to
// conditionally remove functions from overload resolution based on
// type traits and to provide separate function overloads and
// specializations for different type traits. std::enable_if can be
// used as an additional function argument (not applicable to operator
// overloads), as a return type (not applicable to constructors and
// destructors), or as a class template or function template
// parameter.
//

// Base case. No "type" member, so usage will fail.
template<bool B, typename T = void> struct enable_if {};

// Specialisation for true case.
template<typename T> struct enable_if<true, T> { using type = T; };

}  // namespace ustl

#endif  // USTL_TYPE_TRAITS_H
