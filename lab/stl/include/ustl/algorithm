// -*-c++-*-
//
// algorithm
//
#ifndef __USTL_ALGORITHM__
#define __USTL_ALGORITHM__

#include <cstddef>
#include <memory>

#include "./vector"

namespace ustl {


//
// Merge function.
//
template<class InputIterator1, class InputIterator2,
         class OutputIterator, class Compare>
OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result, Compare comp) {
  auto ret = result;  // Return the initial position of result iterator.

  while (first1 != last1 && first2 != last2) {
    if (comp(*first1, *first2)) {
      *result = *first1;
      first1++;
    } else {
      *result = *first2;
      first2++;
    }
    result++;
  }

  while (first1 != last1)
    *(result++) = *(first1++);
  while (first2 != last2)
    *(result++) = *(first2++);

  return ret;
}

//
// Merge function, using '<' operator for comparison.
//
template<class InputIterator1, class InputIterator2, class OutputIterator>
OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result) {
  using InputType1 = typename std::iterator_traits<InputIterator1>::value_type;
  using InputType2 = typename std::iterator_traits<InputIterator2>::value_type;
  return merge(first1, last1, first2, last2, result,
               [](const InputType1 &a, const InputType2 &b) { return a < b; });
}


//
// Sort functions.
//


//
// Bubble sort.
//
template<typename RandomAccessIterator, typename Compare>
void __bubble_sort(RandomAccessIterator first,
                   RandomAccessIterator last,
                   Compare comp) {
  bool changed;

  do {
    changed = false;

    for (RandomAccessIterator i = first + 1; i != last; i++) {
      if (comp(*i, *(i - 1))) {
        auto tmp = *(i-1);
        *(i-1) = *i;
        *i = tmp;
        changed = true;
      }
    }
  } while (changed);
}

//
// Insertion sort.
//
template<typename RandomAccessIterator, typename Compare>
void __insertion_sort(RandomAccessIterator first,
                      RandomAccessIterator last,
                      Compare comp) {

  for (auto i = first; i != last; i++) {
    auto j = i;

    while (j != first && comp(*j, *(j - 1))) {
      auto temp = *j;
      *j = *(j - 1);
      *(j - 1) = temp;
      j--;
    }
  }
}

//
// Merge sort.
//
#define __merge_sort_bottom_out_sort __bubble_sort
static const size_t __merge_sort_bottom_out_threshold = 8;


template<typename RandomAccessIterator, typename Compare>
void __merge_sort(RandomAccessIterator first,
                  RandomAccessIterator last,
                  Compare comp) {
  const size_t len = static_cast<size_t>(last - first);

  if (len <= __merge_sort_bottom_out_threshold) {
    __merge_sort_bottom_out_sort(first, last, comp);
  } else {
    // Split midway:
    const RandomAccessIterator mid = first + len / 2;
    using ElementType =
        typename std::pointer_traits<RandomAccessIterator>::element_type;

    ustl::vector<ElementType> left(0);
    ustl::vector<ElementType> right(0);

    for (auto i = first; i != mid; i++)
      left.push_back(*i);
    for (auto i = mid; i != last; i++)
      right.push_back(*i);

    __merge_sort(left.begin(), left.end(), comp);
    __merge_sort(right.begin(), right.end(), comp);

    // Merge temporary buffers into original array:
    merge(left.begin(), left.end(), right.begin(), right.end(), first, comp);
  }
}


//
// Sort function.
//
template<typename RandomAccessIterator, typename Compare>
void sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp) {
  __merge_sort(first, last, comp);
}

//
// Sort function, using '<' operator for comparison.
//
template<typename RandomAccessIterator>
void sort(RandomAccessIterator first, RandomAccessIterator last) {
  using Type = typename std::iterator_traits<RandomAccessIterator>::value_type;
  sort(first, last, [](const Type &a, const Type &b) { return a < b; });
}


//
// Stable sort function.
//
template<class RandomAccessIterator, class Compare>
void stable_sort(RandomAccessIterator first, RandomAccessIterator last,
                 Compare comp) {
  __merge_sort(first, last, comp);
}

//
// Stable sort function, using '<' operator for comparison.
//
template<class RandomAccessIterator>
void stable_sort(RandomAccessIterator first, RandomAccessIterator last) {
  using Type = typename std::iterator_traits<RandomAccessIterator>::value_type;
  stable_sort(first, last, [](const Type &a, const Type &b) { return a < b; });
}


//
// Is sorted function.
//
template<class ForwardIterator, class Compare>
bool is_sorted(ForwardIterator first, ForwardIterator last, Compare comp) {
  auto prev = first;
  first++;

  while (first != last) {
    if (comp(*first, *prev))
      return false;
    prev = first;
    first++;
  }

  return true;
}


//
// Is sorted function, using '<' operator for comparison.
//
template<class ForwardIterator>
bool is_sorted(ForwardIterator first, ForwardIterator last) {
  using Type = typename std::iterator_traits<ForwardIterator>::value_type;
  return is_sorted(first, last, [](const Type &a, const Type &b) {
      return a < b;
    });
}



}  // namespace ustl

#endif  // __USTL_ALGORITHM__
