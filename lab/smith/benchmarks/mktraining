#!/usr/bin/env python3
from __future__ import print_function
from __future__ import division

import csv
import editdistance
import sys
import os

from argparse import ArgumentParser
from six import iteritems

import labm8
from labm8 import fs

import smith
from smith import cecl


class MalformedDataException(smith.SmithException): pass


def read_csv(path):
    with open(path) as infile:
        reader = csv.DictReader(infile)
        return [row for row in reader]


def get_dynamic_to_static_mapping(static, dynamic):
    # We can hardcode any known mappings here:
    mappings = {}

    for name in sorted(set([x["benchmark"] for x in dynamic])):
        components = name.split("-")
        # The last component is the kernel name.
        benchmark = "-".join(components[:-1])
        path = benchmark + ".cl"
        kernel = components[-1]

        if path not in mappings:
            candidates = [d["file"] for d in static if d["kernel"] == kernel]
            distances = []

            if not len(candidates):
                print("error: no candidate for benchmark '{}' kernel '{}'"
                      .format(benchmark, kernel), file=sys.stderr)
                continue
            if path in candidates:
                mappings[name] = path
            else:
                for spath in candidates:
                    distances.append((editdistance.eval(spath, path), spath))
                mindistance = min(x[0] for x in distances)
                mins = [x for x in distances if x[0] == mindistance]
                if len(mins) > 1:
                    print("error: multiple plausible candidates for file '{}'"
                          .format(path), file=sys.stderr)
                    continue
                mappings[name] = mins[0][1]
                print("warning: inferred mapping:", path, "->", mins +
                      ". Is this correct?", file=sys.stderr)

    return mappings


def lookup_static(static, name, mappings):
    components = name.split("-")
    kernel = components[-1]
    mapped = mappings[name]

    for s in static:
        if s["file"] == mapped and s["kernel"] == kernel:
            return s
    # Something has gone seriously wrong.
    assert(False)


def print_header(file=sys.stdout):
    print(
        "benchmark",
        "dataset",
        "comp",
        "rational",
        "mem",
        "localmem",
        "coalesced",
        "atomic",
        "transfer",
        "wgsize",
        "F1:transfer/(comp+mem)",
        "F2:coalesced/mem",
        "F3:(localmem/mem)*avgws",
        "F4:comp/mem",
        sep=',', file=file)


def mktraining(static_path, dynamic_path):
    static = read_csv(static_path)
    dynamic = read_csv(dynamic_path)

    # Get mappings from dynamic benchmark -> static features file
    mappings = get_dynamic_to_static_mapping(static, dynamic)

    print_header(file=sys.stdout)
    for d in dynamic:
        if d["benchmark"] in mappings:
            s = lookup_static(static, d["benchmark"], mappings)
            comp = int(s["comp"])
            mem = int(s["mem"])
            localmem = int(s["localmem"])
            transfer = int(d["transfer"])
            wgsize = int(d["local_size"])

            F1 = transfer / (comp + mem)
            F3 = (localmem / mem) * wgsize

            print(
                d["benchmark"],
                d["dataset"],
                s["comp"],
                s["rational"],
                s["mem"],
                s["localmem"],
                s["coalesced"],
                s["atomic"],
                F1,
                s["F2:coalesced/mem"],
                F3,
                s["F4:comp/mem"],
                sep=",")


def main():
    parser = ArgumentParser()
    parser.add_argument('kernels', help='path to kernels directory')
    parser.add_argument('dynamic', help='path to dynamic kernel features CSV')
    args = parser.parse_args()

    # try:
    static_path = fs.path(args.kernels, "features.csv")

    static = smith.assert_exists(static_path)
    dynamic = smith.assert_exists(args.dynamic)

    mktraining(static, dynamic)
    # except Exception as e:
    #     print("fatal:", e, file=sys.stderr)


if __name__ == '__main__':
    main()
