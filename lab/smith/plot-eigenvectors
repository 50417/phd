#!/usr/bin/env python3
#
# Visualise Eigenvectors. Eigenvectors were found by applying
# PrincipleComponents over combined benchmarks training data in
# Weka.
#
from argparse import ArgumentParser

import matplotlib.cm as cm
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import re
import seaborn as sns
import sklearn
import sys

from math import sqrt,ceil
from functools import partial
from random import seed,random

import labm8
from labm8 import fmt
from labm8 import fs

import smith
from smith import clutil


def rand_jitter(arr, factor=0.01):
    stdev = factor* (max(arr) - min(arr))
    return arr + np.random.randn(len(arr)) * stdev


def eigenvector(d):
    F1 = float(d["F1:transfer/(comp+mem)"])
    F2 = float(d["F2:coalesced/mem"])
    F3 = float(d["F3:(localmem/mem)*avgws"])
    F4 = float(d["F4:comp/mem"])

    # Eigenvectors: (hardcoded values as returned by Weka)
    V1 = - .1881 * F1 + .6796 * F2 - .2141 * F3 - .6760 * F4
    V2 = - .7282 * F1 - .0004 * F2 + .6852 * F3 + .0149 * F4
    V3 = - .6590 * F1 - .1867 * F2 - .6958 * F3 - .2161 * F4
    V4 =   .0063 * F1 + .7095 * F2 + .0224 * F3 - .7044 * F4

    return (V1, V2, V3, V4)


def normalize(data, key):
    f = max([float(d[key]) for d in data])
    for d in data:
        d[key] = float(d[key]) / f
    return data


def scatter_with_jitter(plt, x, y, **kwargs):
    jitter_opts = kwargs.get("jitter_opts", {})
    if "jitter_opts" in kwargs: kwargs.pop("jitter_opts")

    return plt.scatter(rand_jitter(x, **jitter_opts),
                       rand_jitter(y, **jitter_opts), **kwargs)


def ingroup(getgroup, d, group):
    return getgroup(d) == group


def getsuite(d):
    return re.match(r"^[a-zA-Z-]+-[0-9\.]+", d["benchmark"]).group(0)


def getprog(d):
    return re.match(r"^[a-zA-Z-]+-[0-9\.]+-[^-]+-", d["benchmark"]).group(0)


def getclass(d):
    return d["oracle"]


def suite_filter(d):
    """
    Groups filter.
    """
    return getsuite(d).startswith("rodinia") # or getsuite(d).startswith("parboil")


def plot_eigenvectors(data, subplots=False, group_by="class", filter_by="none"):
    jitter = partial(scatter_with_jitter, plt)

    # Normalize data.
    normalize(data, "F1:transfer/(comp+mem)")
    normalize(data, "F2:coalesced/mem")
    normalize(data, "F3:(localmem/mem)*avgws")
    normalize(data, "F4:comp/mem")

    datafilter = {
        "suite": suite_filter
    }.get(filter_by, lambda x: True)

    data = [d for d in data if datafilter(d)]

    getgroup = {
        "class": getclass,
        "suite": getsuite,
        "prog": getprog
    }.get(group_by, lambda x: "None")

    groups = sorted(set([getgroup(d) for d in data]))

    COLORS = [ "k", "r", "g", "b", "m", "y", "c" ]
    if len(groups) <= len(COLORS):
        colors = COLORS[:len(groups)]
    else:
        colors = [cm.cool(i / len(groups) * 2) for i in range(len(groups))]

    # Split data into groups.
    raw = []
    for d in data:
        raw.append(tuple(list(eigenvector(d)) + [getgroup(d)]))

    s = pd.DataFrame(raw, columns=["V1", "V2", "V3", "V4", "Group"])

    sns.set(style="ticks", color_codes=True)
    sns.pairplot(s, hue="Group")
    plt.show()

    sys.exit(0)

    # Plot
    opts = { "s": 35, "marker": "o", "alpha": ".25", "jitter_opts": { "factor": 0.02 } }

    xlim = (min([min(e[0]) for e in eigens]), max([max(e[0]) for e in eigens]))
    ylim = (min([min(e[1]) for e in eigens]), max([max(e[1]) for e in eigens]))

    for i,row in enumerate(zip(eigens, colors)):
        if subplots:
            sz = ceil(sqrt(len(eigens)))
            plt.subplot(sz, sz, i + 1)
            plt.title(groups[i])

        eigen, color = row
        x, y = zip(*[(e[0], e[1]) for e in eigen])
        x, y = np.array(x), np.array(y)
        # sns.kdeplot(x, y, color=color, bw=.15)
        jitter(x, y, color=color, **opts)

        # Apply axis limits:
        # plt.xlim((-.2,.2))
        # plt.ylim((-.2,.2))
        plt.xlim((-1,1))
        plt.ylim((-1,1))

        # Turn off ticks:
        plt.gca().xaxis.set_major_locator(plt.NullLocator())
        plt.gca().yaxis.set_major_locator(plt.NullLocator())

    plt.show()


def main():
    parser = ArgumentParser()
    parser.add_argument('input', help='path to input training data CSV')
    parser.add_argument("-g", "--group", action="store", default="none",
                        help='group results by {none,class,suite,prog}')
    parser.add_argument("--subplots", action="store_true",
                        help="plot each group in a separate subplot")
    parser.add_argument("--filter", action="store", default="none",
                        help="filter data by {none,suite}")
    args = parser.parse_args()

    data = smith.read_csv(smith.assert_exists(args.input))
    plot_eigenvectors(data, subplots=args.subplots, group_by=args.group,
                      filter_by=args.filter)


if __name__ == '__main__':
    main()
