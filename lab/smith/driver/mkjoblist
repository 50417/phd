#!/usr/bin/env python2
from __future__ import print_function
from __future__ import division

import csv
import sys
import os

from argparse import ArgumentParser
from random import shuffle

import labm8
from labm8 import fs
from labm8 import math as labmath

import smith
from smith import features

class MalformedDataException(smith.SmithException): pass

DSIZES = [32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384]

def read_file_dataset(path):
    results = []

    with open(path) as infile:
        reader = csv.reader(infile)
        # SCHEMA: [ file, dataset, ... ]
        for row in reader:
            try:
                results.append(str(row[0] + row[1]))
            except Exception:
                print("error: can't read '{}' line: ".format(path),
                      ','.join(row)[:30], file=sys.stderr)
    return results


def match_and_remove(entry, inlist):
    try:
        idx = inlist.index(entry)
        del inlist[idx]
        return True
    except ValueError:
        return False


def mkjoblist(kernels_dir, results_path, errors_path):
    kernels = [x for x in fs.ls(kernels_dir) if x.endswith(".cl")]

    results = read_file_dataset(results_path)
    errors = read_file_dataset(errors_path)

    if 'DSIZES' in os.environ:
        dsizes = [str(var) for var in os.environ['DSIZES'].split()]
    else:
        dsizes = [str(var) for var in DSIZES]

    jobs = []
    for file in kernels:
        for dsize in dsizes:
            key = str(file + dsize)
            if match_and_remove(key, results):
                has_result = True
            elif match_and_remove(key, errors):
                has_result = True
            else:
                has_result = False
            if not has_result:
                jobs.append((file, dsize))
    shuffle(jobs)
    return jobs


def main():
    parser = ArgumentParser()
    parser.add_argument('kernels', help='path to kernels directory')
    parser.add_argument('results', help='path to CSV results file')
    parser.add_argument('errors', help='path to CSV errors file')
    args = parser.parse_args()

    try:
        smith.assert_exists(args.kernels)
        smith.assert_exists(args.results)
        smith.assert_exists(args.errors)

        jobs = mkjoblist(args.kernels, args.results, args.errors)
        for job in jobs:
            print(','.join(job))
    except Exception as e:
        print('fatal:', e, file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
