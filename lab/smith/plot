#!/usr/bin/env python3
#
# Visualise Eigenvectors. Eigenvectors were found by applying
# PrincipleComponents over combined benchmarks training data in
# Weka.
#
from argparse import ArgumentParser

import matplotlib.cm as cm
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import re
import seaborn as sns
import sklearn
import sys

from math import sqrt,ceil
from functools import partial
from random import seed,random

import labm8
from labm8 import fmt
from labm8 import fs
from labm8 import viz

import smith
from smith import cgo13


# Seaborn configuration:
sns.set(style="ticks", color_codes=True)


def rand_jitter(arr, factor=0.01):
    stdev = factor* (max(arr) - min(arr))
    return arr + np.random.randn(len(arr)) * stdev


def scatter_with_jitter(plt, x, y, **kwargs):
    jitter_opts = kwargs.get("jitter_opts", {})
    if "jitter_opts" in kwargs: kwargs.pop("jitter_opts")

    return plt.scatter(rand_jitter(x, **jitter_opts),
                       rand_jitter(y, **jitter_opts), **kwargs)


def plot_eigenvectors(data):
    if len(set(data["Group"])) > 1:
        s = pd.concat([data["E1"], data["E2"], data["E3"], data["E4"],
                       data["Group"]], axis=1,
                      keys=["E1", "E2", "E3", "E4", "Group"])
        g = sns.pairplot(s, hue="Group")
    else:
        s = pd.concat([data["E1"], data["E2"], data["E3"], data["E4"]], axis=1,
                      keys=["E1", "E2", "E3", "E4"])
        g = sns.pairplot(s)


def plot_features(data):
    if len(set(data["Group"])) > 1:
        s = pd.concat([
            data["F1_norm"], data["F2_norm"], data["F3_norm"], data["F4_norm"],
            data["Group"]], axis=1, keys=["F1", "F2", "F3", "F4", "Group"])
        sns.pairplot(s, hue="Group")
    else:
        s = pd.concat([
            data["F1_norm"], data["F2_norm"], data["F3_norm"], data["F4_norm"]],
                      axis=1, keys=["F1", "F2", "F3", "F4"])
        sns.pairplot(s)


def main():
    parser = ArgumentParser()
    parser.add_argument('type', help='{features,eigens}')
    parser.add_argument('input', help='path to input training data CSV')
    parser.add_argument("-g", "--group", action="store", default="none",
                        help='group results by {none,class,suite,prog}')
    parser.add_argument("--filter", action="store", default="none",
                        help="filter data by {none,suite}")
    parser.add_argument("-o", "--output", action="store", default=None,
                        help="Save plot to location")
    args = parser.parse_args()

    data = cgo13.LabelledData.from_csv(smith.assert_exists(args.input),
                                       group_by=args.group,
                                       filter_by=args.filter)

    if args.type == "features":
        plot_features(data)
    elif args.type == "eigens":
        plot_eigenvectors(data)
    else:
        print("fatal: Unknown plot type '{}'".format(args.type))
        sys.exit(1)

    viz.finalise(args.output)


if __name__ == '__main__':
    main()
